/*! For license information please see bundle.fdf47a938ecb8cb30dae.js.LICENSE.txt */
(()=>{var e={9817:(e,t,n)=>{"use strict";n.r(t),n.d(t,{load:()=>h,BlazeFaceModel:()=>p});var o=n(1140),A=n(2766);function i(e,t,n,o){return new(n||(n=Promise))((function(A,i){function r(e){try{a(o.next(e))}catch(e){i(e)}}function s(e){try{a(o.throw(e))}catch(e){i(e)}}function a(e){var t;e.done?A(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,s)}a((o=o.apply(e,t||[])).next())}))}function r(e,t){var n,o,A,i,r={label:0,sent:function(){if(1&A[0])throw A[1];return A[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;r;)try{if(n=1,o&&(A=2&i[0]?o.return:i[0]?o.throw||((A=o.return)&&A.call(o),0):o.next)&&!(A=A.call(o,i[1])).done)return A;switch(o=0,A&&(i=[2&i[0],A.value]),i[0]){case 0:case 1:A=i;break;case 4:return r.label++,{value:i[1],done:!1};case 5:r.label++,o=i[1],i=[0];continue;case 7:i=r.ops.pop(),r.trys.pop();continue;default:if(!(A=(A=r.trys).length>0&&A[A.length-1])&&(6===i[0]||2===i[0])){r=0;continue}if(3===i[0]&&(!A||i[1]>A[0]&&i[1]<A[3])){r.label=i[1];break}if(6===i[0]&&r.label<A[1]){r.label=A[1],A=i;break}if(A&&r.label<A[2]){r.label=A[2],r.ops.push(i);break}A[2]&&r.ops.pop(),r.trys.pop();continue}i=t.call(e,r)}catch(e){i=[6,e],o=0}finally{n=A=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}}var s=function(e){return{startEndTensor:e,startPoint:(0,o.tPi)(e,[0,0],[-1,2]),endPoint:(0,o.tPi)(e,[0,2],[-1,2])}},a={strides:[8,16],anchors:[2,6]};function l(e,t){var n,A,i;if(e.topLeft instanceof o.esB&&e.bottomRight instanceof o.esB){var r=(0,o.lub)((function(){return[(0,o.zoF)([(0,o.tPi)((0,o.luU)(t-1,e.topLeft),0,1),(0,o.tPi)(e.topLeft,1,1)]),(0,o.zoF)([(0,o.luU)(t-1,(0,o.tPi)(e.bottomRight,0,1)),(0,o.tPi)(e.bottomRight,1,1)])]}));n=r[0],A=r[1],null!=e.landmarks&&(i=(0,o.lub)((function(){var n=(0,o.luU)((0,o.RRF)([t-1,0]),e.landmarks),A=(0,o.RRF)([1,-1]);return(0,o.dC7)(n,A)})))}else{var s=e.topLeft,a=s[0],l=s[1],m=e.bottomRight,p=m[0],h=m[1];n=[t-1-a,l],A=[t-1-p,h],null!=e.landmarks&&(i=e.landmarks.map((function(e){return[t-1-e[0],e[1]]})))}var u={topLeft:n,bottomRight:A};return null!=i&&(u.landmarks=i),null!=e.probability&&(u.probability=e.probability instanceof o.esB?e.probability.clone():e.probability),u}function m(e,t){return(0,o.lub)((function(){var n;return n=e.hasOwnProperty("box")?e.box:e,(0,o.L9e)(function(e,t){var n=(0,o.dC7)(e.startPoint,t),A=(0,o.dC7)(e.endPoint,t),i=(0,o.Izb)([n,A],1);return s(i)}(n,t).startEndTensor)}))}var p=function(){function e(e,t,n,A,i,r){this.blazeFaceModel=e,this.width=t,this.height=n,this.maxFaces=A,this.anchorsData=function(e,t,n){for(var o=[],A=0;A<n.strides.length;A++)for(var i=n.strides[A],r=Math.floor((t+i-1)/i),s=Math.floor((e+i-1)/i),a=n.anchors[A],l=0;l<r;l++)for(var m=i*(l+.5),p=0;p<s;p++)for(var h=i*(p+.5),u=0;u<a;u++)o.push([h,m]);return o}(t,n,a),this.anchors=(0,o.odF)(this.anchorsData),this.inputSizeData=[t,n],this.inputSize=(0,o.RRF)([t,n]),this.iouThreshold=i,this.scoreThreshold=r}return e.prototype.getBoundingBoxes=function(e,t,n){return void 0===n&&(n=!0),i(this,void 0,void 0,(function(){var A,a,l,m,p,h,u,c,d,I,G,E,k,g,f=this;return r(this,(function(H){switch(H.label){case 0:return A=(0,o.lub)((function(){var t=o.BHj.resizeBilinear(e,[f.width,f.height]),n=(0,o.dC7)((0,o.luU)((0,o.hiC)(t,255),.5),2),A=f.blazeFaceModel.predict(n),i=(0,o.L9e)(A),r=function(e,t,n){var A=(0,o.tPi)(e,[0,1],[-1,2]),i=(0,o.IHx)(A,t),r=(0,o.tPi)(e,[0,3],[-1,2]),s=(0,o.hiC)(r,n),a=(0,o.hiC)(i,n),l=(0,o.hiC)(s,2),m=(0,o.luU)(a,l),p=(0,o.IHx)(a,l),h=(0,o.dC7)(m,n),u=(0,o.dC7)(p,n);return(0,o.Izb)([h,u],1)}(i,f.anchors,f.inputSize),s=(0,o.tPi)(i,[0,0],[-1,1]);return[i,r,(0,o.L9e)((0,o.XD2)(s))]})),a=A[0],l=A[1],m=A[2],p=console.warn,console.warn=function(){},h=o.BHj.nonMaxSuppression(l,m,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=p,[4,h.array()];case 1:return u=H.sent(),h.dispose(),c=u.map((function(e){return(0,o.tPi)(l,[e,0],[1,-1])})),t?[3,3]:[4,Promise.all(c.map((function(e){return i(f,void 0,void 0,(function(){var t;return r(this,(function(n){switch(n.label){case 0:return[4,e.array()];case 1:return t=n.sent(),e.dispose(),[2,t]}}))}))})))];case 2:c=H.sent(),H.label=3;case 3:for(d=e.shape[1],I=e.shape[2],G=t?(0,o.hiC)([I,d],this.inputSize):[I/this.inputSizeData[0],d/this.inputSizeData[1]],E=[],k=function(e){var A=c[e],i=(0,o.lub)((function(){var i=s(A instanceof o.esB?A:(0,o.odF)(A));if(!n)return i;var r,l=u[e];return r=t?(0,o.tPi)(f.anchors,[l,0],[1,2]):f.anchorsData[l],{box:i,landmarks:(0,o.XLQ)((0,o.L9e)((0,o.tPi)(a,[l,5],[1,-1])),[6,-1]),probability:(0,o.tPi)(m,[l],[1]),anchor:r}}));E.push(i)},g=0;g<c.length;g++)k(g);return l.dispose(),m.dispose(),a.dispose(),[2,{boxes:E,scaleFactor:G}]}}))}))},e.prototype.estimateFaces=function(e,t,n,A){return void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===A&&(A=!0),i(this,void 0,void 0,(function(){var s,a,p,h,u,c,d=this;return r(this,(function(I){switch(I.label){case 0:return s=function(e){return e instanceof o.esB?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),a=s[1],p=(0,o.lub)((function(){return e instanceof o.esB||(e=o.Xhn.fromPixels(e)),(0,o.dt4)((0,o.pju)(e,"float32"),0)})),[4,this.getBoundingBoxes(p,t,A)];case 1:return h=I.sent(),u=h.boxes,c=h.scaleFactor,p.dispose(),t?[2,u.map((function(e){var t=m(e,c),i={topLeft:(0,o.tPi)(t,[0],[2]),bottomRight:(0,o.tPi)(t,[2],[2])};if(A){var r=e,s=r.landmarks,p=r.probability,h=r.anchor,u=(0,o.dC7)((0,o.IHx)(s,h),c);i.landmarks=u,i.probability=p}return n&&(i=l(i,a)),i}))]:[2,Promise.all(u.map((function(e){return i(d,void 0,void 0,(function(){var t,o,s,p,h,u,d,I,G,E,k,g=this;return r(this,(function(f){switch(f.label){case 0:return t=m(e,c),A?[3,2]:[4,t.array()];case 1:return h=f.sent(),o={topLeft:h.slice(0,2),bottomRight:h.slice(2)},[3,4];case 2:return[4,Promise.all([e.landmarks,t,e.probability].map((function(e){return i(g,void 0,void 0,(function(){return r(this,(function(t){return[2,e.array()]}))}))})))];case 3:s=f.sent(),p=s[0],h=s[1],u=s[2],d=e.anchor,G=(I=c)[0],E=I[1],k=p.map((function(e){return[(e[0]+d[0])*G,(e[1]+d[1])*E]})),o={topLeft:h.slice(0,2),bottomRight:h.slice(2),landmarks:k,probability:u},function(e){e.startEndTensor.dispose(),e.startPoint.dispose(),e.endPoint.dispose()}(e.box),e.landmarks.dispose(),e.probability.dispose(),f.label=4;case 4:return t.dispose(),n&&(o=l(o,a)),[2,o]}}))}))})))]}}))}))},e}();function h(e){var t=void 0===e?{}:e,n=t.maxFaces,o=void 0===n?10:n,s=t.inputWidth,a=void 0===s?128:s,l=t.inputHeight,m=void 0===l?128:l,h=t.iouThreshold,u=void 0===h?.3:h,c=t.scoreThreshold,d=void 0===c?.75:c,I=t.modelUrl;return i(this,void 0,void 0,(function(){var e;return r(this,(function(t){switch(t.label){case 0:return null==I?[3,2]:[4,(0,A.YL)(I)];case 1:return e=t.sent(),[3,4];case 2:return[4,(0,A.YL)("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:e=t.sent(),t.label=4;case 4:return[2,new p(e,a,m,o,u,d)]}}))}))}},2766:(e,t,n)=>{"use strict";n.d(t,{YL:()=>Ho,gJ:()=>Fo});var o={};n.r(o),n.d(o,{json:()=>B});var A={};n.r(A),n.d(A,{json:()=>w});var i={};n.r(i),n.d(i,{json:()=>M});var r={};n.r(r),n.d(r,{json:()=>L});var s={};n.r(s),n.d(s,{json:()=>S});var a={};n.r(a),n.d(a,{json:()=>T});var l={};n.r(l),n.d(l,{json:()=>N});var m={};n.r(m),n.d(m,{json:()=>R});var p={};n.r(p),n.d(p,{json:()=>O});var h={};n.r(h),n.d(h,{json:()=>P});var u={};n.r(u),n.d(u,{json:()=>U});var c={};n.r(c),n.d(c,{json:()=>V});var d={};n.r(d),n.d(d,{json:()=>W});var I={};n.r(I),n.d(I,{json:()=>_});var G={};n.r(G),n.d(G,{json:()=>z});var E={};n.r(E),n.d(E,{json:()=>X});var k={};n.r(k),n.d(k,{json:()=>Q});var g={};n.r(g),n.d(g,{json:()=>Z});var f={};n.r(f),n.d(f,{json:()=>Y});var H,F,C=n(1140);!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(H||(H={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(F||(F={}));const D={};function J(e){return D[e]}function v(e,t,n,o,A){const i=t.inputParams[e];if(i&&void 0!==i.inputIndexStart){const e=i.inputIndexStart,r=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?e+1:i.inputIndexEnd;if("tensor"===i.type)return j(t.inputNames[i.inputIndexStart],n,o,A);if("tensors"===i.type)return t.inputNames.slice(e,r).map((e=>j(e,n,o,A)));const s=j(t.inputNames.slice(e)[0],n,o,A),a=s.dataSync();return"number"===i.type?a[0]:C.D5U.toNestedArray(s.shape,a)}const r=t.attrParams[e];return r&&r.value}function j(e,t,n,o){const[A,i]=b(e);if(null!=o){const e=o.getHashTableHandleByName(A);if(null!=e)return e}const r=n.currentContextIds.find((e=>!!t[y(A,e)]));return void 0!==r?t[y(A,r)][i]:void 0}function K(e,t){const[n,o,A]=b(e);return[y(n,t&&t.currentContextId),o,A]}function y(e,t){return t?`${e}-${t}`:e}function b(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],o=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),o]}function q(e,t,n){let o=v("pad",e,t,n);if("explicit"===o){o=v("explicitPaddings",e,t,n);const A=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)A[e][0]=o[2*e],A[e][1]=o[2*e+1];return A}return o}function x(e){return e.kept?e:(0,C.d9v)(e)}const B=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],w=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],M=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],L=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],S=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],T=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],N=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],R=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],O=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],P=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],U=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],V=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],W=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],_=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],z=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],X=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Q=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Z=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Y=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class ${static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[o,A,i,r,s,a,l,m,p,h,u,c,d,I,G,E,k,g,f].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,o=[],A=[],i=[],r=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?o.push(e[t.name]):"Const"===t.op?A.push(e[t.name]):null!=t.input&&0!==t.input.length||i.push(e[t.name]),e)),{});let s=[];const a=[];let l={},m={};null!=t&&(l=this.mapSignatureEntries(t.inputs),m=this.mapSignatureEntries(t.outputs));const p=Object.keys(r);p.forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[o,,A]=K(e),i=r[o];if(null!=i.outputs){const e=i.outputs.indexOf(A);if(-1!==e){const A=`${o}:${e}`;t.inputNames[n]=A}}t.inputs.push(i),i.children.push(t)}))})),0===Object.keys(m).length?p.forEach((e=>{const t=r[e];0===t.children.length&&a.push(t)})):Object.keys(m).forEach((e=>{const[t]=K(e),n=r[t];null!=n&&(n.signatureKey=m[e],a.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=K(e),n=r[t];n&&(n.signatureKey=l[e],s.push(n))})):s=o;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const u={nodes:r,inputs:s,outputs:a,weights:A,placeholders:o,signature:t,functions:h};return i.length>0&&(u.initNodes=i),u}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=J(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const o=n.type;let A;switch(n.type){case"string":A=te(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=te(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":A=pe(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=pe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":A=oe(e.attr,n.tfName,n.defaultValue||0),void 0===A&&n.tfDeprecatedName&&(A=oe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":A=me(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=me(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":A=ne(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=ne(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":A=ue(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=ue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":A=le(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=le(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":A=he(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=he(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":A=re(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=re(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":A=se(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=se(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":A=ie(e.attr,n.tfName,n.defaultValue),void 0===A&&n.tfDeprecatedName&&(A=ie(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:A,type:o},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let o={};null!=t&&(o=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const A=[],i=[];e.signature.inputArg.forEach((e=>{const[t]=K(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Ae(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,A.push(n),o[t]=n})),Object.keys(o).forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[A,,i]=K(e),r=o[A];if(null!=r.outputs){const e=r.outputs.indexOf(i);if(-1!==e){const o=`${A}:${e}`;t.inputNames[n]=o}}t.inputs.push(r),r.children.push(t)}))}));const r=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=K(r[e.name]),A=o[t];null!=A&&(A.defaultOutput=n,i.push(A))}));const s=this.mapArgsToSignature(e);return{nodes:o,inputs:A,outputs:i,weights:n,placeholders:[],signature:s}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function ee(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=(0,C.OBj)().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function te(e,t,n,o=!1){const A=e[t];return null!=A?ee(A.s,o):n}function ne(e,t,n){const o=e[t];return o?o.b:n}function oe(e,t,n){const o=e[t]||{},A=null!=o.i?o.i:null!=o.f?o.f:n;return"number"==typeof A?A:parseInt(A,10)}function Ae(e){switch("string"==typeof e&&(e=H[e]),e){case H.DT_FLOAT:return"float32";case H.DT_INT32:case H.DT_INT64:case H.DT_INT8:case H.DT_UINT8:return"int32";case H.DT_BOOL:return"bool";case H.DT_DOUBLE:return"float32";case H.DT_STRING:return"string";default:return null}}function ie(e,t,n){const o=e[t];return o&&o.func?o.func.name:n}function re(e,t,n){const o=e[t];return o&&o.type?Ae(o.type):n}function se(e,t,n){const o=e[t];return o&&o.list&&o.list.type?o.list.type.map((e=>Ae(e))):n}function ae(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function le(e,t,n){const o=e[t];return o&&o.shape?ae(o.shape):n}function me(e,t,n){const o=e[t];return o?((o.list.f&&o.list.f.length?o.list.f:o.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function pe(e,t,n,o=!1){const A=e[t];return A&&A.list&&A.list.s?A.list.s.map((e=>ee(e,o))):n}function he(e,t,n){const o=e[t];return o&&o.list&&o.list.shape?o.list.shape.map((e=>ae(e))):n}function ue(e,t,n){const o=e[t];return o&&o.list&&o.list.b?o.list.b:n}class ce{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return j(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return j(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return oe(this.node.rawAttrs,e,t);if(null!=n.s)return te(this.node.rawAttrs,e,t);if(null!=n.b)return ne(this.node.rawAttrs,e,t);if(null!=n.shape)return le(this.node.rawAttrs,e,t);if(null!=n.type)return re(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return me(this.node.rawAttrs,e,t);if(null!=n.list.s)return pe(this.node.rawAttrs,e,t);if(null!=n.list.shape)return he(this.node.rawAttrs,e,t);if(null!=n.list.b)return ue(this.node.rawAttrs,e,t);if(null!=n.list.type)return se(this.node.rawAttrs,e,t)}return t}}var de=n(6407),Ie=n(7097),Ge=n(9121),Ee=n(3740),ke=n(569),ge=n(2668);const fe=(0,ge.op)({addN_:function(e){ke.hu(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),ke.hu(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>(0,Ee._1)(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!ke.cO(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const o=t;return Ie.BV.runKernel(Ge.Xz,o)}});var He=n(5228),Fe=n(4841),Ce=n(1274),De=n(9322),Je=n(9165),ve=n(827),je=n(4513),Ke=n(632),ye=n(3453),be=n(5265),qe=n(6235),xe=n(7839),Be=n(1470),we=n(2421),Me=n(1891),Le=n(7037),Se=n(9812),Te=n(369),Ne=n(6825),Re=n(1661),Oe=n(173),Pe=n(2699),Ue=n(3233),Ve=n(4650),We=n(4842),_e=n(3426),ze=n(6943),Xe=n(2597),Qe=n(7474),Ze=n(4386),Ye=n(7370),$e=n(9036),et=n(766),tt=n(7409),nt=n(7809),ot=n(5503),At=n(625),it=n(9331),rt=n(4434),st=n(3254),at=n(3694),lt=n(3261),mt=n(248),pt=n(1869),ht=n(1173),ut=n(2279),ct=n(3582),dt=n(2634),It=n(9451),Gt=n(9133),Et=n(8151),kt=n(6230);function gt(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){C.D5U.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let o=0;o<e.length;o++){const A=e[o],i=t[o];C.D5U.assert(A<0||i<0||A===i,(()=>n+` Shapes ${e} and ${t} must match`))}}}function ft(e){return"number"!=typeof e&&!e.some((e=>e<0))}function Ht(e,t,n){let o=Ft(e,n);const A=!ft(o);if(A&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${o}`);if(A&&t.forEach((e=>{o=Ft(e.shape,o)})),!ft(o))throw new Error(`Non-fully-defined elementShape: ${o}`);return o}function Ft(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let o=0;o<e.length;++o){const A=e[o],i=t[o];if(A>=0&&i>=0&&A!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[o]=A>=0?A:i}return n}class Ct{constructor(e,t,n,o,A,i,r){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=A,this.dynamicSize=i,this.clearAfterRead=r,this.tensors=[],this.closed_=!1,this.idTensor=(0,C.iD$)(0),(0,C.CnY)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),gt(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,(0,C.CnY)(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,C.XeE)([],[0].concat(this.elementShape));const n=this.readMany(e);return gt(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),(0,C.knu)(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,C.XeE)([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return gt(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),(0,C.zoF)(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,(0,C.HHK)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const o=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const A=0===n?0:t.size/n,i=[];(0,C.lub)((()=>{t=(0,C.XLQ)(t,[1,n,A]);for(let n=0;n<e.length;++n){const r=[0,0===n?0:o[n-1],0],s=[1,e[n],A];i[n]=(0,C.XLQ)((0,C.tPi)(t,r,s),this.elementShape)}return i}));const r=[];for(let t=0;t<e.length;t++)r[t]=t;this.writeMany(r,i)}}class Dt{constructor(e,t,n,o=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);gt(t,e.shape,"TensorList shape mismatch: "),(0,C.CnY)(e)})),this.idTensor=(0,C.iD$)(0),this.maxNumElements=o,(0,C.CnY)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Dt([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);gt(e,this.elementShape,"TensorList shape mismatch: ");const o=Ht(this.elementShape,this.tensors,e);return(0,C.lub)((()=>{const e=this.tensors.map((e=>(0,C.XLQ)(e,o)));return(0,C.knu)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=Ht(this.elementShape,this.tensors,e),o=this.tensors.pop();return gt(o.shape,e,"TensorList shape mismatch: "),(0,C.XLQ)(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(gt(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,C.CnY)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);gt(this.tensors[e].shape,t,"TensorList shape mismatch: ");const o=Ht(this.elementShape,this.tensors,t);return(0,C.XLQ)(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);gt(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,C.CnY)(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);gt(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const o=Ht(this.elementShape,this.tensors,n);return 0===e.length?(0,C.XeE)([],[0].concat(o)):(0,C.lub)((()=>{const t=e.map((e=>(0,C.XLQ)(this.tensors[e],o)));return(0,C.knu)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);gt(this.elementShape,t,"TensorList shape mismatch: ");const n=Ht(this.elementShape,this.tensors,t);return 0===this.size()?(0,C.XeE)([],[0].concat(n)):(0,C.lub)((()=>{const e=this.tensors.map((e=>(0,C.XLQ)(e,n)));return(0,C.zoF)(e,0)}))}}var Jt=n(1355),vt=n(4794),jt=n(4624),Kt=n(1405),yt=n(4718),bt=n(473),qt=n(5176),xt=n(1174);const Bt=(0,ge.op)({maxPoolWithArgmax_:function(e,t,n,o,A=!1){const i={x:(0,Ee._1)(e,"x","maxPoolWithArgmax")},r={filterSize:t,strides:n,pad:o,includeBatchInIndex:A},s=Ie.BV.runKernel(Ge.vF,i,r);return{result:s[0],indexes:s[1]}}});var wt=n(1749),Mt=n(5020),Lt=n(557);function St(e,t,n){const[o,A]=v("fusedOps",e,t,n),i="biasadd"===o,r=!i,s="prelu"===A,a="fusedbatchnorm"===o,l=v("numArgs",e,t,n);if(i){if(s&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!s&&i&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(a)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const m=v("strides",e,t,n),p=q(e,t,n),h=v("dataFormat",e,t,n).toUpperCase(),u=v("dilations",e,t,n);let[c,d]=v("args",e,t,n);return r&&(d=c,c=void 0),{stride:m,pad:p,dataFormat:h,dilations:u,biasArg:c,preluArg:d,activationFunc:A,leakyreluAlpha:v("leakyreluAlpha",e,t,n)}}var Tt=n(4006);function Nt(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const o={start:e,stop:t,num:n};return Ie.BV.runKernel(Ge.e7,{},o)}var Rt=n(4968);const Ot=(0,ge.op)({multinomial_:function(e,t,n,o=!1){const A=(0,Ee._1)(e,"logits","multinomial"),i=A.size,r=A.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(r>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${r}`);n=n||Math.random();const s={logits:1===r?(0,Rt.X)(A,[1,-1]):A},a={numSamples:t,seed:n,normalized:o},l=Ie.BV.runKernel(Ge.NZ,s,a);return 1===r?(0,Rt.X)(l,[l.size]):l}});var Pt=n(6708),Ut=n(4917),Vt=n(7846),Wt=n(5002),_t=n(7245),zt=n(3596),Xt=n(9640),Qt=n(6577),Zt=n(8869),Yt=n(2271),$t=n(8333);const en=async function(e){const t=(0,Ee._1)(e,"condition","whereAsync","bool"),n=await t.data(),o=(0,$t.Z)(t.shape,n);return e!==t&&t.dispose(),o};var tn=n(4077);function nn(e,t,n){return{boxes:v("boxes",e,t,n),scores:v("scores",e,t,n),maxOutputSize:v("maxOutputSize",e,t,n),iouThreshold:v("iouThreshold",e,t,n),scoreThreshold:v("scoreThreshold",e,t,n),softNmsSigma:v("softNmsSigma",e,t,n)}}var on=n(3243),An=n(9608),rn=n(6092),sn=n(9494);class an{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,C.iD$)(0),this.tensorMap=new Map,(0,C.CnY)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return sn.i(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),(0,C.lub)((()=>{const e=(0,C.HHK)(t),o=n.length,A=e.length;C.D5U.assert(o===A,(()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${A} elements.`));for(let t=0;t<o;t++){const o=n[t],A=e[t];(0,C.CnY)(A),this.tensorMap.set(o,A)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return(0,C.lub)((()=>{const e=[];for(let o=0;o<n.length;o++){const A=n[o],i=this.findWithDefault(A,t);e.push(i)}return(0,C.knu)(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}var ln=n(6477),mn=n(6500),pn=n(636),hn=n(7630),un=n(6573),cn=n(624),dn=n(2856),In=n(8651),Gn=n(5750),En=n(5912),kn=n(8687);const gn=(0,ge.op)({einsum_:function(e,...t){const n=t.map(((e,t)=>(0,Ee._1)(e,`tensors${t}`,"einsum"))),o={equation:e};return Ie.BV.runKernel(Ge.$g,n,o)}});var fn=n(9065),Hn=n(7505),Fn=n(9648),Cn=n(682),Dn=n(1510);const Jn=(0,ge.op)({sparseToDense_:function(e,t,n,o=0){const A=(0,Ee._1)(e,"sparseIndices","sparseToDense","int32"),i=(0,Ee._1)(t,"sparseValues","sparseToDense"),r=(0,Ee._1)(o,"defaultValue","sparseToDense",i.dtype);!function(e,t,n,o){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const A=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);const r=t.size;if(0!==t.rank&&(1!==t.rank||r!==A))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${A}]`);if(t.dtype!==o.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(A,i,n,r);const s={sparseIndices:A,sparseValues:i,defaultValue:r},a={outputShape:n};return Ie.BV.runKernel(Ge.D2,s,a)}});var vn=n(3307),jn=n(5130),Kn=n(5735),yn=n(5475),bn=n(781),qn=n(2998),xn=n(47),Bn=n(7394),wn=n(7405),Mn=n(3865);const Ln=(0,ge.op)({denseBincount_:function(e,t,n,o=!1){const A=(0,Ee._1)(e,"x","denseBincount"),i=(0,Ee._1)(t,"weights","denseBincount");ke.hu("int32"===A.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${A.dtype}`)),ke.hu(A.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${A.rank}.`)),ke.hu(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ke.hu(i.size===A.size||0===i.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${A.shape}, weights shape: ${i.shape}.`));const r={x:A,weights:i},s={size:n,binaryOutput:o};return Ie.BV.runKernel(Ge.QR,r,s)}});var Sn=n(6884),Tn=n(4926),Nn=n(7486),Rn=n(2676),On=n(5158),Pn=n(9590),Un=n(2991),Vn=n(4136),Wn=n(7501),_n=n(8644),zn=n(3028);const Xn=(0,ge.op)({scatterND_:function(e,t,n){const o=(0,Ee._1)(e,"indices","scatterND","int32"),A=(0,Ee._1)(t,"updates","scatterND");zn.b0(A,o,n);const i={indices:o,updates:A},r={shape:n};return Ie.BV.runKernel(Ge.xQ,i,r)}}),Qn=(0,ge.op)({gatherND_:function(e,t){const n=(0,Ee._1)(t,"indices","gatherND","int32"),o={params:(0,Ee._1)(e,"x","gatherND","string_or_numeric"),indices:n};return Ie.BV.runKernel(Ge.q1,o)}});var Zn=n(7020),Yn=n(8447),$n=n(3710),eo=n(4415),to=n(1300),no=n(1483),oo=n(9682),Ao=n(7918),io=n(8441),ro=n(9112),so=n(8247);const ao=(0,ge.op)({broadcastArgs_:function(e,t){const n=(0,Ee._1)(e,"s0","broadcastArgs","int32"),o=(0,Ee._1)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==o.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${o.rank}`);const A={s0:n,s1:o};return Ie.BV.runKernel(Ge.eE,A)}});function lo(e,t,n,o){const A=((e,t,n)=>{switch(e.category){case"arithmetic":return C.lub((()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[de.I(v("a",e,t,n),v("b",e,t,n))];case"AddN":return[fe(v("tensors",e,t,n))];case"FloorMod":case"Mod":return[He.w(v("a",e,t,n),v("b",e,t,n))];case"Mul":return[Fe.d(v("a",e,t,n),v("b",e,t,n))];case"RealDiv":case"Div":return[Ce.h(v("a",e,t,n),v("b",e,t,n))];case"DivNoNan":return[De.N(v("a",e,t,n),v("b",e,t,n))];case"FloorDiv":return[Je.q(v("a",e,t,n),v("b",e,t,n))];case"Sub":return[ve.l(v("a",e,t,n),v("b",e,t,n))];case"Minimum":return[je.L(v("a",e,t,n),v("b",e,t,n))];case"Maximum":return[Ke.g(v("a",e,t,n),v("b",e,t,n))];case"Pow":return[ye.s(v("a",e,t,n),v("b",e,t,n))];case"SquaredDifference":return[be.$(v("a",e,t,n),v("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[qe.W(v("x",e,t,n))];case"Acos":return[xe.K(v("x",e,t,n))];case"Acosh":return[Be._(v("x",e,t,n))];case"Asin":return[we.Z(v("x",e,t,n))];case"Asinh":return[Me.V(v("x",e,t,n))];case"Atan":return[Le.z(v("x",e,t,n))];case"Atan2":return[Se.f(v("x",e,t,n),v("y",e,t,n))];case"Atanh":return[Te.C(v("x",e,t,n))];case"Ceil":return[Ne.m(v("x",e,t,n))];case"Complex":return[Re.P(v("real",e,t,n),v("imag",e,t,n))];case"Cos":return[Oe.m(v("x",e,t,n))];case"Cosh":return[Pe.f(v("x",e,t,n))];case"Elu":return[Ue.p(v("x",e,t,n))];case"Erf":return[Ve.q(v("x",e,t,n))];case"Exp":return[We.Q(v("x",e,t,n))];case"Expm1":return[_e.t(v("x",e,t,n))];case"Floor":return[ze.G(v("x",e,t,n))];case"Log":return[Xe.c(v("x",e,t,n))];case"Log1p":return[Qe.K(v("x",e,t,n))];case"Imag":return[Ze.a(v("x",e,t,n))];case"Neg":return[Ye.W(v("x",e,t,n))];case"Reciprocal":return[$e.M(v("x",e,t,n))];case"Real":return[et.k(v("x",e,t,n))];case"Relu":return[tt.U(v("x",e,t,n))];case"Round":return[nt.N(v("x",e,t,n))];case"Selu":return[ot.U(v("x",e,t,n))];case"Sigmoid":return[At.X(v("x",e,t,n))];case"Sin":return[it.O(v("x",e,t,n))];case"Sign":return[rt.X(v("x",e,t,n))];case"Sinh":return[st.R(v("x",e,t,n))];case"Softplus":return[at.W(v("x",e,t,n))];case"Sqrt":return[lt._(v("x",e,t,n))];case"Square":return[mt.h(v("x",e,t,n))];case"Tanh":return[pt.A(v("x",e,t,n))];case"Tan":return[ht.O(v("x",e,t,n))];case"ClipByValue":return[ut.i(v("x",e,t,n),v("clipValueMin",e,t,n),v("clipValueMax",e,t,n))];case"Relu6":return[ct.b(v("x",e,t,n))];case"Rsqrt":return[dt.b(j(e.inputNames[0],t,n))];case"Prod":return[It.W(v("x",e,t,n),v("axes",e,t,n))];case"LeakyRelu":return[Gt.h(v("x",e,t,n),v("alpha",e,t,n))];case"Prelu":return[Et.A(v("x",e,t,n),v("alpha",e,t,n))];case"IsNan":return[kt.i(j(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return(async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const o=v("thenBranch",e,t,n),A=v("elseBranch",e,t,n),i=v("cond",e,t,n),r=v("args",e,t,n);return(await i.data())[0]?n.functionMap[o].executeFunctionAsync(r,n.tensorArrayMap,n.tensorListMap):n.functionMap[A].executeFunctionAsync(r,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const o=v("body",e,t,n),A=v("cond",e,t,n),i=v("args",e,t,n),r=await n.functionMap[A].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),s=i.map((e=>e.id));let a=await r[0].data();r.forEach((e=>{e.kept||-1!==s.indexOf(e.id)||e.dispose()}));let l=i;for(;a[0];){const e=l;l=await n.functionMap[o].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==s.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const i=await n.functionMap[A].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);a=await i[0].data(),i.forEach((e=>{e.kept||-1!==s.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[x(v("pred",e,t,n))];case"Switch":{const o=v("pred",e,t,n);let A=v("data",e,t,n);return A.kept||(A=x(A)),(await o.data())[0]?[void 0,A]:[A,void 0]}case"Merge":{const o=e.inputNames.find((e=>void 0!==j(e,t,n)));return o?[x(j(o,t,n))]:void 0}case"Enter":{const o=v("frameName",e,t,n),A=v("tensor",e,t,n);return n.enterFrame(o),[x(A)]}case"Exit":{const o=v("tensor",e,t,n);return n.exitFrame(),[x(o)]}case"NextIteration":{const o=v("tensor",e,t,n);return n.nextIteration(),[x(o)]}case"TensorArrayV3":{const o=v("size",e,t,n),A=v("dtype",e,t,n),i=v("elementShape",e,t,n),r=v("dynamicSize",e,t,n),s=v("clearAfterRead",e,t,n),a=v("identicalElementShapes",e,t,n),l=v("name",e,t,n),m=new Ct(l,A,o,i,a,r,s);return n.addTensorArray(m),[m.idTensor,(0,C.iD$)(1)]}case"TensorArrayWriteV3":{const o=v("tensorArrayId",e,t,n),A=v("index",e,t,n),i=v("tensor",e,t,n),r=n.getTensorArray(o.id);return r.write(A,i),[r.idTensor]}case"TensorArrayReadV3":{const o=v("tensorArrayId",e,t,n),A=v("index",e,t,n);return[n.getTensorArray(o.id).read(A)]}case"TensorArrayGatherV3":{const o=v("tensorArrayId",e,t,n),A=v("indices",e,t,n),i=v("dtype",e,t,n);return[n.getTensorArray(o.id).gather(A,i)]}case"TensorArrayScatterV3":{const o=v("tensorArrayId",e,t,n),A=v("indices",e,t,n),i=v("tensor",e,t,n),r=n.getTensorArray(o.id);return r.scatter(A,i),[r.idTensor]}case"TensorArrayConcatV3":{const o=v("tensorArrayId",e,t,n),A=n.getTensorArray(o.id),i=v("dtype",e,t,n);return[A.concat(i)]}case"TensorArraySplitV3":{const o=v("tensorArrayId",e,t,n),A=v("tensor",e,t,n),i=v("lengths",e,t,n),r=n.getTensorArray(o.id);return r.split(i,A),[r.idTensor]}case"TensorArraySizeV3":{const o=v("tensorArrayId",e,t,n),A=n.getTensorArray(o.id);return[(0,C.iD$)(A.size(),"int32")]}case"TensorArrayCloseV3":{const o=v("tensorArrayId",e,t,n),A=n.getTensorArray(o.id);return A.clearAndClose(),[A.idTensor]}case"TensorListSetItem":{const o=v("tensorListId",e,t,n),A=v("index",e,t,n),i=v("tensor",e,t,n),r=n.getTensorList(o.id);return r.setItem(A,i),[r.idTensor]}case"TensorListGetItem":{const o=v("tensorListId",e,t,n),A=v("index",e,t,n),i=v("elementShape",e,t,n),r=v("elementDType",e,t,n);return[n.getTensorList(o.id).getItem(A,i,r)]}case"TensorListScatterV2":case"TensorListScatter":{const o=v("indices",e,t,n),A=function(e,t,n,o){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const A=Math.max(...t);if(null!=o&&-1!==o&&A>=o)throw new Error(`Max index must be < array size (${A}  vs. ${o})`);const i=new Dt([],n,e.dtype,o),r=(0,C.HHK)(e,0);return t.forEach(((e,t)=>{i.setItem(e,r[t])})),i}(v("tensor",e,t,n),o,v("elementShape",e,t,n),v("numElements",e,t,n));return n.addTensorList(A),[A.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const o=v("elementShape",e,t,n),A=v("elementDType",e,t,n);let i;i="TensorListReserve"===e.op?"numElements":"maxNumElements";const r=function(e,t,n){return new Dt([],e,t,n)}(o,A,v(i,e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListGather":{const o=v("tensorListId",e,t,n),A=v("indices",e,t,n),i=v("elementShape",e,t,n),r=v("elementDType",e,t,n);return[n.getTensorList(o.id).gather(A,r,i)]}case"TensorListStack":{const o=v("tensorListId",e,t,n),A=v("elementShape",e,t,n),i=v("elementDType",e,t,n),r=v("numElements",e,t,n);return[n.getTensorList(o.id).stack(A,i,r)]}case"TensorListFromTensor":{const o=function(e,t,n){const o=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);gt(e.shape.slice(1),t,"TensorList shape mismatch: ");const A=(0,C.HHK)(e);return new Dt(A,t,o)}(v("tensor",e,t,n),v("elementShape",e,t,n),v("elementDType",e,t,n));return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const o=v("tensorListId",e,t,n),A=n.getTensorList(o.id),i=v("dtype",e,t,n),r=v("elementShape",e,t,n);return[A.concat(i,r)]}case"TensorListPushBack":{const o=v("tensorListId",e,t,n),A=v("tensor",e,t,n),i=n.getTensorList(o.id);return i.pushBack(A),[i.idTensor]}case"TensorListPopBack":{const o=v("tensorListId",e,t,n),A=v("elementShape",e,t,n),i=v("elementDType",e,t,n);return[n.getTensorList(o.id).popBack(A,i)]}case"TensorListSplit":{const o=v("tensor",e,t,n),A=v("elementShape",e,t,n),i=function(e,t,n){let o=0;const A=t.map((e=>(o+=e,o)));if(o!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${o}, and tensor's shape is: ${e.shape}`);const i=Ft(e.shape.slice(1),n),r=0===o?0:e.size/o,s=(0,C.lub)((()=>{const n=[];e=(0,C.XLQ)(e,[1,o,r]);for(let o=0;o<t.length;++o){const s=[0,0===o?0:A[o-1],0],a=[1,t[o],r];n[o]=(0,C.XLQ)((0,C.tPi)(e,s,a),i)}return e.dispose(),n})),a=new Dt([],n,e.dtype,t.length);for(let e=0;e<s.length;e++)a.setItem(e,s[e]);return a}(o,v("lengths",e,t,n),A);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"convolution":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const o=v("stride",e,t,n),A=v("pad",e,t,n),i=v("dataFormat",e,t,n).toUpperCase(),r=v("dilation",e,t,n);return[Jt.P(v("x",e,t,n),v("filter",e,t,n),o,A,i,r)]}case"Conv2D":{const o=v("strides",e,t,n),A=q(e,t,n),i=v("dataFormat",e,t,n).toUpperCase(),r=v("dilations",e,t,n);return[vt.T(v("x",e,t,n),v("filter",e,t,n),[o[1],o[2]],A,i,[r[1],r[2]])]}case"_FusedConv2D":{const{stride:o,pad:A,dataFormat:i,dilations:r,biasArg:s,preluArg:a,activationFunc:l,leakyreluAlpha:m}=St(e,t,n);return[jt.conv2d({x:v("x",e,t,n),filter:v("filter",e,t,n),strides:[o[1],o[2]],pad:A,dataFormat:i,dilations:[r[1],r[2]],bias:s,activation:l,preluActivationWeights:a,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{const{stride:o,pad:A,dataFormat:i,dilations:r,biasArg:s,preluArg:a,activationFunc:l,leakyreluAlpha:m}=St(e,t,n);return[jt.depthwiseConv2d({x:v("x",e,t,n),filter:v("filter",e,t,n),strides:[o[1],o[2]],pad:A,dataFormat:i,dilations:[r[1],r[2]],bias:s,activation:l,preluActivationWeights:a,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const o=v("outputShape",e,t,n),A=v("strides",e,t,n),i=q(e,t,n);return[Kt.b(v("x",e,t,n),v("filter",e,t,n),o,[A[1],A[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const o=v("strides",e,t,n),A=q(e,t,n),i=v("dilations",e,t,n),r=v("dataFormat",e,t,n).toUpperCase();return[yt.B(v("input",e,t,n),v("filter",e,t,n),[o[1],o[2]],A,r,[i[1],i[2]])]}case"Conv3D":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("dataFormat",e,t,n).toUpperCase(),r=v("dilations",e,t,n);return[bt.p(v("x",e,t,n),v("filter",e,t,n),[o[1],o[2],o[3]],A,i,[r[1],r[2],r[3]])]}case"AvgPool":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("kernelSize",e,t,n);return[qt.w(v("x",e,t,n),[i[1],i[2]],[o[1],o[2]],A)]}case"MaxPool":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("kernelSize",e,t,n);return[xt._(v("x",e,t,n),[i[1],i[2]],[o[1],o[2]],A)]}case"MaxPoolWithArgmax":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("kernelSize",e,t,n),r=v("includeBatchInIndex",e,t,n),{result:s,indexes:a}=Bt(v("x",e,t,n),[i[1],i[2]],[o[1],o[2]],A,r);return[s,a]}case"AvgPool3D":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("kernelSize",e,t,n);return[wt.u(v("x",e,t,n),[i[1],i[2],i[3]],[o[1],o[2],o[3]],A)]}case"MaxPool3D":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("kernelSize",e,t,n);return[Mt.Y(v("x",e,t,n),[i[1],i[2],i[3]],[o[1],o[2],o[3]],A)]}case"Dilation2D":{const o=v("strides",e,t,n),A=v("pad",e,t,n),i=v("dilations",e,t,n),r=o[1],s=o[2],a=i[1],l=i[2];return[Lt.W(v("x",e,t,n),v("filter",e,t,n),[r,s],A,[a,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Fill":{const o=v("shape",e,t,n),A=v("dtype",e,t,n),i=v("value",e,t,n);return[Tt.h(o,i,A)]}case"LinSpace":return[Nt(v("start",e,t,n),v("stop",e,t,n),v("num",e,t,n))];case"Multinomial":{const o=v("logits",e,t,n),A=v("numSamples",e,t,n),i=v("seed",e,t,n);return[Ot(o,A,i)]}case"OneHot":{const o=v("indices",e,t,n),A=v("depth",e,t,n),i=v("onValue",e,t,n),r=v("offValue",e,t,n);return[Pt.l(o,A,i,r)]}case"Ones":return[Ut.i(v("shape",e,t,n),v("dtype",e,t,n))];case"OnesLike":return[Vt.J(v("x",e,t,n))];case"RandomUniform":return[Wt.L(v("shape",e,t,n),v("minval",e,t,n),v("maxval",e,t,n),v("dtype",e,t,n))];case"Range":{const o=v("start",e,t,n),A=v("stop",e,t,n),i=v("step",e,t,n);return[_t.w(o,A,i,v("dtype",e,t,n))]}case"TruncatedNormal":{const o=v("shape",e,t,n),A=v("mean",e,t,n),i=v("stdDev",e,t,n),r=v("seed",e,t,n);return[zt.X(o,A,i,v("dtype",e,t,n),r)]}case"Zeros":return[Xt.l(v("shape",e,t,n),v("dtype",e,t,n))];case"ZerosLike":return[Qt.P(v("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:A,maxOutputSize:i,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}=nn(e,t,n),l=await Zt.BHj.nonMaxSuppressionWithScoreAsync(o,A,i,r,s,a);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:A,maxOutputSize:i,iouThreshold:r,scoreThreshold:s}=nn(e,t,n),a=v("padToMaxOutputSize",e,t,n),l=await Zt.BHj.nonMaxSuppressionPaddedAsync(o,A,i,r,s,a);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:A,maxOutputSize:i,iouThreshold:r,scoreThreshold:s}=nn(e,t,n);return[await Zt.BHj.nonMaxSuppressionAsync(o,A,i,r,s)]}case"Where":{const o=Yt.p(v("condition",e,t,n),"bool"),A=[await en(o)];return o.dispose(),A}case"ListDiff":return async function(e,t){const n=(0,Ee._1)(e,"x","setdiff1d"),o=(0,Ee._1)(t,"y","setdiff1d");ke.hu(n.dtype===o.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${o.dtype}).`)),ke.hu(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),ke.hu(1===o.rank,(()=>`y should be 1D tensor, but got y (${o.shape}).`));const A=await n.data(),i=await o.data(),r=new Set(i);let s=0;for(let e=0;e<A.length;e++)r.has(A[e])||s++;const a=new tn.YD([s],n.dtype),l=new tn.YD([s],"int32");for(let e=0,t=0;e<A.length;e++)r.has(A[e])||(a.values[t]=A[e],l.values[t]=e,t++);return[a.toTensor(),l.toTensor()]}(v("x",e,t,n),v("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return C.lub((()=>((e,t,n)=>{switch(e.op){case"TopKV2":{const o=v("x",e,t,n),A=v("k",e,t,n),i=v("sorted",e,t,n),r=on.h(o,A,i);return[r.values,r.indices]}case"Unique":{const o=v("x",e,t,n),A=An.T(o);return[A.values,A.indices]}case"UniqueV2":{const o=v("x",e,t,n),A=v("axis",e,t,n),i=An.T(o,A);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return C.lub((()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const o=v("images",e,t,n),A=v("size",e,t,n),i=v("alignCorners",e,t,n),r=v("halfPixelCenters",e,t,n);return[Zt.BHj.resizeBilinear(o,[A[0],A[1]],i,r)]}case"ResizeNearestNeighbor":{const o=v("images",e,t,n),A=v("size",e,t,n),i=v("alignCorners",e,t,n),r=v("halfPixelCenters",e,t,n);return[Zt.BHj.resizeNearestNeighbor(o,[A[0],A[1]],i,r)]}case"CropAndResize":{const o=v("image",e,t,n),A=v("boxes",e,t,n),i=v("boxInd",e,t,n),r=v("cropSize",e,t,n),s=v("method",e,t,n),a=v("extrapolationValue",e,t,n);return[Zt.BHj.cropAndResize(o,A,i,r,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const o=v("default",e,t,n);return[j(e.name,t,n)||o];case"Placeholder":return[j(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[x(v("x",e,t,n))];case"IdentityN":return v("x",e,t,n).map((e=>x(e)));case"Shape":return[rn.R(v("x",e,t,n).shape,"int32")];case"ShapeN":return v("x",e,t,n).map((e=>rn.R(e.shape)));case"Size":return[sn.i(v("x",e,t,n).size,"int32")];case"Rank":return[sn.i(v("x",e,t,n).rank,"int32")];case"NoOp":return[sn.i(1)];case"Print":const A=v("x",e,t,n),i=v("data",e,t,n),r=v("message",e,t,n),s=v("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(r);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,s));return[A];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Equal":return[ln.D(v("a",e,t,n),v("b",e,t,n))];case"NotEqual":return[mn.Q(v("a",e,t,n),v("b",e,t,n))];case"Greater":return[pn.p(v("a",e,t,n),v("b",e,t,n))];case"GreaterEqual":return[hn.b(v("a",e,t,n),v("b",e,t,n))];case"Less":return[un.d(v("a",e,t,n),v("b",e,t,n))];case"LessEqual":return[cn.z(v("a",e,t,n),v("b",e,t,n))];case"LogicalAnd":return[dn.H(v("a",e,t,n),v("b",e,t,n))];case"LogicalNot":return[In.h(v("a",e,t,n))];case"LogicalOr":return[Gn.K(v("a",e,t,n),v("b",e,t,n))];case"Select":case"SelectV2":return[En.a(v("condition",e,t,n),v("a",e,t,n),v("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return C.lub((()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[kn.O(v("a",e,t,n),v("b",e,t,n),v("transposeA",e,t,n),v("transposeB",e,t,n))];case"Einsum":return[gn(v("equation",e,t,n),...v("tensors",e,t,n))];case"Transpose":return[fn.p(v("x",e,t,n),v("perm",e,t,n))];case"_FusedMatMul":const[o,A]=v("fusedOps",e,t,n),i="biasadd"===o,r="prelu"===A,s=v("numArgs",e,t,n),a=v("leakyreluAlpha",e,t,n);if(i){if(r&&2!==s)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!r&&1!==s)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,m]=v("args",e,t,n);return[jt.matMul({a:v("a",e,t,n),b:v("b",e,t,n),transposeA:v("transposeA",e,t,n),transposeB:v("transposeB",e,t,n),bias:l,activation:A,preluActivationWeights:m,leakyreluAlpha:a})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return C.lub((()=>((e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Hn.t(v("x",e,t,n),v("mean",e,t,n),v("variance",e,t,n),v("offset",e,t,n),v("scale",e,t,n),v("epsilon",e,t,n))];case"LRN":return[Fn.G(v("x",e,t,n),v("radius",e,t,n),v("bias",e,t,n),v("alpha",e,t,n),v("beta",e,t,n))];case"Softmax":return[Cn.X(v("x",e,t,n))];case"LogSoftmax":return[Dn.C(v("x",e,t,n))];case"SparseToDense":return[Jn(v("sparseIndices",e,t,n),v("outputShape",e,t,n),v("sparseValues",e,t,n),v("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Max":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[vn.F(v("x",e,t,n),o,A)]}case"Mean":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[jn.J(v("x",e,t,n),o,A)]}case"Min":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[Kn.V(v("x",e,t,n),o,A)]}case"Sum":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[yn.S(v("x",e,t,n),o,A)]}case"All":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[bn.$(v("x",e,t,n),o,A)]}case"Any":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[qn.Y(v("x",e,t,n),o,A)]}case"ArgMax":{const o=v("axis",e,t,n);return[xn.N(v("x",e,t,n),o)]}case"ArgMin":{const o=v("axis",e,t,n);return[Bn.v(v("x",e,t,n),o)]}case"Prod":{const o=v("axis",e,t,n),A=v("keepDims",e,t,n);return[It.W(v("x",e,t,n),o,A)]}case"Cumsum":{const o=v("axis",e,t,n),A=v("exclusive",e,t,n),i=v("reverse",e,t,n);return[wn.z(v("x",e,t,n),o,A,i)]}case"Bincount":const o=v("x",e,t,n),A=v("weights",e,t,n),i=v("size",e,t,n);return[Mn.y(o,A,i)];case"DenseBincount":{const o=v("x",e,t,n),A=v("weights",e,t,n),i=v("size",e,t,n),r=v("binaryOutput",e,t,n);return[Ln(o,A,i,r)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return C.lub((()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const o=v("n",e,t,n),A=v("axis",e,t,n);let i=v("tensors",e,t,n);return i=i.slice(0,o),[Sn.z(i,A)]}case"Gather":{const o=v("x",e,t,n),A=v("indices",e,t,n);return[Tn.I(o,Yt.p(A,"int32"),0)]}case"GatherV2":{const o=v("axis",e,t,n),A=v("batchDims",e,t,n),i=v("x",e,t,n),r=v("indices",e,t,n);return[Tn.I(i,Yt.p(r,"int32"),o,A)]}case"Reverse":{const o=v("dims",e,t,n),A=[];for(let e=0;e<o.length;e++)o[e]&&A.push(e);const i=v("x",e,t,n);return[Nn.G(i,A)]}case"ReverseV2":{const o=v("axis",e,t,n),A=v("x",e,t,n);return[Nn.G(A,o)]}case"Slice":{const o=v("begin",e,t,n),A=v("size",e,t,n);return[Rn.t(v("x",e,t,n),o,A)]}case"StridedSlice":{const o=v("begin",e,t,n),A=v("end",e,t,n),i=v("strides",e,t,n),r=v("beginMask",e,t,n),s=v("endMask",e,t,n),a=v("ellipsisMask",e,t,n),l=v("newAxisMask",e,t,n),m=v("shrinkAxisMask",e,t,n),p=v("x",e,t,n);return[On.N(p,o,A,i,r,s,a,l,m)]}case"Pack":return(0,C.lub)((()=>{const o=v("axis",e,t,n),A=v("tensors",e,t,n),i=A[0].shape,r=Pn.L(A[0]).shape,s=A.map((e=>{const t=C.D5U.arraysEqual(e.shape,i);if(!t&&!C.D5U.arraysEqual(Pn.L(e).shape,r))throw new Error("the input tensors shape does not match");return t?e:Rt.X(e,i)}));return[Un.k(s,o)]}));case"Unpack":{const o=v("axis",e,t,n),A=v("tensor",e,t,n);return Vn.H(A,o)}case"Tile":{const o=v("reps",e,t,n);return[Wn.G(v("x",e,t,n),o)]}case"Split":case"SplitV":{const o=v("axis",e,t,n),A=v("numOrSizeSplits",e,t,n),i=v("x",e,t,n);return _n.V(i,A,o)}case"ScatterNd":{const o=v("indices",e,t,n),A=v("values",e,t,n),i=v("shape",e,t,n);return[Xn(o,A,i)]}case"GatherNd":{const o=v("x",e,t,n),A=v("indices",e,t,n);return[Qn(o,A)]}case"SparseToDense":{const o=v("sparseIndices",e,t,n),A=v("outputShape",e,t,n),i=v("sparseValues",e,t,n),r=v("defaultValue",e,t,n);return[Jn(o,i,A,i.dtype===r.dtype?r:Yt.p(r,i.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return C.lub((()=>((e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:o,outputValues:A,emptyRowIndicator:i,reverseIndexMap:r}=Zt.rVs.sparseFillEmptyRows(v("indices",e,t,n),v("values",e,t,n),v("denseShape",e,t,n),v("defaultValue",e,t,n));return[o,A,i,r]}case"SparseReshape":{const{outputIndices:o,outputShape:A}=Zt.rVs.sparseReshape(v("inputIndices",e,t,n),v("inputShape",e,t,n),v("newShape",e,t,n));return[o,A]}case"SparseSegmentMean":return[Zt.rVs.sparseSegmentMean(v("data",e,t,n),v("indices",e,t,n),v("segmentIds",e,t,n))];case"SparseSegmentSum":return[Zt.rVs.sparseSegmentSum(v("data",e,t,n),v("indices",e,t,n),v("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return C.lub((()=>((e,t,n)=>{switch(e.op){case"FFT":return[Zn.k(v("x",e,t,n))];case"IFFT":return[Yn.S(v("x",e,t,n))];case"RFFT":return[$n.Q(v("x",e,t,n))];case"IRFFT":return[eo.w(v("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return C.lub((()=>((e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:o,nGramsSplits:A}=Zt.Z_8.stringNGrams(v("data",e,t,n),v("dataSplits",e,t,n),v("separator",e,t,n),v("nGramWidths",e,t,n),v("leftPad",e,t,n),v("rightPad",e,t,n),v("padWidth",e,t,n),v("preserveShortSequences",e,t,n));return[o,A]}case"StringSplit":{const{indices:o,values:A,shape:i}=Zt.Z_8.stringSplit(v("input",e,t,n),v("delimiter",e,t,n),v("skipEmpty",e,t,n));return[o,A,i]}case"StringToHashBucketFast":return[Zt.Z_8.stringToHashBucketFast(v("input",e,t,n),v("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return C.lub((()=>((e,t,n)=>{switch(e.op){case"Cast":return[Yt.p(v("x",e,t,n),v("dtype",e,t,n))];case"ExpandDims":{const o=v("axis",e,t,n);return[to.d(v("x",e,t,n),o)]}case"Squeeze":{const o=v("axis",e,t,n);return[Pn.L(v("x",e,t,n),o)]}case"Reshape":return[Rt.X(v("x",e,t,n),v("shape",e,t,n))];case"MirrorPad":return[no.V(v("x",e,t,n),v("padding",e,t,n),v("mode",e,t,n))];case"PadV2":case"Pad":return[oo.v(v("x",e,t,n),v("padding",e,t,n),v("constantValue",e,t,n))];case"SpaceToBatchND":{const o=v("blockShape",e,t,n),A=v("paddings",e,t,n);return[Ao.f(v("x",e,t,n),o,A)]}case"BatchToSpaceND":{const o=v("blockShape",e,t,n),A=v("crops",e,t,n);return[io.E(v("x",e,t,n),o,A)]}case"DepthToSpace":{const o=v("blockSize",e,t,n),A=v("dataFormat",e,t,n).toUpperCase();return[ro.n(v("x",e,t,n),o,A)]}case"BroadcastTo":return[so.U(v("x",e,t,n),v("shape",e,t,n))];case"BroadcastArgs":return[ao(v("s0",e,t,n),v("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,o)=>{switch(e.op){case"HashTable":case"HashTableV2":{const A=v("keyDType",e,t,n),i=v("valueDType",e,t,n),r=new an(A,i);return o.addHashTable(e.name,r),[r.handle]}case"LookupTableImport":case"LookupTableImportV2":{const A=v("tableHandle",e,t,n,o),i=v("keys",e,t,n),r=v("values",e,t,n),s=o.getHashTableById(A.id);return[await s.import(i,r)]}case"LookupTableFind":case"LookupTableFindV2":{const A=v("tableHandle",e,t,n,o),i=v("keys",e,t,n),r=v("defaultValue",e,t,n),s=o.getHashTableById(A.id);return[await s.find(i,r)]}case"LookupTableSize":case"LookupTableSizeV2":{const A=v("tableHandle",e,t,n,o);return[o.getHashTableById(A.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,o);case"custom":const A=J(e.op);if(A&&A.customExecutor)return A.customExecutor(new ce(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return C.D5U.isPromise(A)?A.then((e=>[].concat(e))):[].concat(A)}class mo{constructor(e={},t={},n={},o={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function po(e,t,n,o){const A=new Set,i=[];let r=null,s=null;const a=new Set,l=Object.keys(e).map((e=>b(e)[0]));let m=[];null!=o&&(m=o.map((e=>b(e.name)[0])));const p=[...t];for(;p.length>0;){const e=p.pop();(Io(e)||Go(e)||Eo(e))&&null==r&&(r=e,s=r.children.map((e=>e.name)).filter((e=>A.has(e)))),A.add(e.name),null==n[e.name]&&-1===l.indexOf(e.name)&&-1===m.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{a.has(e.name)||(a.add(e.name),p.push(e))})):i.push(e.name))}return{inputs:e,outputs:t,usedNodes:A,missingInputs:i,dynamicNode:r,syncInputs:s}}const ho=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],uo=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],co=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Io(e){return ho.indexOf(e.op)>=0}function Go(e){return uo.indexOf(e.op)>=0}function Eo(e){return co.indexOf(e.op)>=0}class ko{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new ko(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),o=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){const n=po(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:A,syncInputs:i}=n;if(null!=A)throw new Error(`This execution contains the node '${A.name}', which has the dynamic op '${A.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){const n=t.map((e=>e.name)),A=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${A}]. Missing the following inputs: [${o}]`)}return function(e,t,n){const{usedNodes:o,inputs:A}=n,i=[],r=Object.keys(A).map((e=>b(e)[0])).map((t=>e.nodes[t])),s=e.initNodes;r.forEach((e=>{o.has(e.name)&&i.push(e)})),e.weights.forEach((e=>{o.has(e.name)&&i.push(e)})),null!=s&&s.forEach((e=>{o.has(e.name)&&i.push(e)}));const a=new Set,l=[];for(;i.length>0;){const e=i.pop();a.add(e.name),t[e.name]||l.push(e),e.children.forEach((e=>{!a.has(e.name)&&o.has(e.name)&&e.inputs.every((e=>a.has(e.name)))&&i.push(e)}))}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const o=n.map((e=>this.graph.nodes[b(e)[0]])),A=t.map((e=>b(e)[0]));let i=A.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const r=this.getCompilationKey(o,i);let s=this.compiledMap.get(r);null==s&&(s=this.compile(e,i),this.compiledMap.set(r,s));const a={},l={};return(0,C.lub)((()=>{const n=new mo(this.weightMap,a,l,this.functionExecutorMap),o=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,A]=b(t),i=[];i[A]=e[t],o[n]=i}));const i=this.getFrozenTensorIds(o),r={};for(let e=0;e<s.length;e++){const t=s[e];if(!o[t.name]){const e=lo(t,o,n,this._resourceManager);if(C.D5U.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);o[t.name]=e,this.checkTensorForDisposal(t.name,t,o,n,i,A,r)}}return null==this.parent&&n.dispose(i),t.map((e=>j(e,o,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,o,A,i,r){"control"!==t.category&&-1===i.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(r[e.id]=(r[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const t=function(e,t,n){return t[y(e,n.currentContextId)]}(e.name,n,o);null!=t&&t.forEach((e=>{if(e&&!e.kept&&!A.has(e.id)){const t=r[e.id];1===t?(e.dispose(),delete r[e.id]):null!=t&&r[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,o={},A={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const i=new mo(this.weightMap,o,A,this.functionExecutorMap),r=await this.executeWithControlFlow(e,i,t,n),s=t.map((e=>j(e,r,i))),a=s.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),m=new Set([...a,...l,...this.weightIds]);return Object.keys(r).forEach((e=>{r[e].forEach((e=>{!e||e.kept||e.isDisposed||m.has(e.id)||e.dispose()}))})),null==this.parent&&i.dispose(m),s}async executeFunctionAsync(e,t,n){const o=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){const A=Object.keys(e),i=A.map((e=>this.graph.nodes[b(e)[0]])),r=n.map((e=>b(e)[0]));let s=r.map((e=>this.graph.nodes[e]));0===s.length&&(s=this._outputs);const{usedNodes:a,missingInputs:l,dynamicNode:m,syncInputs:p}=po(e,s,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),u=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,o]=b(t),A=[];A[o]=e[t],u[n]=A}));const c={},d=this.getFrozenTensorIds(u),I={};for(;h.length>0;){const e=this.processStack(i,h,t,u,I,d,r,c,a);await Promise.all(e)}null!=m||o||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const G=s.filter((e=>!Io(e)&&!j(e.name,u,t))).map((e=>e.name));if(G.length>0){let e="";throw null!=m&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${G}] from the provided inputs [${A}]. Consider providing the following inputs: [${l}]. ${e}`)}return u}processStack(e,t,n,o,A,i,r,s,a){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let m="";if("Enter"===e.node.op&&v("isConstant",e.node,o,n)&&([m]=K(e.node.name,n)),null==o[e.node.name]){const p=lo(e.node,o,n,this._resourceManager);m||([m]=K(e.node.name,n));const h=n.currentContext;C.D5U.isPromise(p)?l.push(p.then((l=>(o[m]=l,n.currentContext=h,this.checkTensorForDisposal(m,e.node,o,n,i,r,s),this.processChildNodes(e.node,t,n,o,A,a),l)))):(o[m]=p,this.checkTensorForDisposal(m,e.node,o,n,i,r,s),this.processChildNodes(e.node,t,n,o,A,a))}else this.processChildNodes(e.node,t,n,o,A,a)}return l}processChildNodes(e,t,n,o,A,i){e.children.forEach((e=>{const[r]=K(e.name,n);!A[r]&&i.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!j(e,o,n)))&&(A[r]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!j(e,o,n)))&&(A[r]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[o]=b(t),A=this.graph.nodes[o];if(A.attrParams.shape&&A.attrParams.shape.value){const e=A.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));C.D5U.assert(t,(()=>`The shape of dict['${A.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}A.attrParams.dtype&&A.attrParams.dtype.value&&C.D5U.assert(n.dtype===A.attrParams.dtype.value,(()=>`The dtype of dict['${A.name}'] provided in model.execute(dict) must be ${A.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const n in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?t[this._signature.inputs[n].name]=e[n]:t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=b(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e),{})}checkOutputs(e){e.forEach((e=>{const[t]=b(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class go{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class fo{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new go}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=C.io.browserHTTPRequest(e,this.loadOptions);else{const t=C.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(C.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const o=C.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ko($.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=$.Instance.transformGraph(e.modelInitializer);this.initializer=new ko(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=C.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof C.esB||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,o)=>(t[n]=e[o],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Ho(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const n=new fo(e,t);return await n.load(),n}const Fo="3.11.0"},8713:(e,t,n)=>{"use strict";n.d(t,{JL:()=>o,Zu:()=>A});class o{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class A{refCount(e){return i("refCount")}incRef(e){return i("incRef")}timerAvailable(){return!0}time(e){return i("time")}read(e){return i("read")}readSync(e){return i("readSync")}numDataIds(){return i("numDataIds")}disposeData(e,t){return i("disposeData")}write(e,t,n){return i("write")}move(e,t,n,o,A){return i("move")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return i("dispose")}}function i(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},3337:(e,t,n)=>{"use strict";function o(e,t,n){const o=function(e,t,n){return function(e,t,n){let o=0,A=e.length,i=0,r=!1;for(;o<A;){i=o+(A-o>>>1);const s=n(t,e[i]);s>0?o=i+1:(A=i,r=!s)}return r?o:-o-1}(e,t,n||A)}(e,t,n),i=o<0?-(o+1):o;e.splice(i,0,t)}function A(e,t){return e>t?1:e<t?-1:0}function i(e,t,n,o,A){return a(e,t,n,o,A,0)}function r(e,t,n,o,A,i){return a(e,t,n,o,A,0,!1,i,!0)}function s(e,t,n,o,A,i){return a(e,t,n,o,A,i,!0)}function a(e,t,n,A,i,r,s=!1,a=!1,h=!1){const u=[];for(let e=0;e<t.length;e++)t[e]>i&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(p);const c=r>0?-.5/r:0,d=[],I=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:r,suppressBeginIndex:s}=t;if(n<i)break;let a=!1;for(let n=d.length-1;n>=s;--n){const o=l(e,r,d[n]);if(o>=A){a=!0;break}if(t.score=t.score*m(A,c,o),t.score<=i)break}t.suppressBeginIndex=d.length,a||(t.score===n?(d.push(r),I.push(t.score)):t.score>i&&o(u,t,p))}const G=d.length,E=n-G;a&&E>0&&(d.push(...new Array(E).fill(0)),I.push(...new Array(E).fill(0)));const k={selectedIndices:d};return s&&(k.selectedScores=I),h&&(k.validOutputs=G),k}function l(e,t,n){const o=e.subarray(4*t,4*t+4),A=e.subarray(4*n,4*n+4),i=Math.min(o[0],o[2]),r=Math.min(o[1],o[3]),s=Math.max(o[0],o[2]),a=Math.max(o[1],o[3]),l=Math.min(A[0],A[2]),m=Math.min(A[1],A[3]),p=Math.max(A[0],A[2]),h=Math.max(A[1],A[3]),u=(s-i)*(a-r),c=(p-l)*(h-m);if(u<=0||c<=0)return 0;const d=Math.max(i,l),I=Math.max(r,m),G=Math.min(s,p),E=Math.min(a,h),k=Math.max(G-d,0)*Math.max(E-I,0);return k/(u+c-k)}function m(e,t,n){const o=Math.exp(t*n*n);return n<=e?o:0}function p(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,{GP:()=>i,qP:()=>r,pA:()=>s})},8333:(e,t,n)=>{"use strict";n.d(t,{Z:()=>A});var o=n(2657);function A(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const A=(0,o.f)(e,"int32"),i=(0,o.f)([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const o=A.indexToLoc(n[t]),r=t*e.length;i.values.set(o,r)}return i.toTensor()}},7097:(e,t,n)=>{"use strict";n.d(t,{BV:()=>g,wv:()=>k});var o=n(8713),A=n(2885),i=n(5938),r=n(9121),s=n(6151),a=n(9122),l=n(569);class m{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new h)}profileKernel(e,t,n){let o;const i=()=>{o=n()};let r;const s=a.now();if(this.backendTimer.timerAvailable())r=this.backendTimer.time(i);else{i();for(const e of o)e.dataSync();r=Promise.resolve({kernelMs:a.now()-s})}if((0,A.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<o.length;t++){const n=o[t];n.data().then((t=>{p(t,n.dtype,e)}))}return{kernelName:e,outputs:o,inputs:t,timeMs:r.then((e=>e.kernelMs)),extraInfo:r.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:o,inputs:A,extraInfo:i}=e;n.forEach((e=>{Promise.all([e.data(),o,i]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],A,n[2])}))}))}}function p(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const o=e[t];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${n}'`),!0}return!1}class h{logKernelProfile(e,t,n,o,A,i){const r="number"==typeof o?l.oj(`${o}ms`,9):o.error,s=l.oj(e,25),a=t.rank,m=t.size,p=l.oj(t.shape.toString(),14);let h="";for(const e in A){const n=A[e];if(null!=n){const o=n.shape||t.shape,A=o.length;h+=`${e}: ${A}D ${A>0?o:""} `}}console.log(`%c${s}\t%c${r}\t%c${a}D ${p}\t%c${m}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var u=n(4077),c=n(747),d=n(4706);function I(e){return null!=e.kernelName}class G{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class E{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new G}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(d.Z(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new m(this.backendInstance),!0}setupRegisteredKernels(){(0,s.tr)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){(0,s.tr)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof o.Zu||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,o=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,d.Z(`Initialization of backend ${e} failed`),d.Z(n.stack||n.message)),!1)));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(t){return d.Z(`Initialization of backend ${e} failed`),d.Z(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:o,asyncInit:A}=this.initializeBackend(n);if(A||o)return{name:n,asyncInit:A}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),o=n.backend,A=this.readSync(t),i=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,A,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,o=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=e}return this.scopedRun((()=>this.startScope(o)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return E.nextTensorId++}nextVariableId(){return E.nextVariableId++}clone(e){const t=g.runKernel(r.iJ,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return g.runKernel(r.RF,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==(0,s.pI)(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const o=this.backend.numDataIds();let A=0;n.forEach((e=>{A+="complex64"===e.dtype?3:1}));const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],r=o-t-A-i;if(r>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${r} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const o=this.isTapeOn(),A=this.state.numBytes,i=this.state.numTensors;let r,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const m=I(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(I(e)){const{kernelName:t,inputs:A,attrs:i}=e;null==this.backendName&&this.backend;const m=(0,s.pI)(t,this.backendName);l.hu(null!=m,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),r=()=>{const e=this.backend.numDataIds();a=m.kernelFunc({inputs:A,attrs:i,backend:this.backend});const r=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,r);const s=r.map((e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:o}=e;return this.makeTensorFromDataId(t,n,o)}));if(o){const e=this.getTensorsForGradient(t,A,s);n=this.saveTensorsForBackwardMode(e)}return s}}else{const{forwardFunc:t}=e,A=e=>{o&&(n=e.map((e=>this.keep(this.clone(e)))))};r=()=>{const e=this.backend.numDataIds();a=this.tidy((()=>t(this.backend,A)));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,e,n),n}}const{inputs:p,attrs:h}=e,u=I(e)?null:e.backwardsFunc;let c;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(c=this.profiler.profileKernel(m,p,(()=>r())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(c),t=c.outputs):t=r()})),o&&this.addTapeNode(m,p,t,u,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:m,bytesAdded:this.state.numBytes-A,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map((e=>null!=p[e]?p[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:c.timeMs,extraInfo:c.extraInfo}),Array.isArray(a)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const o=(0,s.uk)(e);if(null!=o){const e=o.inputsToSave||[],A=o.outputsToSave||[];let i;o.saveAllInputs?(l.hu(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),i=Object.keys(t).map((e=>t[e]))):i=e.map((e=>t[e]));const r=n.filter(((e,t)=>A[t]));return i.concat(r)}return[]}makeTensor(e,t,n,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let A=e;"string"===n&&l.HD(e[0])&&(A=e.map((e=>a.encodeString(e))));const i=o.write(A,t,n),r=new u.es(t,n,i,this.nextTensorId());if(this.trackTensor(r,o),"string"===n){const e=this.state.tensorInfo.get(i),t=(0,l.Ub)(A);this.state.numBytes+=t-e.bytes,e.bytes=t}return r}makeTensorFromDataId(e,t,n,o){n=n||"float32";const A=new u.es(t,n,e,this.nextTensorId());return this.trackTensor(A,o),A}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const A=new u._w(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[A.name])throw new Error(`Variable with name ${A.name} was already registered`);return this.state.registeredVariables[A.name]=A,this.incRef(A,this.backend),A}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*l.bT(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof u._w||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*l.bT(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,o,A,i){const r={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:A},a=(0,s.uk)(e);null!=a&&(o=a.gradFunc),null!=o&&(r.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],o=l.wT(e.size,e.dtype);return this.makeTensor(o,e.shape,e.dtype)}return e})),o(e.length>1?e:e[0],A,i))),this.state.activeTape.push(r)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=(0,c.getTensorsInContainer)(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==o.id||this.track(e)}))}gradients(e,t,n,o=!1){if(l.hu(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const A=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));l.hu(A instanceof u.es,(()=>"The result y returned by f() must be a tensor."));const i=function(e,t,n){const o={},A={};for(let e=0;e<t.length;e++)o[t[e].id]=!0;for(let n=0;n<e.length;n++){const i=e[n],r=i.inputs;for(const e in r){const n=r[e];let s=!1;for(let e=0;e<t.length;e++)if(o[n.id]){i.outputs.forEach((e=>o[e.id]=!0)),s=!0,A[i.id]=!0;break}if(s)break}}const i={};i[n.id]=!0;const r={};for(let t=e.length-1;t>=0;t--){const n=e[t],o=n.inputs;for(let e=0;e<n.outputs.length;e++)if(i[n.outputs[e].id]){for(const e in o)i[o[e].id]=!0,r[n.id]=!0;break}}const s=[];for(let t=0;t<e.length;t++){const n=e[t];if(A[n.id]&&r[n.id]){const e={};for(const t in n.inputs){const A=n.inputs[t];o[A.id]&&(e[t]=A)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,s.push(t)}}return s}(this.state.activeTape,t,A);if(!o&&0===i.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[A.id]=null==n?function(e){const t=(0,l.p8)((0,l.NA)(e),"float32");return g.makeTensor(t,e,"float32")}(A.shape):n,function(e,t,n,o){for(let A=t.length-1;A>=0;A--){const i=t[A],r=[];if(i.outputs.forEach((t=>{const n=e[t.id];null!=n?r.push(n):r.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const s=i.gradient(r);for(const t in i.inputs){if(!(t in s))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(s)}.`);const A=n((()=>s[t]()));if("float32"!==A.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${A.dtype}'`);const r=i.inputs[t];if(!l.cO(A.shape,r.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${A.shape}', which does not match the shape of the input '${r.shape}'`);if(null==e[r.id])e[r.id]=A;else{const t=e[r.id];e[r.id]=o(t,A),t.dispose()}}}}(e,i,(e=>this.tidy(e)),f);const o=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:A,grads:o}}))}customGrad(e){return l.hu(l.mf(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;l.hu(t.every((e=>e instanceof u.es)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};return t.forEach(((e,t)=>{o[t]=e})),this.runKernelFunc({forwardFunc:(o,A)=>(n=e(...t,A),l.hu(n.value instanceof u.es,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),l.hu(l.mf(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,o)=>{const A=n.gradFunc(e,o),i=Array.isArray(A)?A:[A];l.hu(i.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),l.hu(i.every((e=>e instanceof u.es)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const r={};return i.forEach(((e,t)=>{r[t]=()=>e})),r},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=(0,a.now)(),n=await this.backend.time(e);return n.wallMs=(0,a.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new G;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function k(){const e=(0,i.D)();if(null==e._tfengine){const t=new A.qA(e);e._tfengine=new E(t)}return(0,A.iG)(e._tfengine.ENV),(0,u.Vi)((()=>e._tfengine)),e._tfengine}E.nextTensorId=0,E.nextVariableId=0;const g=k();function f(e,t){const n={a:e,b:t};return g.runKernel(r.mm,n)}},2885:(e,t,n)=>{"use strict";n.d(t,{qA:()=>i,OB:()=>s,iG:()=>l});var o=n(569),A=n(4706);class i{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=r,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&A.Z(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];A.Z(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if((0,o.tI)(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}function r(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function s(){return a}let a=null;function l(e){a=e}},5938:(e,t,n)=>{"use strict";let o;function A(){if(null==o){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}o=e}return o}function i(e,t){const n=function(){const e=A();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const o=t();return n.set(e,o),n.get(e)}}n.d(t,{D:()=>A,R:()=>i})},4368:(e,t,n)=>{"use strict";n.d(t,{SR:()=>s,sq:()=>a,lu:()=>l,B9:()=>m,Cn:()=>p,jq:()=>h,y3:()=>u});var o=n(7097),A=n(2885),i=n(4077),r=n(747);function s(){return o.BV}function a(){return o.BV.memory()}function l(e,t){return o.BV.tidy(e,t)}function m(e){(0,r.getTensorsInContainer)(e).forEach((e=>e.dispose()))}function p(e){return o.BV.keep(e)}function h(e,t,n=1){return o.BV.registerBackend(e,t,n)}function u(){return o.BV.backend}(0,i.FZ)((function(e){(0,A.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}))},633:(e,t,n)=>{"use strict";n.d(t,{cb:()=>s,pn:()=>r});var o=n(7097),A=n(4077),i=n(569);function r(e,t){i.hu(i.mf(e),(()=>"The f passed in variableGrads(f) must be a function")),i.hu(null==t||Array.isArray(t)&&t.every((e=>e instanceof A._w)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in o.BV.registeredVariables)t.push(o.BV.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),i.hu(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:l}=o.BV.gradients(e,t,null,!0);i.hu(l.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),i.hu(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const m={};return t.forEach(((e,t)=>{null!=l[t]&&(m[e.name]=l[t])})),null!=r&&r.forEach((e=>m[e.name]=null)),{value:a,grads:m}}function s(e){return o.BV.customGrad(e)}},1140:(e,t,n)=>{"use strict";n.d(t,{SYM:()=>Me.SY,VGw:()=>Me.VG,SpW:()=>Me.Sp,mm_:()=>Me.mm,Xze:()=>Me.Xz,oT6:()=>Me.oT,IKK:()=>Me.IK,sJF:()=>Me.sJ,aJk:()=>Me.aJ,M2y:()=>Me.M2,qw7:()=>Me.qw,jMg:()=>Me.jM,QCc:()=>Me.QC,Oyi:()=>Me.Oy,JhU:()=>Me.Jh,_k9:()=>Me._k,IMb:()=>Me.IM,ROF:()=>Me.RO,XLW:()=>Me.XL,zws:()=>Me.zw,zvY:()=>Me.zv,eEB:()=>Me.eE,RFZ:()=>Me.RF,gJX:()=>Me.gJ,xnO:()=>Me.xn,Zz9:()=>Me.Zz,yj2:()=>Me.yj,Eh3:()=>Me.Eh,mhS:()=>Me.mh,wUP:()=>Me.wU,wm:()=>Me.wm,x12:()=>Me.x1,o2y:()=>Me.o2,ik2:()=>Me.ik,mc4:()=>Me.mc,TR1:()=>Me.TR,VcC:()=>Me.Vc,iHb:()=>Me.iH,JLz:()=>fn.JL,QRR:()=>Me.QR,T0n:()=>Me.T0,cie:()=>Me.ci,sL$:()=>Me.sL,y7R:()=>Me.y7,$w:()=>Me.$w,p4S:()=>Me.p4,Vn9:()=>Me.Vn,ekb:()=>Me.ek,$g6:()=>Me.$g,SX0:()=>Me.SX,HEU:()=>Me.HE,hdR:()=>Me.hd,Omj:()=>Me.Om,NEP:()=>Me.NE,YFo:()=>Me.YF,Y0y:()=>Me.Y0,vwp:()=>Me.vw,deh:()=>Me.de,Uyb:()=>Me.Uy,OR:()=>Me.OR,jeX:()=>Me.je,eBW:()=>Me.eB,sHE:()=>Me.sH,_V0:()=>Me._V,luS:()=>Me.lu,q1x:()=>Me.q1,qi_:()=>Me.qi,iZT:()=>Me.iZ,Acj:()=>Me.Ac,Qg5:()=>Me.Qg,iJz:()=>Me.iJ,J_u:()=>Me.J_,avt:()=>Me.av,iWB:()=>Me.iW,r7n:()=>Me.r7,Zuw:()=>fn.Zu,eZ0:()=>Me.eZ,Hhh:()=>Me.Hh,J$2:()=>Me.J$,vtC:()=>Me.vt,CAk:()=>Me.CA,e7N:()=>Me.e7,ZbH:()=>Me.Zb,kU:()=>Me.kU,PYm:()=>Me.PY,VfG:()=>Me.Vf,MZg:()=>Me.MZ,YoZ:()=>Me.Yo,mTV:()=>Me.mT,OAf:()=>Me.OA,OU7:()=>Me.OU,OV7:()=>Me.OV,vFR:()=>Me.vF,BMI:()=>Me.BM,q2K:()=>Me.q2,c17:()=>Me.c1,q8u:()=>Me.q8,jQs:()=>Me.jQ,Vbg:()=>Me.Vb,NZg:()=>Me.NZ,wYn:()=>Me.wY,kuV:()=>Me.ku,uv1:()=>Me.uv,cye:()=>Me.cy,W0H:()=>Me.W0,yQU:()=>Me.yQ,we_:()=>Me.we,qWM:()=>Me.qW,gaJ:()=>nt,QiL:()=>Me.Qi,lyA:()=>Me.ly,pe_:()=>Me.pe,o0g:()=>Me.o0,DlI:()=>Me.Dl,e6w:()=>Me.e6,xJR:()=>Me.xJ,oHH:()=>Me.oH,$HU:()=>Me.$H,qkr:()=>Me.qk,SbG:()=>Me.Sb,HZH:()=>Me.HZ,_Yw:()=>Me._Y,zbQ:()=>Me.zb,dpD:()=>Me.dp,Hmb:()=>Me.Hm,mKl:()=>Me.mK,b9H:()=>Me.b9,e07:()=>Me.e0,bV0:()=>Me.bV,xQA:()=>Me.xQ,PhF:()=>Me.Ph,oFR:()=>Me.oF,a5O:()=>Me.a5,i5y:()=>Me.i5,RQH:()=>Me.RQ,wYB:()=>Me.w3,p2w:()=>Me.p2,Gcp:()=>Me.Gc,MRv:()=>Me.MR,TQc:()=>Me.TQ,O3z:()=>Me.O3,nhH:()=>Me.nh,w3H:()=>Me.YW,ZjV:()=>Me.Zj,D2d:()=>Me.D2,L8s:()=>Me.L8,FKq:()=>Me.FK,bK0:()=>Me.bK,_tC:()=>Me._t,h8e:()=>Me.h8,jQk:()=>Me.m2,_JP:()=>Me._J,s1s:()=>Me.s1,XkS:()=>Me.Xk,Tr8:()=>Me.Tr,GBy:()=>Me.GB,sEM:()=>Me.sE,MIZ:()=>Me.MI,esB:()=>Ge.es,YDk:()=>Ge.YD,n9L:()=>Me.n9,cWu:()=>Me.cW,wx7:()=>Me.wx,G3Y:()=>Me.G3,kpP:()=>Me.kp,ToN:()=>Me.To,Qvg:()=>Me.Qv,RuY:()=>Me.Ru,usg:()=>Me.us,WnP:()=>At.WnP,IHx:()=>At.IHx,$6P:()=>At.$6P,YjB:()=>At.YjB,NqF:()=>At.NqF,wS1:()=>At.wS1,uR5:()=>At.uR5,y3$:()=>$e.y3,Wap:()=>a,Dxk:()=>At.Dxk,JY5:()=>At.JY5,p3b:()=>At.p3b,Xhn:()=>i,f3b:()=>At.f3b,pju:()=>At.pju,iUl:()=>At.iUl,d9v:()=>At.d9v,zoF:()=>At.zoF,gME:()=>At.gME,Izb:()=>At.Izb,MNy:()=>At.MNy,ZaL:()=>At.ZaL,PAt:()=>At.PAt,Tek:()=>At.Tek,bc:()=>At.bc,pdZ:()=>At.pdZ,$QV:()=>At.$QV,B10:()=>At.B10,C2$:()=>o,B90:()=>$e.B9,hiC:()=>At.hiC,rvX:()=>At.rvX,pyx:()=>At.pyx,SRH:()=>$e.SR,OBj:()=>d.OB,DgJ:()=>At.DgJ,Qqt:()=>At.Qqt,dt4:()=>At.dt4,iyy:()=>At.iyy,hlL:()=>At.hlL,GWj:()=>At.GWj,imm:()=>At.imm,Iqj:()=>At.Iqj,pjt:()=>At.pjt,brS:()=>At.brS,BHj:()=>At.BHj,io:()=>A,CnY:()=>$e.Cn,GDt:()=>l,hi7:()=>At.hi7,$r2:()=>At.$r2,cM7:()=>At.cM7,Krr:()=>At.Krr,CmS:()=>At.CmS,HvI:()=>At.HvI,OI3:()=>At.OI3,Fp7:()=>At.Fp7,_sB:()=>At._sB,YQQ:()=>At.YQQ,gWQ:()=>At.gWQ,J69:()=>At.J69,sq6:()=>$e.sq,LTh:()=>At.LTh,Gi7:()=>At.Gi7,dC7:()=>At.dC7,W76:()=>At.W76,glt:()=>Jt,Quu:()=>At.Quu,lfX:()=>At.lfX,iUs:()=>At.iUs,JpU:()=>At.JpU,vku:()=>At.vku,AL3:()=>At.AL3,nGf:()=>At.nGf,LGj:()=>At.LGj,jqO:()=>$e.jq,wCN:()=>Le.wC,UYe:()=>At.UYe,XLQ:()=>At.XLQ,GYS:()=>At.GYS,iD$:()=>At.iD$,U8D:()=>At.U8D,U_I:()=>At.U_I,m7h:()=>r,XD2:()=>At.XD2,tPi:()=>At.tPi,jZU:()=>At.jZU,SmN:()=>At.SmN,CnO:()=>At.CnO,p0P:()=>At.p0P,kuN:()=>We,XAC:()=>At.XAC,Wvh:()=>At.Wvh,Vl2:()=>At.Vl2,_b3:()=>At._b3,L9e:()=>At.L9e,knu:()=>At.knu,luU:()=>At.luU,Smz:()=>At.Smz,z4k:()=>ot.z4,AEp:()=>At.AEp,XeE:()=>At.XeE,RRF:()=>At.RRF,odF:()=>At.odF,piX:()=>Qe,lub:()=>$e.lu,Gg6:()=>At.Gg6,p_j:()=>Ct,p4s:()=>At.p4s,Xu6:()=>At.Xu6,HHK:()=>At.HHK,x8V:()=>ot.x8,D5U:()=>Ze,VD$:()=>At.VD$,jTM:()=>Ye,arb:()=>At.arb,lls:()=>At.lls,P84:()=>At.P84});var o={};n.r(o),n.d(o,{isBrowser:()=>c,isMobile:()=>u,mockIsMobile:()=>h});var A={};n.r(A),n.d(A,{browserFiles:()=>He,browserHTTPRequest:()=>be,concatenateArrayBuffers:()=>J,copyModel:()=>me,decodeWeights:()=>H,encodeWeights:()=>f,fromMemory:()=>Be,getLoadHandlers:()=>M,getModelArtifactsForJSON:()=>K,getModelArtifactsInfoForJSON:()=>y,getSaveHandlers:()=>w,http:()=>ye,isHTTPScheme:()=>je,listModels:()=>ae,loadWeights:()=>De,moveModel:()=>pe,registerLoadRouter:()=>B,registerSaveRouter:()=>x,removeModel:()=>le,weightsLoaderFactory:()=>Je,withSaveHandler:()=>we});var i={};n.r(i),n.d(i,{fromPixels:()=>Ve,fromPixelsAsync:()=>Pe,toPixels:()=>Ue});var r={};n.r(r),n.d(r,{Serializable:()=>_e,SerializationMap:()=>ze,registerClass:()=>Xe});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>In,computeOutShape:()=>dn,segOpComputeOptimalWindowSize:()=>cn});var a={};n.r(a),n.d(a,{ERF_A1:()=>Vt,ERF_A2:()=>Wt,ERF_A3:()=>_t,ERF_A4:()=>zt,ERF_A5:()=>Xt,ERF_P:()=>Ut,PARALLELIZE_THRESHOLD:()=>xt,SELU_SCALE:()=>Pt.$,SELU_SCALEALPHA:()=>Pt.y,applyActivation:()=>qt.QH,assertAndGetBroadcastShape:()=>jt.$N,assertAxesAreInnerMostDims:()=>vt.lB,assertParamsConsistent:()=>Kt,assignToTypedArray:()=>nn,axesAreInnerMostDims:()=>vt.YB,calculateShapes:()=>Ot.SU,checkEinsumDimSizes:()=>ln,combineLocations:()=>vt.Vh,complexWithEvenIndex:()=>$t,complexWithOddIndex:()=>en,computeConv2DInfo:()=>bt.Ix,computeConv3DInfo:()=>bt.jw,computeDefaultPad:()=>bt.aO,computeDilation2DInfo:()=>bt.Rf,computeOptimalWindowSize:()=>Bt,computeOutAndReduceShapes:()=>vt.kz,computeOutShape:()=>yt,computePool2DInfo:()=>bt.Xw,computePool3DInfo:()=>bt.pl,convertConv2DDataFormat:()=>bt.sl,decodeEinsumEquation:()=>sn,eitherStridesOrDilationsAreOne:()=>bt.jT,expandShapeToKeepDim:()=>vt.rv,exponent:()=>An,exponents:()=>on,fromStringArrayToUint8:()=>En,fromUint8ToStringArray:()=>Gn,getAxesPermutation:()=>vt.Q3,getBroadcastDims:()=>jt.XF,getComplexWithIndex:()=>tn,getEinsumComputePath:()=>mn,getEinsumPermutation:()=>an,getFusedBiasGradient:()=>qt.pf,getFusedDyActivation:()=>qt.Fr,getImageCenter:()=>wt,getInnerMostAxes:()=>vt.sY,getPermuted:()=>Lt,getReductionAxes:()=>jt.RR,getReshaped:()=>Mt,getReshapedPermuted:()=>St,getSliceBeginCoords:()=>Tt,getSliceSize:()=>Nt,getUndoAxesPermutation:()=>vt.LJ,isIdentityPermutation:()=>pn,log:()=>Qt.c,mergeRealAndImagArrays:()=>Zt,prepareAndValidate:()=>Rt,prepareSplitSize:()=>un,segment_util:()=>s,shouldFuse:()=>qt.uy,slice_util:()=>We,splitRealAndImagArrays:()=>Yt,tupleValuesAreOne:()=>bt.I0,upcastType:()=>ot.x8,validateInput:()=>Ot.b0,validateUpdateShape:()=>Ot.l5,warn:()=>Qt.Z});var l={};n.r(l),n.d(l,{GP:()=>kn.GP,qP:()=>kn.qP,pA:()=>kn.pA,ZA:()=>gn.Z});var m=n(7097);let p;function h(e){p=e}function u(e){if(void 0!==p)return p;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function c(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var d=n(2885);const I=(0,d.OB)();I.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),I.registerFlag("IS_BROWSER",(()=>c())),I.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),I.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),I.registerFlag("PROD",(()=>!1)),I.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>I.getBool("DEBUG"))),I.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),I.registerFlag("IS_TEST",(()=>!1)),I.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),I.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1));var G=n(1661),E=n(701),k=n(569);const g={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function f(e,t){const n=[],o=[],A=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<A.length;++i){const r=A[i],s=Array.isArray(e)?e[i].tensor:e[r];if("float32"!==s.dtype&&"int32"!==s.dtype&&"bool"!==s.dtype&&"string"!==s.dtype&&"complex64"!==s.dtype)throw new Error(`Unsupported dtype in weight '${r}': ${s.dtype}`);const a={name:r,shape:s.shape,dtype:s.dtype};if("string"===s.dtype){const e=new Promise((async e=>{const t=await s.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,o=new Uint8Array(n);let A=0;for(let e=0;e<t.length;e++){const n=t[e],i=new Uint8Array(new Uint32Array([n.length]).buffer);o.set(i,A),A+=4,o.set(n,A),A+=n.length}e(o)}));o.push(e)}else o.push(s.data());null!=t&&(a.group=t),n.push(a)}return{data:F(await Promise.all(o)),specs:n}}function H(e,t){const n={};let o,A=0;for(const i of t){const t=i.name,r=i.dtype,s=i.shape,a=(0,k.NA)(s);let l;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${r}.`)}const s=g[n.dtype],m=e.slice(A,A+a*s),p="uint8"===n.dtype?new Uint8Array(m):new Uint16Array(m);if("float32"===r)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(p.length);for(let e=0;e<p.length;e++){const t=p[e];l[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===o&&(o=b()),l=o(p)}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${t}': ${r}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(p.length);for(let e=0;e<p.length;e++){const t=p[e];l[e]=Math.round(t*n.scale+n.min)}}A+=a*s}else if("string"===r){const t=(0,k.NA)(i.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(A,A+4))[0];A+=4;const n=new Uint8Array(e.slice(A,A+t));l.push(n),A+=t}}else{const o=g[r],i=e.slice(A,A+a*o);if("float32"===r)l=new Float32Array(i);else if("int32"===r)l=new Int32Array(i);else if("bool"===r)l=new Uint8Array(i);else{if("complex64"!==r)throw new Error(`Unsupported dtype in weight '${t}': ${r}`);{l=new Float32Array(i);const e=new Float32Array(l.length/2),o=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],o[t]=l[2*t+1];const A=(0,E.X)(e,s,"float32"),r=(0,E.X)(o,s,"float32");n[t]=(0,G.P)(A,r),A.dispose(),r.dispose()}}A+=a*o}"complex64"!==r&&(n[t]=(0,E.X)(l,s,r))}return n}function F(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const o=new Uint8Array(t);let A=0;return n.forEach((e=>{o.set(new Uint8Array(e.buffer),A),A+=e.byteLength})),o.buffer}const C="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function D(e){return C?Buffer.byteLength(e):new Blob([e]).size}function J(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let o=0;return e.forEach((e=>{n.set(new Uint8Array(e),o),o+=e.byteLength})),n.buffer}function v(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function j(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function K(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){const[o,A]=await t(e.weightsManifest);n.weightSpecs=o,n.weightData=A}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function y(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:D(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:D(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function b(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return o=>{const A=new ArrayBuffer(4*o.length),i=new Uint32Array(A);for(let A=0;A<o.length;A++){const r=o[A],s=e[n[r>>10]+(1023&r)]+t[r>>10];i[A]=s}return new Float32Array(A)}}class q{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==q.instance&&(q.instance=new q),q.instance}static registerSaveRouter(e){q.getInstance().saveRouters.push(e)}static registerLoadRouter(e){q.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return q.getHandlers(e,"save")}static getLoadHandlers(e,t){return q.getHandlers(e,"load",t)}static getHandlers(e,t,n){const o=[];return("load"===t?q.getInstance().loadRouters:q.getInstance().saveRouters).forEach((t=>{const A=t(e,n);null!==A&&o.push(A)})),o}}const x=e=>q.registerSaveRouter(e),B=e=>q.registerLoadRouter(e),w=e=>q.getSaveHandlers(e),M=(e,t)=>q.getLoadHandlers(e,t),L="tensorflowjs",S="models_store",T="model_info_store";function N(){if(!(0,d.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function R(e){const t=e.result;t.createObjectStore(S,{keyPath:"modelPath"}),t.createObjectStore(T,{keyPath:"modelPath"})}class O{constructor(e){if(this.indexedDB=N(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const o=this.indexedDB.open(L,1);o.onupgradeneeded=()=>R(o),o.onsuccess=()=>{const A=o.result;if(null==t){const t=A.transaction(S,"readonly"),o=t.objectStore(S).get(this.modelPath);o.onsuccess=()=>{if(null==o.result)return A.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(o.result.modelArtifacts)},o.onerror=e=>(A.close(),n(o.error)),t.oncomplete=()=>A.close()}else{const o=y(t),i=A.transaction(T,"readwrite");let r=i.objectStore(T);const s=r.put({modelPath:this.modelPath,modelArtifactsInfo:o});let a;s.onsuccess=()=>{a=A.transaction(S,"readwrite");const s=a.objectStore(S).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o});s.onsuccess=()=>e({modelArtifactsInfo:o}),s.onerror=e=>{r=i.objectStore(T);const t=r.delete(this.modelPath);t.onsuccess=()=>(A.close(),n(s.error)),t.onerror=e=>(A.close(),n(s.error))}},s.onerror=e=>(A.close(),n(s.error)),i.oncomplete=()=>{null==a?A.close():a.oncomplete=()=>A.close()}}},o.onerror=e=>n(o.error)}))}}O.URL_SCHEME="indexeddb://";const P=e=>{return(0,d.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(O.URL_SCHEME)?(t=e.slice(O.URL_SCHEME.length),new O(t)):null;var t};q.registerSaveRouter(P),q.registerLoadRouter(P);class U{constructor(){this.indexedDB=N()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(L,1);n.onupgradeneeded=()=>R(n),n.onsuccess=()=>{const o=n.result,A=o.transaction(T,"readonly"),i=A.objectStore(T).getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(o.close(),t(i.error)),A.oncomplete=()=>o.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(O.URL_SCHEME)?t.slice(O.URL_SCHEME.length):t,new Promise(((t,n)=>{const o=this.indexedDB.open(L,1);o.onupgradeneeded=()=>R(o),o.onsuccess=()=>{const A=o.result,i=A.transaction(T,"readwrite"),r=i.objectStore(T),s=r.get(e);let a;s.onsuccess=()=>{if(null==s.result)return A.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const o=r.delete(e),i=()=>{a=A.transaction(S,"readwrite");const o=a.objectStore(S).delete(e);o.onsuccess=()=>t(s.result.modelArtifactsInfo),o.onerror=e=>n(s.error)};o.onsuccess=i,o.onerror=e=>(i(),A.close(),n(s.error))}},s.onerror=e=>(A.close(),n(s.error)),i.oncomplete=()=>{null==a?A.close():a.oncomplete=()=>A.close()}},o.onerror=e=>n(o.error)}))}}const V="/",W="tensorflowjs_models",_="info",z="model_topology",X="weight_specs",Q="weight_data",Z="model_metadata";function Y(e){return{info:[W,e,_].join(V),topology:[W,e,z].join(V),weightSpecs:[W,e,X].join(V),weightData:[W,e,Q].join(V),modelMetadata:[W,e,Z].join(V)}}function $(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function ee(e){const t=e.split(V);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(V)}class te{constructor(e){if(!(0,d.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Y(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=y(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(C)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,o=t.length;e<o;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(e.weightData));const A={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(A)),{modelArtifactsInfo:o}}catch(e){throw $(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;const A=this.LS.getItem(this.keys.modelMetadata);if(null!=A){const e=JSON.parse(A);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(C){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(i),t}}te.URL_SCHEME="localstorage://";const ne=e=>{return(0,d.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(te.URL_SCHEME)?(t=e.slice(te.URL_SCHEME.length),new te(t)):null;var t};q.registerSaveRouter(ne),q.registerLoadRouter(ne);class oe{constructor(){(0,k.hu)((0,d.OB)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,k.hu)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=W+V,n=V+_;for(let o=0;o<this.LS.length;++o){const A=this.LS.key(o);A.startsWith(t)&&A.endsWith(n)&&(e[ee(A)]=JSON.parse(this.LS.getItem(A)))}return e}async removeModel(e){var t;const n=Y(e=(t=e).startsWith(te.URL_SCHEME)?t.slice(te.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const o=JSON.parse(this.LS.getItem(n.info));return $(n),o}}const Ae="://";class ie{constructor(){this.managers={}}static getInstance(){return null==ie.instance&&(ie.instance=new ie),ie.instance}static registerManager(e,t){(0,k.hu)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Ae)&&(e=e.slice(0,e.indexOf(Ae))),(0,k.hu)(e.length>0,(()=>"scheme must not be an empty string."));const n=ie.getInstance();(0,k.hu)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}function re(e){if(-1===e.indexOf(Ae))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ie.getSchemes().join(",")}`);return{scheme:e.split(Ae)[0],path:e.split(Ae)[1]}}async function se(e,t,n=!1){(0,k.hu)(e!==t,(()=>`Old path and new path are the same: '${e}'`));const o=q.getLoadHandlers(e);(0,k.hu)(o.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),(0,k.hu)(o.length<2,(()=>`Copying failed because more than one (${o.length}) load handlers for source URL ${e}.`));const A=o[0],i=q.getSaveHandlers(t);(0,k.hu)(i.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),(0,k.hu)(i.length<2,(()=>`Copying failed because more than one (${o.length}) save handlers for destination URL ${t}.`));const r=i[0],s=re(e).scheme,a=re(e).path,l=s===re(e).scheme,m=await A.load();n&&l&&await ie.getManager(s).removeModel(a);const p=await r.save(m);return n&&!l&&await ie.getManager(s).removeModel(a),p.modelArtifactsInfo}async function ae(){const e=ie.getSchemes(),t={};for(const n of e){const e=await ie.getManager(n).listModels();for(const o in e)t[n+Ae+o]=e[o]}return t}async function le(e){const t=re(e);return ie.getManager(t.scheme).removeModel(t.path)}async function me(e,t){return se(e,t,!1)}async function pe(e,t){return se(e,t,!0)}class he{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if((0,d.OB)().get("IS_BROWSER")){(0,d.OB)().setPlatform("browser",new he);try{ie.registerManager(te.URL_SCHEME,new oe)}catch(e){}try{ie.registerManager(O.URL_SCHEME,new U)}catch(e){}}let ue;(0,d.OB)().get("IS_NODE")&&(0,d.OB)().setPlatform("node",new class{constructor(){this.util=n(8628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,d.OB)().global.fetch?(0,d.OB)().global.fetch(e,t):(null==ue&&(ue=n(5410)),ue(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});var ce=n(2657),de=n(2271),Ie=n(8723),Ge=n(4077);(0,m.wv)();const Ee={buffer:ce.f,cast:de.p,clone:Ie.d,print:function(e,t=!1){console.log(e.toString(t))}};function ke(e){return new Promise((e=>setTimeout(e))).then(e)}(0,Ge.Vp)(Ee);class ge{constructor(e){if(!(0,d.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ge.URL_SCHEME)&&(e=e.slice(ge.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=j(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),o=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),A=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(A.download=this.modelJsonFileName,A.href=o,await ke((()=>A.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await ke((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:y(e)}}}}ge.URL_SCHEME="downloads://";class fe{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const o=JSON.parse(n.target.result),A=o.modelTopology;if(null==A)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==o.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:A});const i=K(o,(e=>this.loadWeights(e)));e(i)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const o of e)t.push(...o.weights),n.push(...o.paths);const o=this.checkManifestAndWeightFiles(e),A=n.map((e=>this.loadWeightsFile(e,o[e])));return Promise.all(A).then((e=>[t,J(e)]))}loadWeightsFile(e,t){return new Promise(((n,o)=>{const A=new FileReader;A.onload=e=>{const t=e.target.result;n(t)},A.onerror=t=>o(`Failed to weights data from file of path '${e}'.`),A.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>v(e.name))),o={};for(const A of e)A.paths.forEach((e=>{const A=v(e);if(-1!==t.indexOf(A))throw new Error(`Duplicate file basename found in weights manifest: '${A}'`);if(t.push(A),-1===n.indexOf(A))throw new Error(`Weight file with basename '${A}' is not provided.`);o[e]=this.weightsFiles[n.indexOf(A)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}}function He(e){return new fe(e)}function Fe(e,t,n,o){!function(e){(0,k.hu)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){(0,k.hu)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),(0,k.hu)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),(0,k.hu)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,o=null==o?1:o);let A=0;return Promise.all(e.map((i=>(i.then((i=>{const r=n+ ++A/e.length*(o-n);return t(r),i})),i))))}async function Ce(e,t){null==t&&(t={});const n=null==t.fetchFunc?(0,d.OB)().platform.fetch:t.fetchFunc,o=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),A=(null==t.onProgress?await Promise.all(o):await Fe(o,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(A):await Fe(A,t.onProgress,.5,1)}async function De(e,t="",n,o){return Je((e=>Ce(e,{requestInit:o})))(e,t,n)}function Je(e){return async(t,n="",o)=>{const A=t.map((()=>!1)),i={},r=null!=o?o.map((()=>!1)):[],s=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const a="quantization"in e?e.quantization.dtype:e.dtype,l=g[a]*k.NA(e.shape),m=()=>{A[t]=!0,null==i[t]&&(i[t]=[]),i[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=o?o.forEach(((t,n)=>{t===e.name&&(m(),r[n]=!0)})):m(),s.push(e.name),n+=l}))})),!r.every((e=>e))){const e=o.filter(((e,t)=>!r[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${s.join(", ")}.`)}const a=A.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];a.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const m=await e(l),p={};let h=0;return a.forEach((e=>{const n=t[e].paths.length;let o=0;for(let e=0;e<n;e++)o+=m[h+e].byteLength;const A=new ArrayBuffer(o),r=new Uint8Array(A);let s=0;for(let e=0;e<n;e++){const t=new Uint8Array(m[h+e]);r.set(t,s),s+=t.byteLength}i[e].forEach((e=>{const t=H(A.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)p[e]=t[e]})),h+=n})),p}}q.registerSaveRouter((e=>(0,d.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ge.URL_SCHEME)?function(e="model"){return new ge(e)}(e.slice(ge.URL_SCHEME.length)):null));class ve{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,k.hu)("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=(0,d.OB)().platform.fetch,(0,k.hu)(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&(0,k.hu)(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=j(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:y(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,o=t.weightsManifest;if(null==n&&null==o)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return K(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),A=this.weightPathPrefix||n,i=[];for(const t of e)i.push(...t.weights);const r=[],s=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):r.push(A+e+o);return this.weightUrlConverter&&r.push(...await Promise.all(s)),[i,J(await Ce(r,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function je(e){return null!=e.match(ve.URL_SCHEME_REGEX)}ve.URL_SCHEME_REGEX=/^https?:\/\//;const Ke=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>je(e))):je(e),n)return ye(e,t)}return null};function ye(e,t){return new ve(e,t)}function be(e,t){return ye(e,t)}q.registerSaveRouter(Ke),q.registerLoadRouter(Ke);class qe{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class xe{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function Be(e,t,n,o){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new qe(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new qe({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new qe({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:o}))}function we(e){return new xe(e)}var Me=n(9121),Le=n(6151),Se=n(3740),Te=n(2668),Ne=n(7852);let Re;function Oe(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,o=!1,A=!1,i=!1,r=!1,s=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)o=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)A=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)i=!0;else if(null!=e.getContext)r=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);s=!0}if(A){const t=2;if(A&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=(0,Le.pI)(Me.eB,m.BV.backendName)){const n={pixels:e},o={numChannels:t};return m.BV.runKernel(Me.eB,n,o)}const[a,l]=A?[e.videoWidth,e.videoHeight]:[e.width,e.height];let p,h;if(r)p=e.getContext("2d").getImageData(0,0,a,l).data;else if(o||n)p=e.data;else if(i||A||s){if(null==Re)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Re=new OffscreenCanvas(1,1).getContext("2d")}else Re=document.createElement("canvas").getContext("2d");Re.canvas.width=a,Re.canvas.height=l,Re.drawImage(e,0,0,a,l),p=Re.getImageData(0,0,a,l).data}if(4===t)h=new Int32Array(p);else{const e=a*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=p[4*n+e]}return function(e,t,n){if((0,k.Cq)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const o=(0,Se.C)(e,n);if(3!==o.length&&1!==o.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===o.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,Ne.H)(e,t,o,n)}(h,[l,a,t],"int32")}async function Pe(e,t=3){let n=null;if((0,d.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return Oe(n,t)}async function Ue(e,t){let n=(0,Se._1)(e,"img","toPixels");if(!(e instanceof Ge.es)){const e=n;n=(0,de.p)(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[o,A]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${i}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const r=await n.data(),s="float32"===n.dtype?255:1,a=new Uint8ClampedArray(A*o*4);for(let e=0;e<o*A;++e){const t=[0,0,0,255];for(let o=0;o<i;o++){const A=r[e*i+o];if("float32"===n.dtype){if(A<0||A>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${A}.`)}else if("int32"===n.dtype&&(A<0||A>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${A}.`);1===i?(t[0]=A*s,t[1]=A*s,t[2]=A*s):t[o]=A*s}const o=4*e;a[o+0]=Math.round(t[0]),a[o+1]=Math.round(t[1]),a[o+2]=Math.round(t[2]),a[o+3]=Math.round(t[3])}if(null!=t){t.width=A,t.height=o;const e=t.getContext("2d"),n=new ImageData(a,A,o);e.putImageData(n,0,0)}return n!==e&&n.dispose(),a}const Ve=(0,Te.op)({fromPixels_:Oe});var We=n(7650);class _e{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class ze{constructor(){this.classNameMap={}}static getMap(){return null==ze.instance&&(ze.instance=new ze),ze.instance}static register(e){ze.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Xe(e){(0,k.hu)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),(0,k.hu)("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),(0,k.hu)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),ze.register(e)}var Qe=n(747),Ze=n(9122);const Ye="3.11.0";var $e=n(4368),et=n(633),tt=n(9494);class nt extends _e{minimize(e,t=!1,n){const{value:o,grads:A}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:A[e.name]})));this.applyGradients(e)}else this.applyGradients(A);return(0,$e.B9)(A),t?o:(o.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,et.pn)(e,t)}dispose(){null!=this.iterations_&&(0,$e.B9)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,tt.i)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(nt,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var ot=n(1221),At=n(8869),it=n(6407),rt=n(1274),st=n(4841),at=n(3261),lt=n(248),mt=n(6577);class pt extends nt{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=m.BV.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=m.BV.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,$e.lu)((()=>(0,mt.P)(o).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,$e.lu)((()=>(0,mt.P)(o).variable(!1)))});const A=Array.isArray(e)?e[n].tensor:e[t];if(null==A)return;const i=this.accumulatedGrads[n].variable,r=this.accumulatedUpdates[n].variable;(0,$e.lu)((()=>{const e=(0,it.I)((0,st.d)(i,this.rho),(0,st.d)((0,lt.h)(A),1-this.rho)),t=(0,st.d)((0,rt.h)((0,at._)((0,it.I)(r,this.epsilon)),(0,at._)((0,it.I)(i,this.epsilon))),A),n=(0,it.I)((0,st.d)(r,this.rho),(0,st.d)((0,lt.h)(t),1-this.rho));i.assign(e),r.assign(n);const s=(0,it.I)((0,st.d)(t,-this.learningRate),o);o.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,$e.B9)(this.accumulatedGrads.map((e=>e.variable))),(0,$e.B9)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}pt.className="Adadelta",Xe(pt);var ht=n(4006);class ut extends nt{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=m.BV.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,$e.lu)((()=>(0,ht.h)(o.shape,this.initialAccumulatorValue).variable(e)))}}const A=Array.isArray(e)?e[n].tensor:e[t];if(null==A)return;const i=this.accumulatedGrads[n].variable;(0,$e.lu)((()=>{const e=(0,it.I)(i,(0,lt.h)(A));i.assign(e);const t=(0,it.I)((0,st.d)((0,rt.h)(A,(0,at._)((0,it.I)(e,m.BV.backend.epsilon()))),-this.learningRate),o);o.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,$e.B9)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}ut.className="Adagrad",Xe(ut);var ct=n(3453),dt=n(827);class It extends nt{constructor(e,t,n,o=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,$e.lu)((()=>{this.accBeta1=(0,tt.i)(t).variable(),this.accBeta2=(0,tt.i)(n).variable()})),null==o&&(this.epsilon=m.BV.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,$e.lu)((()=>{const n=(0,dt.l)(1,this.accBeta1),o=(0,dt.l)(1,this.accBeta2);t.forEach(((t,A)=>{const i=m.BV.registeredVariables[t];null==this.accumulatedFirstMoment[A]&&(this.accumulatedFirstMoment[A]={originalName:`${t}/m`,variable:(0,$e.lu)((()=>(0,mt.P)(i).variable(!1)))}),null==this.accumulatedSecondMoment[A]&&(this.accumulatedSecondMoment[A]={originalName:`${t}/v`,variable:(0,$e.lu)((()=>(0,mt.P)(i).variable(!1)))});const r=Array.isArray(e)?e[A].tensor:e[t];if(null==r)return;const s=this.accumulatedFirstMoment[A].variable,a=this.accumulatedSecondMoment[A].variable,l=(0,it.I)((0,st.d)(s,this.beta1),(0,st.d)(r,1-this.beta1)),p=(0,it.I)((0,st.d)(a,this.beta2),(0,st.d)((0,lt.h)(r),1-this.beta2)),h=(0,rt.h)(l,n),u=(0,rt.h)(p,o);s.assign(l),a.assign(p);const c=(0,it.I)((0,st.d)((0,rt.h)(h,(0,it.I)((0,at._)(u),this.epsilon)),-this.learningRate),i);i.assign(c)})),this.accBeta1.assign((0,st.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,st.d)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,$e.B9)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&(0,$e.B9)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),(0,$e.lu)((()=>{this.accBeta1.assign((0,ct.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,ct.s)(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}It.className="Adam",Xe(It);var Gt=n(6235),Et=n(632);class kt extends nt{constructor(e,t,n,o=null,A=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=o,this.decay=A,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,$e.lu)((()=>{this.iteration=(0,tt.i)(0).variable(),this.accBeta1=(0,tt.i)(t).variable()})),null==o&&(this.epsilon=m.BV.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,$e.lu)((()=>{const n=(0,dt.l)(1,this.accBeta1),o=(0,rt.h)(-this.learningRate,(0,it.I)((0,st.d)(this.iteration,this.decay),1));t.forEach(((t,A)=>{const i=m.BV.registeredVariables[t];null==this.accumulatedFirstMoment[A]&&(this.accumulatedFirstMoment[A]={originalName:`${t}/m`,variable:(0,mt.P)(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[A]&&(this.accumulatedWeightedInfNorm[A]={originalName:`${t}/v`,variable:(0,mt.P)(i).variable(!1)});const r=Array.isArray(e)?e[A].tensor:e[t];if(null==r)return;const s=this.accumulatedFirstMoment[A].variable,a=this.accumulatedWeightedInfNorm[A].variable,l=(0,it.I)((0,st.d)(s,this.beta1),(0,st.d)(r,1-this.beta1)),p=(0,st.d)(a,this.beta2),h=(0,Gt.W)(r),u=(0,Et.g)(p,h);s.assign(l),a.assign(u);const c=(0,it.I)((0,st.d)((0,rt.h)(o,n),(0,rt.h)(l,(0,it.I)(u,this.epsilon))),i);i.assign(c)})),this.iteration.assign((0,it.I)(this.iteration,1)),this.accBeta1.assign((0,st.d)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,$e.B9)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&(0,$e.B9)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}kt.className="Adamax",Xe(kt);class gt extends nt{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const A=m.BV.registeredVariables[t];(0,$e.lu)((()=>{const e=(0,it.I)((0,st.d)(this.c,o),A);A.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,$e.Cn)((0,tt.i)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}gt.className="SGD",Xe(gt);class ft extends gt{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,tt.i)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=m.BV.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,$e.lu)((()=>(0,mt.P)(o).variable(e)))}}const A=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];null!=i&&(0,$e.lu)((()=>{let e;const t=(0,it.I)((0,st.d)(this.m,A),i);e=this.useNesterov?(0,it.I)((0,st.d)(this.c,(0,it.I)(i,(0,st.d)(t,this.m))),o):(0,it.I)((0,st.d)(this.c,t),o),A.assign(t),o.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,$e.B9)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}ft.className="Momentum",Xe(ft);class Ht extends nt{constructor(e,t=.9,n=0,o=null,A=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=A,null==o&&(this.epsilon=m.BV.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=m.BV.registeredVariables[t],A=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,$e.lu)((()=>(0,mt.P)(o).variable(A)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,$e.lu)((()=>(0,mt.P)(o).variable(A)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,$e.lu)((()=>(0,mt.P)(o).variable(A)))});const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const r=this.accumulatedMeanSquares[n].variable,s=this.accumulatedMoments[n].variable;(0,$e.lu)((()=>{const e=(0,it.I)((0,st.d)(r,this.decay),(0,st.d)((0,lt.h)(i),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,A=(0,it.I)((0,st.d)(t,this.decay),(0,st.d)(i,1-this.decay)),a=(0,rt.h)((0,st.d)(i,this.learningRate),(0,at._)((0,dt.l)(e,(0,it.I)((0,lt.h)(A),this.epsilon)))),l=(0,it.I)((0,st.d)(s,this.momentum),a);r.assign(e),t.assign(A),s.assign(l);const m=(0,dt.l)(o,l);o.assign(m)}else{const e=(0,it.I)((0,st.d)(r,this.decay),(0,st.d)((0,lt.h)(i),1-this.decay)),t=(0,it.I)((0,st.d)(s,this.momentum),(0,rt.h)((0,st.d)(i,this.learningRate),(0,at._)((0,it.I)(e,this.epsilon))));r.assign(e),s.assign(t);const n=(0,dt.l)(o,t);o.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,$e.B9)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,$e.B9)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&(0,$e.B9)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Ht.className="RMSProp",Xe(Ht);class Ft{static sgd(e){return new gt(e)}static momentum(e,t,n=!1){return new ft(e,t,n)}static rmsprop(e,t=.9,n=0,o=null,A=!1){return new Ht(e,t,n,o,A)}static adam(e=.001,t=.9,n=.999,o=null){return new It(e,t,n,o)}static adadelta(e=.001,t=.95,n=null){return new pt(e,t,n)}static adamax(e=.002,t=.9,n=.999,o=null,A=0){return new kt(e,t,n,o,A)}static adagrad(e,t=.1){return new ut(e,t)}}const Ct={sgd:Ft.sgd,momentum:Ft.momentum,adadelta:Ft.adadelta,adagrad:Ft.adagrad,rmsprop:Ft.rmsprop,adamax:Ft.adamax,adam:Ft.adam},Dt="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Jt(){return new Promise((e=>Dt((()=>e()))))}var vt=n(3591),jt=n(2200);function Kt(e,t){const n=e[0].length;e.forEach(((e,t)=>{k.hu(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),k.hu(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const o=e[0];e.forEach(((e,A)=>{for(let i=0;i<n;i++)k.hu(i===t||e[i]===o[i],(()=>`Error in concat${n}D: Shape of tensors[${A}] (${e}) does not match the shape of the rest (${o}) along the non-concatenated axis ${A}.`))}))}function yt(e,t){const n=e[0].slice();for(let o=1;o<e.length;o++)n[t]+=e[o][t];return n}var bt=n(2582),qt=n(9323);const xt=30;function Bt(e){return e<=xt?e:(0,k.jP)(e,Math.floor(Math.sqrt(e)))}function wt(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Mt(e,t,n,o=!0){let A=[];if(o)A=A.concat(t.slice(0)),A.push(e[0]/n),A=A.concat(e.slice(1));else{A=A.concat(e[0]);const n=t.length;for(let o=0;o<n;++o)A=A.concat([e[o+1]/t[o],t[o]]);A=A.concat(e.slice(n+1))}return A}function Lt(e,t,n=!0){const o=[];if(n){o.push(t);for(let n=t+1;n<e;++n)n<=2*t?(o.push(n),o.push(n-(t+1))):o.push(n)}else{const n=[],A=[];for(let o=1;o<e;++o)o>=2*t+1||o%2==1?A.push(o):n.push(o);o.push(...n),o.push(0),o.push(...A)}return o}function St(e,t,n,o=!0){const A=[];o?A.push(e[0]/n):A.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?o?A.push(t[n-1]*e[n]):A.push(e[n]/t[n-1]):A.push(e[n]);return A}function Tt(e,t){const n=[0];for(let o=0;o<t;++o)n.push(e[o][0]);return n}function Nt(e,t,n){const o=e.slice(0,1);for(let A=0;A<n;++A)o.push(e[A+1]-t[A][0]-t[A][1]);return o}function Rt(e,t){const n=e.shape.length,o=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(o<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${o}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[o-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[o-1]} vs. ${n}`);if(0===(0,k.NA)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const A=t.shape,i=A[A.length-1];let r=1;for(let e=0;e<A.length-1;++e)r*=A[e];const s=e.shape,a=A.slice();a.pop();let l=1;for(let e=i;e<n;++e)l*=s[e],a.push(s[e]);const m=[...(0,k.e3)(e.shape).map((e=>e/l)),1].slice(0,i);return[a,r,l,m]}var Ot=n(3028),Pt=n(3179);const Ut=.3275911,Vt=.254829592,Wt=-.284496736,_t=1.421413741,zt=-1.453152027,Xt=1.061405429;var Qt=n(4706);function Zt(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let o=0;o<n.length;o+=2)n[o]=e[o/2],n[o+1]=t[o/2];return n}function Yt(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let o=0;o<e.length;o+=2)t[o/2]=e[o],n[o/2]=e[o+1];return{real:t,imag:n}}function $t(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),o=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],o[Math.floor(t/4)]=e[t+1];return{real:n,imag:o}}function en(e){const t=Math.floor(e.length/4),n=new Float32Array(t),o=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],o[Math.floor(t/4)]=e[t+1];return{real:n,imag:o}}function tn(e,t){return{real:e[2*t],imag:e[2*t+1]}}function nn(e,t,n,o){e[2*o]=t,e[2*o+1]=n}function on(e,t){const n=new Float32Array(e/2),o=new Float32Array(e/2);for(let A=0;A<Math.ceil(e/2);A++){const i=(t?2:-2)*Math.PI*(A/e);n[A]=Math.cos(i),o[A]=Math.sin(i)}return{real:n,imag:o}}function An(e,t,n){const o=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(o),imag:Math.sin(o)}}const rn=/->/g;function sn(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(rn,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[o,A]=e.split("->");(0,k.hu)(-1===o.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const i=o.split(","),r=i.length;if(t!==r)throw new Error(`Expected ${r} input tensors, received ${t}`);if(r>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const s=[];for(let e=0;e<A.length;++e){const t=A[e];if(!i.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===s.indexOf(t)&&s.push(t)}for(let e=0;e<o.length;++e){const t=o[e];-1===s.indexOf(t)&&","!==t&&s.push(t)}const a=new Array(i.length);for(let e=0;e<r;++e){if(new Set(i[e].split("")).size!==i[e].length)throw new Error(`Found duplicate axes in input component ${i[e]}. Support for duplicate axes in input is not implemented yet.`);a[e]=[];for(let t=0;t<i[e].length;++t)a[e].push(s.indexOf(i[e][t]))}const l=s.length,m=[];for(let e=A.length;e<l;++e)m.push(e);return{allDims:s,summedDims:m,idDims:a}}function an(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const o=[];for(let t=0;t<e;++t)-1===n[t]&&o.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:o}}function ln(e,t,n){const o=new Array(e);for(let e=0;e<n.length;++e){const A=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===o[t[e][n]]?o[t[e][n]]=A[n]:(0,k.hu)(o[t[e][n]]===A[n],(()=>`Expected dimension ${o[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(A)}, but got dimension ${A[n]}`))}}function mn(e,t){const n=e,o=[];let A=0;0===e.length&&n.push(-1),A=e.length+1;for(let e=0;e<A;++e)o.push([]);const i=[];for(let e=0;e<n.length;++e){const A=hn(t,n[e]);for(const t of A)-1===i.indexOf(t)&&(o[e].push(t),i.push(t))}return{path:n,steps:o}}function pn(e){return e.every(((e,t)=>e===t))}function hn(e,t){const n=[];for(let o=0;o<e.length;++o)0!==e[o].length&&-1===e[o].indexOf(t)&&-1!==t||n.push(o);return n}function un(e,t,n=0){let o=[];if("number"==typeof t)(0,k.hu)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),o=new Array(t).fill(e.shape[n]/t);else{const A=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,k.hu)(A<=1,(()=>"There should be only one negative value in split array."));const i=t.indexOf(-1);if(-1!==i){const o=t.reduce(((e,t)=>t>0?e+t:e));t[i]=e.shape[n]-o}(0,k.hu)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),o=t}return o}function cn(e,t){let n,o=!1;for(e<=xt?(n=e,o=!0):n=(0,k.jP)(e,Math.floor(Math.sqrt(e)));!o;)n>t||n===e?o=!0:n=(0,k.jP)(e,n+1);return n}function dn(e,t,n){const o=[],A=e.length;for(let i=0;i<A;i++)i!==t?o.push(e[i]):o.push(n);return o}function In(e,t,n,o){const A=t.shape.length,i=e.shape.length;if(0!==o&&(o<-A||o>A))throw new Error(`Expect batchDims in the range of [-${A}, ${A}], but got ${o}`);if(o<0&&(o+=A),o>i)throw new Error(`batchDims (${o}) must be less than rank(x) (\n    ${i}).`);if(n<o)throw new Error(`batchDims (${o}) must be less than or equal to axis (${n}).`);for(let n=0;n<o;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const r=e.shape[n],s=[];let a=1,l=1,m=1;for(let t=0;t<o;++t)s.push(e.shape[t]),a*=e.shape[t];for(let t=o;t<n;t++)s.push(e.shape[t]),l*=e.shape[t];for(let e=o;e<A;e++)s.push(t.shape[e]);for(let t=n+1;t<i;t++)s.push(e.shape[t]),m*=e.shape[t];return{batchSize:a,sliceSize:m,outerSize:l,dimSize:r,outputShape:s}}function Gn(e){try{return e.map((e=>(0,Ze.decodeString)(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function En(e){return e.map((e=>(0,Ze.encodeString)(e)))}var kn=n(3337),gn=n(8333),fn=n(8713)},9121:(e,t,n)=>{"use strict";n.d(t,{SY:()=>o,VG:()=>A,Sp:()=>i,mm:()=>r,Xz:()=>s,oT:()=>a,IK:()=>l,sJ:()=>m,aJ:()=>p,M2:()=>h,qw:()=>u,jM:()=>c,Oy:()=>d,QC:()=>I,Jh:()=>G,RO:()=>E,_k:()=>k,IM:()=>g,XL:()=>f,zw:()=>H,zv:()=>F,Ly:()=>C,eE:()=>D,RF:()=>J,gJ:()=>v,xn:()=>j,Zz:()=>K,yj:()=>y,Eh:()=>b,mh:()=>q,wU:()=>x,wm:()=>B,x1:()=>w,o2:()=>M,ik:()=>L,mc:()=>S,TR:()=>T,iH:()=>N,Vc:()=>R,QR:()=>O,T0:()=>P,ci:()=>U,sL:()=>V,y7:()=>W,$w:()=>_,p4:()=>z,ek:()=>X,Vn:()=>Q,oH:()=>Z,$g:()=>Y,SX:()=>$,HE:()=>ee,Om:()=>te,hd:()=>ne,NE:()=>oe,YF:()=>Ae,Y0:()=>ie,vw:()=>re,de:()=>se,Uy:()=>ae,OR:()=>le,je:()=>me,sH:()=>pe,qi:()=>he,q1:()=>ue,iZ:()=>ce,Ac:()=>de,iJ:()=>Ie,Qg:()=>Ge,J_:()=>Ee,av:()=>ke,iW:()=>ge,r7:()=>fe,J$:()=>He,vt:()=>Fe,CA:()=>Ce,e7:()=>De,Zb:()=>Je,kU:()=>ve,PY:()=>je,Vf:()=>Ke,MZ:()=>ye,qC:()=>be,eZ:()=>qe,Hh:()=>xe,Yo:()=>Be,BM:()=>we,mT:()=>Me,OV:()=>Le,OA:()=>Se,OU:()=>Te,vF:()=>Ne,q2:()=>Re,c1:()=>Oe,q8:()=>Pe,jQ:()=>Ue,Vb:()=>Ve,NZ:()=>We,wY:()=>_e,ku:()=>ze,yQ:()=>Xe,uv:()=>Qe,cy:()=>Ze,W0:()=>Ye,qW:()=>$e,we:()=>et,Qi:()=>tt,ly:()=>nt,pe:()=>ot,o0:()=>At,Dl:()=>it,e6:()=>rt,xJ:()=>st,$H:()=>at,qk:()=>lt,HZ:()=>mt,dp:()=>pt,Hm:()=>ht,_Y:()=>ut,zb:()=>ct,Sb:()=>dt,mK:()=>It,e0:()=>Gt,bV:()=>Et,xQ:()=>kt,Ph:()=>gt,oF:()=>ft,p2:()=>Ht,RQ:()=>Ft,w3:()=>Ct,i5:()=>Dt,a5:()=>Jt,MR:()=>vt,FK:()=>jt,GB:()=>Kt,TQ:()=>yt,L8:()=>bt,Gc:()=>qt,O3:()=>xt,nh:()=>Bt,YW:()=>wt,Zj:()=>Mt,D2:()=>Lt,_t:()=>St,bK:()=>Tt,m2:()=>Nt,_J:()=>Rt,s1:()=>Ot,Xk:()=>Pt,Tr:()=>Ut,sE:()=>Vt,MI:()=>Wt,n9:()=>_t,cW:()=>zt,wx:()=>Xt,G3:()=>Qt,kp:()=>Zt,To:()=>Yt,Qv:()=>$t,Ru:()=>en,h8:()=>tn,eB:()=>nn,b9:()=>on,us:()=>An,_V:()=>rn,lu:()=>sn});const o="Abs",A="Acos",i="Acosh",r="Add",s="AddN",a="All",l="Any",m="ArgMax",p="ArgMin",h="Asin",u="Asinh",c="Atan",d="Atanh",I="Atan2",G="AvgPool",E="AvgPoolGrad",k="AvgPool3D",g="AvgPool3DGrad",f="BatchMatMul",H="BatchToSpaceND",F="Bincount",C="BroadcastTo",D="BroadcastArgs",J="Cast",v="Ceil",j="ClipByValue",K="Complex",y="ComplexAbs",b="Concat",q="Conv2D",x="Conv2DBackpropFilter",B="Conv2DBackpropInput",w="Conv3D",M="Conv3DBackpropFilterV2",L="Conv3DBackpropInputV2",S="Cos",T="Cosh",N="Cumsum",R="CropAndResize",O="DenseBincount",P="DepthToSpace",U="DepthwiseConv2dNative",V="DepthwiseConv2dNativeBackpropFilter",W="DepthwiseConv2dNativeBackpropInput",_="Diag",z="Dilation2D",X="Dilation2DBackpropInput",Q="Dilation2DBackpropFilter",Z="RealDiv",Y="Einsum",$="Elu",ee="EluGrad",te="Erf",ne="Equal",oe="Exp",Ae="ExpandDims",ie="Expm1",re="FFT",se="Fill",ae="FlipLeftRight",le="Floor",me="FloorDiv",pe="FusedBatchNorm",he="GatherV2",ue="GatherNd",ce="Greater",de="GreaterEqual",Ie="Identity",Ge="IFFT",Ee="Imag",ke="IsFinite",ge="IsInf",fe="IsNan",He="LeakyRelu",Fe="Less",Ce="LessEqual",De="LinSpace",Je="Log",ve="Log1p",je="LogicalAnd",Ke="LogicalNot",ye="LogicalOr",be="LogSoftmax",qe="LRN",xe="LRNGrad",Be="Max",we="Maximum",Me="MaxPool",Le="MaxPoolGrad",Se="MaxPool3D",Te="MaxPool3DGrad",Ne="MaxPoolWithArgmax",Re="Mean",Oe="Min",Pe="Minimum",Ue="MirrorPad",Ve="Mod",We="Multinomial",_e="Multiply",ze="Neg",Xe="NotEqual",Qe="NonMaxSuppressionV3",Ze="NonMaxSuppressionV4",Ye="NonMaxSuppressionV5",$e="OnesLike",et="OneHot",tt="Pack",nt="PadV2",ot="Pow",At="Prelu",it="Prod",rt="Range",st="Real",at="Reciprocal",lt="Relu",mt="Reshape",pt="ResizeNearestNeighbor",ht="ResizeNearestNeighborGrad",ut="ResizeBilinear",ct="ResizeBilinearGrad",dt="Relu6",It="Reverse",Gt="Round",Et="Rsqrt",kt="ScatterNd",gt="Select",ft="Selu",Ht="Slice",Ft="Sin",Ct="Sinh",Dt="Sign",Jt="Sigmoid",vt="Softplus",jt="Sqrt",Kt="Sum",yt="SpaceToBatchND",bt="SplitV",qt="Softmax",xt="SparseFillEmptyRows",Bt="SparseReshape",wt="SparseSegmentMean",Mt="SparseSegmentSum",Lt="SparseToDense",St="SquaredDifference",Tt="Square",Nt="StridedSlice",Rt="StringNGrams",Ot="StringSplit",Pt="StringToHashBucketFast",Ut="Sub",Vt="Tan",Wt="Tanh",_t="Tile",zt="TopK",Xt="Transform",Qt="Transpose",Zt="Unique",Yt="Unpack",$t="UnsortedSegmentSum",en="ZerosLike",tn="Step",nn="FromPixels",on="RotateWithOffset",An="_FusedMatMul",rn="FusedConv2D",sn="FusedDepthwiseConv2D"},6151:(e,t,n)=>{"use strict";n.d(t,{pI:()=>a,uk:()=>l,tr:()=>m,wC:()=>p,Li:()=>h});var o=n(2885),A=n(5938),i=n(4706);const r=(0,A.R)("kernelRegistry",(()=>new Map)),s=(0,A.R)("gradRegistry",(()=>new Map));function a(e,t){const n=u(e,t);return r.get(n)}function l(e){return s.get(e)}function m(e){const t=r.entries(),n=[];for(;;){const{done:o,value:A}=t.next();if(o)break;const[i,r]=A,[s]=i.split("_");s===e&&n.push(r)}return n}function p(e){const{kernelName:t,backendName:n}=e,o=u(t,n);r.has(o)&&i.Z(`The kernel '${t}' for backend '${n}' is already registered`),r.set(o,e)}function h(e){const{kernelName:t}=e;s.has(t)&&(0,o.OB)().getBool("DEBUG")&&i.Z(`Overriding the gradient for '${t}'`),s.set(t,e)}function u(e,t){return`${t}_${e}`}},4706:(e,t,n)=>{"use strict";n.d(t,{Z:()=>A,c:()=>i});var o=n(2885);function A(...e){(0,o.OB)().getBool("IS_TEST")||(0,o.OB)().getBool("PROD")||console.warn(...e)}function i(...e){(0,o.OB)().getBool("IS_TEST")||(0,o.OB)().getBool("PROD")||console.log(...e)}},6235:(e,t,n)=>{"use strict";n.d(t,{W:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({abs_:function(e){const t=(0,i._1)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return o.BV.runKernel(A.yj,e)}{const e={x:t};return o.BV.runKernel(A.SY,e)}}})},7839:(e,t,n)=>{"use strict";n.d(t,{K:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({acos_:function(e){const t={x:(0,i._1)(e,"x","acos")};return o.BV.runKernel(A.VG,t)}})},1470:(e,t,n)=>{"use strict";n.d(t,{_:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({acosh_:function(e){const t={x:(0,i._1)(e,"x","acosh")};return o.BV.runKernel(A.Sp,t)}})},6407:(e,t,n)=>{"use strict";n.d(t,{I:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({add_:function(e,t){let n=(0,r._1)(e,"a","add"),s=(0,r._1)(t,"b","add");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.mm,a)}})},781:(e,t,n)=>{"use strict";n.d(t,{$:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({all_:function(e,t=null,n=!1){const r={x:(0,i._1)(e,"x","all","bool")},s={axis:t,keepDims:n};return o.BV.runKernel(A.oT,r,s)}})},2998:(e,t,n)=>{"use strict";n.d(t,{Y:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({any_:function(e,t=null,n=!1){const r={x:(0,i._1)(e,"x","any","bool")},s={axis:t,keepDims:n};return o.BV.runKernel(A.IK,r,s)}})},47:(e,t,n)=>{"use strict";n.d(t,{N:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({argMax_:function(e,t=0){const n={x:(0,i._1)(e,"x","argMax")},r={axis:t};return o.BV.runKernel(A.sJ,n,r)}})},7394:(e,t,n)=>{"use strict";n.d(t,{v:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({argMin_:function(e,t=0){const n={x:(0,i._1)(e,"x","argMin")},r={axis:t};return o.BV.runKernel(A.aJ,n,r)}})},2421:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({asin_:function(e){const t={x:(0,i._1)(e,"x","asin")};return o.BV.runKernel(A.M2,t)}})},1891:(e,t,n)=>{"use strict";n.d(t,{V:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({asinh_:function(e){const t={x:(0,i._1)(e,"x","asinh")};return o.BV.runKernel(A.qw,t)}})},7037:(e,t,n)=>{"use strict";n.d(t,{z:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({atan_:function(e){const t={x:(0,i._1)(e,"x","atan")};return o.BV.runKernel(A.jM,t)}})},9812:(e,t,n)=>{"use strict";n.d(t,{f:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({atan2_:function(e,t){let n=(0,r._1)(e,"a","atan2"),s=(0,r._1)(t,"b","atan2");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.QC,a)}})},369:(e,t,n)=>{"use strict";n.d(t,{C:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({atanh_:function(e){const t={x:(0,i._1)(e,"x","atanh")};return o.BV.runKernel(A.Oy,t)}})},5176:(e,t,n)=>{"use strict";n.d(t,{w:()=>p});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2271),a=n(2582),l=n(2668),m=n(4968);const p=(0,l.op)({avgPool_:function(e,t,n,l,p){const h=(0,i._1)(e,"x","avgPool","float32");r.hu(a.jT(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let u=h,c=!1;3===h.rank&&(c=!0,u=(0,m.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),r.hu(4===u.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`)),null!=p&&r.hu(r.GN(l),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${p} but got pad ${l}.`));const d={x:u},I={filterSize:t,strides:n,pad:l,dimRoundingMode:p};let G=o.BV.runKernel(A.Jh,d,I);return G=(0,s.p)(G,h.dtype),c?(0,m.X)(G,[G.shape[1],G.shape[2],G.shape[3]]):G}})},1749:(e,t,n)=>{"use strict";n.d(t,{u:()=>m});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2271),a=n(2668),l=n(4968);const m=(0,a.op)({avgPool3d_:function(e,t,n,a,m,p="NDHWC"){const h=(0,i._1)(e,"x","avgPool3d","float32");let u=h,c=!1;4===h.rank&&(c=!0,u=(0,l.X)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),r.hu(5===u.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`)),r.hu("NDHWC"===p,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${p}`)),null!=m&&r.hu(r.GN(a),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${m} but got pad ${a}.`));const d={x:u},I={filterSize:t,strides:n,pad:a,dimRoundingMode:m,dataFormat:p};let G=o.BV.runKernel(A._k,d,I);return G=(0,s.p)(G,u.dtype),c?(0,l.X)(G,[G.shape[1],G.shape[2],G.shape[3],G.shape[4]]):G}})},3591:(e,t,n)=>{"use strict";n.d(t,{YB:()=>A,Vh:()=>i,kz:()=>r,rv:()=>s,lB:()=>a,Q3:()=>l,LJ:()=>m,sY:()=>p});var o=n(569);function A(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function i(e,t,n){const o=e.length+t.length,A=[];let i=0,r=0;for(let s=0;s<o;s++)-1===n.indexOf(s)?A.push(e[i++]):A.push(t[r++]);return A}function r(e,t){const n=[],o=e.length;for(let A=0;A<o;A++)-1===t.indexOf(A)&&n.push(e[A]);return[n,t.map((t=>e[t]))]}function s(e,t){return i(e,t.map((e=>1)),t)}function a(e,t,n){o.hu(A(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function l(e,t){if(A(e,t))return null;const n=[];for(let o=0;o<t;++o)-1===e.indexOf(o)&&n.push(o);return e.forEach((e=>n.push(e))),n}function m(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function p(e,t){const n=[];for(let o=t-e;o<t;++o)n.push(o);return n}},8441:(e,t,n)=>{"use strict";n.d(t,{E:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({batchToSpaceND_:function(e,t,n){const s=(0,i._1)(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));r.hu(s.rank>=1+t.length,(()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`)),r.hu(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),r.hu(s.shape[0]%a==0,(()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));const l={x:s},m={blockShape:t,crops:n};return o.BV.runKernel(A.zw,l,m)}})},7505:(e,t,n)=>{"use strict";n.d(t,{t:()=>a});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(4968);const a=(0,n(2668).op)({batchNorm_:function(e,t,n,a,l,m){null==m&&(m=.001);const p=(0,i._1)(e,"x","batchNorm"),h=(0,i._1)(t,"mean","batchNorm"),u=(0,i._1)(n,"variance","batchNorm");let c,d;null!=l&&(c=(0,i._1)(l,"scale","batchNorm")),null!=a&&(d=(0,i._1)(a,"offset","batchNorm")),r.hu(h.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),r.hu(null==d||h.rank===d.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),r.hu(null==c||h.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const I=function(e){let t;return t=0===e.rank||1===e.rank?(0,s.X)(e,[1,1,1,e.size]):2===e.rank?(0,s.X)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,s.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(p),G={x:I,scale:c,offset:d,mean:h,variance:u},E={varianceEpsilon:m},k=o.BV.runKernel(A.sH,G,E);return(0,s.X)(k,p.shape)}})},3865:(e,t,n)=>{"use strict";n.d(t,{y:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({bincount_:function(e,t,n){const s=(0,i._1)(e,"x","bincount"),a=(0,i._1)(t,"weights","bincount");r.hu("int32"===s.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`)),r.hu(n>=0,(()=>`size must be non-negative, but got ${n}.`)),r.hu(a.size===s.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${a.shape}.`));const l={x:s,weights:a},m={size:n};return o.BV.runKernel(A.zv,l,m)}})},8247:(e,t,n)=>{"use strict";n.d(t,{U:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(8723),s=n(2668),a=n(4968);const l=(0,s.op)({broadcastTo_:function(e,t){let n=(0,i._1)(e,"broadcastTo","x");const s=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=(0,a.X)(n,e)}const l=n.shape,m=Array.from(t);for(let e=t.length-1;e>=0;e--)if(l[e]===t[e])m[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(0===m.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return(0,r.d)(n);const p={x:n},h={reps:m};return o.BV.runKernel(A.n9,p,h)}})},2200:(e,t,n)=>{"use strict";function o(e,t){const n=e.length,o=[];for(let A=0;A<n;A++){const i=n-1-A,r=e[i]||1;(t[t.length-1-A]||1)>1&&1===r&&o.unshift(i)}return o}function A(e,t){const n=[];for(let o=0;o<t.length;o++){const A=e[e.length-o-1],i=t.length-o-1,r=t[i];(null==A||1===A&&r>1)&&n.unshift(i)}return n}function i(e,t){const n=[],o=Math.max(e.length,t.length);for(let A=0;A<o;A++){let o=e[e.length-A-1];null==o&&(o=1);let i=t[t.length-A-1];if(null==i&&(i=1),1===o)n.unshift(i);else if(1===i)n.unshift(o);else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(o)}}return n}n.d(t,{XF:()=>o,RR:()=>A,$N:()=>i})},2657:(e,t,n)=>{"use strict";n.d(t,{f:()=>i});var o=n(4077),A=n(569);function i(e,t="float32",n){return t=t||"float32",A.Mu(e),new o.YD(e,t,n)}},2271:(e,t,n)=>{"use strict";n.d(t,{p:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({cast_:function(e,t){const n=(0,i._1)(e,"x","cast");if(!r.LP(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const s={x:n},a={dtype:t};return o.BV.runKernel(A.RF,s,a)}})},6825:(e,t,n)=>{"use strict";n.d(t,{m:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({ceil_:function(e){const t={x:(0,i._1)(e,"x","ceil","float32")};return o.BV.runKernel(A.gJ,t)}})},2279:(e,t,n)=>{"use strict";n.d(t,{i:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({clipByValue_:function(e,t,n){const s=(0,i._1)(e,"x","clipByValue");r.hu(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const a={x:s},l={clipValueMin:t,clipValueMax:n};return o.BV.runKernel(A.xn,a,l)}})},8723:(e,t,n)=>{"use strict";n.d(t,{d:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({clone_:function(e){const t={x:(0,i._1)(e,"x","clone","string_or_numeric")};return o.BV.runKernel(A.iJ,t)}})},1661:(e,t,n)=>{"use strict";n.d(t,{P:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({complex_:function(e,t){const n=(0,i._1)(e,"real","complex"),s=(0,i._1)(t,"imag","complex");r.k5(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const a={real:n,imag:s};return o.BV.runKernel(A.Zz,a)}})},6884:(e,t,n)=>{"use strict";n.d(t,{z:()=>a});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(8723);const a=(0,n(2668).op)({concat_:function(e,t=0){(0,r.hu)(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=(0,i.sI)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return(0,s.d)(n[0]);const a=n,l={axis:t};return o.BV.runKernel(A.Eh,a,l)}})},1355:(e,t,n)=>{"use strict";n.d(t,{P:()=>l});var o=n(3740),A=n(569),i=n(4794),r=n(2582),s=n(2668),a=n(4968);const l=(0,s.op)({conv1d_:function(e,t,n,s,l="NWC",m=1,p){const h=(0,o._1)(e,"x","conv1d"),u=(0,o._1)(t,"filter","conv1d");let c=h,d=!1;2===h.rank&&(d=!0,c=(0,a.X)(h,[1,h.shape[0],h.shape[1]])),A.hu(3===c.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`)),A.hu(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),null!=p&&A.hu(A.GN(s),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${p} but got pad ${s}.`)),A.hu(c.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),A.hu(r.jT(n,m),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${m}'`)),A.hu("NWC"===l,(()=>`Error in conv1d: got dataFormat of ${l} but only NWC is currently supported.`));const I=(0,a.X)(u,[1,u.shape[0],u.shape[1],u.shape[2]]),G=(0,a.X)(c,[c.shape[0],1,c.shape[1],c.shape[2]]),E=[1,n],k=[1,m],g=(0,i.T)(G,I,E,s,"NHWC",k,p);return d?(0,a.X)(g,[g.shape[2],g.shape[3]]):(0,a.X)(g,[g.shape[0],g.shape[2],g.shape[3]])}})},4794:(e,t,n)=>{"use strict";n.d(t,{T:()=>m});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2582),a=n(2668),l=n(4968);const m=(0,a.op)({conv2d_:function(e,t,n,a,m="NHWC",p=[1,1],h){const u=(0,i._1)(e,"x","conv2d","float32"),c=(0,i._1)(t,"filter","conv2d","float32");let d=u,I=!1;3===u.rank&&(I=!0,d=(0,l.X)(u,[1,u.shape[0],u.shape[1],u.shape[2]])),r.hu(4===d.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`)),r.hu(4===c.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`)),null!=h&&r.hu(r.GN(a),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${h} but got pad ${a}.`));const G="NHWC"===m?d.shape[3]:d.shape[1];r.hu(G===c.shape[2],(()=>`Error in conv2d: depth of input (${G}) must match input depth for filter ${c.shape[2]}.`)),r.hu(s.jT(n,p),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`));const E={x:d,filter:c},k={strides:n,pad:a,dataFormat:m,dilations:p,dimRoundingMode:h},g=o.BV.runKernel(A.mh,E,k);return I?(0,l.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},6013:(e,t,n)=>{"use strict";n.d(t,{p:()=>a});var o=n(7097),A=n(9121),i=n(569),r=n(2668),s=n(4968);const a=(0,r.op)({conv2DBackpropFilter_:function(e,t,n,r,a,l="NHWC",m){let p=e;3===e.rank&&(p=(0,s.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let h=t;3===h.rank&&(h=(0,s.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),i.hu(4===p.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${p.shape}.`)),i.hu(4===h.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`)),i.hu(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===l?p.shape[3]:p.shape[1],c="NHWC"===l?h.shape[3]:h.shape[1];i.hu(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),i.hu(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),null!=m&&i.hu(i.GN(a),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${m} but got pad ${a}.`));const d={x:p,dy:h},I={strides:r,pad:a,dataFormat:l,dimRoundingMode:m,filterShape:n};return o.BV.runKernel(A.wU,d,I)}})},9832:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var o=n(7097),A=n(9121),i=n(569),r=n(2668),s=n(4968);const a=(0,r.op)({conv2DBackpropInput_:function(e,t,n,r,a,l="NHWC",m){i.hu(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let p=e,h=t,u=!1;3===t.rank&&(u=!0,h=(0,s.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),p=[1,e[0],e[1],e[2]]),i.hu(4===p.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${p.length}.`)),i.hu(4===h.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`)),i.hu(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===l?p[3]:p[1],d="NHWC"===l?h.shape[3]:h.shape[1];i.hu(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),i.hu(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),null!=m&&i.hu(i.GN(a),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${m} but got pad ${a}.`));const I={dy:h,filter:n},G={strides:r,pad:a,dataFormat:l,dimRoundingMode:m,inputShape:p},E=o.BV.runKernel(A.wm,I,G);return u?(0,s.X)(E,[E.shape[1],E.shape[2],E.shape[3]]):E}})},1405:(e,t,n)=>{"use strict";n.d(t,{b:()=>i});var o=n(3740),A=n(9832);const i=(0,n(2668).op)({conv2dTranspose_:function(e,t,n,i,r,s){const a=(0,o._1)(e,"x","conv2dTranspose"),l=(0,o._1)(t,"filter","conv2dTranspose");return(0,A._)(n,a,l,i,r,"NHWC",s)}})},473:(e,t,n)=>{"use strict";n.d(t,{p:()=>m});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2582),a=n(2668),l=n(4968);const m=(0,a.op)({conv3d_:function(e,t,n,a,m="NDHWC",p=[1,1,1]){const h=(0,i._1)(e,"x","conv3d"),u=(0,i._1)(t,"filter","conv3d");let c=h,d=!1;4===h.rank&&(d=!0,c=(0,l.X)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),r.hu(5===c.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`)),r.hu(5===u.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`)),r.hu(c.shape[4]===u.shape[3],(()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${u.shape[3]}.`)),r.hu((0,s.jT)(n,p),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`)),r.hu("NDHWC"===m,(()=>`Error in conv3d: got dataFormat of ${m} but only NDHWC is currently supported.`));const I={x:c,filter:u},G={strides:n,pad:a,dataFormat:m,dilations:p},E=o.BV.runKernel(A.x1,I,G);return d?(0,l.X)(E,[E.shape[1],E.shape[2],E.shape[3],E.shape[4]]):E}})},7594:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var o=n(7097),A=n(9121),i=n(569),r=n(2668),s=n(4968);const a=(0,r.op)({conv3DBackpropInput_:function(e,t,n,r,a){i.hu(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let l=e,m=t,p=!1;4===t.rank&&(p=!0,m=(0,s.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),l=[1,e[0],e[1],e[2],e[3]]);const h=l[4],u=m.shape[4];i.hu(5===l.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${l.length}.`)),i.hu(5===m.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${m.rank}`)),i.hu(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),i.hu(h===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[3]}.`)),i.hu(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:m,filter:n},d={pad:a,strides:r,inputShape:l},I=o.BV.runKernel(A.ik,c,d);return p?(0,s.X)(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}})},2582:(e,t,n)=>{"use strict";function o(e,t,n,o,A="NHWC",i){return r(e,[...t,e[3]],n,i,o,null,null,d(A))}function A(e,t,n,o,A,i,s="channelsLast"){const[a,m]=l(t);let p;if("channelsLast"===s)p=[a,m,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);p=[a,m,e[1],e[1]]}return r(e,p,n,o,A,i,!1,s)}function i(e,t,n,o,A,i,r="NDHWC"){const[a,l,p]=m(t);let h,u;if("NDHWC"===r)u="channelsLast",h=[a,l,p,e[4],e[4]];else{if("NCDHW"!==r)throw new Error(`Unknown dataFormat ${r}`);u="channelsFirst",h=[a,l,p,e[1],e[1]]}return s(e,h,n,o,A,!1,u,i)}function r(e,t,n,o,A,i,r=!1,s="channelsLast"){let[m,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===s)[m,u,c,d]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[m,d,u,c]=e}const[I,G,,E]=t,[k,g]=l(n),[f,H]=l(o),F=p(I,f),C=p(G,H),{padInfo:D,outHeight:J,outWidth:v}=function(e,t,n,o,A,i,r,s,l){let m,p,u;if("number"==typeof e){m={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const A=function(e,t,n,o,A){null==o&&(o=a(e,t,n));const i=e[1];return[h((e[0]-t+2*o)/n+1,A),h((i-t+2*o)/n+1,A)]}([t,n],i,o,e,s);p=A[0],u=A[1]}else if("same"===e){p=Math.ceil(t/o),u=Math.ceil(n/A);const e=Math.max(0,(p-1)*o+i-t),s=Math.max(0,(u-1)*A+r-n),a=Math.floor(e/2),l=e-a,h=Math.floor(s/2);m={top:a,bottom:l,left:h,right:s-h,type:"SAME"}}else if("valid"===e)m={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-i+1)/o),u=Math.ceil((n-r+1)/A);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const a="channelsLast"===l?e[1][0]:e[2][0],c="channelsLast"===l?e[1][1]:e[2][1],d="channelsLast"===l?e[2][0]:e[3][0],I="channelsLast"===l?e[2][1]:e[3][1];m={top:a,bottom:c,left:d,right:I,type:0===a&&0===c&&0===d&&0===I?"VALID":"EXPLICIT"},p=h((t-i+a+c)/o+1,s),u=h((n-r+d+I)/A+1,s)}}return{padInfo:m,outHeight:p,outWidth:u}}(A,u,c,k,g,F,C,i,s),j=r?E*d:E;let K;return"channelsFirst"===s?K=[m,j,J,v]:"channelsLast"===s&&(K=[m,J,v,j]),{batchSize:m,dataFormat:s,inHeight:u,inWidth:c,inChannels:d,outHeight:J,outWidth:v,outChannels:j,padInfo:D,strideHeight:k,strideWidth:g,filterHeight:I,filterWidth:G,effectiveFilterHeight:F,effectiveFilterWidth:C,dilationHeight:f,dilationWidth:H,inShape:e,outShape:K,filterShape:t}}function s(e,t,n,o,A,i=!1,r="channelsLast",s){let[l,u,c,d,I]=[-1,-1,-1,-1,-1];if("channelsLast"===r)[l,u,c,d,I]=e;else{if("channelsFirst"!==r)throw new Error(`Unknown dataFormat ${r}`);[l,I,u,c,d]=e}const[G,E,k,,g]=t,[f,H,F]=m(n),[C,D,J]=m(o),v=p(G,C),j=p(E,D),K=p(k,J),{padInfo:y,outDepth:b,outHeight:q,outWidth:x}=function(e,t,n,o,A,i,r,s,l,m,p){let u,c,d,I;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const i=function(e,t,n,o,A,i){null==A&&(A=a(e,t,o));const r=e[1],s=e[2];return[h((e[0]-t+2*A)/o+1,i),h((r-t+2*A)/o+1,i),h((s-t+2*A)/o+1,i),1]}([t,n,o,1],s,0,A,e,p);c=i[0],d=i[1],I=i[2]}else if("same"===e){c=Math.ceil(t/A),d=Math.ceil(n/i),I=Math.ceil(o/r);const e=(c-1)*A+s-t,a=(d-1)*i+l-n,p=(I-1)*r+m-o,h=Math.floor(e/2),G=e-h,E=Math.floor(a/2),k=a-E,g=Math.floor(p/2);u={top:E,bottom:k,left:g,right:p-g,front:h,back:G,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);u={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},c=Math.ceil((t-s+1)/A),d=Math.ceil((n-l+1)/i),I=Math.ceil((o-m+1)/r)}return{padInfo:u,outDepth:c,outHeight:d,outWidth:I}}(A,u,c,d,f,H,F,v,j,K,s),B=i?g*I:g;let w;return"channelsFirst"===r?w=[l,B,b,q,x]:"channelsLast"===r&&(w=[l,b,q,x,B]),{batchSize:l,dataFormat:r,inDepth:u,inHeight:c,inWidth:d,inChannels:I,outDepth:b,outHeight:q,outWidth:x,outChannels:B,padInfo:y,strideDepth:f,strideHeight:H,strideWidth:F,filterDepth:G,filterHeight:E,filterWidth:k,effectiveFilterDepth:v,effectiveFilterHeight:j,effectiveFilterWidth:K,dilationDepth:C,dilationHeight:D,dilationWidth:J,inShape:e,outShape:w,filterShape:t}}function a(e,t,n,o=1){const A=p(t,o);return Math.floor((e[0]*(n-1)-n+A)/2)}function l(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function m(e){return"number"==typeof e?[e,e,e]:e}function p(e,t){return t<=1?e:e+(e-1)*(t-1)}function h(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function u(e){const[t,n,o]=l(e);return 1===t&&1===n&&1===o}function c(e,t){return u(e)||u(t)}function d(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}n.d(t,{Rf:()=>o,Xw:()=>A,pl:()=>i,Ix:()=>r,jw:()=>s,aO:()=>a,I0:()=>u,jT:()=>c,sl:()=>d})},173:(e,t,n)=>{"use strict";n.d(t,{m:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({cos_:function(e){const t={x:(0,i._1)(e,"x","cos","float32")};return o.BV.runKernel(A.mc,t)}})},2699:(e,t,n)=>{"use strict";n.d(t,{f:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({cosh_:function(e){const t={x:(0,i._1)(e,"x","cosh","float32")};return o.BV.runKernel(A.TR,t)}})},7405:(e,t,n)=>{"use strict";n.d(t,{z:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:(0,i._1)(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return o.BV.runKernel(A.iH,s,a)}})},9112:(e,t,n)=>{"use strict";n.d(t,{n:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({depthToSpace_:function(e,t,n="NHWC"){const s=(0,i._1)(e,"x","depthToSpace","float32"),a="NHWC"===n?s.shape[1]:s.shape[2],l="NHWC"===n?s.shape[2]:s.shape[3],m="NHWC"===n?s.shape[3]:s.shape[1];r.hu(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),r.hu(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${s.shape}`)),r.hu(l*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${l} and ${t} for depthToSpace with input shape\n        ${s.shape}`)),r.hu(m%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${m} for depthToSpace with input shape ${s.shape}`));const p={x:s},h={blockSize:t,dataFormat:n};return o.BV.runKernel(A.T0,p,h)}})},4718:(e,t,n)=>{"use strict";n.d(t,{B:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2668),a=n(4968);const l=(0,s.op)({depthwiseConv2d_:function(e,t,n,s,l="NHWC",m=[1,1],p){const h=(0,i._1)(e,"x","depthwiseConv2d","float32"),u=(0,i._1)(t,"filter","depthwiseConv2d","float32");let c=h,d=!1;3===h.rank&&(d=!0,c=(0,a.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),r.hu(4===c.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`)),r.hu(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`)),r.hu(c.shape[3]===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),null!=p&&r.hu(r.GN(s),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${p} but got pad ${s}.`));const I={x:c,filter:u},G={strides:n,pad:s,dataFormat:l,dilations:m,dimRoundingMode:p},E=o.BV.runKernel(A.ci,I,G);return d?(0,a.X)(E,[E.shape[1],E.shape[2],E.shape[3]]):E}})},8098:(e,t,n)=>{"use strict";n.d(t,{z:()=>s});var o=n(7097),A=n(9121),i=n(2668),r=n(4968);const s=(0,i.op)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,i,s,a=[1,1],l){let m=e;3===e.rank&&(m=(0,r.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let p=t;3===p.rank&&(p=(0,r.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:m,dy:p},u={strides:i,pad:s,dimRoundingMode:l,dilations:a,filterShape:n};return o.BV.runKernel(A.sL,h,u)}})},4375:(e,t,n)=>{"use strict";n.d(t,{v:()=>s});var o=n(7097),A=n(9121),i=n(2668),r=n(4968);const s=(0,i.op)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,i,s,a=[1,1],l){let m=t,p=!1;3===t.rank&&(p=!0,m=(0,r.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:m,filter:n},u={strides:i,pad:s,dimRoundingMode:l,dilations:a,inputShape:e},c=o.BV.runKernel(A.y7,h,u);return p?(0,r.X)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}})},557:(e,t,n)=>{"use strict";n.d(t,{W:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2668),a=n(4968);const l=(0,s.op)({dilation2d_:function(e,t,n,s,l=[1,1],m="NHWC"){const p=(0,i._1)(e,"x","dilation2d"),h=(0,i._1)(t,"filter","dilation2d");r.hu(3===p.rank||4===p.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${p.rank}.`)),r.hu(3===h.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`)),r.hu("NHWC"===m,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${m}`));let u=p,c=!1;3===p.rank&&(u=(0,a.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),c=!0);const d={x:u,filter:h},I={strides:n,pad:s,dilations:l},G=o.BV.runKernel(A.p4,d,I);return c?(0,a.X)(G,[G.shape[1],G.shape[2],G.shape[3]]):G}})},1274:(e,t,n)=>{"use strict";n.d(t,{h:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(9165);const a=(0,n(2668).op)({div_:function(e,t){let n=(0,r._1)(e,"a","div"),a=(0,r._1)(t,"b","div");if([n,a]=(0,i.makeTypesMatch)(n,a),"int32"===n.dtype&&"int32"===a.dtype)return(0,s.q)(n,a);const l={a:n,b:a};return o.BV.runKernel(A.oH,l,{})}})},9322:(e,t,n)=>{"use strict";n.d(t,{N:()=>m});var o=n(747),A=n(3740),i=n(1274),r=n(6477),s=n(2668),a=n(5912),l=n(6577);const m=(0,s.op)({divNoNan_:function(e,t){let n=(0,A._1)(e,"a","div"),s=(0,A._1)(t,"b","div");[n,s]=(0,o.makeTypesMatch)(n,s);const m=(0,i.h)(n,s),p=(0,l.P)(m),h=(0,r.D)(s,p);return(0,a.a)(h,p,m)}})},3233:(e,t,n)=>{"use strict";n.d(t,{p:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({elu_:function(e){const t={x:(0,i._1)(e,"x","elu","float32")};return o.BV.runKernel(A.SX,t)}})},6477:(e,t,n)=>{"use strict";n.d(t,{D:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({equal_:function(e,t){let n=(0,r._1)(e,"a","equal","string_or_numeric"),a=(0,r._1)(t,"b","equal","string_or_numeric");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A.hd,l)}})},4650:(e,t,n)=>{"use strict";n.d(t,{q:()=>a});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2271);const a=(0,n(2668).op)({erf_:function(e){let t=(0,i._1)(e,"x","erf");r.hu("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=(0,s.p)(t,"float32"));const n={x:t};return o.BV.runKernel(A.Om,n)}})},4842:(e,t,n)=>{"use strict";n.d(t,{Q:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({exp_:function(e){const t={x:(0,i._1)(e,"x","exp")};return o.BV.runKernel(A.NE,t)}})},1300:(e,t,n)=>{"use strict";n.d(t,{d:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({expandDims_:function(e,t=0){const n=(0,i._1)(e,"x","expandDims","string_or_numeric");r.hu(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const s={input:n},a={dim:t};return o.BV.runKernel(A.YF,s,a)}})},3426:(e,t,n)=>{"use strict";n.d(t,{t:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({expm1_:function(e){const t={x:(0,i._1)(e,"x","expm1")};return o.BV.runKernel(A.Y0,t)}})},4006:(e,t,n)=>{"use strict";n.d(t,{h:()=>i});var o=n(7097),A=n(9121);function i(e,t,n){const i={shape:e,value:t,dtype:n};return o.BV.runKernel(A.de,{},i)}},6943:(e,t,n)=>{"use strict";n.d(t,{G:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({floor_:function(e){const t={x:(0,i._1)(e,"x","floor","float32")};return o.BV.runKernel(A.OR,t)}})},9165:(e,t,n)=>{"use strict";n.d(t,{q:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({floorDiv_:function(e,t){let n=(0,r._1)(e,"a","floorDiv"),s=(0,r._1)(t,"b","floorDiv");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.je,a)}})},4624:(e,t,n)=>{"use strict";n.r(t),n.d(t,{conv2d:()=>E,depthwiseConv2d:()=>H,matMul:()=>C});var o=n(7097),A=n(633),i=n(9121),r=n(747),s=n(3740),a=n(569),l=n(6407),m=n(2200),p=n(4794),h=n(6013),u=n(9832),c=n(2582),d=n(9323),I=n(2668),G=n(4968);const E=(0,I.op)({fusedConv2d_:function({x:e,filter:t,strides:n,pad:I,dataFormat:E="NHWC",dilations:k=[1,1],dimRoundingMode:g,bias:f,activation:H="linear",preluActivationWeights:F,leakyreluAlpha:C}){if(H=H||"linear",!1===(0,d.uy)(o.BV.state.gradientDepth,H)){let o=(0,p.T)(e,t,n,I,E,k,g);return null!=f&&(o=(0,l.I)(o,f)),(0,d.QH)(o,H,F,C)}const D=(0,s._1)(e,"x","conv2d","float32"),J=(0,s._1)(t,"filter","conv2d","float32");let v=D,j=!1;3===D.rank&&(j=!0,v=(0,G.X)(D,[1,D.shape[0],D.shape[1],D.shape[2]])),a.hu(4===v.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${v.rank}.`)),a.hu(4===J.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${J.rank}.`)),null!=g&&a.hu(a.GN(I),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${g} but got pad ${I}.`)),a.hu(v.shape[3]===J.shape[2],(()=>`Error in conv2d: depth of input (${v.shape[3]}) must match input depth for filter ${J.shape[2]}.`)),a.hu(c.jT(n,k),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${k}'`)),a.hu("NHWC"===E,(()=>`Error in conv2d: got dataFormat of ${E} but only NHWC is currently supported.`));const K=c.Ix(v.shape,J.shape,n,k,I,g);let y,b;null!=f&&(y=(0,s._1)(f,"bias","fused conv2d"),[y]=(0,r.makeTypesMatch)(y,D),m.$N(K.outShape,y.shape)),null!=F&&(b=(0,s._1)(F,"prelu weights","fused conv2d"));const q=(e,t)=>{const[o,A,i,r]=t,s=(0,d.Fr)(e,i,H);a.hu(c.I0(k),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${k}'`));const l=[(0,u._)(A.shape,s,o,n,I),(0,h.p)(A,s,o.shape,n,I)];if(null!=r){const e=(0,d.pf)(r,s);l.push(e)}return l},x={x:v,filter:J,bias:y,preluActivationWeights:b},B={strides:n,pad:I,dataFormat:E,dilations:k,dimRoundingMode:g,activation:H,leakyreluAlpha:C};if(null==f){const e=(0,A.cb)(((e,t,n)=>{let A=o.BV.runKernel(i._V,x,B);return n([t,e,A]),j&&(A=(0,G.X)(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:q}}));return e(v,J)}{const e=(0,A.cb)(((e,t,n,A)=>{let r=o.BV.runKernel(i._V,x,B);return A([t,e,r,n]),j&&(r=(0,G.X)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:q}}));return e(v,J,y)}}});var k=n(4718),g=n(8098),f=n(4375);const H=(0,I.op)({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:p,dataFormat:h="NHWC",dilations:u=[1,1],dimRoundingMode:I,bias:E,activation:H="linear",preluActivationWeights:F,leakyreluAlpha:C}){if(!1===(0,d.uy)(o.BV.state.gradientDepth,H)){let o=(0,k.B)(e,t,n,p,h,u,I);return null!=E&&(o=(0,l.I)(o,E)),(0,d.QH)(o,H,F,C)}const D=(0,s._1)(e,"x","depthwiseConv2d","float32"),J=(0,s._1)(t,"filter","depthwiseConv2d","float32");let v=D,j=!1;3===D.rank&&(j=!0,v=(0,G.X)(D,[1,D.shape[0],D.shape[1],D.shape[2]])),a.hu(4===v.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${v.rank}.`)),a.hu(4===J.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${J.rank}.`)),a.hu(v.shape[3]===J.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${v.shape[3]}) must match the inChannels dimension in filter ${J.shape[2]}.`)),null==u&&(u=[1,1]),a.hu(c.jT(n,u),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${u}'`)),null!=I&&a.hu(a.GN(p),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${I} but got pad ${p}.`));const K=c.Ix(v.shape,J.shape,n,u,p,I,!0);let y,b;null!=E&&(y=(0,s._1)(E,"bias","fused conv2d"),[y]=(0,r.makeTypesMatch)(y,D),m.$N(K.outShape,y.shape)),null!=F&&(b=(0,s._1)(F,"prelu weights","fused depthwiseConv2d"));const q=(e,t)=>{a.hu(c.I0(u),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${u}'`));const[o,A,i,r]=t,s=(0,d.Fr)(e,i,H),l=(0,f.v)(A.shape,s,o,n,p,u,I),m=(0,g.z)(A,s,o.shape,n,p,u,I);return null!=r?[l,m,(0,d.pf)(y,s)]:[l,m]},x={x:v,filter:J,bias:y,preluActivationWeights:b},B={strides:n,pad:p,dataFormat:h,dilations:u,dimRoundingMode:I,activation:H,leakyreluAlpha:C};if(null==E){const e=(0,A.cb)(((e,t,n)=>{let A=o.BV.runKernel(i.lu,x,B);return n([t,e,A]),j&&(A=(0,G.X)(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:q}}));return e(v,J)}{const e=(0,A.cb)(((e,t,n,A)=>{let r=o.BV.runKernel(i.lu,x,B);return A([t,e,r,n]),j&&(r=(0,G.X)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:q}}));return e(v,J,y)}}});var F=n(8687);const C=(0,I.op)({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:p=!1,bias:h,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:I}){if(!1===(0,d.uy)(o.BV.state.gradientDepth,u)){let o=(0,F.O)(e,t,n,p);return null!=h&&(o=(0,l.I)(o,h)),(0,d.QH)(o,u,c,I)}let E=(0,s._1)(e,"a","fused matMul"),k=(0,s._1)(t,"b","fused matMul");[E,k]=(0,r.makeTypesMatch)(E,k);const g=n?E.shape[E.rank-2]:E.shape[E.rank-1],f=p?k.shape[k.rank-1]:k.shape[k.rank-2],H=n?E.shape[E.rank-1]:E.shape[E.rank-2],C=p?k.shape[k.rank-2]:k.shape[k.rank-1],D=E.shape.slice(0,-2),J=k.shape.slice(0,-2),v=a.NA(D),j=a.NA(J);a.hu(E.rank>=2&&k.rank>=2&&E.rank===k.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${E.rank} and ${k.rank}.`)),a.hu(a.cO(D,J),(()=>`Error in fused matMul: outer dimensions (${D}) and (${J}) of Tensors with shapes ${E.shape} and ${k.shape} must match.`)),a.hu(g===f,(()=>`Error in fused matMul: inner shapes (${g}) and (${f}) of Tensors with shapes ${E.shape} and ${k.shape} and transposeA=${n} and transposeB=${p} must match.`));const K=E.shape.slice(0,-2).concat([H,C]),y=n?(0,G.X)(E,[v,g,H]):(0,G.X)(E,[v,H,g]),b=p?(0,G.X)(k,[j,C,f]):(0,G.X)(k,[j,f,C]);let q,x;null!=h&&(q=(0,s._1)(h,"bias","fused matMul"),[q]=(0,r.makeTypesMatch)(q,E),m.$N(K,q.shape)),null!=c&&(x=(0,s._1)(c,"prelu weights","fused matMul"));const B=(e,t)=>{const[o,A,i,r]=t,s=(0,d.Fr)((0,G.X)(e,i.shape),i,u);let a,l;return n||p?!n&&p?(a=(0,F.O)(s,A,!1,!1),l=(0,F.O)(s,o,!0,!1)):n&&!p?(a=(0,F.O)(A,s,!1,!0),l=(0,F.O)(o,s,!1,!1)):(a=(0,F.O)(A,s,!0,!0),l=(0,F.O)(s,o,!0,!0)):(a=(0,F.O)(s,A,!1,!0),l=(0,F.O)(o,s,!0,!1)),null!=h?[a,l,(0,d.pf)(r,s)]:[a,l]},w={a:y,b,bias:q,preluActivationWeights:x},M={transposeA:n,transposeB:p,activation:u,leakyreluAlpha:I};if(null==h){const e=(0,A.cb)(((e,t,n)=>{const A=o.BV.runKernel(i.us,w,M);return n([e,t,A]),{value:(0,G.X)(A,K),gradFunc:B}}));return e(y,b)}{const e=(0,A.cb)(((e,t,n,A)=>{const r=o.BV.runKernel(i.us,w,M);return A([e,t,r,n]),{value:(0,G.X)(r,K),gradFunc:B}}));return e(y,b,q)}}})},9323:(e,t,n)=>{"use strict";n.d(t,{Fr:()=>c,pf:()=>d,QH:()=>I,uy:()=>G});var o=n(2200),A=n(3233),i=n(9133),r=n(4841),s=n(8151),a=n(7409),l=n(3582),m=n(4968),p=n(625),h=n(1901),u=n(5475);function c(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return(0,r.d)(e,(0,h.N)(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function d(e,t){let n=t;const A=o.RR(e.shape,t.shape);return A.length>0&&(n=(0,u.S)(n,A)),(0,m.X)(n,e.shape)}function I(e,t,n,o){if("linear"===t)return e;if("relu"===t)return(0,a.U)(e);if("elu"===t)return(0,A.p)(e);if("relu6"===t)return(0,l.b)(e);if("prelu"===t)return(0,s.A)(e,n);if("leakyrelu"===t)return(0,i.h)(e,o);if("sigmoid"===t)return(0,p.X)(e);throw new Error(`Unknown fused activation ${t}.`)}const G=(e,t)=>!(e>0)||"linear"===t},4926:(e,t,n)=>{"use strict";n.d(t,{I:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({gather_:function(e,t,n=0,r=0){const s={x:(0,i._1)(e,"x","gather"),indices:(0,i._1)(t,"indices","gather","int32")},a={axis:n,batchDims:r};return o.BV.runKernel(A.qi,s,a)}})},636:(e,t,n)=>{"use strict";n.d(t,{p:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({greater_:function(e,t){let n=(0,r._1)(e,"a","greater","string_or_numeric"),a=(0,r._1)(t,"b","greater","string_or_numeric");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A.iZ,l)}})},7630:(e,t,n)=>{"use strict";n.d(t,{b:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({greaterEqual_:function(e,t){let n=(0,r._1)(e,"a","greaterEqual","string_or_numeric"),a=(0,r._1)(t,"b","greaterEqual","string_or_numeric");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A.Ac,l)}})},4386:(e,t,n)=>{"use strict";n.d(t,{a:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({imag_:function(e){const t={input:(0,i._1)(e,"input","imag")};return o.BV.runKernel(A.J_,t)}})},3305:(e,t,n)=>{"use strict";n.d(t,{I:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2668),a=n(4968);const l=(0,s.op)({resizeBilinear_:function(e,t,n=!1,s=!1){const l=(0,i._1)(e,"images","resizeBilinear");r.hu(3===l.rank||4===l.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${l.rank}.`)),r.hu(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),r.hu(!1===s||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let m=l,p=!1;3===l.rank&&(p=!0,m=(0,a.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const[]=t,h={images:m},u={alignCorners:n,halfPixelCenters:s,size:t},c=o.BV.runKernel(A._Y,h,u);return p?(0,a.X)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}})},5098:(e,t,n)=>{"use strict";n.d(t,{j:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2668),a=n(4968);const l=(0,s.op)({resizeNearestNeighbor_:function(e,t,n=!1,s=!1){const l=(0,i._1)(e,"images","resizeNearestNeighbor");r.hu(3===l.rank||4===l.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${l.rank}.`)),r.hu(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),r.hu("float32"===l.dtype||"int32"===l.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),r.hu(!1===s||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let m=l,p=!1;3===l.rank&&(p=!0,m=(0,a.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const[]=t,h={images:m},u={alignCorners:n,halfPixelCenters:s,size:t},c=o.BV.runKernel(A.dp,h,u);return p?(0,a.X)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}})},6230:(e,t,n)=>{"use strict";n.d(t,{i:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({isNaN_:function(e){const t={x:(0,i._1)(e,"x","isNaN")};return o.BV.runKernel(A.r7,t)}})},9133:(e,t,n)=>{"use strict";n.d(t,{h:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({leakyRelu_:function(e,t=.2){const n={x:(0,i._1)(e,"x","leakyRelu")},r={alpha:t};return o.BV.runKernel(A.J$,n,r)}})},6573:(e,t,n)=>{"use strict";n.d(t,{d:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({less_:function(e,t){let n=(0,r._1)(e,"a","less","string_or_numeric"),a=(0,r._1)(t,"b","less","string_or_numeric");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A.vt,l)}})},624:(e,t,n)=>{"use strict";n.d(t,{z:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({lessEqual_:function(e,t){let n=(0,r._1)(e,"a","lessEqual","string_or_numeric"),a=(0,r._1)(t,"b","lessEqual","string_or_numeric");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A.CA,l)}})},9648:(e,t,n)=>{"use strict";n.d(t,{G:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2668),a=n(4968);const l=(0,s.op)({localResponseNormalization_:function(e,t=5,n=1,s=1,l=.5){const m=(0,i._1)(e,"x","localResponseNormalization");r.hu(4===m.rank||3===m.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${m.rank}.`)),r.hu(r.GN(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let p=m,h=!1;3===m.rank&&(h=!0,p=(0,a.X)(m,[1,m.shape[0],m.shape[1],m.shape[2]]));const u={x:p},c={depthRadius:t,bias:n,alpha:s,beta:l},d=o.BV.runKernel(A.eZ,u,c);return h?(0,a.X)(d,[d.shape[1],d.shape[2],d.shape[3]]):d}})},2597:(e,t,n)=>{"use strict";n.d(t,{c:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({log_:function(e){const t={x:(0,i._1)(e,"x","log","float32")};return o.BV.runKernel(A.Zb,t)}})},7474:(e,t,n)=>{"use strict";n.d(t,{K:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({log1p_:function(e){const t={x:(0,i._1)(e,"x","log1p")};return o.BV.runKernel(A.kU,t)}})},1510:(e,t,n)=>{"use strict";n.d(t,{C:()=>u});var o=n(633),A=n(3740),i=n(2271),r=n(4842),s=n(2597),a=n(3307),l=n(4841),m=n(2668),p=n(827),h=n(5475);const u=(0,m.op)({logSoftmax_:function(e,t=-1){const n=(0,A._1)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const m=(0,o.cb)(((e,n)=>{const o=(0,a.F)(e,t,!0),A=(0,p.l)(e,o),m=(0,p.l)((0,i.p)(A,"float32"),(0,s.c)((0,h.S)((0,r.Q)(A),t,!0)));return n([m]),{value:m,gradFunc:(e,n)=>{const[o]=n,A=(0,r.Q)(o);return(0,p.l)(e,(0,l.d)((0,h.S)(e,t,!0),A))}}}));return m(n)}})},1391:(e,t,n)=>{"use strict";n.d(t,{l:()=>c});var o=n(3740),A=n(569),i=n(6407),r=n(3591),s=n(4842),a=n(2597),l=n(3307),m=n(2668),p=n(4968),h=n(827),u=n(5475);const c=(0,m.op)({logSumExp_:function(e,t=null,n=!1){const m=(0,o._1)(e,"x","logSumExp"),c=(0,A.EC)(t,m.shape),d=(0,l.F)(m,c,!0),I=(0,h.l)(m,d),G=(0,s.Q)(I),E=(0,u.S)(G,c),k=(0,a.c)(E),g=(0,i.I)((0,p.X)(d,k.shape),k);if(n){const e=(0,r.rv)(g.shape,c);return(0,p.X)(g,e)}return g}})},2856:(e,t,n)=>{"use strict";n.d(t,{H:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(2200);const s=(0,n(2668).op)({logicalAnd_:function(e,t){const n=(0,i._1)(e,"a","logicalAnd","bool"),s=(0,i._1)(t,"b","logicalAnd","bool");(0,r.$N)(n.shape,s.shape);const a={a:n,b:s};return o.BV.runKernel(A.PY,a)}})},8651:(e,t,n)=>{"use strict";n.d(t,{h:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({logicalNot_:function(e){const t={x:(0,i._1)(e,"x","logicalNot","bool")};return o.BV.runKernel(A.Vf,t)}})},5750:(e,t,n)=>{"use strict";n.d(t,{K:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(2200);const s=(0,n(2668).op)({logicalOr_:function(e,t){const n=(0,i._1)(e,"a","logicalOr","bool"),s=(0,i._1)(t,"b","logicalOr","bool");(0,r.$N)(n.shape,s.shape);const a={a:n,b:s};return o.BV.runKernel(A.MZ,a)}})},8687:(e,t,n)=>{"use strict";n.d(t,{O:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({matMul_:function(e,t,n=!1,s=!1){let a=(0,r._1)(e,"a","matMul"),l=(0,r._1)(t,"b","matMul");[a,l]=(0,i.makeTypesMatch)(a,l);const m={a,b:l},p={transposeA:n,transposeB:s};return o.BV.runKernel(A.XL,m,p)}})},3307:(e,t,n)=>{"use strict";n.d(t,{F:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({max_:function(e,t=null,n=!1){const r={x:(0,i._1)(e,"x","max")},s={reductionIndices:t,keepDims:n};return o.BV.runKernel(A.Yo,r,s)}})},1174:(e,t,n)=>{"use strict";n.d(t,{_:()=>m});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2582),a=n(2668),l=n(4968);const m=(0,a.op)({maxPool_:function(e,t,n,a,m){const p=(0,i._1)(e,"x","maxPool");let h=p,u=!1;3===p.rank&&(u=!0,h=(0,l.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),r.hu(4===h.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`)),r.hu(s.jT(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=m&&r.hu(r.GN(a),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${m} but got pad ${a}.`));const c={x:h},d={filterSize:t,strides:n,pad:a,dimRoundingMode:m},I=o.BV.runKernel(A.mT,c,d);return u?(0,l.X)(I,[I.shape[1],I.shape[2],I.shape[3]]):I}})},5020:(e,t,n)=>{"use strict";n.d(t,{Y:()=>l});var o=n(7097),A=n(9121),i=n(3740),r=n(569),s=n(2668),a=n(4968);const l=(0,s.op)({maxPool3d_:function(e,t=[1,1,1],n,s,l,m="NDHWC"){const p=(0,i._1)(e,"x","maxPool3d");let h=p,u=!1;4===p.rank&&(u=!0,h=(0,a.X)(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),r.hu(5===h.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${h.rank}.`)),r.hu("NDHWC"===m,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${m}`)),null!=l&&r.hu(r.GN(s),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${s}.`));const c={x:h},d={filterSize:t,strides:n,pad:s,dimRoundingMode:l,dataFormat:m},I=o.BV.runKernel(A.OA,c,d);return u?(0,a.X)(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}})},632:(e,t,n)=>{"use strict";n.d(t,{g:()=>l});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200),a=n(2271);const l=(0,n(2668).op)({maximum_:function(e,t){let n=(0,r._1)(e,"a","maximum"),l=(0,r._1)(t,"b","maximum");[n,l]=(0,i.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=(0,a.p)(n,"int32"),l=(0,a.p)(l,"int32")),(0,s.$N)(n.shape,l.shape);const m={a:n,b:l};return o.BV.runKernel(A.BM,m)}})},5130:(e,t,n)=>{"use strict";n.d(t,{J:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({mean_:function(e,t=null,n=!1){const r={x:(0,i._1)(e,"x","mean")},s={axis:t,keepDims:n};return o.BV.runKernel(A.q2,r,s)}})},5735:(e,t,n)=>{"use strict";n.d(t,{V:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({min_:function(e,t=null,n=!1){const r={x:(0,i._1)(e,"x","min")},s={axis:t,keepDims:n};return o.BV.runKernel(A.c1,r,s)}})},4513:(e,t,n)=>{"use strict";n.d(t,{L:()=>l});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200),a=n(2271);const l=(0,n(2668).op)({minimum_:function(e,t){let n=(0,r._1)(e,"a","minimum"),l=(0,r._1)(t,"b","minimum");[n,l]=(0,i.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=(0,a.p)(n,"int32"),l=(0,a.p)(l,"int32")),(0,s.$N)(n.shape,l.shape);const m={a:n,b:l};return o.BV.runKernel(A.q8,m)}})},1483:(e,t,n)=>{"use strict";n.d(t,{V:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({mirrorPad_:function(e,t,n){r.hu("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const s=(0,i._1)(e,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");r.hu(t.length===s.rank,(()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`));const a="reflect"===n?1:0;for(let e=0;e<s.rank;e++)r.hu(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),r.hu(t[e][0]>=0&&t[e][0]<=s.shape[e]-a&&t[e][1]>=0&&t[e][1]<=s.shape[e]-a,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${s.shape[e]-a} or less than 0 for input of shape ${s.shape}`));const l={paddings:t,mode:n},m={x:s};return o.BV.runKernel(A.jQ,m,l)}})},5228:(e,t,n)=>{"use strict";n.d(t,{w:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({mod_:function(e,t){let n=(0,r._1)(e,"a","mod"),s=(0,r._1)(t,"b","mod");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.Vb,a)}})},4841:(e,t,n)=>{"use strict";n.d(t,{d:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({mul_:function(e,t){let n=(0,r._1)(e,"a","mul"),s=(0,r._1)(t,"b","mul");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.wY,a)}})},7370:(e,t,n)=>{"use strict";n.d(t,{W:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({neg_:function(e){const t={x:(0,i._1)(e,"x","neg")};return o.BV.runKernel(A.ku,t)}})},3561:(e,t,n)=>{"use strict";n.d(t,{K:()=>G});var o=n(3740),A=n(569),i=n(6235),r=n(3591),s=n(3307),a=n(5735),l=n(2668),m=n(3453),p=n(4968),h=n(9494),u=n(3261),c=n(248),d=n(5475);function I(e,t,n=null){if(0===e.rank)return(0,i.W)(e);if(1!==e.rank&&null===n)return I((0,p.X)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,d.S)((0,i.W)(e),n);if(t===1/0)return(0,s.F)((0,i.W)(e),n);if(t===-1/0)return(0,a.V)((0,i.W)(e),n);if("euclidean"===t||2===t)return(0,u._)((0,d.S)((0,m.s)((0,i.W)(e),(0,h.i)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,s.F)((0,d.S)((0,i.W)(e),n[0]),n[1]-1);if(t===1/0)return(0,s.F)((0,d.S)((0,i.W)(e),n[1]),n[0]);if(t===-1/0)return(0,a.V)((0,d.S)((0,i.W)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,u._)((0,d.S)((0,c.h)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const G=(0,l.op)({norm_:function(e,t="euclidean",n=null,i=!1){const s=I(e=(0,o._1)(e,"x","norm"),t,n);let a=s.shape;if(i){const t=(0,A.EC)(n,e.shape);a=r.rv(s.shape,t)}return(0,p.X)(s,a)}})},6500:(e,t,n)=>{"use strict";n.d(t,{Q:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({notEqual_:function(e,t){let n=(0,r._1)(e,"a","notEqual","string_or_numeric"),a=(0,r._1)(t,"b","notEqual","string_or_numeric");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A.yQ,l)}})},6708:(e,t,n)=>{"use strict";n.d(t,{l:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s={indices:(0,i._1)(e,"indices","oneHot","int32")},a={depth:t,onValue:n,offValue:r};return o.BV.runKernel(A.we,s,a)}})},4917:(e,t,n)=>{"use strict";n.d(t,{i:()=>s});var o=n(7097),A=n(569),i=n(1661),r=n(9640);function s(e,t="float32"){if("complex64"===t){const t=s(e,"float32"),n=(0,r.l)(e,"float32");return(0,i.P)(t,n)}const n=(0,A.p8)((0,A.NA)(e),t);return o.BV.makeTensor(n,e,t)}},7846:(e,t,n)=>{"use strict";n.d(t,{J:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({onesLike_:function(e){const t={x:(0,i._1)(e,"x","onesLike")};return o.BV.runKernel(A.qW,t)}})},2668:(e,t,n)=>{"use strict";n.d(t,{op:()=>i});var o=n(7097),A=n(569);function i(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const i=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...e)=>{o.BV.startScope(n);try{const t=i(...e);return(0,A.tI)(t)&&console.error("Cannot return a Promise inside of tidy."),o.BV.endScope(t),t}catch(e){throw o.BV.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}},8869:(e,t,n)=>{"use strict";n.d(t,{WnP:()=>o.W,IHx:()=>A.I,$6P:()=>i.$,YjB:()=>r.Y,NqF:()=>s.N,wS1:()=>a.w,uR5:()=>l.u,Dxk:()=>c,JY5:()=>d,p3b:()=>I,f3b:()=>G.f,pju:()=>E.p,iUl:()=>k.i,d9v:()=>g.d,zoF:()=>f.z,gME:()=>H,Izb:()=>F,MNy:()=>C,ZaL:()=>D,PAt:()=>J.P,Tek:()=>v.T,bc:()=>j.b,pdZ:()=>K.p,$QV:()=>b,B10:()=>q.B,hiC:()=>x.h,rvX:()=>Ze,pyx:()=>B.p,DgJ:()=>w.D,Qqt:()=>M.Q,dt4:()=>L.d,iyy:()=>N,hlL:()=>R.h,GWj:()=>O.G,imm:()=>nt,Iqj:()=>P.I,pjt:()=>U.p,brS:()=>V.b,BHj:()=>Ot,hi7:()=>W.h,$r2:()=>Pt,cM7:()=>_.c,Krr:()=>z.K,CmS:()=>X.C,HvI:()=>Q.H,OI3:()=>Z.O,Fp7:()=>Y.F,_sB:()=>$._,YQQ:()=>ee.Y,gWQ:()=>te.g,J69:()=>ne.J,LTh:()=>oe.L,Gi7:()=>se,dC7:()=>ae.d,W76:()=>le.W,Quu:()=>me.Q,lfX:()=>pe.l,iUs:()=>he.i,JpU:()=>ue.J,vku:()=>ce.v,AL3:()=>de.A,nGf:()=>Ge,LGj:()=>Ee.L,UYe:()=>ke.U,XLQ:()=>S.X,GYS:()=>ge.G,iD$:()=>fe.i,U8D:()=>He.U,U_I:()=>Fe.U,XD2:()=>Ce.X,tPi:()=>De.t,jZU:()=>Je,SmN:()=>ve,CnO:()=>je,p0P:()=>Ke,XAC:()=>ye.X,Wvh:()=>be.W,rVs:()=>Ut,Vl2:()=>qe.V,_b3:()=>xe._,L9e:()=>Be.L,knu:()=>we.k,Z_8:()=>Vt,luU:()=>re.l,Smz:()=>Me.S,AEp:()=>Le.A,XeE:()=>Se.X,RRF:()=>Te.R,odF:()=>Re,Gg6:()=>T.G,p4s:()=>Xe.p,Xu6:()=>Oe.X,HHK:()=>Pe.H,VD$:()=>Ve,arb:()=>We.a,lls:()=>_e.l,P84:()=>ze.P});var o=n(6235),A=n(6407),i=n(781),r=n(2998),s=n(47),a=n(5176),l=n(1749),m=n(3740),p=n(569),h=n(7505),u=n(2668);const c=(0,u.op)({batchNorm2d_:function(e,t,n,o,A,i){const r=(0,m._1)(e,"x","batchNorm"),s=(0,m._1)(t,"mean","batchNorm"),a=(0,m._1)(n,"variance","batchNorm");let l,u;return null!=A&&(l=(0,m._1)(A,"scale","batchNorm")),null!=o&&(u=(0,m._1)(o,"offset","batchNorm")),p.hu(2===r.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${r.rank}.`)),p.hu(2===s.rank||1===s.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${s.rank}.`)),p.hu(2===a.rank||1===a.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${a.rank}.`)),null!=l&&p.hu(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&p.hu(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`)),(0,h.t)(r,s,a,u,l,i)}}),d=(0,u.op)({batchNorm3d_:function(e,t,n,o,A,i){const r=(0,m._1)(e,"x","batchNorm"),s=(0,m._1)(t,"mean","batchNorm"),a=(0,m._1)(n,"variance","batchNorm");let l,u;return null!=A&&(l=(0,m._1)(A,"scale","batchNorm")),null!=o&&(u=(0,m._1)(o,"offset","batchNorm")),p.hu(3===r.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${r.rank}.`)),p.hu(3===s.rank||1===s.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${s.rank}.`)),p.hu(3===a.rank||1===a.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${a.rank}.`)),null!=l&&p.hu(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&p.hu(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`)),(0,h.t)(r,s,a,u,l,i)}}),I=(0,u.op)({batchNorm4d_:function(e,t,n,o,A,i){const r=(0,m._1)(e,"x","batchNorm"),s=(0,m._1)(t,"mean","batchNorm"),a=(0,m._1)(n,"variance","batchNorm");let l,u;return null!=A&&(l=(0,m._1)(A,"scale","batchNorm")),null!=o&&(u=(0,m._1)(o,"offset","batchNorm")),p.hu(4===r.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${r.rank}.`)),p.hu(4===s.rank||1===s.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${s.rank}.`)),p.hu(4===a.rank||1===a.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${a.rank}.`)),null!=l&&p.hu(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&p.hu(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`)),(0,h.t)(r,s,a,u,l,i)}});var G=n(2657),E=n(2271),k=n(2279),g=n(8723),f=n(6884);const H=(0,u.op)({concat1d_:function(e){return(0,f.z)(e,0)}}),F=(0,u.op)({concat2d_:function(e,t){return(0,f.z)(e,t)}}),C=(0,u.op)({concat3d_:function(e,t){return(0,f.z)(e,t)}}),D=(0,u.op)({concat4d_:function(e,t){return(0,f.z)(e,t)}});var J=n(1355),v=n(4794),j=n(1405),K=n(473),y=n(7594);const b=(0,u.op)({conv3dTranspose_:function(e,t,n,o,A){const i=(0,m._1)(e,"x","conv3dTranspose"),r=(0,m._1)(t,"filter","conv3dTranspose");return(0,y._)(n,i,r,o,A)}});var q=n(4718),x=n(1274),B=n(3233),w=n(6477),M=n(4842),L=n(1300),S=n(4968),T=n(7501);const N=(0,u.op)({eye_:function(e,t,n,o="float32"){null==t&&(t=e);const A=(0,G.f)([e,t],o),i=e<=t?e:t;for(let e=0;e<i;++e)A.set(1,e,e);const r=(0,S.X)(A.toTensor(),[e,t]);if(null==n)return r;if(1===n.length)return(0,T.G)((0,L.d)(r,0),[n[0],1,1]);if(2===n.length)return(0,T.G)((0,L.d)((0,L.d)(r,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,T.G)((0,L.d)((0,L.d)((0,L.d)(r,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var R=n(4006),O=n(6943),P=n(4926),U=n(636),V=n(7630),W=n(9133),_=n(2597),z=n(7474),X=n(1510),Q=n(2856),Z=n(8687),Y=n(3307),$=n(1174),ee=n(5020),te=n(632),ne=n(5130),oe=n(4513),Ae=n(3591),ie=n(248),re=n(827);const se=(0,u.op)({moments_:function(e,t=null,n=!1){e=(0,m._1)(e,"x","moments");const o=(0,p.EC)(t,e.shape),A=(0,ne.J)(e,o,n);let i=A.shape;n||(i=(0,Ae.rv)(A.shape,o));const r=(0,ie.h)((0,re.l)((0,E.p)(e,"float32"),(0,S.X)(A,i)));return{mean:A,variance:(0,ne.J)(r,o,n)}}});var ae=n(4841),le=n(7370),me=n(6500),pe=n(6708),he=n(4917),ue=n(7846),ce=n(9682),de=n(8151),Ie=n(6845);const Ge=(0,u.op)({randomNormal_:function(e,t=0,n=1,o,A){if(null!=o&&"bool"===o)throw new Error(`Unsupported data type ${o}`);const i=new Ie.Yi(t,n,o,!1,A),r=(0,G.f)(e,o);for(let e=0;e<r.values.length;e++)r.values[e]=i.nextValue();return r.toTensor()}});var Ee=n(5002),ke=n(7409),ge=n(7486),fe=n(9494),He=n(5503),Fe=n(8678),Ce=n(625),De=n(2676);const Je=(0,u.op)({slice1d_:function(e,t,n){const o=(0,m._1)(e,"x","slice1d");return p.hu(1===o.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${o.rank} tensor`)),(0,De.t)(o,[t],[n])}}),ve=(0,u.op)({slice2d_:function(e,t,n){const o=(0,m._1)(e,"x","slice2d");return p.hu(2===o.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${o.rank} tensor`)),(0,De.t)(o,t,n)}}),je=(0,u.op)({slice3d_:function(e,t,n){const o=(0,m._1)(e,"x","slice3d");return p.hu(3===o.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${o.rank} tensor`)),(0,De.t)(o,t,n)}}),Ke=(0,u.op)({slice4d_:function(e,t,n){const o=(0,m._1)(e,"x","slice4d");return p.hu(4===o.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${o.rank} tensor`)),(0,De.t)(o,t,n)}});var ye=n(682),be=n(3694),qe=n(8644),xe=n(3261),Be=n(9590),we=n(2991),Me=n(5475),Le=n(1869),Se=n(701),Te=n(6092),Ne=n(7852);function Re(e,t,n){if((0,p.Cq)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const o=(0,m.C)(e,n);if(2!==o.length&&1!==o.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===o.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Ne.H)(e,t,o,n)}var Oe=n(3596),Pe=n(4136),Ue=n(7097);function Ve(e,t=!0,n,o){return Ue.BV.makeVariable(e,t,n,o)}var We=n(5912),_e=n(9640),ze=n(6577),Xe=n(9065),Qe=n(4077);const Ze=(0,u.op)({dropout_:function(e,t,n,o){const i=(0,m._1)(e,"x","dropout");if(p.hu("float32"===i.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`)),p.hu(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof Qe.es?i.clone():i;const r=function(e,t){if(null==t)return e.shape.slice();if(p.cO(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let o=0;o<e.shape.length;o++)null==t[o]&&null!=e.shape[o]?n.push(e.shape[o]):n.push(t[o]);return n}return t}(i,n),s=1-t,a=(0,x.h)((0,O.G)((0,A.I)((0,Ee.L)(r,0,1,"float32",o),s)),s);return(0,ae.d)(i,a)}});var Ye=n(3710),$e=n(7020),et=n(8447),tt=n(4415),nt=n(4624);function ot(e,t,n){const o=1-e%2,A=new Float32Array(e);for(let i=0;i<e;++i){const r=2*Math.PI*i/(e+o-1);A[i]=t-n*Math.cos(r)}return(0,Te.R)(A,"float32")}(0,u.op)({hammingWindow_:function(e){return ot(e,.54,.46)}});const At=(0,u.op)({hannWindow_:function(e){return ot(e,.5,.5)}}),it=(0,u.op)({frame_:function(e,t,n,o=!1,A=0){let i=0;const r=[];for(;i+t<=e.size;)r.push((0,De.t)(e,i,t)),i+=n;if(o)for(;i<e.size;){const o=i+t-e.size,s=(0,f.z)([(0,De.t)(e,i,t-o),(0,R.h)([o],A)]);r.push(s),i+=n}return 0===r.length?Re([],[0,t]):(0,S.X)((0,f.z)(r),[r.length,t])}});(0,u.op)({stft_:function(e,t,n,o,A=At){var i;null==o&&(i=t,o=Math.floor(Math.pow(2,Math.ceil(Math.log(i)/Math.log(2)))));const r=it(e,t,n),s=(0,ae.d)(r,A(t));return(0,Ye.Q)(s,o)}});var rt=n(9121);const st=(0,u.op)({cropAndResize_:function(e,t,n,o,A="bilinear",i=0){const r=(0,m._1)(e,"image","cropAndResize"),s=(0,m._1)(t,"boxes","cropAndResize","float32"),a=(0,m._1)(n,"boxInd","cropAndResize","int32"),l=s.shape[0];p.hu(4===r.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${r.rank}.`)),p.hu(2===s.rank&&4===s.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${s.shape}.`)),p.hu(1===a.rank&&a.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${s.shape}.`)),p.hu(2===o.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${o.length}.`)),p.hu(o[0]>=1&&o[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${o}`)),p.hu("bilinear"===A||"nearest"===A,(()=>`method must be bilinear or nearest, but was ${A}`));const h={image:r,boxes:s,boxInd:a},u={method:A,extrapolationValue:i,cropSize:o};return Ue.BV.runKernel(rt.Vc,h,u)}}),at=(0,u.op)({flipLeftRight_:function(e){const t=(0,m._1)(e,"image","flipLeftRight","float32");p.hu(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Ue.BV.runKernel(rt.Uy,n,{})}}),lt=(0,u.op)({grayscaleToRGB_:function(e){const t=(0,m._1)(e,"image","grayscaleToRGB"),n=t.rank-1,o=t.shape[n];p.hu(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),p.hu(1===o,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${o}.`));const A=new Array(t.rank);return A.fill(1,0,n),A[n]=3,(0,T.G)(t,A)}}),mt=(0,u.op)({rotateWithOffset_:function(e,t,n=0,o=.5){const A=(0,m._1)(e,"image","rotateWithOffset","float32");p.hu(4===A.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${A.rank}.`));const i={image:A},r={radians:t,fillValue:n,center:o};return Ue.BV.runKernel(rt.b9,i,r)}});function pt(e,t,n,o,A,i){null==o&&(o=.5),null==A&&(A=Number.NEGATIVE_INFINITY),null==i&&(i=0);const r=e.shape[0];return n=Math.min(n,r),p.hu(0<=o&&o<=1,(()=>`iouThreshold must be in [0, 1], but was '${o}'`)),p.hu(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),p.hu(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),p.hu(1===t.rank,(()=>"scores must be a 1D tensor")),p.hu(t.shape[0]===r,(()=>`scores has incompatible shape with boxes. Expected ${r}, but was ${t.shape[0]}`)),p.hu(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:o,scoreThreshold:A,softNmsSigma:i}}const ht=(0,u.op)({nonMaxSuppression_:function(e,t,n,o=.5,A=Number.NEGATIVE_INFINITY){const i=(0,m._1)(e,"boxes","nonMaxSuppression","float32"),r=(0,m._1)(t,"scores","nonMaxSuppression","float32"),s=pt(i,r,n,o,A),a={maxOutputSize:n=s.maxOutputSize,iouThreshold:o=s.iouThreshold,scoreThreshold:A=s.scoreThreshold};return Ue.BV.runKernel(rt.uv,{boxes:i,scores:r},a)}});var ut=n(3337);const ct=(0,u.op)({nonMaxSuppressionWithScore_:function(e,t,n,o=.5,A=Number.NEGATIVE_INFINITY,i=0){const r=(0,m._1)(e,"boxes","nonMaxSuppression"),s=(0,m._1)(t,"scores","nonMaxSuppression"),a=pt(r,s,n,o,A,i),l={boxes:r,scores:s},p={maxOutputSize:n=a.maxOutputSize,iouThreshold:o=a.iouThreshold,scoreThreshold:A=a.scoreThreshold,softNmsSigma:i=a.softNmsSigma},h=Ue.BV.runKernel(rt.W0,l,p);return{selectedIndices:h[0],selectedScores:h[1]}}}),dt=(0,u.op)({nonMaxSuppressionPadded_:function(e,t,n,o=.5,A=Number.NEGATIVE_INFINITY,i=!1){const r=(0,m._1)(e,"boxes","nonMaxSuppression"),s=(0,m._1)(t,"scores","nonMaxSuppression"),a=pt(r,s,n,o,A,null),l={boxes:r,scores:s},p={maxOutputSize:a.maxOutputSize,iouThreshold:a.iouThreshold,scoreThreshold:a.scoreThreshold,padToMaxOutputSize:i},h=Ue.BV.runKernel(rt.cy,l,p);return{selectedIndices:h[0],validOutputs:h[1]}}});var It=n(3305),Gt=n(5098),Et=n(3865),kt=n(624),gt=n(7809),ft=n(7245);const Ht=(0,u.op)({threshold_:function(e,t="binary",n=!1,o=.5){const i=(0,m._1)(e,"image","threshold"),r=i.shape[0]*i.shape[1];let s,a,l,h,u=(0,ae.d)((0,Te.R)([o]),255);if(p.hu(3===i.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`)),p.hu(3===i.shape[2]||1===i.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`)),p.hu("int32"===i.dtype||"float32"===i.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`)),p.hu("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===i.shape[2]){[s,a,l]=(0,qe.V)(i,[1,1,1],-1);const e=(0,ae.d)(s,.2989),t=(0,ae.d)(a,.587),n=(0,ae.d)(l,.114);h=(0,A.I)((0,A.I)(e,t),n)}else h=e;"otsu"===t&&(u=function(e,t){let n,o,i,r,s,a,l=(0,Te.R)([-1]),m=(0,Te.R)([0]),p=(0,Te.R)([0]);for(let h=0;h<e.size-1;h++){n=(0,De.t)(e,0,h+1),o=(0,De.t)(e,h+1),s=(0,x.h)((0,Me.S)(n),t),a=(0,x.h)((0,Me.S)(o),t);const u=(0,Me.S)((0,ae.d)(n,(0,ft.w)(0,n.size)));i=(0,x.h)(u,(0,Me.S)(n));const c=(0,R.h)(o.shape,n.size),d=(0,A.I)((0,ft.w)(0,o.size),c),I=(0,ae.d)(o,d);r=(0,x.h)((0,Me.S)(I),(0,Me.S)(o));const G=(0,re.l)(i,r),E=(0,re.l)(i,r),k=(0,ae.d)(s,a);p=(0,ae.d)((0,ae.d)(k,G),E);const g=(0,U.p)(p,m);m=(0,We.a)(g,p,m),l=(0,We.a)(g,(0,Te.R)([h]),l)}return l}((0,Et.y)((0,E.p)((0,gt.N)(h),"int32"),(0,Se.X)([]),256),r));const c=n?(0,kt.z)(h,u):(0,U.p)(h,u);return(0,E.p)((0,ae.d)(c,255),"int32")}}),Ft=(0,u.op)({transform_:function(e,t,n="nearest",o="constant",A=0,i){const r=(0,m._1)(e,"image","transform","float32"),s=(0,m._1)(t,"transforms","transform","float32");p.hu(4===r.rank,(()=>`Error in transform: image must be rank 4,but got rank ${r.rank}.`)),p.hu(2===s.rank&&(s.shape[0]===r.shape[0]||1===s.shape[0])&&8===s.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),p.hu(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));const a={image:r,transforms:s},l={interpolation:n,fillMode:o,fillValue:A,outputShape:i};return Ue.BV.runKernel(rt.wx,a,l)}}),Ct=(0,u.op)({bandPart_:function(e,t,n){(0,p.hu)(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),(0,p.hu)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const o=(0,m._1)(e,"a","bandPart");(0,p.hu)(o.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${o.rank}.`));const A=o.shape,[i,r]=o.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(n<=r))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${r}).`);t<0&&(t=i),n<0&&(n=r);const s=(0,S.X)((0,ft.w)(0,i,1,"int32"),[-1,1]),a=(0,ft.w)(0,r,1,"int32"),l=(0,re.l)(s,a),h=(0,Q.H)((0,kt.z)(l,(0,fe.i)(+t,"int32")),(0,V.b)(l,(0,fe.i)(-n,"int32"))),u=(0,_e.l)([i,r],o.dtype);return(0,S.X)((0,we.k)((0,Pe.H)((0,S.X)(o,[-1,i,r])).map((e=>(0,We.a)(h,e,u)))),A)}});var Dt=n(3561);const Jt=(0,u.op)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,(0,p.hu)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)(0,p.hu)(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=(0,qe.V)(e,e.shape[0],0).map((e=>(0,Be.L)(e,[0])));(0,p.hu)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],o=e;for(let t=0;t<e.length;++t)n.push(Ue.BV.tidy((()=>{let e=o[t];if(t>0)for(let o=0;o<t;++o){const t=(0,ae.d)((0,Me.S)((0,ae.d)(n[o],e)),n[o]);e=(0,re.l)(e,t)}return(0,x.h)(e,(0,Dt.K)(e,"euclidean"))})));return t?(0,we.k)(n,0):n}});var vt=n(4368);function jt(e,t=!1){return Ue.BV.tidy((()=>{(0,p.hu)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],o=e.shape[1];let A=N(n),i=(0,g.d)(e);const r=Re([[1]],[1,1]);let s=(0,g.d)(r);const a=n>=o?o:n;for(let e=0;e<a;++e){const t=i,a=s,l=A;[s,i,A]=Ue.BV.tidy((()=>{const t=(0,De.t)(i,[e,e],[n-e,1]),a=(0,Dt.K)(t),l=(0,De.t)(i,[e,e],[1,1]),m=(0,We.a)((0,U.p)(l,0),Re([[-1]]),Re([[1]])),p=(0,re.l)(l,(0,ae.d)(m,a)),h=(0,x.h)(t,p);s=1===h.shape[0]?(0,g.d)(r):(0,f.z)([r,(0,De.t)(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const u=(0,le.W)((0,x.h)((0,Z.O)(m,p),a)),c=(0,De.t)(i,[e,0],[n-e,o]),d=(0,ae.d)(u,s),I=(0,Xe.p)(s);if(0===e)i=(0,re.l)(c,(0,Z.O)(d,(0,Z.O)(I,c)));else{const t=(0,re.l)(c,(0,Z.O)(d,(0,Z.O)(I,c)));i=(0,f.z)([(0,De.t)(i,[0,0],[e,o]),t],0)}const G=(0,Xe.p)(d),E=(0,De.t)(A,[0,e],[n,A.shape[1]-e]);if(0===e)A=(0,re.l)(E,(0,Z.O)((0,Z.O)(E,s),G));else{const t=(0,re.l)(E,(0,Z.O)((0,Z.O)(E,s),G));A=(0,f.z)([(0,De.t)(A,[0,0],[n,e]),t],1)}return[s,i,A]})),(0,vt.B9)([t,a,l])}return!t&&n>o&&(A=(0,De.t)(A,[0,0],[n,o]),i=(0,De.t)(i,[0,0],[o,o])),[A,i]}))}const Kt=(0,u.op)({qr_:function(e,t=!1){if((0,p.hu)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return jt(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),o=(0,Pe.H)((0,S.X)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),A=[],i=[];return o.forEach((e=>{const[n,o]=jt(e,t);A.push(n),i.push(o)})),[(0,S.X)((0,we.k)(A,0),e.shape),(0,S.X)((0,we.k)(i,0),e.shape)]}}});var yt;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(yt||(yt={}));const bt=(0,u.op)({computeWeightedLoss_:function(e,t,n=yt.SUM_BY_NONZERO_WEIGHTS){const o=(0,m._1)(e,"losses","computeWeightedLoss");let A=null;null!=t&&(A=(0,m._1)(t,"weights","computeWeightedLoss"));const i=null==A?o:(0,ae.d)(o,A);if(n===yt.NONE)return i;if(n===yt.SUM)return(0,Me.S)(i);if(n===yt.MEAN){if(null==A)return(0,ne.J)(i);{const e=o.size/A.size,t=(0,x.h)((0,Me.S)(i),(0,Me.S)(A));return e>1?(0,x.h)(t,(0,fe.i)(e)):t}}if(n===yt.SUM_BY_NONZERO_WEIGHTS){if(null==A)return(0,x.h)((0,Me.S)(i),(0,fe.i)(o.size));{const e=(0,ae.d)(A,(0,he.i)(o.shape)),t=(0,E.p)((0,Me.S)((0,me.Q)(e,(0,fe.i)(0))),"float32");return(0,x.h)((0,Me.S)(i),t)}}throw Error(`Unknown reduction: ${n}`)}});(0,u.op)({absoluteDifference_:function(e,t,n,A=yt.SUM_BY_NONZERO_WEIGHTS){const i=(0,m._1)(e,"labels","absoluteDifference"),r=(0,m._1)(t,"predictions","absoluteDifference");let s=null;null!=n&&(s=(0,m._1)(n,"weights","absoluteDifference")),(0,p.k5)(i.shape,r.shape,"Error in absoluteDifference: ");const a=(0,o.W)((0,re.l)(i,r));return bt(a,s,A)}}),(0,u.op)({cosineDistance_:function(e,t,n,o,A=yt.SUM_BY_NONZERO_WEIGHTS){const i=(0,m._1)(e,"labels","cosineDistance"),r=(0,m._1)(t,"predictions","cosineDistance");let s=null;null!=o&&(s=(0,m._1)(o,"weights","cosineDistance")),(0,p.k5)(i.shape,r.shape,"Error in cosineDistance: ");const a=(0,fe.i)(1),l=(0,re.l)(a,(0,Me.S)((0,ae.d)(i,r),n,!0));return bt(l,s,A)}}),(0,u.op)({hingeLoss_:function(e,t,n,o=yt.SUM_BY_NONZERO_WEIGHTS){let A=(0,m._1)(e,"labels","hingeLoss");const i=(0,m._1)(t,"predictions","hingeLoss");let r=null;null!=n&&(r=(0,m._1)(n,"weights","hingeLoss")),(0,p.k5)(A.shape,i.shape,"Error in hingeLoss: ");const s=(0,fe.i)(1);A=(0,re.l)((0,ae.d)((0,fe.i)(2),A),s);const a=(0,ke.U)((0,re.l)(s,(0,ae.d)(A,i)));return bt(a,r,o)}}),(0,u.op)({huberLoss_:function(e,t,n,i=1,r=yt.SUM_BY_NONZERO_WEIGHTS){const s=(0,m._1)(e,"labels","huberLoss"),a=(0,m._1)(t,"predictions","huberLoss");let l=null;null!=n&&(l=(0,m._1)(n,"weights","huberLoss")),(0,p.k5)(s.shape,a.shape,"Error in huberLoss: ");const h=(0,fe.i)(i),u=(0,o.W)((0,re.l)(a,s)),c=(0,oe.L)(u,h),d=(0,re.l)(u,c),I=(0,A.I)((0,ae.d)((0,fe.i)(.5),(0,ie.h)(c)),(0,ae.d)(h,d));return bt(I,l,r)}}),(0,u.op)({logLoss_:function(e,t,n,o=1e-7,i=yt.SUM_BY_NONZERO_WEIGHTS){const r=(0,m._1)(e,"labels","logLoss"),s=(0,m._1)(t,"predictions","logLoss");let a=null;null!=n&&(a=(0,m._1)(n,"weights","logLoss")),(0,p.k5)(r.shape,s.shape,"Error in logLoss: ");const l=(0,fe.i)(1),h=(0,fe.i)(o),u=(0,le.W)((0,ae.d)(r,(0,_.c)((0,A.I)(s,h)))),c=(0,ae.d)((0,re.l)(l,r),(0,_.c)((0,A.I)((0,re.l)(l,s),h))),d=(0,re.l)(u,c);return bt(d,a,i)}});var qt=n(5265);(0,u.op)({meanSquaredError_:function(e,t,n,o=yt.SUM_BY_NONZERO_WEIGHTS){const A=(0,m._1)(e,"labels","meanSquaredError"),i=(0,m._1)(t,"predictions","meanSquaredError");let r=null;null!=n&&(r=(0,m._1)(n,"weights","meanSquaredError")),(0,p.k5)(A.shape,i.shape,"Error in meanSquaredError: ");const s=(0,qt.$)(A,i);return bt(s,r,o)}}),(0,u.op)({sigmoidCrossEntropy_:function(e,t,n,i=0,r=yt.SUM_BY_NONZERO_WEIGHTS){let s=(0,m._1)(e,"multiClassLabels","sigmoidCrossEntropy");const a=(0,m._1)(t,"logits","sigmoidCrossEntropy");let l=null;if(null!=n&&(l=(0,m._1)(n,"weights","sigmoidCrossEntropy")),(0,p.k5)(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),i>0){const e=(0,fe.i)(i),t=(0,fe.i)(1),n=(0,fe.i)(.5);s=(0,A.I)((0,ae.d)(s,(0,re.l)(t,e)),(0,ae.d)(n,e))}const h=function(e,t){const n=(0,m._1)(e,"labels","sigmoidCrossEntropyWithLogits"),i=(0,m._1)(t,"logits","sigmoidCrossEntropyWithLogits");(0,p.k5)(n.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=(0,ke.U)(i),s=(0,ae.d)(i,n),a=(0,z.K)((0,M.Q)((0,le.W)((0,o.W)(i))));return(0,A.I)((0,re.l)(r,s),a)}(s,a);return bt(h,l,r)}});var xt=n(633),Bt=n(1391);(0,u.op)({softmaxCrossEntropy_:function(e,t,n,o=0,i=yt.SUM_BY_NONZERO_WEIGHTS){let r=(0,m._1)(e,"onehotLabels","softmaxCrossEntropy");const s=(0,m._1)(t,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=(0,m._1)(n,"weights","softmaxCrossEntropy")),(0,p.k5)(r.shape,s.shape,"Error in softmaxCrossEntropy: "),o>0){const e=(0,fe.i)(o),t=(0,fe.i)(1),n=(0,fe.i)(r.shape[1]);r=(0,A.I)((0,ae.d)(r,(0,re.l)(t,e)),(0,x.h)(e,n))}const l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const o=(0,xt.cb)(((e,t,o)=>{const A=(0,Bt.l)(t,[n],!0),i=(0,re.l)((0,E.p)(t,"float32"),A);o([e,i]);const r=(0,le.W)((0,ae.d)(i,e));return{value:(0,Me.S)(r,[n]),gradFunc:(e,t)=>{const[o,A]=t,i=(0,Ae.rv)(e.shape,[n]);return[(0,ae.d)((0,S.X)(e,i),(0,re.l)((0,E.p)(o,"float32"),(0,M.Q)(A))),(0,ae.d)((0,S.X)(e,i),(0,re.l)((0,M.Q)(A),(0,E.p)(o,"float32")))]}}}));return o(e,t)}(r,s);return bt(l,a,i)}});const wt=(0,u.op)({sparseFillEmptyRows_:function(e,t,n,o){const A=(0,m._1)(e,"indices","sparseFillEmptyRows"),i=(0,m._1)(t,"values","sparseFillEmptyRows"),r=(0,m._1)(n,"denseShape","sparseFillEmptyRows"),s=(0,m._1)(o,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==A.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${A.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==r.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Default value should be a scalar but received shape ${s.shape}`);const a={indices:A,values:i,denseShape:r,defaultValue:s},l=Ue.BV.runKernel(rt.O3,a);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),Mt=(0,u.op)({sparseReshape_:function(e,t,n){const o=(0,m._1)(e,"inputIndices","sparseReshape"),A=(0,m._1)(t,"inputShape","sparseReshape"),i=(0,m._1)(n,"newShape","sparseReshape");if(2!==o.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${o.shape}`);if(1!==A.rank)throw new Error(`Input shape should be Tensor1D but received shape ${A.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const r={inputIndices:o,inputShape:A,newShape:i},s=Ue.BV.runKernel(rt.nh,r);return{outputIndices:s[0],outputShape:s[1]}}}),Lt=(0,u.op)({sparseSegmentMean_:function(e,t,n){const o=(0,m._1)(e,"data","sparseSegmentMean"),A=(0,m._1)(t,"indices","sparseSegmentMean"),i=(0,m._1)(n,"segmentIds","sparseSegmentMean");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==A.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${A.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);const r={data:o,indices:A,segmentIds:i};return Ue.BV.runKernel(rt.YW,r)}}),St=(0,u.op)({sparseSegmentSum_:function(e,t,n){const o=(0,m._1)(e,"data","sparseSegmentSum"),A=(0,m._1)(t,"indices","sparseSegmentSum"),i=(0,m._1)(n,"segmentIds","sparseSegmentSum");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==A.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${A.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);const r={data:o,indices:A,segmentIds:i};return Ue.BV.runKernel(rt.Zj,r)}}),Tt=(0,u.op)({stringNGrams_:function(e,t,n,o,A,i,r,s){const a=(0,m._1)(e,"data","stringNGrams","string");if("string"!==a.dtype)throw new Error("Data must be of datatype string");if(1!==a.shape.length)throw new Error(`Data must be a vector, saw: ${a.shape}`);const l=(0,m._1)(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const p={separator:n,nGramWidths:o,leftPad:A,rightPad:i,padWidth:r,preserveShortSequences:s},h={data:a,dataSplits:l},u=Ue.BV.runKernel(rt._J,h,p);return{nGrams:u[0],nGramsSplits:u[1]}}}),Nt=(0,u.op)({stringSplit_:function(e,t,n=!0){const o=(0,m._1)(e,"input","stringSplit","string"),A=(0,m._1)(t,"delimiter","stringSplit","string");if(1!==o.rank)throw new Error(`Input should be Tensor1D but received shape ${o.shape}`);if(0!==A.rank)throw new Error(`Delimiter should be a scalar but received shape ${A.shape}`);const i={skipEmpty:n},r={input:o,delimiter:A},s=Ue.BV.runKernel(rt.s1,r,i);return{indices:s[0],values:s[1],shape:s[2]}}}),Rt=(0,u.op)({stringToHashBucketFast_:function(e,t){const n=(0,m._1)(e,"input","stringToHashBucketFast","string"),o={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const A={input:n};return Ue.BV.runKernel(rt.Xk,A,o)}}),Ot=($e.k,et.S,Ye.Q,tt.w,{flipLeftRight:at,grayscaleToRGB:lt,resizeNearestNeighbor:Gt.j,resizeBilinear:It.I,rotateWithOffset:mt,cropAndResize:st,nonMaxSuppression:ht,nonMaxSuppressionAsync:async function(e,t,n,o=.5,A=Number.NEGATIVE_INFINITY){const i=(0,m._1)(e,"boxes","nonMaxSuppressionAsync"),r=(0,m._1)(t,"scores","nonMaxSuppressionAsync"),s=pt(i,r,n,o,A);n=s.maxOutputSize,o=s.iouThreshold,A=s.scoreThreshold;const a=await Promise.all([i.data(),r.data()]),l=a[0],p=a[1],{selectedIndices:h}=(0,ut.GP)(l,p,n,o,A);return i!==e&&i.dispose(),r!==t&&r.dispose(),(0,Te.R)(h,"int32")},nonMaxSuppressionWithScore:ct,nonMaxSuppressionWithScoreAsync:async function(e,t,n,o=.5,A=Number.NEGATIVE_INFINITY,i=0){const r=(0,m._1)(e,"boxes","nonMaxSuppressionAsync"),s=(0,m._1)(t,"scores","nonMaxSuppressionAsync"),a=pt(r,s,n,o,A,i);n=a.maxOutputSize,o=a.iouThreshold,A=a.scoreThreshold,i=a.softNmsSigma;const l=await Promise.all([r.data(),s.data()]),p=l[0],h=l[1],{selectedIndices:u,selectedScores:c}=(0,ut.pA)(p,h,n,o,A,i);return r!==e&&r.dispose(),s!==t&&s.dispose(),{selectedIndices:(0,Te.R)(u,"int32"),selectedScores:(0,Te.R)(c)}},nonMaxSuppressionPadded:dt,nonMaxSuppressionPaddedAsync:async function(e,t,n,o=.5,A=Number.NEGATIVE_INFINITY,i=!1){const r=(0,m._1)(e,"boxes","nonMaxSuppressionAsync"),s=(0,m._1)(t,"scores","nonMaxSuppressionAsync"),a=pt(r,s,n,o,A,null),l=a.maxOutputSize,p=a.iouThreshold,h=a.scoreThreshold,[u,c]=await Promise.all([r.data(),s.data()]),{selectedIndices:d,validOutputs:I}=(0,ut.qP)(u,c,l,p,h,i);return r!==e&&r.dispose(),s!==t&&s.dispose(),{selectedIndices:(0,Te.R)(d,"int32"),validOutputs:(0,fe.i)(I,"int32")}},threshold:Ht,transform:Ft}),Pt={bandPart:Ct,gramSchmidt:Jt,qr:Kt},Ut={sparseFillEmptyRows:wt,sparseReshape:Mt,sparseSegmentMean:Lt,sparseSegmentSum:St},Vt={stringNGrams:Tt,stringSplit:Nt,stringToHashBucketFast:Rt}},9682:(e,t,n)=>{"use strict";n.d(t,{v:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({pad_:function(e,t,n=0){const r=(0,i._1)(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return o.BV.runKernel(A.ly,a,s)}})},3453:(e,t,n)=>{"use strict";n.d(t,{s:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({pow_:function(e,t){let n=(0,r._1)(e,"base","pow"),s=(0,r._1)(t,"exp","pow");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.pe,a)}})},8151:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({prelu_:function(e,t){const n={x:(0,i._1)(e,"x","prelu"),alpha:(0,i._1)(t,"alpha","prelu")};return o.BV.runKernel(A.o0,n)}})},9451:(e,t,n)=>{"use strict";n.d(t,{W:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(2271);const s=(0,n(2668).op)({prod_:function(e,t=null,n=!1){let s=(0,i._1)(e,"x","prod");"bool"===s.dtype&&(s=(0,r.p)(s,"int32"));const a={x:s},l={axis:t,keepDims:n};return o.BV.runKernel(A.Dl,a,l)}})},6845:(e,t,n)=>{"use strict";n.d(t,{Yi:()=>A,wv:()=>i});var o=n(6377);class A{constructor(e,t,n,A,i){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=A,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const r=i||Math.random();this.random=o.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let o,A,i;do{o=2*this.random()-1,A=2*this.random()-1,i=o*o+A*A}while(i>=1||0===i);const r=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*r,t=this.mean+this.stdDev*A*r,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class i{constructor(e=0,t=1,n,A){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==A&&(A=Math.random()),"number"==typeof A&&(A=A.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=o.alea(A)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},5002:(e,t,n)=>{"use strict";n.d(t,{L:()=>r});var o=n(2657),A=n(2668),i=n(6845);const r=(0,A.op)({randomUniform_:function(e,t=0,n=1,A="float32",r){const s=(0,o.f)(e,A),a=new i.wv(t,n,null,r);for(let e=0;e<s.values.length;e++)s.values[e]=a.nextValue();return s.toTensor()}})},7245:(e,t,n)=>{"use strict";n.d(t,{w:()=>i});var o=n(7097),A=n(9121);function i(e,t,n=1,i="float32"){if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:i};return o.BV.runKernel(A.e6,{},r)}},766:(e,t,n)=>{"use strict";n.d(t,{k:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({real_:function(e){const t={input:(0,i._1)(e,"input","real")};return o.BV.runKernel(A.xJ,t)}})},9036:(e,t,n)=>{"use strict";n.d(t,{M:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({reciprocal_:function(e){const t={x:(0,i._1)(e,"x","reciprocal")};return o.BV.runKernel(A.$H,t)}})},7409:(e,t,n)=>{"use strict";n.d(t,{U:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({relu_:function(e){const t={x:(0,i._1)(e,"x","relu")};return o.BV.runKernel(A.qk,t)}})},3582:(e,t,n)=>{"use strict";n.d(t,{b:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({relu6_:function(e){const t={x:(0,i._1)(e,"x","relu6")};return o.BV.runKernel(A.Sb,t)}})},4968:(e,t,n)=>{"use strict";n.d(t,{X:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({reshape_:function(e,t){const n={x:(0,i._1)(e,"x","reshape","string_or_numeric")},r={shape:t};return o.BV.runKernel(A.HZ,n,r)}})},7486:(e,t,n)=>{"use strict";n.d(t,{G:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({reverse_:function(e,t){const n={x:(0,i._1)(e,"x","reverse")},r={dims:t};return o.BV.runKernel(A.mK,n,r)}})},7809:(e,t,n)=>{"use strict";n.d(t,{N:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({round_:function(e){const t={x:(0,i._1)(e,"x","round")};return o.BV.runKernel(A.e0,t)}})},2634:(e,t,n)=>{"use strict";n.d(t,{b:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({rsqrt_:function(e){const t={x:(0,i._1)(e,"x","rsqrt","float32")};return o.BV.runKernel(A.bV,t)}})},9494:(e,t,n)=>{"use strict";n.d(t,{i:()=>i});var o=n(569),A=n(7852);function i(e,t){if(((0,o.fU)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,o.fU)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,A.H)(e,[],[],t)}},3028:(e,t,n)=>{"use strict";n.d(t,{l5:()=>A,b0:()=>i,SU:()=>r});var o=n(569);function A(e,t,n){const o=t.rank>1?t.shape[t.rank-1]:1,A=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${o}, and batchDim: ${A}.`;if(n.rank<A)throw new Error(i+` update.rank < ${A}. `);if(e.length<o+(n.rank-A))throw new Error(i+` Output shape length < ${o+(n.rank-A)}`);if(n.rank!==A+e.length-o)throw new Error(i+" update.rank != "+(A+e.length-o));for(let e=0;e<A;++e)if(n.shape[e]!==t.shape[e])throw new Error(i+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-A;++t)if(n.shape[t+A]!==e[t+o])throw new Error(i+` updates.shape[${t+A}] (${n.shape[t+A]}) != shape[${t+A}] (${e[t+A]})`)}function i(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}A(n,t,e)}function r(e,t,n){const A=t.shape.length,i=A>1?t.shape[A-1]:1,r=n.length;let s=1;for(let e=i;e<r;++e)s*=n[e];const a=i<1?1:i;return{sliceRank:i,numUpdates:(0,o.NA)(t.shape)/a,sliceSize:s,strides:[...(0,o.e3)(n.slice(0,i)),1],outputSize:(0,o.NA)(n)}}},5503:(e,t,n)=>{"use strict";n.d(t,{U:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({selu_:function(e){const t={x:(0,i._1)(e,"x","selu")};return o.BV.runKernel(A.oF,t)}})},3179:(e,t,n)=>{"use strict";n.d(t,{y:()=>o,$:()=>A});const o=1.7580993408473768,A=1.0507009873554805},8678:(e,t,n)=>{"use strict";n.d(t,{U:()=>l});var o=n(3740),A=n(569),i=n(4794),r=n(4718),s=n(2668),a=n(4968);const l=(0,s.op)({separableConv2d_:function(e,t,n,s,l,m=[1,1],p="NHWC"){const h=(0,o._1)(e,"x","separableConv2d"),u=(0,o._1)(t,"depthwiseFilter","separableConv2d"),c=(0,o._1)(n,"pointwiseFilter","separableConv2d");let d=h,I=!1;if(3===h.rank&&(I=!0,d=(0,a.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===p)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A.hu(4===d.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`)),A.hu(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),A.hu(4===c.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),A.hu(1===c.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`)),A.hu(1===c.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`));const G=u.shape[2],E=u.shape[3];A.hu(c.shape[2]===G*E,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${G*E}, but got ${c.shape[2]}.`));const k=(0,r.B)(d,u,s,l,p,m),g=(0,i.T)(k,c,1,"valid",p);return I?(0,a.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},625:(e,t,n)=>{"use strict";n.d(t,{X:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({sigmoid_:function(e){const t={x:(0,i._1)(e,"x","sigmoid","float32")};return o.BV.runKernel(A.a5,t)}})},4434:(e,t,n)=>{"use strict";n.d(t,{X:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({sign_:function(e){const t={x:(0,i._1)(e,"x","sign")};return o.BV.runKernel(A.i5,t)}})},9331:(e,t,n)=>{"use strict";n.d(t,{O:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({sin_:function(e){const t={x:(0,i._1)(e,"x","sin","float32")};return o.BV.runKernel(A.RQ,t)}})},3254:(e,t,n)=>{"use strict";n.d(t,{R:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({sinh_:function(e){const t={x:(0,i._1)(e,"x","sinh")};return o.BV.runKernel(A.w3,t)}})},2676:(e,t,n)=>{"use strict";n.d(t,{t:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({slice_:function(e,t,n){const r=(0,i._1)(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return o.BV.runKernel(A.p2,s,a)}})},7650:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertParamsValid:()=>A,maskToAxes:()=>i,computeOutShape:()=>r,stridesWithElidedDims:()=>s,getNormalizedAxes:()=>m,startIndicesWithElidedDims:()=>p,stopIndicesWithElidedDims:()=>h,stridesForAxis:()=>u,startForAxis:()=>c,stopForAxis:()=>d,isSliceContinous:()=>I,computeFlatOffset:()=>G,parseSliceParams:()=>E,sliceInfo:()=>k});var o=n(569);function A(e,t,n){const A=e.shape.length;o.hu(A===t.length,(()=>`Error in slice${A}D: Length of begin ${t} must match the rank of the array (${A}).`)),o.hu(A===n.length,(()=>`Error in slice${A}D: Length of size ${n} must match the rank of the array (${A}).`));for(let i=0;i<A;++i)o.hu(t[i]+n[i]<=e.shape[i],(()=>`Error in slice${A}D: begin[${i}] + size[${i}] (${t[i]+n[i]}) would overflow input.shape[${i}] (${e.shape[i]})`))}function i(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function r(e,t,n){const o=[];for(let A=0;A<e.length;A++)o[A]=Math.ceil((t[A]-e[A])/n[A]);return o}function s(e,t,n,o){const A=[...e];for(let e=A.length;e<o.length;e++)A.push(1);for(let e=0;e<n;e++)0===e?A[t]=1:(A.splice(t,0,1),A.pop());return A}function a(e,t,n){return n<=e?n:n-(t-1)}function l(e,t){const n=[];for(let o=0;o<e;o++)n.push(t+o);return n}function m(e,t,n,o,A,i,r,a,l){const m=e.length;let I=new Array(m),G=new Array(m),E=new Array(m);if(t.length&&n>0){const l=t[0],m=n+1;I=p(r,l,m,o,e),G=h(a,l,m,A,e),E=s(i,l,m,e)}else for(let t=0;t<m;t++)I[t]=c(r,o,i,e,t,l),G[t]=d(a,A,i,e,t,l),E[t]=u(i,t,l);return{begin:I,end:G,strides:E}}function p(e,t,n,o,A){const i=[...A],r=l(n,t);for(let A=0;A<i.length;A++)if(r.indexOf(A)>-1)i[A]=0;else{const r=a(t,n,A);let s=o[r];e&1<<r&&(s=0),i[A]=s}return i}function h(e,t,n,A,i){const r=[...i],s=l(n,t);for(let o=0;o<r.length;o++)if(s.indexOf(o)>-1)r[o]=Number.MAX_SAFE_INTEGER;else{const i=a(t,n,o);let s=A[i];e&1<<i&&(s=Number.MAX_SAFE_INTEGER),r[o]=s}for(let e=0;e<r.length;e++){const t=i[e];r[e]<0&&(r[e]+=t),r[e]=o.uZ(0,r[e],i[e])}return r}function u(e,t,n){let o=e[t];return(n&1<<t||null==o)&&(o=1),o}function c(e,t,n,A,i,r){let s=t[i];const a=n[i]||1;(e&1<<i||r&1<<i||null==s)&&(s=a>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=A[i];return s<0&&(s+=l),s=o.uZ(0,s,l-1),s}function d(e,t,n,A,i,r){let s=t[i];const a=n[i]||1;(e&1<<i||r&1<<i||null==s)&&(s=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=A[i];return s<0&&(s+=l),s=a>0?o.uZ(0,s,l):o.uZ(-1,s,l-1),s}function I(e,t,n){let o=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){o=e;break}for(let A=o+1;A<n.length;A++)if(t[A]>0||n[A]!==e[A])return!1;return!0}function G(e,t){let n=e.length>0?e[e.length-1]:1;for(let o=0;o<e.length-1;o++)n+=e[o]*t[o];return n}function E(e,t,n){let A;const i=e.shape.length;let r;return A="number"==typeof t?[t,...new Array(i-1).fill(0)]:t.length<i?t.concat(new Array(i-t.length).fill(0)):t.slice(),A.forEach((e=>{o.hu(-1!==e,(()=>"slice() does not support negative begin indexing."))})),r=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,r=r.map(((t,n)=>t>=0?t:(o.hu(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-A[n]))),[A,r]}function k(e,t,n,o,A,i,r,s,a){let l;if(null==o?(l=new Array(t.length),l.fill(1)):l=o,null!=r&&0!=(r&r-1))throw new Error("Multiple ellipses in slice is not allowed.");let m=!1;const p={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:A,endMask:i,ellipsisMask:r,newAxisMask:s,shrinkAxisMask:a};for(let e=0;e<p.dims;e++)m&&0!=(1<<e&s)&&p.numAddAxisAfterEllipsis++,1<<e&r&&(m=!0);m||(p.ellipsisMask|=1<<p.dims,p.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let o=0;o<e.dims;o++)if(1<<o&e.ellipsisMask){const A=Math.min(t.dims-(e.dims-o)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<A;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=o}else if(1<<o&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[o]),null!=e.end&&(t.end[n]=e.end[o]),t.strides[n]=e.strides[o],e.beginMask&1<<o&&(t.beginMask|=1<<n),e.endMask&1<<o&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<o?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(o)),t.inputShapeGatherIndicesSparse[n]=o,n++}}(p,h);let u=!0,c=!0,d=!0;const I=[],G=[];for(let t=0;t<e.length;++t){if(0===h.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(h.shrinkAxisMask&1<<t),o=e[t];if(-1===o){I.push(n?1:-1);continue}const A=[h.beginMask&1<<t,h.endMask&1<<t],i=[h.strides[t]>0?0:-1,h.strides[t]>0?o:o-1];if(n&&h.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");d=d&&1===h.strides[t];const r=!!(h.beginMask&1<<t&&h.endMask&1<<t);if(h.beginValid&&h.endValid){if(n){const e=h.begin[t]<0?o+h.begin[t]:h.begin[t];if(h.begin[t]=e,h.end[t]=h.begin[t]+1,e<0||e>=o)throw Error(`slice index ${h.begin[t]} of dimension ${t} out of bounds.`)}else h.begin[t]=g(h.begin[t],0,h.strides[t],o,A,i),h.end[t]=g(h.end[t],1,h.strides[t],o,A,i);const e=1===h.strides[t]&&0===h.begin[t]&&h.end[t]===o;u=u&&e,c=c&&(0===t&&1===h.strides[t]||e)}else u=u&&1===h.strides[t]&&r,c=c&&(0===t&&1===h.strides[t]||r);let s,a=!1;if(h.beginValid&&h.endValid?(s=h.end[t]-h.begin[t],a=!0):n?(s=1,a=!0):r&&o>=0&&(s=h.strides[t]<0?-o:o,a=!0),a){let e;e=0===s||s<0!=h.strides[t]<0?0:Math.trunc(s/h.strides[t])+(s%h.strides[t]!=0?1:0),I.push(e)}else I.push(-1)}for(let e=0;e<h.finalShapeGatherIndices.length;++e){const t=h.finalShapeGatherIndices[e];t>=0?G.push(I[t]):-2===t&&G.push(1)}return{finalShapeSparse:G.filter(((e,t)=>-2!==h.finalShapeGatherIndices[t])),finalShape:G,isIdentity:u,sliceDim0:c,isSimpleSlice:d,begin:h.begin,end:h.end,strides:h.strides}}function g(e,t,n,o,A,i){if(A[t])return n>0?i[t]:i[t+1&1];{const t=e<0?o+e:e;return t<i[0]?i[0]:t>i[1]?i[1]:t}}},682:(e,t,n)=>{"use strict";n.d(t,{X:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({softmax_:function(e,t=-1){const n=(0,i._1)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return o.BV.runKernel(A.Gc,r,s)}})},3694:(e,t,n)=>{"use strict";n.d(t,{W:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({softplus_:function(e){const t={x:(0,i._1)(e,"x","softplus")};return o.BV.runKernel(A.MR,t)}})},7918:(e,t,n)=>{"use strict";n.d(t,{f:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({spaceToBatchND_:function(e,t,n){const s=(0,i._1)(e,"x","spaceToBatchND");r.hu(s.rank>=1+t.length,(()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`)),r.hu(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),r.hu(s.shape.reduce(((e,o,A)=>A>0&&A<=t.length?e&&(o+n[A-1][0]+n[A-1][1])%t[A-1]==0:e),!0),(()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const a={x:s},l={blockShape:t,paddings:n};return o.BV.runKernel(A.TQ,a,l)}})},7020:(e,t,n)=>{"use strict";n.d(t,{k:()=>r});var o=n(7097),A=n(9121),i=n(569);const r=(0,n(2668).op)({fft_:function(e){(0,i.hu)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return o.BV.runKernel(A.vw,t)}})},8447:(e,t,n)=>{"use strict";n.d(t,{S:()=>r});var o=n(7097),A=n(9121),i=n(569);const r=(0,n(2668).op)({ifft_:function(e){(0,i.hu)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return o.BV.runKernel(A.Qg,t)}})},4415:(e,t,n)=>{"use strict";n.d(t,{w:()=>c});var o=n(1661),A=n(6884),i=n(4386),r=n(4841),s=n(2668),a=n(766),l=n(4968),m=n(7486),p=n(9494),h=n(2676),u=n(8447);const c=(0,s.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const o=(0,l.X)(e,[n,t]);s=(0,u.S)(o)}else{const c=[n,2*(t-1)],d=(0,l.X)((0,a.k)(e),[n,t]),I=(0,l.X)((0,i.a)(e),[n,t]),G=(0,m.G)((0,h.t)(d,[0,1],[n,t-2]),1),E=(0,r.d)((0,m.G)((0,h.t)(I,[0,1],[n,t-2]),1),(0,p.i)(-1)),k=(0,A.z)([d,G],1),g=(0,A.z)([I,E],1),f=(0,l.X)((0,o.P)(k,g),[c[0],c[1]]);s=(0,u.S)(f)}if(s=(0,a.k)(s),3===e.rank&&0!==e.shape[0]){const t=s,n=e.shape[0];s=(0,l.X)(s,[n,s.shape[0]/n,s.shape[1]]),t.dispose()}return s}})},3710:(e,t,n)=>{"use strict";n.d(t,{Q:()=>d});var o=n(569),A=n(1661),i=n(6884),r=n(4386),s=n(2668),a=n(766),l=n(4968),m=n(2676),p=n(8644),h=n(9640),u=n(6577),c=n(7020);const d=(0,s.op)({rfft_:function(e,t){(0,o.hu)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const s=e.size/n;let d;if(null!=t&&t<n){const o=e.shape.map((e=>0)),A=e.shape.map((e=>e));A[e.shape.length-1]=t,d=(0,m.t)(e,o,A),n=t}else if(null!=t&&t>n){const o=e.shape.map((e=>e));o[e.shape.length-1]=t-n,d=(0,i.z)([e,(0,h.l)(o)],e.shape.length-1),n=t}else d=e;const I=(0,u.P)(d),G=(0,l.X)((0,A.P)(d,I),[s,n]),E=(0,c.k)(G),k=Math.floor(n/2)+1,g=(0,a.k)(E),f=(0,r.a)(E),H=(0,p.V)(g,[k,n-k],g.shape.length-1),F=(0,p.V)(f,[k,n-k],f.shape.length-1),C=d.shape.slice();return C[d.shape.length-1]=k,(0,l.X)((0,A.P)(H[0],F[0]),C)}})},8644:(e,t,n)=>{"use strict";n.d(t,{V:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({split_:function(e,t,n=0){const r={x:(0,i._1)(e,"x","split")},s={numOrSizeSplits:t,axis:n};return o.BV.runKernel(A.L8,r,s)}})},3261:(e,t,n)=>{"use strict";n.d(t,{_:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({sqrt_:function(e){const t={x:(0,i._1)(e,"x","sqrt","float32")};return o.BV.runKernel(A.FK,t)}})},248:(e,t,n)=>{"use strict";n.d(t,{h:()=>i});var o=n(7097),A=n(3740);const i=(0,n(2668).op)({square_:function(e){const t=(0,A._1)(e,"x","square");return o.BV.runKernel("Square",{x:t},{})}})},5265:(e,t,n)=>{"use strict";n.d(t,{$:()=>a});var o=n(7097),A=n(9121),i=n(747),r=n(3740),s=n(2200);const a=(0,n(2668).op)({squaredDifference_:function(e,t){let n=(0,r._1)(e,"a","squaredDifference"),a=(0,r._1)(t,"b","squaredDifference");[n,a]=(0,i.makeTypesMatch)(n,a),(0,s.$N)(n.shape,a.shape);const l={a:n,b:a};return o.BV.runKernel(A._t,l,{})}})},9590:(e,t,n)=>{"use strict";n.d(t,{L:()=>s});var o=n(3740),A=n(569),i=n(2668),r=n(4968);const s=(0,i.op)({squeeze_:function(e,t){const n=(0,o._1)(e,"x","squeeze");return(0,r.X)(n,(0,A.bp)(n.shape,t).newShape)}})},2991:(e,t,n)=>{"use strict";n.d(t,{k:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({stack_:function(e,t=0){const n=(0,i.sI)(e,"tensors","stack","string_or_numeric");r.hu(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&r.hu(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const s=n,a={axis:t};return o.BV.runKernel(A.Qi,s,a)}})},1901:(e,t,n)=>{"use strict";n.d(t,{N:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({step_:function(e,t=0){const n={x:(0,i._1)(e,"x","step")},r={alpha:t};return o.BV.runKernel(A.h8,n,r)}})},5158:(e,t,n)=>{"use strict";n.d(t,{N:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({stridedSlice_:function(e,t,n,r,s=0,a=0,l=0,m=0,p=0){const h={x:(0,i._1)(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:p};return o.BV.runKernel(A.m2,h,u)}})},827:(e,t,n)=>{"use strict";n.d(t,{l:()=>s});var o=n(7097),A=n(9121),i=n(747),r=n(3740);const s=(0,n(2668).op)({sub_:function(e,t){let n=(0,r._1)(e,"a","sub"),s=(0,r._1)(t,"b","sub");[n,s]=(0,i.makeTypesMatch)(n,s);const a={a:n,b:s};return o.BV.runKernel(A.Tr,a)}})},5475:(e,t,n)=>{"use strict";n.d(t,{S:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(2271);const s=(0,n(2668).op)({sum_:function(e,t=null,n=!1){let s=(0,i._1)(e,"x","sum");"bool"===s.dtype&&(s=(0,r.p)(s,"int32"));const a={x:s},l={axis:t,keepDims:n};return o.BV.runKernel(A.GB,a,l)}})},1173:(e,t,n)=>{"use strict";n.d(t,{O:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({tan_:function(e){const t={x:(0,i._1)(e,"x","tan","float32")};return o.BV.runKernel(A.sE,t)}})},1869:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({tanh_:function(e){const t={x:(0,i._1)(e,"x","tanh","float32")};return o.BV.runKernel(A.MI,t)}})},701:(e,t,n)=>{"use strict";n.d(t,{X:()=>i});var o=n(3740),A=n(7852);function i(e,t,n){const i=(0,o.C)(e,n);return(0,A.H)(e,t,i,n)}},6092:(e,t,n)=>{"use strict";n.d(t,{R:()=>r});var o=n(3740),A=n(569),i=n(7852);function r(e,t){(0,A.Cq)(e);const n=(0,o.C)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,i.H)(e,null,n,t)}},7852:(e,t,n)=>{"use strict";n.d(t,{H:()=>r});var o=n(7097),A=n(569),i=n(9122);function r(e,t,n,r){if(null==r&&(r=(0,A.D2)(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,A.fU)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,A.Mu)(t);const e=(0,A.NA)(t),o=(0,A.NA)(n);(0,A.hu)(e===o,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${o}`));for(let e=0;e<n.length;++e){const o=n[e],i=e!==n.length-1||o!==(0,A.NA)(t.slice(e));(0,A.hu)(n[e]===t[e]||!i,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,A.fU)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?(0,i.toTypedArray)(e,r):(0,A.xH)(e,[],!0),o.BV.makeTensor(e,t,r)}},7501:(e,t,n)=>{"use strict";n.d(t,{G:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({tile_:function(e,t){const n=(0,i._1)(e,"x","tile","string_or_numeric");r.hu(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const s={x:n},a={reps:t};return o.BV.runKernel(A.n9,s,a)}})},3243:(e,t,n)=>{"use strict";n.d(t,{h:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({topk_:function(e,t=1,n=!0){const r=(0,i._1)(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},l={k:t,sorted:n},[m,p]=o.BV.runKernel(A.cW,a,l);return{values:m,indices:p}}})},9065:(e,t,n)=>{"use strict";n.d(t,{p:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({transpose_:function(e,t){const n=(0,i._1)(e,"x","transpose");if(null==t&&(t=n.shape.map(((e,t)=>t)).reverse()),r.hu(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`)),t.forEach((e=>{r.hu(e>=0&&e<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`))})),n.rank<=1)return n.clone();const s={x:n},a={perm:t};return o.BV.runKernel(A.G3,s,a)}})},3596:(e,t,n)=>{"use strict";n.d(t,{X:()=>r});var o=n(2657),A=n(2668),i=n(6845);const r=(0,A.op)({truncatedNormal_:function(e,t=0,n=1,A,r){if(null!=A&&"bool"===A)throw new Error("Unsupported data type $ { dtype }");const s=new i.Yi(t,n,A,!0,r),a=(0,o.f)(e,A);for(let e=0;e<a.values.length;e++)a.values[e]=s.nextValue();return a.toTensor()}})},9608:(e,t,n)=>{"use strict";n.d(t,{T:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({unique_:function(e,t=0){const n=(0,i._1)(e,"x","unique","string_or_numeric");(0,r.hu)(n.rank>0,(()=>"The input tensor must be at least 1D"));const s={x:n},a={axis:t},[l,m]=o.BV.runKernel(A.kp,s,a);return{values:l,indices:m}}})},4136:(e,t,n)=>{"use strict";n.d(t,{H:()=>s});var o=n(7097),A=n(9121),i=n(3740),r=n(569);const s=(0,n(2668).op)({unstack_:function(e,t=0){const n=(0,i._1)(e,"x","unstack","string_or_numeric");r.hu(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const s={value:n},a={axis:t};return o.BV.runKernel(A.To,s,a)}})},5912:(e,t,n)=>{"use strict";n.d(t,{a:()=>a});var o=n(7097),A=n(9121),i=n(3740),r=n(8247),s=n(2200);const a=(0,n(2668).op)({where_:function(e,t,n){const a=(0,i._1)(t,"a","where"),l=(0,i._1)(n,"b","where"),m=(0,i._1)(e,"condition","where","bool"),p=(0,s.$N)((0,s.$N)(m.shape,a.shape),l.shape),h={condition:(0,r.U)(m,p),t:(0,r.U)(a,p),e:(0,r.U)(l,p)};return o.BV.runKernel(A.Ph,h)}})},9640:(e,t,n)=>{"use strict";n.d(t,{l:()=>r});var o=n(7097),A=n(569),i=n(1661);function r(e,t="float32"){if("complex64"===t){const t=r(e,"float32"),n=r(e,"float32");return(0,i.P)(t,n)}const n=(0,A.wT)((0,A.NA)(e),t);return o.BV.makeTensor(n,e,t)}},6577:(e,t,n)=>{"use strict";n.d(t,{P:()=>r});var o=n(7097),A=n(9121),i=n(3740);const r=(0,n(2668).op)({zerosLike_:function(e){const t={x:(0,i._1)(e,"x","zerosLike")};return o.BV.runKernel(A.Ru,t)}})},4077:(e,t,n)=>{"use strict";n.d(t,{es:()=>E,YD:()=>p,_w:()=>g,t3:()=>k,FZ:()=>G,Vp:()=>I,Vi:()=>d});var o=n(5938),A=n(569);function i(e,t,n,o){const i=(0,A.e3)(t),s=function(e,t,n,o){const i=(0,A.NA)(t),s=o[o.length-1],a=new Array(s).fill(0),m=t.length,p="complex64"===n?l(e):e;if(m>1)for(let e=0;e<i/s;e++){const t=e*s;for(let e=0;e<s;e++)a[e]=Math.max(a[e],r(p[t+e],0,n).length)}return a}(e,t,n,i),m=t.length,p=a(e,t,n,i,s),h=["Tensor"];return o&&(h.push(`  dtype: ${n}`),h.push(`  rank: ${m}`),h.push(`  shape: [${t}]`),h.push("  values:")),h.push(p.map((e=>"    "+e)).join("\n")),h.join("\n")}function r(e,t,n){let o;return o=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:(0,A.HD)(e)?`'${e}'`:"bool"===n?s(e):parseFloat(e.toFixed(7)).toString(),(0,A.oj)(o,t)}function s(e){return 0===e?"false":"true"}function a(e,t,n,o,A,i=!0){const m="complex64"===n?2:1,p=t[0],h=t.length;if(0===h)return"complex64"===n?[r(l(e)[0],0,n)]:"bool"===n?[s(e[0])]:[e[0].toString()];if(1===h){if(p>20){const t=3*m;let o=Array.from(e.slice(0,t)),i=Array.from(e.slice((p-3)*m,p*m));return"complex64"===n&&(o=l(o),i=l(i)),["["+o.map(((e,t)=>r(e,A[t],n))).join(", ")+", ..., "+i.map(((e,t)=>r(e,A[p-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?l(e):Array.from(e)).map(((e,t)=>r(e,A[t],n))).join(", ")+"]"]}const u=t.slice(1),c=o.slice(1),d=o[0]*m,I=[];if(p>20){for(let t=0;t<3;t++){const o=t*d,i=o+d;I.push(...a(e.slice(o,i),u,n,c,A,!1))}I.push("...");for(let t=p-3;t<p;t++){const o=t*d,i=o+d;I.push(...a(e.slice(o,i),u,n,c,A,t===p-1))}}else for(let t=0;t<p;t++){const o=t*d,i=o+d;I.push(...a(e.slice(o,i),u,n,c,A,t===p-1))}const G=2===h?",":"";I[0]="["+I[0]+G;for(let e=1;e<I.length-1;e++)I[e]=" "+I[e]+G;let E=",\n";for(let e=2;e<h;e++)E+="\n";return I[I.length-1]=" "+I[I.length-1]+"]"+(i?"":E),I}function l(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var m=n(9122);class p{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=A.NA(e),null!=n){const e=n.length;A.hu(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||A.rQ(t,this.size),this.strides=(0,A.e3)(e)}set(e,...t){0===t.length&&(t=[0]),A.hu(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return h().makeTensor(this.values,this.shape,this.dtype)}}let h=null,u=null,c=null;function d(e){h=e}function I(e){u=e}function G(e){c=e}class E{constructor(e,t,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=A.NA(e),this.strides=(0,A.e3)(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return u.buffer(this.shape,this.dtype,e)}bufferSync(){return u.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,A.GX)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,A.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=h().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>m.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=h().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>m.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await h().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(h().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return u.print(this,e)}clone(){return this.throwIfDisposed(),u.clone(this)}toString(e=!1){return i(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),u.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),h().makeVariable(this,e,t,n)}}function k(){return(0,o.R)("Tensor",(()=>E))}Object.defineProperty(E,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),k();class g extends E{constructor(e,t,n,o){super(e.shape,e.dtype,e.dataId,o),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!A.cO(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);h().disposeTensor(this),this.dataId=e.dataId,h().incRef(this,null)}dispose(){h().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(g,Symbol.hasInstance,{value:e=>e instanceof E&&null!=e.assign&&e.assign instanceof Function})},747:(e,t,n)=>{"use strict";n.r(t),n.d(t,{makeTypesMatch:()=>r,assertTypesMatch:()=>s,isTensorInList:()=>a,getTensorsInContainer:()=>l});var o=n(4077),A=n(1221),i=n(569);function r(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,A.x8)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function s(e,t){(0,i.hu)(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function a(e,t){return t.some((t=>t.id===e.id))}function l(e){const t=[];return m(e,t,new Set),t}function m(e,t,n){if(null==e)return;if(e instanceof o.es)return void t.push(e);if(A=e,!Array.isArray(A)&&"object"!=typeof A)return;var A;const i=e;for(const e in i){const o=i[e];n.has(o)||(n.add(o),m(o,t,n))}}},3740:(e,t,n)=>{"use strict";n.d(t,{C:()=>a,_1:()=>p,sI:()=>h});var o=n(7097),A=n(2885),i=n(4077),r=n(569),s=n(9122);function a(e,t){let n=e;if((0,r.fU)(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const o=[];for(;Array.isArray(n)||(0,r.fU)(n)&&"string"!==t;)o.push(n.length),n=n[0];return Array.isArray(e)&&(0,A.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&l(e,o,[]),o}function l(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,r.fU)(e))return void(0,r.hu)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,r.hu)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,r.hu)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const o=t.slice(1);for(let t=0;t<e.length;++t)l(e[t],o,n.concat(t))}function m(e,t,n,o){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${o}' must be ${e} tensor, but got ${t} tensor`)}}function p(e,t,n,A="numeric"){if(e instanceof i.es)return m(A,e.dtype,t,n),e;let l=(0,r.D2)(e);if("string"!==l&&["bool","int32","float32"].indexOf(A)>=0&&(l=A),m(A,l,t,n),null==e||!(0,r.fU)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const o=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}const p=a(e,l);(0,r.fU)(e)||Array.isArray(e)||(e=[e]);const h="string"!==l?(0,s.toTypedArray)(e,l):(0,r.xH)(e,[],!0);return o.BV.makeTensor(h,p,l)}function h(e,t,n,o="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,A)=>p(e,`${t}[${A}]`,n,o)))}},1221:(e,t,n)=>{"use strict";var o,A,i,r,s;n.d(t,{x8:()=>l,z4:()=>m}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(o||(o={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(A||(A={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(i||(i={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(r||(r={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(s||(s={}));const a={float32:r,int32:A,bool:i,complex64:s};function l(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return a[e][t]}function m(e){return l(e,"int32")}},9122:(e,t,n)=>{"use strict";n.r(t),n.d(t,{arraysEqual:()=>A.cO,assert:()=>A.hu,assertNonNegativeIntegerDimensions:()=>A.Mu,assertNonNull:()=>A.Cq,assertShapesMatch:()=>A.k5,bytesFromStringArray:()=>A.Ub,bytesPerElement:()=>A.bT,checkConversionForErrors:()=>A.D5,clamp:()=>A.uZ,computeStrides:()=>A.e3,createScalarValue:()=>k,createShuffledIndices:()=>A.U$,decodeString:()=>C,distSquared:()=>A.E7,encodeString:()=>F,fetch:()=>H,fingerPrint64:()=>E,flatten:()=>A.xH,getArrayFromDType:()=>A.rQ,getTypedArrayFromDType:()=>A.WP,hasEncodingLoss:()=>A.QB,hexToLong:()=>s,indexToLoc:()=>A.NE,inferDtype:()=>A.D2,inferFromImplicitShape:()=>A.JZ,isBoolean:()=>A.jn,isFunction:()=>A.mf,isInt:()=>A.GN,isNumber:()=>A.hj,isPromise:()=>A.tI,isScalarShape:()=>A.N9,isString:()=>A.HD,isTypedArray:()=>A.fU,isValidDtype:()=>A.LP,locToIndex:()=>A.qy,makeOnesTypedArray:()=>A.p8,makeZerosNestedTypedArray:()=>A.l6,makeZerosTypedArray:()=>A.wT,nearestDivisor:()=>A.jP,nearestLargerEven:()=>A.nY,now:()=>f,parseAxisParam:()=>A.EC,randUniform:()=>A.bj,repeatedTry:()=>A.WD,rightPad:()=>A.oj,shuffle:()=>A.TV,shuffleCombo:()=>A.d7,sizeFromShape:()=>A.NA,sizeToSquarishShape:()=>A.YP,squeezeShape:()=>A.bp,sum:()=>A.Sm,swap:()=>A.LF,tanh:()=>A.AE,toNestedArray:()=>A.GX,toTypedArray:()=>g});var o=n(2885),A=n(569),i=n(3720);const r=n.n(i)()||i;function s(e){return r.fromString(e,!0,16)}const a=s("c3a5c85c97cb3127"),l=s("b492b66fbe98f273"),m=s("9ae16a3b2f90404f");function p(e){return e.xor(e.shru(47))}function h(e,t,n){const o=e.slice(t,t+n);return r.fromBytes(Array.from(o),!0,!0)}function u(e,t){return h(e,t,8)}function c(e,t){return h(e,t,4)}function d(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function I(e,t,n=s("9ddfea08eb382d69")){let o=e.xor(t).mul(n);o=o.xor(o.shru(47));let A=t.xor(o).mul(n);return A=A.xor(A.shru(47)),A=A.mul(n),A}function G(e,t,n,o){return function(e,t,n,o,A,i){A=A.add(e),i=d(i.add(A).add(o),21);const r=A;return A=(A=A.add(t)).add(n),i=i.add(d(A,44)),[A.add(o),i.add(r)]}(u(e,t),u(e,t+8),u(e,t+16),u(e,t+24),n,o)}function E(e,t=e.length){const n=r.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=m.add(2*t),o=u(e,0).add(m),A=u(e,t-8);return I(d(A,37).mul(n).add(o),d(o,25).add(A).mul(n),n)}if(t>=4){const n=m.add(2*t);return I(c(e,0).shl(3).add(t),c(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),o=t+(e[t-1]<<2);return p(m.mul(n).xor(a.mul(o))).mul(m)}return m}(e,t):function(e,t=e.length){const n=m.add(2*t),o=u(e,0).mul(l),A=u(e,8),i=u(e,t-8).mul(n),r=u(e,t-16).mul(m);return I(d(o.add(A),43).add(d(i,30)).add(r),o.add(d(A.add(m),18)).add(i),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=m.add(2*t),o=u(e,0).mul(m),A=u(e,8),i=u(e,t-8).mul(n),r=u(e,t-16).mul(m),s=d(o.add(A),43).add(d(i,30)).add(r),a=I(s,o.add(d(A.add(m),18)).add(i),n),l=u(e,16).mul(n),p=u(e,24),h=s.add(u(e,t-32)).mul(n),c=a.add(u(e,t-24)).mul(n);return I(d(l.add(p),43).add(d(h,30)).add(c),l.add(d(p.add(o),18)).add(h),n)}(e,t);let o=n,A=n.mul(l).add(113),i=p(A.mul(m).add(113)).mul(m),s=[r.UZERO,r.UZERO],h=[r.UZERO,r.UZERO];o=o.mul(m).add(u(e,0));let E=0;const k=64*(t-1>>6),g=k+(t-1&63)-63;do{o=d(o.add(A).add(s[0]).add(u(e,E+8)),37).mul(l),A=d(A.add(s[1]).add(u(e,E+48)),42).mul(l),o=o.xor(h[1]),A=A.add(s[0]).add(u(e,E+40)),i=d(i.add(h[0]),33).mul(l),s=G(e,E,s[1].mul(l),o.add(h[0])),h=G(e,E+32,i.add(h[1]),A.add(u(e,E+16))),[i,o]=[o,i],E+=64}while(E!==k);const f=l.add(i.and(255).shl(1));return E=g,h[0]=h[0].add(t-1&63),s[0]=s[0].add(h[0]),h[0]=h[0].add(s[0]),o=d(o.add(A).add(s[0]).add(u(e,E+8)),37).mul(f),A=d(A.add(s[1]).add(u(e,E+48)),42).mul(f),o=o.xor(h[1].mul(9)),A=A.add(s[0].mul(9).add(u(e,E+40))),i=d(i.add(h[0]),33).mul(f),s=G(e,E,s[1].mul(f),o.add(h[0])),h=G(e,E+32,i.add(h[1]),A.add(u(e,E+16))),[i,o]=[o,i],I(I(s[0],h[0],f).add(p(A).mul(a)).add(i),I(s[1],h[1],f).add(o),f)}function k(e,t){return"string"===t?F(e):g([e],t)}function g(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=A.xH(e)),(0,o.OB)().getBool("DEBUG")&&A.D5(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function f(){return(0,o.OB)().platform.now()}function H(e,t){return(0,o.OB)().platform.fetch(e,t)}function F(e,t="utf-8"){return t=t||"utf-8",(0,o.OB)().platform.encode(e,t)}function C(e,t="utf-8"){return t=t||"utf-8",(0,o.OB)().platform.decode(e,t)}},569:(e,t,n)=>{"use strict";function o(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,s(e,t,n)}function A(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,o=0;for(;n>0;)o=Math.random()*n|0,n--,s(e,n,o),s(t,n,o)}function i(e,t,n){return Math.max(e,Math.min(t,n))}function r(e){return e%2==0?e:e+1}function s(e,t,n){const o=e[t];e[t]=e[n],e[n]=o}function a(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function l(e,t){const n=Math.random();return t*n+(1-n)*e}function m(e,t){let n=0;for(let o=0;o<e.length;o++){const A=Number(e[o])-Number(t[o]);n+=A*A}return n}function p(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function h(e,t,n=""){p(G(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function u(e){p(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function c(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||q(e)&&!n)for(let o=0;o<e.length;++o)c(e[o],t,n);else t.push(e);return t}function d(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function I(e){return 0===e.length}function G(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function E(e){return e%1==0}function k(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function g(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function f(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return o(t),t}function H(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function F(e,t=(e=>0),n){return new Promise(((o,A)=>{let i=0;const r=()=>{if(e())return void o();i++;const s=t(i);null!=n&&i>=n?A():setTimeout(r,s)};r()}))}function C(e,t){let n=1,o=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==o)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${o} and dim ${t}`);o=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===o){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const A=e.slice();return A[o]=t/n,A}function D(e,t){const n=t.length;return p((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),p(e.every((e=>E(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function J(e,t){const n=[],o=[],A=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||A?null:D(t,e).sort();let r=0;for(let t=0;t<e.length;++t){if(null!=i){if(i[r]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==i[r]||i[r]>t)&&1===e[t]&&(n.push(e[t]),o.push(t)),i[r]<=t&&r++}1!==e[t]&&(n.push(e[t]),o.push(t))}return{newShape:n,keptDims:o}}function v(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function j(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function K(e,t){for(let n=0;n<e.length;n++){const o=e[n];if(isNaN(o)||!isFinite(o))throw Error(`A tensor of type ${t} being uploaded contains ${o}.`)}}function y(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function b(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function q(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function x(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function B(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function w(e){return"string"==typeof e||e instanceof String}function M(e){return"boolean"==typeof e}function L(e){return"number"==typeof e}function S(e){return Array.isArray(e)?S(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":L(e)?"float32":w(e)?"string":M(e)?"bool":"float32"}function T(e){return!!(e&&e.constructor&&e.call&&e.apply)}function N(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function R(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let o=t-3;o>=0;--o)n[o]=n[o+1]*e[o+1];return n}function O(e,t,n,o=!1){const A=new Array;if(1===t.length){const i=t[0]*(o?2:1);for(let t=0;t<i;t++)A[t]=n[e+t]}else{const i=t[0],r=t.slice(1),s=r.reduce(((e,t)=>e*t))*(o?2:1);for(let t=0;t<i;t++)A[t]=O(e+t*s,r,n,o)}return A}function P(e,t,n=!1){if(0===e.length)return t[0];const o=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===o)return[];if(o!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return O(0,e,t,n)}function U(e,t){const n=V(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function V(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function W(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return P(e,new Float32Array(n));if("int32"===t)return P(e,new Int32Array(n));if("bool"===t)return P(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function _(e){e.forEach((t=>{p(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function z(e,t,n){if(0===t)return 0;if(1===t)return e[0];let o=e[e.length-1];for(let t=0;t<e.length-1;++t)o+=n[t]*e[t];return o}function X(e,t,n){if(0===t)return[];if(1===t)return[e];const o=new Array(t);for(let t=0;t<o.length-1;++t)o[t]=Math.floor(e/n[t]),e-=o[t]*n[t];return o[o.length-1]=e,o}function Q(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{TV:()=>o,d7:()=>A,uZ:()=>i,nY:()=>r,LF:()=>s,Sm:()=>a,bj:()=>l,E7:()=>m,hu:()=>p,k5:()=>h,Cq:()=>u,xH:()=>c,NA:()=>d,N9:()=>I,cO:()=>G,GN:()=>E,AE:()=>k,YP:()=>g,U$:()=>f,oj:()=>H,WD:()=>F,JZ:()=>C,EC:()=>D,bp:()=>J,WP:()=>v,rQ:()=>j,D5:()=>K,LP:()=>y,QB:()=>b,fU:()=>q,bT:()=>x,Ub:()=>B,HD:()=>w,jn:()=>M,hj:()=>L,D2:()=>S,mf:()=>T,jP:()=>N,e3:()=>R,GX:()=>P,p8:()=>U,wT:()=>V,l6:()=>W,Mu:()=>_,qy:()=>z,NE:()=>X,tI:()=>Q})},4519:(e,t,n)=>{const o=n(2212),A=function(){const e={rotationOffsetX:0,pivotOffsetYZ:[.2,.6],detectionThreshold:.8,detectionHysteresis:.02,cameraMinVideoDimFov:35};let t=null,n=null,A=null,i=null,r=null,s=-1,a=!1,l=null,m=!1,p=!1,h=null,u=null,c=!1,d=1,I=-1;const G=[];let E=null,k=null,g=null,f=null,H=null;function F(t){G.forEach((function(n,o){c=n.visible;const A=t[o];c&&A.detected<e.detectionThreshold-e.detectionHysteresis?(l&&l(o,!1),n.visible=!1):!c&&A.detected>e.detectionThreshold+e.detectionHysteresis&&(l&&l(o,!0),n.visible=!0)}))}const C={init:function(e,c){m=!1,G.splice(0),i&&(i.dispose(),i=null),s=e.maxFacesDetected,k=e.videoTexture,H=e.videoTransformMat2,E=e.GL,h=e.canvasElement,a=s>1,u=e.videoElement;let d=null;e.threeCanvasId?(p=!0,d=document.getElementById(e.threeCanvasId),d.setAttribute("width",h.width),d.setAttribute("height",h.height)):d=h,void 0!==c&&(l=c),t=new o.WebGLRenderer({context:p?null:E,canvas:d,alpha:!(!p&&!e.alpha),preserveDrawingBuffer:!0}),n=new o.Scene,r=new o.Vector3,function(){for(let e=0;e<s;++e){const e=new o.Object3D;e.frustumCulled=!1,e.visible=!1,G.push(e),n.add(e)}}(),function(){const e="attribute vec2 position;\n        uniform mat2 videoTransformMat2;\n        varying vec2 vUV;\n        void main(void){\n          gl_Position = vec4(position, 0., 1.);\n          vUV = 0.5 + videoTransformMat2 * position;\n        }",t="precision lowp float;\n        uniform sampler2D samplerVideo;\n        varying vec2 vUV;\n        void main(void){\n          gl_FragColor = texture2D(samplerVideo, vUV);\n        }";if(p){const n=function(e,t,n){const o=E.createShader(t);return E.shaderSource(o,e),E.compileShader(o),E.getShaderParameter(o,E.COMPILE_STATUS)?o:(alert("ERROR IN "+n+" SHADER: "+E.getShaderInfoLog(o)),null)},o=n(e,E.VERTEX_SHADER,"VERTEX"),A=n(t,E.FRAGMENT_SHADER,"FRAGMENT");return g=E.createProgram(),E.attachShader(g,o),E.attachShader(g,A),E.linkProgram(g),E.getUniformLocation(g,"samplerVideo"),void(f=E.getUniformLocation(g,"videoTransformMat2"))}i=new o.DataTexture(new Uint8Array([255,0,0]),1,1,o.RGBFormat),i.needsUpdate=!0;const r=new o.RawShaderMaterial({depthWrite:!1,depthTest:!1,vertexShader:e,fragmentShader:t,uniforms:{samplerVideo:{value:i},videoTransformMat2:{value:H}}}),s=new o.BufferGeometry,a=new Float32Array([-1,-1,1,-1,1,1,-1,1]);s.addAttribute("position",new o.BufferAttribute(a,2)),s.setIndex(new o.BufferAttribute(new Uint16Array([0,1,2,0,2,3]),1)),A=new o.Mesh(s,r),C.apply_videoTexture(A),A.renderOrder=-1e3,A.frustumCulled=!1,n.add(A)}(),window.addEventListener("orientationchange",(function(){setTimeout(JEELIZFACEFILTER.resize,1e3)}),!1);const I={videoMesh:A,renderer:t,scene:n};return a?I.faceObjects=G:I.faceObject=G[0],I},detect:function(e){F(a?e:[e])},get_isDetected:function(){return c},render:function(o,A){const i=a?o:[o];F(i),function(t,n){const o=Math.tan(n.aspect*n.fov*Math.PI/360);G.forEach((function(n,A){if(!n.visible)return;const i=t[A],s=Math.cos(i.rz),a=Math.sin(i.rz),l=1/(i.s*d*2*o)+.5,m=i.x*d,p=i.y*d,h=-l,u=m*l*o,c=p*l*o/I;n.position.set(-a*e.pivotOffsetYZ[0],-s*e.pivotOffsetYZ[0],-e.pivotOffsetYZ[1]),n.rotation.set(i.rx+e.rotationOffsetX,i.ry,i.rz,"ZYX"),n.position.applyEuler(n.rotation),r.set(u,c+e.pivotOffsetYZ[0],h+e.pivotOffsetYZ[1]),n.position.add(r)}))}(i,A),p?(E.viewport(0,0,h.width,h.height),E.useProgram(g),E.uniformMatrix2fv(f,!1,H),E.activeTexture(E.TEXTURE0),E.bindTexture(E.TEXTURE_2D,k),E.drawElements(E.TRIANGLES,3,E.UNSIGNED_SHORT,0)):t.state.reset(),t.render(n,A)},sortFaces:function(e,t,n){const o={X:0,Y:1,Z:2}[t.toUpperCase()],A=n?-1:1,i=e.index.count/3,r=new Array(i);for(let t=0;t<i;++t)r[t]=[e.index.array[3*t],e.index.array[3*t+1],e.index.array[3*t+2]];const s=e.attributes.position.array,a=r.map((function(e,t){return[(s[3*e[0]]+s[3*e[1]]+s[3*e[2]])/3,(s[3*e[0]+1]+s[3*e[1]+1]+s[3*e[2]+1])/3,(s[3*e[0]+2]+s[3*e[1]+2]+s[3*e[2]+2])/3,e]}));a.sort((function(e,t){return(e[o]-t[o])*A})),a.forEach((function(t,n){const o=t[3];e.index.array[3*n]=o[0],e.index.array[3*n+1]=o[1],e.index.array[3*n+2]=o[2]}))},get_threeVideoTexture:function(){return i},apply_videoTexture:function(e){m||(e.onAfterRender=function(){try{t.properties.update(i,"__webglTexture",k),i.magFilter=o.LinearFilter,i.minFilter=o.LinearFilter,m=!0}catch(e){console.log("WARNING in JeelizThreeHelper: the glVideoTexture is not fully initialized")}delete e.onAfterRender})},create_threejsOccluder:function(e,t){const n=new o.Mesh;return(new o.BufferGeometryLoader).load(e,(function(e){const A=new o.ShaderMaterial({vertexShader:o.ShaderLib.basic.vertexShader,fragmentShader:"precision lowp float;\n void main(void){\n gl_FragColor=vec4(1.,0.,0.,1.);\n }",uniforms:o.ShaderLib.basic.uniforms,colorWrite:!1});n.renderOrder=-1,n.material=A,n.geometry=e,void 0!==t&&t&&t(n)})),n},set_pivotOffsetYZ:function(t){e.pivotOffsetYZ=t},create_camera:function(e,t){const n=new o.PerspectiveCamera(1,1,e||.1,t||100);return C.update_camera(n),n},update_camera:function(n){const o=t.domElement,A=o.width,i=o.height;I=A/i;const r=u.videoWidth,s=u.videoHeight,a=r/s,l=s>r?1/a:1,m=e.cameraMinVideoDimFov*l;console.log("INFO in JeelizThreeHelper - update_camera(): Estimated vertical video FoV is",m);let p=1;p=I>a?A/r:i/s;const h=r*p,c=s*p,G=(h-A)/2,E=(c-i)/2;d=A/h,n.aspect=I,n.fov=m,console.log("INFO in JeelizThreeHelper.update_camera(): camera vertical estimated FoV is",m,"deg"),n.setViewOffset(h,c,G,E,A,i),n.updateProjectionMatrix(),t.setSize(A,i,!1),t.setViewport(0,0,A,i)},resize:function(e,n,o){t.domElement.width=e,t.domElement.height=n,JEELIZFACEFILTER.resize(),o&&C.update_camera(o)}};return C}();try{e.exports=A}catch(e){console.log("JeelizThreeHelper ES6 Module not exported"),window.JeelizThreeHelper=A}},5135:e=>{const t=function(){function e(e){var t=null,n=null,o=null,A=0;this.o=function(e){this.Ff(e.mb),o.xe({nc:e.nc,kc:e.kc})},this.Te=function(e){return t[e]},this.Ff=function(e){var i=null;A=e.length,t=e.map((function(e,t){return e=Object.assign({},e,{index:t,parent:this,sb:i,ef:t===A-1}),i=0===t?Y.instance(e):$.instance(e)})),n=t[0],o=t[A-1],t.forEach((function(e,t){0!==t&&e.vf()}))},this.T=function(e){e.g(0);var n=e;return t.forEach((function(e){n=e.T(n,!1)})),n},this.Se=function(){return n.F()},this.Tb=function(){return o.Ve()},this.gd=function(){return o.gd()},this.m=function(){t&&(t.forEach((function(e){e.m()})),o=n=t=null,A=0)},void 0!==e&&this.o(e)}function n(e,t){var n=t%8;return e[(t-n)/8]>>7-n&1}function o(){return-1!==[ce.ready,ce.play,ce.pause].indexOf(de)}function A(){if(de===ce.play)return!1;de=ce.play,le.stop(),l()}function i(){return de===ce.play&&(ae.stop(),le.stop(),de=ce.pause,!0)}function r(e,t,n,o,A){return e=4*(3*t+e)+n,o+(ve.buffer[e]/255+ve.buffer[e+12]/65025)*(A-o)}function s(){T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!1),z.da(),_.reset(),X.reset(),S.P(),S.Wc(),T.disable(T.DEPTH_TEST),T.disable(T.BLEND),_.ua(),S.Ba()}function a(){var e=pe.na();return z.O(),T.viewport(0,0,3,2*e),S.set("s53"),ve.sa.g(0),_.l(!1,!1),W.ub(0,0,3,2*e,ve.buffer,p)}function l(){de!==ce.pause&&(fe.isCleanGLStateAtEachIteration&&(S.Wc(),_.reset(),_.ua(),T.disable(T.DEPTH_TEST),T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!1),S.Ba()),ae.oc(m,a,h,p,u,fe.animateProcessOrder))}function m(){if(z.da(),!Ie.hb)if(Ie.gb)Ie.element.needsUpdate&&(Ie.M.Bb(Ie.element.arrayBuffer),Ie.element.needsUpdate=!1);else{var e=Ie.element.currentTime,t=e-Ie.tb;0>t&&(Ie.tb=e,t=0),1e3*t<he.Xf||(Ie.tb+=t,Ie.M.refresh())}for(e=ae.Ue(),pe.update(e,Ke),t=0;t<e;++t){pe.zb(t),S.set("s55");var n=Ke[pe.hd()];S.G("u43",1+Ce.pc*(Math.cos(n.ry)-1)),Ee.va&&S.G("u42",n.rz),pe.Xd("u41"),De.Na.$(),Ie.M.g(0),ve.sa.g(1),_.l(!1,!1),ge.T(De.Na)}ae.zb()}function p(){z.Uf(),fe.isCleanGLStateAtEachIteration&&(z.reset(),X.reset(),T.enable(T.DEPTH_TEST)),Ee.Eb&&Ee.Eb(pe.yd()?Ke:Ke[0]),fe.isCleanGLStateAtEachIteration&&(T.disable(T.BLEND),_.reset(),_.ua())}function h(){for(var e=0;e<pe.na();++e)if(pe.jf(e)){var t=e,n=je[t],o=[t],A=Ke[t],i=ye[t],s=2*t;if(n.Va=r(1,s,3,0,1),A.detected=B.X(A.detected,n.Va,he.ge),n.x=r(0,s,1,-1,1),n.y=r(0,s,2,-1,1),n.ja=r(0,s,3,0,1),n.Va<fe.multiDetectionThresholdFactors[0]*fe.threshold)n.pa=Math.floor(n.pa/2),Ee.va&&(A.rz=0,A.ry=0);else{var a=ve.Pa;for(n.rx=r(1,s,0,-a[0],a[0]),n.ry=r(1,s,1,-a[1],a[1]),n.Qa=r(1,s,2,-a[2],a[2]),a=0;a<ve.Y;++a)n.cd[a]=ve.La[a](r(2,s,a,0,1));for(s=n.ja*ve.Nd,o.dx=n.x-A.xRaw,o.dy=n.y-A.yRaw,o.Nb=s-A.sRaw,o.Kb=n.rx-A.rx,o.Lb=n.ry-A.ry,o.Mb=Ee.va?n.Qa:n.Qa-A.rz,a=ae.Ne(),o=(1-L.nb(He.translationFactorRange[0],He.translationFactorRange[1],Math.sqrt(o.dx*o.dx+o.dy*o.dy+o.Nb*o.Nb)/a))*(1-L.nb(He.rotationFactorRange[0],He.rotationFactorRange[1],Math.sqrt(o.Kb*o.Kb+o.Lb*o.Lb+o.Mb*o.Mb)/a))*L.nb(He.qualityFactorRange[0],He.qualityFactorRange[1],n.Va),t=i[++be[t]%i.length]=o,a=0;a<i.length;++a)t=Math.min(t,i[a]);for(t=Math.max(.5,t),o=Math.min(t,o),i=B.X(He.alphaRange[1],He.alphaRange[0],Math.pow(o,he.ie)),A.xRaw=B.X(A.xRaw,n.x,i),A.yRaw=B.X(A.yRaw,n.y,i),A.sRaw=B.X(A.sRaw,s,i),A.rx=B.X(A.rx,n.rx,i),A.ry=B.X(A.ry,n.ry,i),A.rz=Ee.va?A.rz+He.followZRotAlphaFactor*i*n.Qa:B.X(A.rz,n.Qa,i),t=A.sRaw*Ce.Jb*Math.sin(A.ry),s=Math.sin(A.rz)*t/Fe,A.x=A.xRaw+Math.cos(A.rz)*t,A.y=A.yRaw+s,A.s=A.sRaw,i=Math.max(i,he.he),t=0;t<ve.Y;++t)A.expressions[t]=B.X(A.expressions[t],n.cd[t],i);++n.pa}}}function u(){de===ce.play&&le.oc(l)}function c(){De.Na=X.instance({isPot:!0,isFloat:!1,width:ge.Se()});var e={width:he.Ud,height:pe.na(),isFloat:!0,isPot:!1,array:pe.De(new Float32Array([0,.5,.5,0,0,0,0,0,0,0,0,0]))};ve.sa=P.instance(e)}function d(){S.S("s55",[{type:"1i",name:"u1",value:0},{type:"1i",name:"u39",value:1},{type:"2f",name:"u40",value:De.D},{type:"1f",name:"u41",value:.5},{type:"1f",name:"u42",value:0}]),S.S("s56",[{type:"1i",name:"u44",value:0},{type:"1i",name:"u39",value:1},{type:"1f",name:"u47",value:he.Sf},{type:"1f",name:"u48",value:fe.threshold},{type:"3f",name:"u46",value:[ve.N[0]*De.D[0],ve.N[1]*De.D[1],ve.N[2]]},{type:"1f",name:"u41",value:.5},{type:"1f",name:"u49",value:1},{type:"1f",name:"u42",value:0}]);var e=[{type:"1i",name:"u44",value:0}];S.S("s57",e),S.S("s58",e),S.S("s53",[{type:"1i",name:"u39",value:0},{type:"1f",name:"u52",value:De.D[0]},{type:"2f",name:"u51",value:[0,.5/pe.na()]}])}function I(){De.D[0]=1,De.D[1]=De.C/De.K,me.o({rb:fe.overlapFactors,Ed:fe.nScaleLevels,C:De.C,K:De.K,Md:fe.scale0Factor,N:ve.N,Od:fe.scanCenterFirst})}function G(e,t){if(e.exportData){var n=e.exportData;if(n.rotationEulerAnglesFactors&&(ve.Pa=n.rotationEulerAnglesFactors),n.translationScalingFactors){var o=n.translationScalingFactors,A=fe.translationScalingFactors;ve.N[0]=o[0]*A[0],ve.N[1]=o[1]*A[1],ve.N[2]=o[2]*A[2]}void 0!==n.nExpressions&&(ve.Y=n.nExpressions),ve.Nd=n.dsMean?1+n.dsMean:1,Ce.pc=.4,Ce.Jb=.7,void 0!==n.fgScaleXFactor&&(Ce.pc=n.fgScaleXFactor),void 0!==n.fgDisplaceXFactor&&(Ce.Jb=n.fgDisplaceXFactor)}if(ve.Y||(ve.Y=he.Dd),!ve.La)for(ve.La=[],n=0;n<ve.Y;++n)ve.La.push(he.He);t(e)}function E(){var e=pe.hd(),t=Ke[e];ve.sa.Df(1),T.viewport(0,e,1,1),S.set("s56"),Ee.va&&S.G("u42",t.rz),pe.Xd("u41");var n=1,o=pe.Nf(je,De.C/De.K);pe.yd()&&(o&&(n=0,je[e].pa=0,t.isDetected=!1,t.detected=0),S.G("u49",n)),S.Jf("u45",me.get(e)),_.l(!1,!1),(pe.xd()||o)&&(T.viewport(1,e,1,1),S.set("s57"),S.G("u49",n),_.l(!1,!1)),pe.xd()&&(T.viewport(2,e,1,1),S.set("s58"),_.l(!1,!1)),ve.sa.sync()}function k(){if(Ie.M&&Ie.M.remove(),Ie.gb=!!Ie.element.isFakeVideo,Ie.gb){var e=H();e={isFlipY:!1,array:Ie.element.arrayBuffer,width:e.w,height:e.xa,isKeepArray:!0}}else e={H:Ie.element};Ie.tc=X.instance(Object.assign({isPot:!1,isLinear:!0,isFloat:!1},e)),Ie.M=Ie.tc}function g(){var e=[{type:"mat2",name:"u38",value:Ie.v}];S.S("s54",[{type:"1i",name:"u1",value:0}].concat(e)),S.S("s55",e)}function f(){var e=[.5,.5],t=Ie.D[1]/Ie.D[0];switch(Fe=N.U()/N.F(),90===Math.abs(ue.rotate)&&(t=1/t),t>Fe?e[1]*=Fe/t:e[0]*=t/Fe,S.S("s56",[{name:"u50",type:"1f",value:Fe}]),Ie.v[0]=0,Ie.v[1]=0,Ie.v[2]=0,Ie.v[3]=0,ue.rotate){case 0:Ie.v[0]=e[0],Ie.v[3]=e[1];break;case 180:Ie.v[0]=-e[0],Ie.v[3]=-e[1];break;case 90:Ie.v[1]=e[0],Ie.v[2]=-e[1];break;case-90:Ie.v[1]=-e[0],Ie.v[2]=e[1]}ue.flipX&&(Ie.v[0]*=-1,Ie.v[2]*=-1),Ie.hb||(Ie.v[1]*=-1,Ie.v[3]*=-1)}function H(){var e={w:Ie.element.videoWidth||Ie.element.width,xa:Ie.element.videoHeight||Ie.element.height};if(!e.w||!e.xa||4>e.w||4>e.xa)throw Error("INVALID VIDEO DIMENSIONS - width = "+e.w+" height = "+e.xa);return e}function F(){var e=H(),t=Ie.D[0]!==e.w||Ie.D[1]!==e.xa;return t&&(Ie.D[0]=e.w,Ie.D[1]=e.xa),t}function C(e,t){return de!==ce.error&&(Ie.element=e,F(),t&&t(),!0)}function D(e,t,n){e&&e(),Ie.Ja={video:{facingMode:{exact:ue.facingMode},width:{min:ue.minWidth,max:ue.maxWidth,ideal:ue.idealWidth},height:{min:ue.minHeight,max:ue.maxHeight,ideal:ue.idealHeight}},audio:!1},se.Ic(Ie.Ja,ue.deviceId),se.get(Ie.element?Ie.element:se.ld(),(function(e){t&&t(e),n(e)}),(function(){J("WEBCAM_UNAVAILABLE")}),Ie.Ja)}function J(e){de!==ce.error&&(de=ce.error,Ee.Ia&&Ee.Ia(e))}var v,j,K,y,b,q,x,B={Wg:function(e){return Math.ceil(Math.log2(e))},rh:function(e){return Math.log2(e)},nh:function(e){return 0==Math.log2(e)%1},hg:function(e){var t=[0,0,0,0];return e.forEach((function(e){t[0]+=e[0],t[1]+=e[1],t[2]+=e[2],t[3]+=e[3]})),t},ig:function(e,t,n){return Math.min(Math.max(e,t),n)},lg:function(e){return e*Math.PI/180},xh:function(e,t){return t=Math.pow(10,t),Math.round(e*t)/t},yh:function(e){return Math.round(1e6*e)/1e6},Xg:function(e,t){return(100*e/t).toFixed(3)},X:function(e,t,n){return e*(1-n)+t*n},sh:function(e,t){return e[0]*(1-t)+e[1]*t},Be:function(e,t){return B.ue(e-t)},ue:function(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<=-Math.PI;)e+=2*Math.PI;return e},qg:function(e,t){return Math.abs(B.Be(e,t))},Yf:function(e,t){return Math.atan2(Math.sin(e)+Math.sin(t),Math.cos(e)+Math.cos(t))}},w={get:function(e,t,n){var o=new XMLHttpRequest;o.open("GET",e,!0),o.withCredentials=!1,o.onreadystatechange=function(){4===o.readyState&&(200===o.status||0===o.status?t(o.responseText):void 0!==n&&n(o.status))},o.send()},We:function(e){return new Promise((function(t,n){w.get(e,t,n)}))},Tg:function(e,t,n){e+=n?"?"+w.Fe(n):"",w.get(e,(function(e){t(JSON.parse(e))}))},uh:function(e,t,n){var o=new XMLHttpRequest;o.open("POST",e,!0),o.setRequestHeader("Content-type","application/x-www-form-urlencoded"),o.onreadystatechange=function(){4!==o.readyState||200!==o.status&&0!==o.status||n(o.responseText)},o.send(t)},Fe:function(e){return"string"==typeof e?e:Object.keys(e).map((function(t){return encodeURIComponent(t)+"="+encodeURIComponent(e[t])})).join("&")},Hg:function(e,t){var n=new XMLHttpRequest;n.open("POST",e,!0),n.responseType="arraybuffer",n.onload=function(){t(n.response)},n.send()}},M={Hb:function(e,t){if(0===t||"object"!=typeof e)return e;for(var n in t=void 0===t||-1===t?-1:t-1,e=Object.assign({},e))e[n]=M.Hb(e[n],t);return e},pg:function(e){return JSON.parse(JSON.stringify(e))}},L={Lh:function(e,t,n){return(e=Math.min(Math.max((n-e)/(t-e),0),1))*e*(3-2*e)},nb:function(e,t,n){return Math.min(Math.max((n-e)/(t-e),0),1)},Bg:function(e,t,n,o){return Math.pow(Math.min(Math.max((o-e)/(t-e),0),1),n)},Qh:function(){return 0},th:function(){return 1},qh:function(e){return e},yg:function(e){return e*e},Dg:function(e){return e*(2-e)},vg:function(e){return.5>e?2*e*e:(4-2*e)*e-1},tg:function(e){return e*e*e},Cg:function(e){return--e*e*e+1},ug:function(e){return.5>e?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1},zg:function(e){return e*e*e*e},Eg:function(e){return 1- --e*e*e*e},wg:function(e){return.5>e?8*e*e*e*e:1-8*--e*e*e*e},Ag:function(e){return e*e*e*e*e},Fg:function(e){return 1+--e*e*e*e*e},xg:function(e){return.5>e?16*e*e*e*e*e:1+16*--e*e*e*e*e}},S=function(){function e(e,t,n){return t=e.createShader(t),e.shaderSource(t,n),e.compileShader(t),!!e.getShaderParameter(t,e.COMPILE_STATUS)&&t}function t(t,n){if(n.B=!!n.B,!n.B){n.ta=n.ta||"precision lowp float;attribute vec2 a0;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=a0*.5+vec2(.5,.5);}",n.Ta=n.Ta||["a0"],n.Ga=n.Ga||[2],n.precision=n.precision||a,n.id=r++,void 0!==n.Qd&&(n.Qd.forEach((function(e,t){n.h=n.h.replace(e,n.vb[t])})),n.Qd.splice(0)),n.Bc=0,n.Ga.forEach((function(e){n.Bc+=4*e}));var s=function(e){return["float","sampler2D","int"].map((function(t){return"precision "+e+" "+t+";\n"})).join("")}(n.precision);if(n.qa=function(t,n,A){n=e(t,t.VERTEX_SHADER,n),A=e(t,t.FRAGMENT_SHADER,A),t===T&&o.push(n,A);var i=t.createProgram();return t.attachShader(i,n),t.attachShader(i,A),t.linkProgram(i),i}(t,s+n.ta,s+n.h),n.A={},n.i.forEach((function(e){n.A[e]=t.getUniformLocation(n.qa,e)})),n.attributes={},n.Ha=[],n.Ta.forEach((function(e){var o=t.getAttribLocation(n.qa,e);n.attributes[e]=o,n.Ha.push(o)})),n.j)for(var l in t.useProgram(n.qa),i=n,A=n.id,n.j)t.uniform1i(n.A[l],n.j[l]);n.oa=!0}}function n(e,n,o){return t(e,n),e.useProgram(n.qa),e.enableVertexAttribArray(0),A=-1,i=n}var o=[],A=-1,i=null,r=0,s=!1,a="highp",l=["u1"],m=["u0"],p={u1:0},h={u0:0},u={u1:0,u2:1},c={u3:0},d={s0:{h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",i:["u1"],j:{u1:0}},s1:{h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",i:l,j:p,precision:"lowp"},s2:{h:"uniform sampler2D u1,u2;varying vec2 vv0;void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a*b;}",i:["u1","u2"],j:u},s3:{h:"uniform sampler2D u1;uniform vec2 u4,u5;varying vec2 vv0;void main(){vec2 a=vv0*u4+u5;gl_FragColor=texture2D(u1,a);}",i:["u1","u4","u5"],j:p,B:!0},s4:{h:"uniform sampler2D u1;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a.r*f;}",i:l,j:p},s5:{h:"uniform sampler2D u1,u2;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a.a*b.r*f;}",i:["u1","u2"],j:u},s6:{h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(1.-vv0.x,vv0.y));}",i:l,j:p},s7:{h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(vv0.x,1.-vv0.y));}",i:l,j:p},s8:{h:"uniform sampler2D u0;uniform float u4;varying vec2 vv0;void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=a*u4;}",i:["u0","u4"],j:h},s9:{h:"uniform sampler2D u0;uniform float u4;varying vec2 vv0;const vec4 f=vec4(.25,.25,.25,.25),g=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);float b=dot(a*u4,f);gl_FragColor=b*g;}",i:["u0","u4"],j:h},s10:{h:"uniform sampler2D u1;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){float a=.25*dot(e,texture2D(u1,vv0));gl_FragColor=a*e;}",i:l,j:p},s11:{h:"uniform sampler2D u1,u6;uniform float u7;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u6,vv0);gl_FragColor=mix(b,a,u7*f);}",i:["u1","u6","u7"],j:{u1:0,u6:1}},s12:{h:"uniform sampler2D u1;uniform vec2 u8;varying vec2 vv0;void main(){gl_FragColor=.25*(texture2D(u1,vv0+u8)+texture2D(u1,vv0+u8*vec2(1.,-1.))+texture2D(u1,vv0+u8*vec2(-1.,-1.))+texture2D(u1,vv0+u8*vec2(-1.,1.)));}",i:["u1","u8"],j:p},s13:{h:"uniform sampler2D u1;uniform vec4 u9;varying vec2 vv0;float g(float a,float b){a=floor(a)+.5;return floor(a/exp2(b));}float h(float a,float b){return floor(a*exp2(b)+.5);}float i(float a,float b){return mod(a,h(1.,b));}float e(float c,float a,float b){a=floor(a+.5),b=floor(b+.5);return i(g(c,a),b-a);}vec4 j(float a){if(a==0.)return vec4(0.,0.,0.,0.);float k=128.*step(a,0.);a=abs(a);float c=floor(log2(a)),l=c+127.,b=(a/exp2(c)-1.)*8388608.,d=l/2.,m=fract(d)*2.,n=floor(d),o=e(b,0.,8.),p=e(b,8.,16.),q=m*128.+e(b,16.,23.),r=k+n;return vec4(o,p,q,r)/255.;}void main(){float a=dot(texture2D(u1,vv0),u9);gl_FragColor=j(a);}",i:["u1","u9"],j:p},s14:{h:"uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=e/(e+exp(-a));gl_FragColor=b;}",i:m,j:h,B:!0},s15:{h:"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(0.,0.,0.,0.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=max(f,a);}",i:m,j:h},s16:{h:"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=mix(exp(-abs(a))-f,a,step(0.,a));}",i:m,j:h},s17:{h:"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=exp(-abs(a))-f;gl_FragColor=mix(.1*b,a,step(0.,a));}",i:m,j:h},s18:{h:"uniform sampler2D u0,u7,u10;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),c=texture2D(u7,vv0),d=texture2D(u10,vv0),b=a/d;gl_FragColor=c*mix(exp(-abs(b))-f,b,step(0.,a));}",i:["u0","u7","u10"],j:{u0:0,u7:1,u10:2},B:!0},s19:{h:"uniform sampler2D u0;const float e=3.141593;varying vec2 vv0;void main(){gl_FragColor=atan(e*texture2D(u0,vv0))/e;}",i:m,j:h},s20:{h:"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=log(f+a);gl_FragColor=b;}",i:m,j:h,B:!0},s21:{h:"uniform sampler2D u0,u11;uniform float u12;const vec2 e=vec2(.5,.5);const float f=1e-5;const vec4 g=vec4(1.,1.,1.,1.),i=vec4(0.,0.,0.,0.);varying vec2 vv0;void main(){vec4 a=texture2D(u11,e);float b=u12*u12;vec4 c=max(b*a,f*g);gl_FragColor=texture2D(u0,vv0)/c;}",i:["u0","u11","u12"],j:{u0:0,u11:1},B:!0},s22:{h:"uniform sampler2D u1;uniform vec2 u13;varying vec2 vv0;void main(){float a=u13.x*u13.y;vec2 b=floor(vv0*a)/a,c=fract(vv0*a),d=floor(b*u13.y),f=floor(u13.x*fract(b*u13.y)),g=(f*u13.y+d)/a;gl_FragColor=texture2D(u1,g+c/a);}",i:["u1","u13"],j:p},s23:{h:"uniform sampler2D u14,u15,u16;varying vec2 vv0;void main(){vec4 a=texture2D(u16,vv0);vec2 b=a.rg,c=a.ba;vec4 d=texture2D(u14,b),f=texture2D(u15,c);gl_FragColor=d*f;}",i:["u14","u15","u16"],j:{u15:0,u14:1,u16:2},B:!0},s24:{h:"uniform float u17;uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec2 a=fract(vv0*u17);vec4 b=texture2D(u14,vv0),c=texture2D(u15,a);gl_FragColor=b*c;}",i:["u15","u14","u17"],j:{u15:0,u14:1}},s25:{h:"uniform float u17;uniform sampler2D u14,u15,u18,u19,u20,u21;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.),g=vec4(1e-3,1e-3,1e-3,1e-3);void main(){vec2 h=vv0*u17,l=floor(h),c=h-l;vec4 m=texture2D(u14,vv0),d=texture2D(u15,c),a=texture2D(u21,vv0);a=a*255.;vec4 n=texture2D(u18,c),o=texture2D(u19,c),p=texture2D(u20,c),i=step(-g,-a),b=e-i,j=b*step(-e-g,-a);b*=e-j;vec4 k=b*step(-2.*e-g,-a);b*=e-k;vec4 q=b;d=i*d+j*n+k*o+q*p,gl_FragColor=m*d;}",i:"u14 u15 u17 u21 u18 u19 u20".split(" "),j:{u15:0,u14:1,u21:3,u18:4,u19:5,u20:6},B:!0},s26:{h:"uniform sampler2D u14,u15,u22;uniform float u17,u23,u24,u25;varying vec2 vv0;const vec2 j=vec2(1.,1.);void main(){vec2 a=floor(u23*vv0),b=u23*vv0-a;float c=u17/u23;vec2 d=floor(b*c),f=b*c-d,g=(a+f)/u23;float k=u23*u25/u17;vec2 l=k*d,h=(l+f*u24)/u25,i=step(h,j);vec4 m=texture2D(u14,g),n=texture2D(u15,h),o=m*n*i.x*i.y,p=texture2D(u22,g);gl_FragColor=o*u24*u24+p;}",i:"u14 u15 u17 u23 u24 u25 u22".split(" "),j:{u15:0,u14:1,u22:2}},s27:{h:"uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec4 a=texture2D(u14,vv0),b=texture2D(u15,vv0);gl_FragColor=a*b;}",i:["u14","u15"],j:{u15:0,u14:1},B:!0},s28:{h:"uniform sampler2D u1,u22;uniform float u26;varying vec2 vv0;void main(){gl_FragColor=texture2D(u22,vv0)+u26*texture2D(u1,vv0);}",i:["u1","u22","u26"],j:{u1:0,u22:1}},s29:{h:"varying vec2 vv0;uniform sampler2D u1;const vec4 f=vec4(1.,1.,1.,1.),g=vec4(.299,.587,.114,0.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=dot(a,g)*f;}",i:l,j:p,precision:"lowp"},s30:{h:"varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(dot(a,f),dot(b,f),dot(c,f),dot(d,f));}",i:["u1","u27"],j:p,precision:"lowp"},s31:{h:"varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(a.r,b.g,c.b,dot(d,f));}",i:["u1","u27"],j:p,precision:"lowp"},s32:{h:"varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=vec4(0.);a-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y))*2.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y))*2.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec4 b=vec4(0.);b-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,b-=texture2D(u1,vec2(vv0.x,vv0.y-u28))*2.,b-=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,b+=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,b+=texture2D(u1,vec2(vv0.x,vv0.y+u28))*2.,b+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec3 c=sqrt(a.rgb*a.rgb+b.rgb*b.rgb);vec4 e=vec4(c,texture2D(u1,vv0).a),g=texture2D(u2,vv0);gl_FragColor=g.a*e.r*f;}",i:["u1","u2","u28"],j:u,B:!0},s33:{h:"varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 j=vec4(1.,1.,1.,1.);const vec2 k=vec2(1.,1.);void main(){float h=0.;vec2 l=k*u28,a,b;float c,d,i=0.;for(float e=-4.;e<=4.;e+=1.)for(float f=-4.;f<=4.;f+=1.)a=vec2(e,f),c=length(a)/2.,d=exp(-c*c),b=vv0+l*a,h+=d*texture2D(u1,b).r,i+=d;vec4 m=texture2D(u2,vv0);gl_FragColor=m.a*(texture2D(u1,b).r-h/i)*j;}",i:["u1","u2","u28"],j:u,B:!0},s34:{h:"uniform sampler2D u3;uniform vec2 u8;varying vec2 vv0;vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}const vec2 g=vec2(.5,.5),h=vec2(1.,0.),i=vec2(0.,1.);void main(){vec2 a=vv0-u8*g;vec4 b=texture2D(u3,a),c=texture2D(u3,a+u8*h),d=texture2D(u3,a+u8*i),j=texture2D(u3,a+u8),k=e(b,c),l=e(d,j);gl_FragColor=e(k,l);}",i:["u3","u8"],j:c},s35:{h:"uniform sampler2D u3;uniform vec2 u8;varying vec2 vv0;const vec2 k=vec2(1.,0.),l=vec2(0.,1.),m=vec2(2.,0.),n=vec2(0.,2.);vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}vec4 f(vec2 a){vec4 b=texture2D(u3,a),c=texture2D(u3,a+u8*k),d=texture2D(u3,a+u8*l),g=texture2D(u3,a+u8),h=e(b,c),i=e(d,g);return e(h,i);}void main(){vec2 a=vv0+u8*vec2(-.55,-1.05);vec4 b=f(a),c=f(a+u8*m),d=f(a+u8*2.),g=f(a+u8*n),h=e(b,c),i=e(d,g);gl_FragColor=e(h,i);}",i:["u3","u8"],j:c,B:!0},s36:{h:"uniform sampler2D u1;varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a*a;}",i:["u1"],j:p,precision:"lowp",B:!0},s37:{h:"uniform sampler2D u1;uniform vec2 u8;varying vec2 vv0;const float e=15444.;void main(){vec4 a=1001./e*texture2D(u1,vv0-3.*u8)+2002./e*texture2D(u1,vv0-2.*u8)+3003./e*texture2D(u1,vv0-u8)+3432./e*texture2D(u1,vv0)+3003./e*texture2D(u1,vv0+u8)+2002./e*texture2D(u1,vv0+2.*u8)+1001./e*texture2D(u1,vv0+3.*u8);gl_FragColor=a;}",i:["u8","u1"],j:p,precision:"lowp",B:!0},s38:{h:"uniform sampler2D u1,u11,u29;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);const float g=.1;void main(){vec4 a=texture2D(u11,vv0),b=texture2D(u29,vv0),c=texture2D(u1,vv0),d=max(f*g,b-a*a),h=sqrt(d);gl_FragColor=(c-a)/h;}",i:["u1","u11","u29"],j:{u1:0,u11:1,u29:2},B:!0}},I={s39:{h:"uniform float u17,u30;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-5,1e-5);void main(){vec4 sum=texture2D(u22,vv0);float toSparsity=1.1111;vec2 uvFrom,uvWeight,xyPatch=ZERO2,eps2=EPS2/u17,xyTo=floor(vv0*u17+eps2);float weightSize=toSparsity*u17;vec2 halfFromSparsity=ONE2*(toSparsity-1.)/2.;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.)xyPatch.y=patch_y,uvFrom=(xyTo+HALF2+u30*(xyPatch-halfFromSparsity))/u17,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),uvWeight=(xyTo*toSparsity+xyPatch+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}gl_FragColor=sum,gl_FragColor*=2.2222;}",i:["u17","u14","u15","u22","u30"],vb:["1.1111","gl_FragColor\\*=2.2222;"]},s40:{h:"uniform float u17,u30,u25;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-4,1e-4);void main(){vec4 sum=texture2D(u22,vv0);float fromSparsity=1.1111,shrinkFactor=3.3333;vec2 uvFrom,uvWeight,xyFrom,xyPatchTo,xyPatch=ZERO2,xyShrink=ZERO2,eps2=EPS2/u25,xyTo=floor(vv0*u17+eps2);float weightSize=fromSparsity*u25;vec2 halfFromSparsity=ONE2*(fromSparsity-1.)/2.;float toSparsity=weightSize/u17;vec2 xyFrom0=xyTo*shrinkFactor;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.){xyPatch.y=patch_y;for(float shrink_x=0.;shrink_x<3.3333;shrink_x+=1.){xyShrink.x=shrink_x;for(float shrink_y=0.;shrink_y<3.3333;shrink_y+=1.)xyShrink.y=shrink_y,xyFrom=xyFrom0+xyShrink+shrinkFactor*u30*(xyPatch-halfFromSparsity),uvFrom=(xyFrom+HALF2)/u25,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),xyPatchTo=xyPatch*shrinkFactor+xyShrink,uvWeight=(xyTo*toSparsity+xyPatchTo+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}}}gl_FragColor=sum,gl_FragColor*=2.2222;}",i:"u17 u25 u14 u15 u22 u30".split(" "),vb:["1.1111","gl_FragColor\\*=2.2222;","3.3333"]}},G=null,E=null,k={kb:function(){return s},o:function(){if(!s){for(var e in G=M.Hb(d,2),E=M.Hb(I,2),a="highp",T.getShaderPrecisionFormat&&(T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.MEDIUM_FLOAT),T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.LOW_FLOAT)),G)t(T,G[e]);S.set("s0"),T.enableVertexAttribArray(0),s=!0}},Kc:function(e){e.forEach((function(e){k.Jc(e)}))},Jc:function(e){G[e.id]=e,t(T,e,e.id)},nd:function(e,n,o){n||(n=e),G[n]=Object.create(E[e]),G[n].df=!0,E[e].vb&&E[e].vb.forEach((function(e,t){G[n].h=G[n].h.replace(new RegExp(e,"g"),o[t])})),t(T,G[n])},set:function(e){var n=G[e];n.B&&(n.B=!1,t(T,n)),function(e){R.If(k),A!==e.id&&(k.P(),A=e.id,i=e,T.useProgram(e.qa),e.Ha.forEach((function(e){0!==e&&T.enableVertexAttribArray(e)})))}(n)},Ra:function(e){return n(e,{h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",i:["u1"],j:{u1:0}})},rc:function(e){return n(e,{h:"void main(){gl_FragColor=vec4(.5,.5,.5,.5);}",i:[],precision:a})},Ge:function(e){return void 0!==G[e]&&G[e].oa},P:function(){-1!==A&&(A=-1,i.Ha.forEach((function(e){0!==e&&T.disableVertexAttribArray(e)})))},sc:function(){var e=0;i.Ha.forEach((function(t,n){n=i.Ga[n],T.vertexAttribPointer(t,n,T.FLOAT,!1,i.Bc,e),e+=4*n}))},Wc:function(){T.enableVertexAttribArray(0)},Ba:function(){k.wb(T)},wb:function(e){e.vertexAttribPointer(i.Ha[0],2,e.FLOAT,!1,8,0)},Eh:function(e,t){T.uniform1i(i.A[e],t)},G:function(e,t){T.uniform1f(i.A[e],t)},ra:function(e,t,n){T.uniform2f(i.A[e],t,n)},Fh:function(e,t){T.uniform2fv(i.A[e],t)},Jf:function(e,t){T.uniform3fv(i.A[e],t)},Gh:function(e,t,n,o){T.uniform3f(i.A[e],t,n,o)},Kf:function(e,t,n,o,A){T.uniform4f(i.A[e],t,n,o,A)},Sd:function(e,t){T.uniform4fv(i.A[e],t)},Hh:function(e,t){T.uniformMatrix2fv(i.A[e],!1,t)},Ih:function(e,t){T.uniformMatrix3fv(i.A[e],!1,t)},Jh:function(e,t){T.uniformMatrix4fv(i.A[e],!1,t)},S:function(e,t){k.set(e),t.forEach((function(e){switch(e.type){case"4f":T.uniform4fv(i.A[e.name],e.value);break;case"3f":T.uniform3fv(i.A[e.name],e.value);break;case"2f":T.uniform2fv(i.A[e.name],e.value);break;case"1f":T.uniform1f(i.A[e.name],e.value);break;case"1i":T.uniform1i(i.A[e.name],e.value);break;case"mat2":T.uniformMatrix2fv(i.A[e.name],!1,e.value);break;case"mat3":T.uniformMatrix3fv(i.A[e.name],!1,e.value);break;case"mat4":T.uniformMatrix4fv(i.A[e.name],!1,e.value)}}))},Vg:function(){return"lowp"},m:function(){for(var e in T.disableVertexAttribArray(0),k.P(),G){var t=G[e];t.oa&&(t.oa=!1,T.deleteProgram(t.qa)),t.df&&delete G[e]}o.forEach((function(e){T.deleteShader(e)})),o.splice(0),r=0,s=!1,i=null,A=-1}};return k}(),T=null,N=function(){function e(e){return console.log("ERROR in ContextFF: ",e),!1}function t(e){function t(){Q.m(),W.reset(),A.getExtension("WEBGL_lose_context").loseContext()}if(navigator.userAgent&&-1!==navigator.userAgent.indexOf("forceWebGL1"))return!1;var o=document.createElement("canvas");o.setAttribute("width",5),o.setAttribute("height",5);var A=null;try{A=o.getContext("webgl2",e)}catch(e){return!1}return!!A&&(n(A),W.Xc(A),(e=W.Ib(A)).fa||e.ha?(e=Q.Nc(A,e),t(),!!e):(t(),!1))}function n(e){e.clearColor(0,0,0,0),e.disable(e.DEPTH_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.STENCIL_TEST),e.disable(e.CULL_FACE),e.GENERATE_MIPMAP_HINT&&e.hint(e.GENERATE_MIPMAP_HINT,e.FASTEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.disable(e.SAMPLE_COVERAGE),e.depthFunc(e.LEQUAL),e.clearDepth(1)}var o=null,A=null,i=null,r=null,s=!0,a=null,l=null,m=[],p={F:function(){return o.width},U:function(){return o.height},Mg:function(){return o},Kg:function(){return T},ia:function(){return s},flush:function(){T.flush()},Me:function(){return a||(a=new Uint8Array(o.width*o.height*4)),T.readPixels(0,0,o.width,o.height,T.RGBA,T.UNSIGNED_BYTE,a),a},Og:function(){return o.toDataURL("image/jpeg")},Pg:function(){z.O(),A||(A=document.createElement("canvas"),i=A.getContext("2d")),A.width=o.width,A.height=o.height;for(var e=p.Me(),t=i.createImageData(A.width,A.height),n=A.width,r=A.height,s=t.data,a=0;a<r;++a)for(var l=r-a-1,m=0;m<n;++m){var h=4*(a*n+m),u=4*(l*n+m);s[h]=e[u],s[h+1]=e[u+1],s[h+2]=e[u+2],s[h+3]=e[u+3]}return i.putImageData(t,0,0),A.toDataURL("image/png")},Ng:function(e){!A&&e&&(A=document.createElement("canvas"),i=A.getContext("2d"));var t=e?A:document.createElement("canvas");return t.width=o.width,t.height=o.height,(e?i:t.getContext("2d")).drawImage(o,0,0),t},o:function(A){if((A=Object.assign({ga:null,jc:null,Ua:null,Tc:null,width:512,height:512,premultipliedAlpha:!1,bf:!0,antialias:!1,debug:!1,og:!1},A)).ga?(T=A.ga,o=A.ga.canvas):A.Tc&&!A.Ua?o=document.getElementById(A.Tc):A.Ua&&(o=A.Ua),o||(o=document.createElement("canvas")),o.width=A.width,o.height=A.height,T)s=T instanceof WebGL2RenderingContext;else{s=!0;var i={antialias:A.antialias,alpha:!0,preserveDrawingBuffer:!0,premultipliedAlpha:A.premultipliedAlpha,stencil:!1,depth:A.bf};navigator&&navigator.userAgent&&-1!==navigator.userAgent.indexOf("noAntialiasing")&&(i.antialias=!1);var a=t(i);!a&&i.antialias&&(i.antialias=!1,a=t(i)),a&&(T=o.getContext("webgl2",i)),T?s=!0:((T=o.getContext("webgl",i))||(T=o.getContext("experimental-webgl",i)),s=!1)}return T?(A.jc&&o.addEventListener&&(r=T.getExtension("WEBGL_lose_context"))&&(l=A.jc,o.addEventListener("webglcontextlost",l,!1)),W.o()?(n(T),S.o(),_.o(),Q.Nc(T,W.Le()),m.forEach((function(e){e(T)})),m.splice(0),!0):e("Not enough GL capabilities")):e("WebGL1 and 2 are not enabled")},dg:function(){return new Promise((function(e){T?e(T):m.push(e)}))},m:function(){T&&(W.m(),S.m(),Q.m()),r&&l&&(o.removeEventListener("webglcontextlost",l,!1),r=l=null),T=a=i=A=o=null,m.splice(0)}};return p}(),R=function(){function e(){null===t&&(void 0!==S?t=S:"undefined"!=typeof JEShaders&&(t=JEShaders))}var t=null;return{reset:function(){t=null},If:function(e){t!==e&&(t&&t.P(),t=e)},kb:function(){return t.kb()},Ba:function(){return t.Ba()},wb:function(e){return t.wb(e)},sc:function(){return t.sc()},P:function(){return t.P()},set:function(n){return e(),t.set(n)},Ra:function(n){return e(),t.Ra(n)},rc:function(n){return e(),t.rc(n)}}}(),O=function(){function e(e){T.bindTexture(T.TEXTURE_2D,e)}function t(e){var t=new Uint16Array(e.length);return e.forEach((function(e,n){t[n]=function(e){H[0]=e;var t=(e=F[0])>>16&32768,n=e>>12&2047,o=e>>23&255;return 103>o?t:142<o?31744|t|((255==o?0:1)&&8388607&e):113>o?t|((n|=2048)>>114-o)+(n>>113-o&1):t=(t|o-112<<10|n>>1)+(1&n)}(e)})),t}function o(e,t){if(!R.kb()||!u)return null;var n=null,o=Math.sqrt(e.length/4);try{var A=T.getError();if("FUCKING_BIG_ERROR"===A)return!1;if(n=D.instance({isFloat:!1,R:t,array:e,width:o}),(A=T.getError())!==T.NO_ERROR)return!1}catch(e){return!1}for(V.O(),T.viewport(0,0,o,o),T.clearColor(0,0,0,0),T.clear(T.COLOR_BUFFER_BIT),R.set("s0"),n.Lc(0),U.l(!0,!0),e=4*o*o,t=new Uint8Array(e),T.readPixels(0,0,o,o,T.RGBA,T.UNSIGNED_BYTE,t),o=!0,A=0;A<e;++A)o=o&&3>Math.abs(t[A]-127);return n.remove(),V.da(),o}var A=0,i=null,r=0,s=null,a=null,l=null,m=null,p=null,h=null,u=!1,c=[],d={isFloat:!1,isPot:!0,isLinear:!1,isMipmap:!1,isAnisotropicFiltering:!1,isMirrorX:!1,isMirrorY:!1,isSrgb:!1,isKeepArray:!1,isFlipY:null,width:0,height:0,url:null,array:null,data:null,H:null,Vb:null,cf:!1,R:!1,ma:null,pb:4,dc:0},I=!1,G=null,E=null,k=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],g=!1,f=!1,H=new Float32Array(1),F=new Int32Array(H.buffer),C={Wb:null,Xb:null},D={o:function(){u||(p=[T.RGBA,null,T.RGBA,T.RGBA],h=[T.RGBA,null,T.RGBA,T.RGBA],i=[T.TEXTURE0,T.TEXTURE1,T.TEXTURE2,T.TEXTURE3,T.TEXTURE4,T.TEXTURE5,T.TEXTURE6,T.TEXTURE7],g="undefined"!=typeof JEContext,f=void 0!==W,g&&JEContext.oh()&&i.push(T.TEXTURE8,T.TEXTURE9),s=[-1,-1,-1,-1,-1,-1,-1,-1],m=[T.UNSIGNED_BYTE,T.FLOAT,T.FLOAT],u=!0)},Ze:function(){if(!a){for(var e=new Float32Array(16384),t=0;16384>t;++t)e[t]=2*Math.random()-1;a={random:D.instance({isFloat:!0,isPot:!0,array:e,width:64}),$d:D.instance({isFloat:!1,isPot:!0,width:1,array:new Uint8Array([0,0,0,0])})}}D.Wf()},eh:function(){return a.$d},Wf:function(){m[1]=W.Rb(T)},Gf:function(){h=p=[T.RGBA,T.RGBA,T.RGBA,T.RGBA]},Ld:function(e){S.set("s1"),V.O();var t=e.F(),n=e.U();T.viewport(0,0,t,n),e.g(0),U.l(!1,!1)},vh:function(e,t){D.Ld(e),T.readPixels(0,0,e.F(),e.U(),T.RGBA,T.UNSIGNED_BYTE,t)},wh:function(e,t){return D.Ld(e),W.ub(0,0,e.F(),e.U(),t)},ed:function(e,t,n,o,i,r,a){e.activeTexture(e.TEXTURE0);var m=e.createTexture();e.bindTexture(e.TEXTURE_2D,m),i=i instanceof Float32Array?i:new Float32Array(i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n,o,0,e.RGBA,e.FLOAT,i),e.bindTexture(e.TEXTURE_2D,null),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),a&&(V.da(),S.Ra(e)),e.viewport(0,0,n,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.bindTexture(e.TEXTURE_2D,m),a?U.l(!0,!0):_.$a(e),e.deleteTexture(m),u&&(s[0]=-1,l=null,A=0)},Db:function(e){e!==A&&(T.activeTexture(i[e]),A=e)},instance:function(a){var u;function H(){P=void 0!==y.H.videoWidth?y.H.videoWidth:y.H.width,_=void 0!==y.H.videoHeight?y.H.videoHeight:y.H.height}function F(e){var t=T.getError();return"FUCKING_BIG_ERROR"!==t&&(T.texImage2D(T.TEXTURE_2D,0,ne,oe,Ae,e),(t=T.getError())!==T.NO_ERROR&&oe!==T.RGBA&&(oe=T.RGBA,T.texImage2D(T.TEXTURE_2D,0,ne,oe,Ae,e)),!0)}function J(){if(!X){if(e(L),ie&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,ie),y.isPot?(T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_S,y.isMirrorX?T.MIRRORED_REPEAT:T.REPEAT),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_T,y.isMirrorY?T.MIRRORED_REPEAT:T.REPEAT)):(T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_S,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_T,T.CLAMP_TO_EDGE)),y.isAnisotropicFiltering&&"undefined"!=typeof JESETTINGS&&T.texParameterf(T.TEXTURE_2D,JEContext.Qg().TEXTURE_MAX_ANISOTROPY_EXT,JESETTINGS.$f),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MAG_FILTER,y.isLinear?T.LINEAR:T.NEAREST),y.isLinear?T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,y.isMipmap&&!se?T.NEAREST_MIPMAP_LINEAR:T.LINEAR):T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,y.isMipmap&&!se?T.NEAREST_MIPMAP_NEAREST:T.NEAREST),oe=p[y.pb-1],ne=h[y.pb-1],Ae=m[q],W.ia()){var t=W.Oe();oe===T.RGBA&&Ae===T.FLOAT?y.isMipmap||y.isLinear?ne=Q.Qe(T):W.Oc()?t&&(ne=t):ne=T.RGBA16F||T.RGBA:oe===T.RGB&&Ae===T.FLOAT&&t&&(ne=t,oe=T.RGBA)}if((y.R&&!y.isFloat||y.isFloat&&y.isMipmap&&Q.hf())&&(ne=W.Pe(),Ae=W.Rb(T)),y.dc&&(le=y.dc),y.isSrgb&&4===y.pb&&(oe=JEContext.bh()),y.H)F(y.H);else if(y.url)F(N);else if(O){t=O;try{"FUCKING_BIG_ERROR"!==T.getError()&&(T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,t),T.getError()!==T.NO_ERROR&&(T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,null),T.getError()!==T.NO_ERROR&&T.texImage2D(T.TEXTURE_2D,0,T.RGBA,P,_,0,T.RGBA,T.UNSIGNED_BYTE,null)))}catch(e){T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,null)}y.isKeepArray||(O=null)}else"FUCKING_BIG_ERROR"!==(t=T.getError())&&(T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,null),(t=T.getError())!==T.NO_ERROR&&(oe=T.RGBA,y.R&&Ae!==T.FLOAT&&(Ae=T.FLOAT,T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,null))));if(y.isMipmap)if(!se&&ue)ue.Qb(),me=!0;else if(se){t=Math.log2(Math.min(P,_)),(ae=Array(1+t))[0]=L;for(var n=1;n<=t;++n){var o=Math.pow(2,n),i=P/o;o=_/o;var r=T.createTexture();e(r),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,T.NEAREST),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MAG_FILTER,T.NEAREST),T.texImage2D(T.TEXTURE_2D,0,ne,i,o,0,oe,Ae,null),e(null),ae[n]=r}me=!0}e(null),s[A]=-1,ie&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!1),z=!0,y.ma&&ue&&(y.ma(ue),y.ma=null)}}function v(){for(var e=P*_,t=2*e,n=3*e,o=0;o<e;++o)Y[0][o]=te[o],Y[1][o]=te[o+e],Y[2][o]=te[o+t],Y[3][o]=te[o+n]}function j(){var e=P*_*4;$=[new Uint8Array(e),new Uint8Array(e),new Uint8Array(e),new Uint8Array(e)],Y=[new Float32Array($[0].buffer),new Float32Array($[1].buffer),new Float32Array($[2].buffer),new Float32Array($[3].buffer)],ee=new Uint8Array(4*e),te=new Float32Array(ee.buffer),Z=!0}function K(){u=new Uint8Array(P*_*4),he=new Float32Array(u.buffer),pe=!0}var y=Object.assign({},d,a),b=r++;null===y.isFlipY&&(y.isFlipY=!(!y.url&&!y.array)),y.data&&(y.array="string"==typeof y.data?function(e){var t=JSON.parse(e);e=t.ne;var o=t.nf,A=t.n,i="undefined"==typeof btoa?Buffer.from(t.data,"base64").toString("latin1"):atob(t.data),r=i.length;t=new Uint8Array(r);for(var s=0;s<r;++s)t[s]=i.charCodeAt(s);i=new Float32Array(A),r=new Float32Array(o),s=e+o+1;for(var a=0;a<A;++a){for(var l=s*a,m=0===n(t,l)?1:-1,p=l+1,h=1,u=0,c=p+e-1;c>=p;--c)u+=h*n(t,c),h*=2;for(p=u,l=l+1+e,h=r.length,u=0,c=l;c<l+h;++c)r[u]=n(t,c),++u;for(h=l=0;h<o;++h)l+=r[h]*Math.pow(2,-h-1);i[a]=0===l&&0===p?0:m*(1+l)*Math.pow(2,1+p-Math.pow(2,e-1))}return i}(y.data):y.isFloat?new Float32Array(y.data):new Uint8Array(y.data),y.isFlipY=!1);var q=0,x=!!y.H,B=null,w=null,M=!1;y.R=y.R||y.isFloat,y.R&&(q=1),!y.cf&&y.isFloat&&f&&!W.Oc()&&(y.isFloat=!1),y.isFloat&&(q=2),y.isAnisotropicFiltering&&g&&!JEContext.hh()&&(y.isAnisotropicFiltering=!1);var L=y.Vb||T.createTexture(),N=null,O=!1,P=0,_=0,z=!1,X=!1,Z=!1,Y=null,$=null,ee=null,te=null,ne=null,oe=null,Ae=null,ie=y.isFlipY,re=(a=y.R&&y.isMipmap)&&Q.pe(),se=!(!a||!re),ae=null,le=-1,me=!1,pe=!1,he=u=null;y.width&&(P=y.width,_=y.height?y.height:P);var ue={get:function(){return L},F:function(){return P},U:function(){return _},fh:function(){return y.url},ih:function(){return y.isFloat},kh:function(){return y.R},lh:function(){return y.isLinear},Qb:function(){T.generateMipmap(T.TEXTURE_2D)},me:function(t,n){se?(t||(t=ue.jd()),D.Db(n),e(ae[t]),s[n]=-1):ue.g(n)},jd:function(){return-1===le&&(le=Math.log(P)/Math.log(2)),le},Ie:function(t){if(se){t||(t=ue.jd()),S.set("s12"),D.Db(0);for(var n=P,o=_,A=1;A<=t;++A)n/=2,o/=2,S.ra("u8",.25/n,.25/o),T.viewport(0,0,n,o),e(ae[A-1]),T.framebufferTexture2D(V.cb(),T.COLOR_ATTACHMENT0,T.TEXTURE_2D,ae[A],0),U.l(!1,1===A);s[0]=-1}else ue.Qb()},Dh:function(e){(x=!function(e){return Array.isArray(e)||e.constructor===Float32Array||e.constructor===Uint8Array}(e))?(O=null,y.H=e,H()):O=e},g:function(t){return!!z&&(D.Db(t),s[t]!==b&&(e(L),s[t]=b,!0))},Lc:function(t){T.activeTexture(i[t]),A=t,e(L),s[t]=b},u:function(){l=ue,T.framebufferTexture2D(V.cb(),T.COLOR_ATTACHMENT0,T.TEXTURE_2D,L,0)},$:function(){l=ue,T.viewport(0,0,P,_),T.framebufferTexture2D(V.cb(),T.COLOR_ATTACHMENT0,T.TEXTURE_2D,L,0)},zc:D.zc,resize:function(e,t){P=e,_=t,J()},clone:function(e){return e=D.instance({width:P,height:_,R:y.R,isFloat:y.isFloat,isLinear:y.isLinear,isMirrorY:y.isMirrorY,isFlipY:e?!ie:ie,isPot:y.isPot}),R.set("s0"),V.da(),e.u(),T.viewport(0,0,P,_),ue.g(0),U.l(!0,!0),e},Lf:function(){T.viewport(0,0,P,_)},remove:function(){T.deleteTexture(L),X=!0,c.splice(c.indexOf(ue),1),ue=null},refresh:function(){ue.Lc(0),ie&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!0),x?T.texImage2D(T.TEXTURE_2D,0,ne,oe,Ae,y.H):T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,O),ie&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!1)},Kd:function(){return Z||j(),T.readPixels(0,0,P,4*_,T.RGBA,T.UNSIGNED_BYTE,ee),v(),Y},yf:function(){return Z||j(),W.ub(0,0,P,4*_,ee).then((function(){return v(),Y}))},Af:function(){return pe||K(),T.readPixels(0,0,P,_,T.RGBA,T.UNSIGNED_BYTE,u),he},zf:function(){return pe||K(),W.ub(0,0,P,_,u)},Uc:function(e){if(V.O(),S.set("s13"),ue.g(0),e)T.viewport(0,0,P,_),S.Kf("u9",.25,.25,.25,.25),U.l(!1,!0);else for(e=0;4>e;++e)T.viewport(0,_*e,P,_),S.Sd("u9",k[e]),U.l(!1,0===e)},Bb:function(t){var n=Ae===m[0]&&!function(){if(null!==C.Xb)return C.Xb;var e=o(new Uint8Array([127,127,127,127]),!1);return null===e||(C.Xb=e)}();e(L),ie&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!0),n?(M||((B=document.createElement("canvas")).width=P,B.height=_,(w=B.getContext("2d")).createImageData(P,_),M=!0),null.data.set(t),w.putImageData(null,0,0),T.texImage2D(T.TEXTURE_2D,0,ne,oe,Ae,B)):T.texImage2D(T.TEXTURE_2D,0,ne,P,_,0,oe,Ae,t),s[A]=b,ie&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!1)},Ph:function(t,n){e(L),n&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!0),T.texImage2D(T.TEXTURE_2D,0,ne,oe,Ae,t),s[A]=b,n&&T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL,!1)},Ch:function(e,t){var n=P*_,o=4*n;e=y.R?e?"RGBE":"JSON":"RGBA",t&&(e=t),t=W.ia()&&!1;var A=null;switch(e){case"RGBE":A="s43";break;case"JSON":A=t?"s0":"s13";break;case"RGBA":case"RGBAARRAY":A="s7"}if(Z||("RGBA"===e||"RGBE"===e||"RGBAARRAY"===e?($=new Uint8Array(o),Z=!0):"JSON"!==e||t||j()),V.O(),S.set(A),ue.g(0),o=null,"RGBA"===e||"RGBE"===e||"RGBAARRAY"===e){if(T.viewport(0,0,P,_),U.l(!0,!0),T.readPixels(0,0,P,_,T.RGBA,T.UNSIGNED_BYTE,$),"RGBAARRAY"===e)return{data:$};I||(G=document.createElement("canvas"),E=G.getContext("2d"),I=!0),G.width=P,G.height=_,(n=E.createImageData(P,_)).data.set($),E.putImageData(n,0,0),o=G.toDataURL("image/png")}else if("JSON"===e)if(t)o=new Float32Array(n),T.viewport(0,0,P,_),U.l(!0,!0),T.readPixels(0,0,P,_,T.RGBA,T.FLOAT,o);else{for(o=0;4>o;++o)T.viewport(0,_*o,P,_),S.Sd("u9",k[o]),U.l(!o,!o);for(ue.Kd(),o=Array(n),t=0;t<n;++t)o[4*t]=Y[0][t],o[4*t+1]=Y[1][t],o[4*t+2]=Y[2][t],o[4*t+3]=Y[3][t]}return{format:e,data:o,width:P,height:_,isMirrorY:y.isMirrorY,isFlipY:"RGBA"===e?y.isFlipY:!y.isFlipY}}};if(y.isMipmap&&!se&&z&&!me&&(ue.Qb(),me=!0),y.url)e(L),T.texImage2D(T.TEXTURE_2D,0,T.RGBA,1,1,0,T.RGBA,T.UNSIGNED_BYTE,null),(N=new Image).ng="Anonymous",N.crossOrigin="Anonymous",N.src=y.url,N.onload=function(){P=N.width,_=N.height,J()};else if(y.H){var ce=function(){H(),P?J():setTimeout(ce,1)};ce()}else y.array?(y.R&&!y.isFloat?y.array instanceof Uint16Array?(O=y.array,J()):function(){if(null!==C.Wb)return C.Wb;var e=o(t([.5,.5,.5,.5]),!0);return null===e||(C.Wb=e)}()?(O=t(y.array),J()):(J(),D.ed(T,L,ue.F(),ue.U(),y.array,ie,!0)):(O=y.isFloat?y.array instanceof Float32Array?y.array:new Float32Array(y.array):y.array instanceof Uint8Array?y.array:new Uint8Array(y.array),J()),y.isKeepArray||(O&&O!==y.array&&(O=null),delete y.array)):y.Vb?z=!0:J();return ue.$g=ue.F,y.ma&&z&&(y.ma(ue),y.ma=null),c.push(ue),ue},O:function(t){t!==A&&(T.activeTexture(i[t]),A=t),s[t]=-1,e(null)},cg:function(e){a.random.g(e)},zc:function(){l=null,T.framebufferTexture2D(V.cb(),T.COLOR_ATTACHMENT0,T.TEXTURE_2D,null,0)},reset:function(){0!==A&&T.activeTexture(i[0]);for(var e=0;e<i.length;++e)s[e]=-1;A=-1},zh:function(){A=-1},Tf:function(){for(var e=0;e<i.length;++e)D.O(e)},fd:function(){a&&(a.random.remove(),a.$d.remove())},Oh:function(e,t){if("RGBA"===e.format||"RGBE"===e.format){var n=new Image;n.src=e.data,n.onload=function(){D.instance({isMirrorY:e.isMirrorY,isFlipY:e.isFlipY,isFloat:!1,H:n,ma:function(n){if("RGBA"===e.format)t(n);else{var o=e.width,A=e.height,i=D.instance({isMirrorY:e.isMirrorY,isFloat:!0,width:o,height:A,isFlipY:e.isFlipY});V.da(),T.viewport(0,0,o,A),S.set("s44"),i.u(),n.g(0),U.l(!0,!0),D.O(0),t(i),W.flush(),setTimeout(n.remove,50)}}})}}else"JSON"===e.format?t(D.instance({isFloat:!0,isFlipY:e.isFlipY,width:e.width,height:e.height,array:new Float32Array(e.data)})):t(!1)},ve:t,m:function(){l&&(z.da(),D.zc(),z.O()),D.Tf(),c.slice(0).forEach((function(e){e.remove()})),c.splice(0),u=!1,r=0,void 0!==Q&&Q.m(),a=null}};return D}(),P={instance:function(e){var t=[O.instance(e),O.instance(e)],n=[t[1],t[0]],o=n,A={Df:function(e){o[1].u(),o[0].g(e),A.Vd()},Ef:function(e){o[1].$(),o[0].g(e),A.Vd()},Vd:function(){o=o===t?n:t},refresh:function(){o[0].refresh(),o[1].refresh()},g:function(e){o[0].g(e)},bg:function(e){o[1].g(e)},Ug:function(){return o[0]},Yg:function(){return o[1]},Bb:function(e){o[0].Bb(e),o[1].Bb(e)},remove:function(){o[0].remove(),o[1].remove(),o=null},sync:function(){A.Ef(0),S.set("s0"),_.l(!1,!1)}};return A}},U=function(){function e(e){var t={aa:null,J:null};return t.aa=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,t.aa),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,3,-1,-1,3]),e.STATIC_DRAW),t.J=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.J),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array([0,1,2]),e.STATIC_DRAW),t}var t=null,n=0,o=!1,A=[],i=-2,r=-2,s={reset:function(){r=i=-2},o:function(){o||(t=e(T),s.ua(),o=!0)},instance:function(e){var t=n++,o=e.J?e.J.length:0,s=void 0===e.mode?T.STATIC_DRAW:e.mode,a=T.createBuffer();T.bindBuffer(T.ARRAY_BUFFER,a),T.bufferData(T.ARRAY_BUFFER,e.aa instanceof Float32Array?e.aa:new Float32Array(e.aa),s),i=t;var l=null,m=null,p=null;if(e.J){l=T.createBuffer(),T.bindBuffer(T.ELEMENT_ARRAY_BUFFER,l);var h=null;65536>e.J.length?(h=Uint16Array,m=T.UNSIGNED_SHORT,p=2):(h=Uint32Array,m=T.UNSIGNED_INT,p=4),h=e.J instanceof h?e.J:new h(e.J),T.bufferData(T.ELEMENT_ARRAY_BUFFER,h,s),r=t}var u={oe:function(e){i!==t&&(T.bindBuffer(T.ARRAY_BUFFER,a),i=t),e&&R.sc()},ke:function(){r!==t&&(T.bindBuffer(T.ELEMENT_ARRAY_BUFFER,l),r=t)},bind:function(e){u.oe(e),u.ke()},rg:function(){T.drawElements(T.TRIANGLES,o,m,0)},sg:function(e,t){T.drawElements(T.TRIANGLES,e,m,t*p)},remove:function(){T.deleteBuffer(a),e.J&&T.deleteBuffer(l),u=null}};return A.push(u),u},ua:function(){-1!==i&&(T.bindBuffer(T.ARRAY_BUFFER,t.aa),i=-1),-1!==r&&(T.bindBuffer(T.ELEMENT_ARRAY_BUFFER,t.J),r=-1)},l:function(e,t){e&&U.ua(),t&&R.Ba(),T.drawElements(T.TRIANGLES,3,T.UNSIGNED_SHORT,0)},$a:function(t){var n=e(t=t||T);t.bindBuffer(t.ARRAY_BUFFER,n.aa),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n.J),R.wb(t),t.clear(t.COLOR_BUFFER_BIT),t.drawElements(t.TRIANGLES,3,t.UNSIGNED_SHORT,0),t.flush(),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.deleteBuffer(n.aa),t.deleteBuffer(n.J),s.reset(),o&&(s.ua(),R.Ba())},fd:function(){var e=T,n=t;e.deleteBuffer(n.aa),e.deleteBuffer(n.J)},m:function(){s.fd(),A.forEach((function(e){e.remove()})),T.bindBuffer(T.ARRAY_BUFFER,null),T.bindBuffer(T.ELEMENT_ARRAY_BUFFER,null),s.reset(),o=!1,A.splice(0),n=0}};return s}(),V=(v=null,j=null,K=null,y=!1,b=[],q={I:-2,dd:1},x={kb:function(){return y},o:function(){if(!y){v=T.createFramebuffer();var e=W.ia();j=e&&T.DRAW_FRAMEBUFFER?T.DRAW_FRAMEBUFFER:T.FRAMEBUFFER,K=e&&T.READ_FRAMEBUFFER?T.READ_FRAMEBUFFER:T.FRAMEBUFFER,y=!0}},Rg:function(){return j},Re:function(){return K},cb:function(){return T.FRAMEBUFFER},Zg:function(){return q},Jg:function(){return v},instance:function(e){void 0===e.qd&&(e.qd=!1);var t=e.M?e.M:null,n=e.width,o=void 0!==e.height?e.height:e.width,A=v,i=null,r=!1,s=!1,a=0;t&&(n=n||t.F(),o=o||t.U());var l={Rd:function(){r||(A=T.createFramebuffer(),r=!0,a=q.dd++)},fe:function(){l.Rd(),l.u(),i=T.createRenderbuffer(),T.bindRenderbuffer(T.RENDERBUFFER,i),T.renderbufferStorage(T.RENDERBUFFER,T.DEPTH_COMPONENT16,n,o),T.framebufferRenderbuffer(j,T.DEPTH_ATTACHMENT,T.RENDERBUFFER,i),T.clearDepth(1)},bind:function(e,i){a!==q.I&&(T.bindFramebuffer(j,A),q.I=a),t&&t.u(),i&&T.viewport(0,0,n,o),e&&T.clear(T.COLOR_BUFFER_BIT|T.DEPTH_BUFFER_BIT)},ag:function(){a!==q.I&&(T.bindFramebuffer(j,A),q.I=a)},clear:function(){T.clear(T.COLOR_BUFFER_BIT|T.DEPTH_BUFFER_BIT)},jg:function(){T.clear(T.COLOR_BUFFER_BIT)},kg:function(){T.clear(T.DEPTH_BUFFER_BIT)},Lf:function(){T.viewport(0,0,n,o)},u:function(){a!==q.I&&(T.bindFramebuffer(j,A),q.I=a)},rtt:function(e){t=e,q.I!==a&&(T.bindFramebuffer(T.FRAMEBUFFER,A),q.I=a),e.u()},O:function(){T.bindFramebuffer(j,null),q.I=-1},resize:function(e,t){n=e,o=t,i&&(T.bindRenderbuffer(T.RENDERBUFFER,i),T.renderbufferStorage(T.RENDERBUFFER,T.DEPTH_COMPONENT16,n,o))},remove:function(){A===v||s||(T.bindFramebuffer(j,A),T.framebufferTexture2D(j,T.COLOR_ATTACHMENT0,T.TEXTURE_2D,null,0),i&&T.framebufferRenderbuffer(j,T.DEPTH_ATTACHMENT,T.RENDERBUFFER,null),T.bindFramebuffer(j,null),T.deleteFramebuffer(A),i&&T.deleteRenderbuffer(i)),s=!0}};return e.qd&&l.fe(),b.push(l),l},O:function(){T.bindFramebuffer(j,null),q.I=-1},Uf:function(){T.bindFramebuffer(j,null),T.clear(T.COLOR_BUFFER_BIT|T.DEPTH_BUFFER_BIT),W.Td(),q.I=-1},reset:function(){q.I=-2},da:function(){0!==q.I&&(T.bindFramebuffer(j,v),q.I=0)},clear:function(){W.Td(),T.clear(T.COLOR_BUFFER_BIT)},m:function(){x.O(),b.forEach((function(e){e.remove()})),null!==v&&(T.deleteFramebuffer(v),v=null),x.reset(),y=!1,b.splice(0),q.dd=1}}),W=function(){function e(){A=void 0===N?JEContext:N,i=!0}function t(e,t){for(var n=0;n<e.length;++n){var o=t.getExtension(e[n]);if(o)return o}return null}function n(){null!==u.Ab&&(clearInterval(u.Ab),u.Ab=null),u.ya=!1}function o(){u.Ma&&(T.deleteSync(u.Ma),u.Ma=null)}var A=null,i=!1,r={sd:!1,uc:null,vc:null,vd:!1,gf:!1,wc:null,wd:!1,xc:null,td:!1,Fb:null,$e:!1,Gb:null,af:!1},s=null,a={fa:!0,ha:!0,Pb:!0,Jd:!1},l=null,m=!0,p=null,h=null,u={ya:!1,wa:null,Ma:null,Ub:-1,V:null,Ab:null},c="undefined"==typeof window?{}:window,d={o:function(){if(i)return!0;d.reset(),i||e();var t=T;return s.sd||(s.uc=d.$c(t),c.GL_EXT_FLOAT=s.uc,s.vd=!!s.uc,(s.vd||d.ia())&&(s.vc=d.ad(t),s.gf=!!s.vc,c.GL_EXT_FLOATLINEAR=s.vc),s.sd=!0),s.td||(s.wc=d.Ya(t),s.wc&&(s.wd=!0,c.GL_EXT_HALFFLOAT=s.wc),(s.wd||d.ia())&&(s.xc=d.bd(t),c.GL_EXT_HALFFLOATLINEAR=s.xc),s.gh=!!s.xc,s.td=!0),s.Fb=d.Yc(t),s.$e=!!s.Fb,c.GL_EXT_COLORBUFFERFLOAT=s.Fb,s.Gb=d.Zc(t),s.af=!!s.Gb,c.GL_EXT_COLORBUFFERHALFFLOAT=s.Gb,V.o(),O.o(),!!d.ye()&&(U.o(),O.Ze(),!0)},reset:function(){s=Object.assign({},r),l=Object.assign({},a)},F:function(){return i||e(),A.F()},U:function(){return i||e(),A.U()},ia:function(){return i||e(),A.ia()},Xc:function(e){d.Yc(e),d.Zc(e),d.$c(e),d.ad(e),d.Ya(e),d.bd(e)},Yc:t.bind(null,["EXT_color_buffer_float","WEBGL_color_buffer_float","OES_color_buffer_float"]),Zc:t.bind(null,["EXT_color_buffer_half_float","WEBGL_color_buffer_half_float","OES_color_buffer_half_float"]),$c:t.bind(null,["OES_texture_float","MOZ_OES_texture_float","WEBKIT_OES_texture_float"]),ad:t.bind(null,["OES_texture_float_linear","MOZ_OES_texture_float_linear","WEBKIT_OES_texture_float_linear"]),Ya:t.bind(null,["OES_texture_half_float","MOZ_OES_texture_half_float","WEBKIT_OES_texture_half_float"]),bd:t.bind(null,["OES_texture_half_float_linear","MOZ_OES_texture_half_float_linear","WEBKIT_OES_texture_half_float_linear"]),Rb:function(e){var t=d.Ya(e);return t&&t.HALF_FLOAT_OES?t.HALF_FLOAT_OES:e.HALF_FLOAT||e.FLOAT},Oe:function(){return h||T.RGBA32F||T.RGBA},Pe:function(){return p||T.RGBA16F||T.RGBA},Le:function(){return l},Oc:function(){return l.fa},fg:function(){return l.ha},eg:function(){return l.Pb},qe:function(){return l.Jd&&m},Yd:function(e){m=e,!e&&u.ya&&(o(),T.bindBuffer(u.V,null),u.ya=!1)},mh:function(){return u.ya},xb:function(e,t,n){function o(){e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(A,null),e.deleteTexture(s),e.deleteFramebuffer(r)}var A=e.FRAMEBUFFER,i=e.NEAREST,r=e.createFramebuffer();e.bindFramebuffer(A,r);var s=e.createTexture();if(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,s),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,i),e.texImage2D(e.TEXTURE_2D,0,t,3,3,0,e.RGBA,n,null),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0),e.checkFramebufferStatus(e.READ_FRAMEBUFFER||e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE)return o(),!1;for(R.rc(e),e.clearColor(0,0,0,0),e.viewport(0,0,3,3),e.disable(e.DEPTH_TEST),e.clear(e.COLOR_BUFFER_BIT),U.$a(e),e.bindFramebuffer(A,null),R.Ra(e),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,s),U.$a(e),t=new Uint8Array(36),e.readPixels(0,0,3,3,e.RGBA,e.UNSIGNED_BYTE,t),o(),n=0;36>n;++n)if(3!=n%4&&3<Math.abs(t[n]-127))return!1;return!0},Ib:function(e){var t={fa:!1,ha:!1};e.disable(e.BLEND),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.RGBA32F&&d.xb(e,e.RGBA32F,e.FLOAT)&&(t.fa=!0,h=e.RGBA32F),!t.fa&&d.xb(e,e.RGBA,e.FLOAT)&&(t.fa=!0,h=e.RGBA);var n=d.Rb(e);return p=null,e.RGBA16F&&d.xb(e,e.RGBA16F,n)&&(t.ha=!0,p=e.RGBA16F),!t.ha&&d.xb(e,e.RGBA,n)&&(t.ha=!0,p=e.RGBA),t},ze:function(){var e=V.instance({width:2});e.Rd();var t=O.instance({width:2,isFloat:!0,pb:3});e.u(),t.u(),d.flush(),T.checkFramebufferStatus(V.Re())!==T.FRAMEBUFFER_COMPLETE?(O.Gf(),l.Pb=!1):l.Pb=!0,e.remove(),t.remove()},Ae:function(){var e=!1;d.ia()&&(e="PIXEL_PACK_BUFFER STREAM_READ SYNC_GPU_COMMANDS_COMPLETE WAIT_FAILED fenceSync deleteSync createBuffer".split(" ").every((function(e){return void 0!==T[e]}))),l.Jd=e},ye:function(){var e=d.Ib(T);return Object.assign(l,e),!(!l.fa&&!l.ha||(d.ze(),d.Ae(),0))},Bf:function(e,t,n,o,A){return T.readPixels(e,t,n,o,T.RGBA,T.UNSIGNED_BYTE,A),Promise.resolve(A,!1)},ub:function(e,t,A,i,r,s){if(!d.qe())return d.Bf(e,t,A,i,r);null===u.wa&&(u.V=T.PIXEL_PACK_BUFFER,u.wa=T.createBuffer(),u.Ub=-1),T.bindBuffer(u.V,u.wa),r.byteLength!==u.Ub&&(T.bufferData(u.V,r.byteLength,T.STREAM_READ),u.Ub=r.byteLength),T.readPixels(e,t,A,i,T.RGBA,T.UNSIGNED_BYTE,0),u.Ma=T.fenceSync(T.SYNC_GPU_COMMANDS_COMPLETE,0),d.flush();var a=!1;return new Promise((function(e,t){function A(){if(!u.ya)return n(),t(),!1;switch(T.clientWaitSync(u.Ma,0,0)){case T.TIMEOUT_EXPIRED:case T.WAIT_FAILED:return!1;default:return n(),o(),T.getBufferSubData(u.V,0,r),T.bindBuffer(u.V,null),e(r,a),!0}}n(),u.ya=!0,A()||(s&&!a&&(a=!0,s()),u.Ab=setInterval(A,0))}))},Td:function(){T.viewport(0,0,d.F(),d.U())},flush:function(){T.flush()},m:function(){n(),o(),O.m(),V.m(),U.m(),null!==u.wa&&(T.deleteBuffer(u.wa),u.wa=null),R.reset(),i=!1}};return d}(),_=U,z=V,X=O,Q=function(){function e(e,t,n,o){I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MIN_FILTER,o?I.NEAREST_MIPMAP_NEAREST:I.LINEAR);var A=null;if(null!==n)try{if("FUCKING_BIG_ERROR"===(A=I.getError()))return!1;if(I.texImage2D(I.TEXTURE_2D,0,e,4,4,0,I.RGBA,t,n),(A=I.getError())!==I.NO_ERROR)return!1}catch(e){return!1}if(o&&I.generateMipmap(I.TEXTURE_2D),I.clear(I.COLOR_BUFFER_BIT),_.$a(I),"FUCKING_BIG_ERROR"===(A=I.getError()))return!1;if(I.readPixels(0,0,2,2,I.RGBA,I.UNSIGNED_BYTE,m),(A=I.getError())===I.INVALID_OPERATION&&void 0!==I.PIXEL_PACK_BUFFER&&(I.bindBuffer(I.PIXEL_PACK_BUFFER,null),I.readPixels(0,0,2,2,I.RGBA,I.UNSIGNED_BYTE,m),A=I.getError()),A!==I.NO_ERROR)return!1;for(n=!0,o=0;16>o;++o)n=n&&4>Math.abs(m[o]-127);return n&&(a.Gd=t,a.pd=e),n}function t(t,n){return!(!G.fa||!e(t,I.FLOAT,new Float32Array(p),n)||(s=r.Hc,0))}function n(t,n,o){if(!G.ha)return!1;var A=O.ve(p),i=W.Ya(I);return i&&i.HALF_FLOAT_OES&&e(t,i.HALF_FLOAT_OES,A,n)||I.HALF_FLOAT&&e(t,I.HALF_FLOAT,A,n)?(s=r.Fa,!0):(A=new Float32Array(p),e(t,I.FLOAT,A,n)?(s=r.Fa,!0):(I.bindTexture(I.TEXTURE_2D,o),I.texImage2D(I.TEXTURE_2D,0,I.RGBA,2,2,0,I.RGBA,I.UNSIGNED_BYTE,null),I.bindFramebuffer(a.Wa,g),O.ed(I,o,2,2,A,!1,!1),I.bindFramebuffer(a.Wa,null),I.bindTexture(I.TEXTURE_2D,o),!!e(t,null,null,n)&&(s=r.Fa,!0)))}function o(e,o,A){return l=!0,!!(n(e,!0,A)||t(o,!0)||(l=!1,n(e,!1,A)||t(o,!1)))}function A(e){if(s===r.P){I=e||T,s=r.RGBA8,l=!0,W.Xc(I),G||(G=W.Ib(I)),z.reset(),g=I.createFramebuffer(),a.Wa=I.DRAW_FRAMEBUFFER||I.FRAMEBUFFER,I.bindFramebuffer(a.Wa,null),I.clearColor(0,0,0,0),I.viewport(0,0,2,2),S.P(),E=S.Ra(I),e=I.createTexture(),I.activeTexture(I.TEXTURE0),I.bindTexture(I.TEXTURE_2D,e),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_S,I.REPEAT),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_T,I.REPEAT),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MAG_FILTER,I.NEAREST),k=e;var t=e=I.RGBA,n=I.RGBA16F,A=I.RGBA32F;return A&&(e=A),n&&(t=n),(n||A)&&o(t,e,k)?(i(),!0):(e=t=I.RGBA,o(t,e,k)?(i(),!0):(s=r.RGBA8,i(),!1))}}function i(){I.deleteProgram(E.qa),I.deleteTexture(k),k=E=null}for(var r={P:-1,Hc:3,Fa:2,RGBA8:0},s=r.P,a={Gd:null,pd:null,Wa:null},l=!0,m=new Uint8Array(16),p=Array(64),h=0;4>h;++h)for(var u=0;4>u;++u){var c=0==(u+h)%2?1:0,d=4*h+u;p[4*d]=c,p[4*d+1]=c,p[4*d+2]=c,p[4*d+3]=c}var I=null,G=null,E=null,k=null,g=null;return{pe:function(e){return A(e),l},Nc:function(e,t){return s===r.P&&(typeof("undefined"!==t)&&(G=t),A(e)),s!==r.RGBA8},jh:function(e){return A(e),s===r.Hc},hf:function(e){return A(e),s===r.Fa},Sg:function(e){return A(e),a.Gd},Qe:function(e){return A(e),a.pd},m:function(){I=null,l=!0,s=r.P,G=null}}}(),Z=function(e){var t=X.instance(e.alpha),n=X.instance(e.beta);return{Ce:function(){t.g(1),n.g(2)}}},Y={instance:function(e){var t=null,n=!1,o=!1,A=null,i=!1,r=!1,s=null,a=void 0!==e.preprocessing&&e.preprocessing,l=void 0===e.preprocessingSize?e.size:e.preprocessingSize;e.mask&&(n=!0,he&&void 0!==he.je&&(e.mask=he.je+e.mask),t=X.instance({isFloat:!1,url:e.mask}));var m=!1;switch(e.customInputShader&&(m="s45",S.Jc({name:"_",id:m,h:e.customInputShader,Nh:["uSource"],precision:"lowp"}),S.S(m,[{type:"1i",name:"_",value:0}])),a){case"sobel":s="s32",i=!0;break;case"meanNormalization":s="s33",i=!0;break;case"grayScale":s="s29",i=!1;break;case"grayScaleTilt":s="s30",r=!0,i=!1;break;case"rgbGrayTilt":s="s31",r=!0,i=!1;break;case"copy":s=m||"s0";break;case"inputLightRegulation":s=m||"s29",A=ie.instance({od:l,Fd:e.size,Cd:e.nBlurPass,jb:!1}),o=!0;break;case"inputMix0":s="none",A=re.instance({C:l,ae:e.varianceMin,Mc:e.blurKernelSizePx,jb:!1}),o=!0;break;case"direct":case"none":s="abort";break;default:s="s4"}r&&S.S(s,[{name:"u27",type:"1f",value:e.tilt}]),n&&(s+="Mask");var p=X.instance({isFloat:!1,isPot:!1,width:e.size}),h={F:function(){return l},Sb:function(){return h.F()},Ve:function(){return o?A.Tb():p},T:function(r){z.da(),"abort"!==s&&("none"!==s&&(S.set(s),i&&S.G("u28",1/e.size),p.$(),n&&t.g(1),_.l(!1,!1),p.g(0),r=p),o&&A.process(r))},m:function(){p.remove(),n&&t.remove()}};return h}},$={instance:function(e){function t(e){return A.forEach((function(t,n){i[n][0]=e[0][t],i[n][1]=e[1][t],i[n][2]=e[2][t],i[n][3]=e[3][t]})),i}e.normalize=e.normalize||!1;var n={input:null,bias:null,Yb:null,Z:null,qb:null,lc:null,mc:null},o=null,A=[],i=[],r=!1,s=null,a=!0,l=-1,m=!!e.isReorganize&&e.isReorganize,p=!!e.kernelsCount,h=!!e.dynPelu&&Z(e.dynPelu),u=!!h,c={isEnabled:!1};e.ef?(e.sparsity=void 0!==e.sparsity?e.sparsity:e.sb.Sb(),a=!1):"full"===e.connectivityUp&&(e.sparsity=e.sb.Sb());var d={elu:"s16",elu01:"s17",relu:"s15",arctan:"s19",sigmoid:"s14",copy:"s0",softplus:"s20",dynPelu:"s18"}[e.activation],I=e.sparsity*e.sparsity,G=!1,E=e.size,k="";if(e.maxPooling){switch(e.maxPooling.size){case 2:k="s34";break;case 4:k="s35"}G=!0,E/=e.maxPooling.size,n.lc=X.instance({isFloat:!0,isPot:!1,width:E})}var g=!!e.normalization,f=null,H=null,F=null;if(g){f="s46"+e.index.toString(),S.nd("s46",f,[((e.normalization.n-1)/2).toFixed(1)]),S.S(f,[{type:"1i",name:"u1",value:0},{type:"2f",name:"u8",value:[1/e.size,1/e.size]},{type:"1f",name:"u7",value:e.normalization.alpha},{type:"1f",name:"u10",value:e.normalization.beta},{type:"1f",name:"u31",value:e.normalization.k}]);var C={isFloat:!0,isPot:!0,width:e.size};H=X.instance(C),F=X.instance(C)}var D=-1,J=null;a&&(n.Z=X.instance({isFloat:!0,isPot:!1,width:e.size})),n.bias=X.instance(e.bias);var v={F:function(){return e.size},Sb:function(){return E},gd:function(){return e.classesCount},le:function(e){o.g(e)},vf:function(){e.remap&&e.remap.isEnabled&&(c={isEnabled:!0,lf:X.instance({isFloat:!1,isFlipY:!1,array:new Uint8Array(e.remap.maskTexture.data),width:e.remap.maskTexture.width,isPot:!1}),mb:e.remap.layers.map((function(t){return e.parent.Te(t)})),depth:e.remap.depth})},Hf:function(){switch(e.connectivityUp){case"direct":J=ee.instance(e.connectivity);break;case"square":J=ne.instance(e.connectivity);break;case"squareFast":J=Ae.instance(e.connectivity,e.activation);break;case"full":J=te.instance(e.connectivity);break;case"conv":l=e.kernelsCount,J=oe.instance(e.connectivity),m&&(n.qb=X.instance({width:E,isFloat:!0,isFlipY:!1,isPot:!1}))}if(J.Ca){var t=e.size*e.sparsity;D=Math.log(t/e.size)/Math.log(2),n.input=X.instance({isMipmap:!0,isFloat:!0,isPot:!0,width:t,dc:D}),n.Yb=X.instance({isFloat:!0,isPot:!0,width:e.size})}},T:function(t,A){if(o=t,J.Ca?(n.input.$(),p&&n.bias.g(2),J.T(c),n.input.g(0),n.input.Ie(D),n.Yb.$(),p?S.set("s0"):(S.set("s28"),S.G("u26",I),n.bias.g(1)),n.input.me(D,0),_.l(!1,!1),S.set(d),g?H.u():n.Z.u(),n.Yb.g(0),u&&h.Ce(),_.l(!1,!1)):(n.Z.$(),n.bias.g(1),J.T()),g&&(S.set(f),F.u(),H.g(0),_.l(!1,!1),S.set("s47"),S.G("u7",1),n.Z.u(),F.g(1),_.l(!1,!1)),a)return G?(n.lc.$(),n.Z.g(0),S.set(k),S.ra("u8",1/e.size,1/e.size),_.l(!1,!1),A=n.lc):A=n.Z,A.g(0),m&&(n.qb.u(),S.set("s22"),S.ra("u13",l,E/l),_.l(!1,!1),A=n.qb,n.qb.g(0)),A;var i=n.Z;switch(e.normalize&&(S.set("gpuRawAvg"===r?"s9":"s8"),S.G("u4",1/e.size),n.mc.$(),n.Z.g(0),_.l(!1,!1),i=n.mc),t=null,r){case"cpuRGBA2Float":i.Uc(!1),A?t=v.wf(i).then(s):(i=v.xf(i),s(i));break;case"cpuMeanFloat":if(i.Uc(!0),A)t=i.zf().then(s);else{i=i.Af();for(var C=0;C<i.length;++C);s(i)}break;case"gpuRawAvg":case"gpuRaw":i.g(0);case"none":null!==s&&s(i)}return A&&null===t&&(t=Promise.resolve()),t},xe:function(t){t&&(r=t.nc||"none",s=t.kc||null),n.Z=X.instance({isFloat:!0,isPot:!0,isMipmap:!1,width:e.size}),t=void 0!==e.classesCount&&e.classesCount?e.classesCount:e.size*e.size;for(var o=0,a=0,l=0;o<t;++o)A.push(a+(e.size-1-l)*e.size),i.push([-1,-1,-1,-1]),++a===e.size&&(a=0,++l);e.normalize&&(n.mc=X.instance({isFloat:!0,isPot:!0,width:e.size}))},wf:function(e){return e.yf().then(t)},xf:function(e){return t(e=e.Kd()),i},m:function(){for(var e in n){var t=n[e];t&&t.remove()}J&&(J.m(),J=null)}};return e.sb&&v.Hf(e.sb),v}},ee={instance:function(e){var t=X.instance(e.weights);return{Ca:!0,bb:function(){return 1},m:function(){t.remove()},Ye:function(){return t},T:function(){S.set("s27"),t.g(1),_.l(!1,!1)}}}},te={instance:function(e){var t=e.fromLayerSize,n=X.instance(e.weights);return{Ca:!0,bb:function(){return t},m:function(){n.remove()},T:function(t){if(t.isEnabled){S.set("s25"),t.lf.g(3);var o,A=Math.min(t.mb.length,t.depth);for(o=0;o<A;++o)t.mb[o].le(4+o)}else S.set("s24");S.G("u17",e.toLayerSize),n.g(1),_.l(!1,!1)}}}},ne={instance:function(e){for(var t=e.fromLayerSize,n=e.toLayerSize,o=e.toSparsity,A=o*n,i=A/t,r=t/n,s=0,a=0,l=Array(o*n*o*n*4),m=Array(o*n*o*n*4),p=Array(t*t),h=0;h<p.length;++h)p[h]=0;h=Math.floor(o/2);for(var u=.5/n,c=.5/t,d=.5/A,I=0;I<n;++I)for(var G=Math.round(I*r),E=0;E<n;++E){var k=Math.round(E*r),g=I/n,f=E/n;g+=u,f+=u;for(var H=0;H<o;++H){var F=G+H-h;0>F&&(F+=t),F>=t&&(F-=t);for(var C=0;C<o;++C){var D=s/A,J=a/A,v=k+C-h;0>v&&(v+=t),v>=t&&(v-=t);var j=F/t,K=v/t;J=1-J-1/A,j+=c,K+=c,D+=d,J+=d;var y=I*o+H,b=E*o+C;l[4*(y=(b=n*o-b-1)*n*o+y)]=D,l[4*y+1]=J,l[4*y+2]=j,l[4*y+3]=K,K=p[v*t+F]++,m[4*(v=(v=t*i-1-(v=v*i+(K-(y=K%i))/i))*t*i+(j=F*i+y))]=D,m[4*v+1]=J,m[4*v+2]=g,m[4*v+3]=f,++s>=A&&(s=0,++a)}}}p=null;var q=X.instance(e.weights);delete e.weights.data;var x=X.instance({width:A,isFloat:!0,array:new Float32Array(m),isPot:!0});m=null;var B=X.instance({width:A,isFloat:!0,array:new Float32Array(l),isPot:!0});return l=null,{Ca:!0,bb:function(){return i},m:function(){x.remove(),B.remove(),q.remove()},T:function(){S.set("s23"),q.g(1),B.g(2),_.l(!1,!1)}}}},oe={instance:function(e){var t=e.kernelsCount,n=e.toSparsity,o=n*e.toLayerSize/e.fromLayerSize,A=X.instance(e.weights);return{Ca:!0,bb:function(){return o},dh:function(){return n},Ye:function(){return A},m:function(){A.remove()},T:function(){S.set("s26"),S.G("u23",t),S.G("u24",n),S.G("u17",e.toLayerSize),S.G("u25",e.fromLayerSize),A.g(1),_.l(!1,!1)}}}},Ae={instance:function(e,t){var n=e.fromLayerSize,o=e.toLayerSize,A=e.toSparsity,i=e.stride?e.stride:1,r=A*o/n,s=o<n,a=n/o,l=X.instance(e.weights),m="s48"+[n.toString(),o.toString(),A.toString(),i.toString(),t].join("_");return S.Ge(m)||(e=function(e,t,n){switch(e){case"relu":return n+"=max(vec4(0.,0.,0.,0.),"+t+");";case"elu":return n+"=mix(exp(-abs("+t+"))-vec4(1.,1.,1.,1.),"+t+",step(0.,"+t+"));";case"elu01":return n+"=mix(0.1*exp(-abs("+t+"))-vec4(0.1,0.1,0.1,0.1),"+t+",step(0.,"+t+"));";case"arctan":return n+"=atan(3.14159265359*texture2D(u0,vUV))/3.14159265359;";case"copy":return"";default:return!1}}(t,"gl_FragColor","gl_FragColor"),o=[{type:"1f",name:"u17",value:o},{type:"1f",name:"u30",value:i}],s&&o.push({type:"1f",name:"u25",value:n}),n=[(s?r:A).toFixed(1),e],s&&n.push(a.toFixed(1)),S.nd(s?"s40":"s39",m,n),S.S(m,o.concat([{type:"1i",name:"u15",value:0},{type:"1i",name:"u22",value:1},{type:"1i",name:"u14",value:3}]))),{Ca:!1,bb:function(){return r},m:function(){l.remove()},T:function(){S.set(m),l.g(3),_.l(!1,!1)}}}},ie={instance:function(e){var t=e.Cd?e.Cd:3,n=e.od?e.od:64,o=e.Fd?e.Fd:64,A=!!e.jb;e={isFloat:!1,width:n,isPot:!1,isFlipY:!1};var i=X.instance(e),r=X.instance(e),s=X.instance(e),a=X.instance(e),l=X.instance({isFloat:!0,width:o,isPot:!1,isFlipY:!1}),m=1/n;return{process:function(e){S.set("s36"),a.u(),_.l(A,!1),S.set("s37");for(var n=0;n<t;++n)i.u(),S.ra("u8",m,0),_.l(A,!1),s.u(),a.g(0),_.l(A,!1),r.u(),i.g(0),S.ra("u8",0,m),_.l(A,!1),a.u(),s.g(0),_.l(A,!1),n!==t-1&&r.g(0);S.set("s38"),l.u(),e.g(0),r.g(1),a.g(2),_.l(A,!1),l.g(0)},Tb:function(){return l}}}},re={instance:function(e){function t(e){return X.instance({isFloat:e,width:n.C,isPot:!1,isFlipY:!1})}var n=Object.assign({ae:.1,Mc:9,C:128,jb:!1},e),o=t(!1),A=[t(!1),t(!1),t(!1)],i=[t(!1),t(!1),t(!1)],r=t(!0),s=[o,i[0],i[1]];e="uniform sampler2D u1;const float e=1.1111,g=2.2222;uniform vec2 u32;varying vec2 vv0;void main(){float b=0.,c=0.;for(float a=-e;a<=e;a+=1.){vec2 i=u32*a,j=vv0+i*g;float d=1.2*a/e,f=exp(-d*d);b+=f*texture2D(u1,j).r,c+=f;}b/=c,gl_FragColor=vec4(b,0.,0.,1.);}".replace("1.1111",Math.round((n.Mc-1)/2).toFixed(2)).replace("2.2222",(1/n.C).toFixed(6));var a={u1:0};return S.Kc([{id:"s50",name:"_",h:"uniform sampler2D u1;varying vec2 vv0;const vec3 f=vec3(.2126,.7152,.0722),g=vec3(1.,1.,1.);void main(){vec3 b=texture2D(u1,vv0).rgb;float a=dot(b,f);gl_FragColor=vec4(a,a,a,a);}",j:a,i:["u1"],precision:"lowp"},{id:"s51",name:"_",h:e,j:a,i:["u1","u32"],precision:"lowp"},{id:"s52",name:"_",h:"uniform sampler2D u33,u34,u35,u36;const float f=1.1111;const vec3 g=vec3(1.,1.,1.);varying vec2 vv0;void main(){vec3 a=texture2D(u33,vv0).rgb;float c=texture2D(u34,vv0).r,d=texture2D(u35,vv0).r,h=texture2D(u36,vv0).r,i=a.r*a.r;vec3 b=vec3(c,d,h),j=max(g*f,abs(i-b*b)),k=sqrt(j);gl_FragColor=vec4(a.r,(a-b)/k);}".replace("1.1111",n.ae.toFixed(4)),j:{u33:0,u34:1,u35:2,u36:3},i:["u33","u34","u35","u36"],precision:"highp"}]),{process:function(){S.set("s50"),o.$(),_.l(n.jb,!1),S.set("s51");for(var e=0;3>e;++e)S.ra("u32",1,0),A[e].u(),s[e].g(0),_.l(!1,!1),S.ra("u32",0,1),i[e].u(),A[e].g(0),_.l(!1,!1);S.set("s52"),r.u(),o.g(0),i[0].g(1),i[1].g(2),i[2].g(3),_.l(!1,!1),r.g(0)},Tb:function(){return r}}}},se={ld:function(){return!!se.Sc()&&document.createElement("video")},Ka:function(e,t){e[t]=!0,e.setAttribute(t,"true")},te:function(){var e=!1,t=navigator.userAgent||navigator.vendor||window.opera;return(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)))&&(e=!0),e},Pc:function(){return/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream},Ke:function(){var e=navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);return e&&e.length&&2<e.length?[parseInt(e[1],10),parseInt(e[2],10),parseInt(e[3]||0,10)]:[0,0,0]},zd:function(){try{return!!window.matchMedia("(orientation: portrait)").matches}catch(e){return window.innerHeight>window.innerWidth}},se:function(){return se.Qc()||se.Pc()},Qc:function(){var e=navigator.userAgent.toLowerCase();return-1!==e.indexOf("safari")&&-1===e.indexOf("chrome")},Gg:function(){return se.te()&&se.zd()?window.innerHeight/window.innerWidth*45:45},Sc:function(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)},pause:function(e){e.pause()},Ah:function(e){e.play()},release:function(e){e.pause(),e.videoStream&&e.videoStream.stop(),e.videoStream=null},Rc:function(e){if(!e)return e;var t=null;if(e.video){var n=function(e){return e&&"object"==typeof e?Object.assign({},e):e};t={},void 0!==e.video.width&&(t.width=n(e.video.width)),void 0!==e.video.height&&(t.height=n(e.video.height)),void 0!==e.video.facingMode&&(t.facingMode=n(e.video.facingMode))}return t={audio:e.audio,video:t},void 0!==e.deviceId&&se.Ic(t,e.deviceId),t},Ic:function(e,t){t&&(e.video=e.video||{},e.video.deviceId={exact:t},e.video.facingMode&&delete e.video.facingMode)},Wd:function(e){var t=e.video.width;return e.video.width=e.video.height,e.video.height=t,e},we:function(e){function t(e){return[480,576,640,648,720,768,800,960,1080,1152,1280,1366,1920].sort((function(t,n){return Math.abs(t-e)-Math.abs(n-e)}))}function n(t){t=t(se.Rc(e)),A.push(t),o(t)}function o(e){if(e.video&&e.video.facingMode&&e.video.facingMode.exact){var t=e.video.facingMode.exact;delete(e=se.Rc(e)).video.facingMode.exact,e.video.facingMode.ideal=t,A.push(e)}}var A=[];if(!e||!e.video)return A;if(o(e),e.video.width&&e.video.height){if(e.video.width.ideal&&e.video.height.ideal){var i=t(e.video.width.ideal).slice(0,3),r=t(e.video.height.ideal).slice(0,3),s={},a=0;for(s.la=void 0;a<i.length;s={la:s.la},++a){s.la=i[a];var l={},m=0;for(l.ka=void 0;m<r.length;l={ka:l.ka},++m)if(l.ka=r[m],s.la!==e.video.width.ideal||l.ka!==e.video.height.ideal){var p=Math.max(s.la,l.ka)/Math.min(s.la,l.ka);p<4/3-.1||p>16/9+.1||n(function(e,t){return function(n){return n.video.width.ideal=e.la,n.video.height.ideal=t.ka,n}}(s,l))}}}n((function(e){return se.Wd(e)}))}return e.video.width&&e.video.height&&(e.video.width.ideal&&e.video.height.ideal&&n((function(e){return delete e.video.width.ideal,delete e.video.height.ideal,e})),n((function(e){return delete e.video.width,delete e.video.height,e}))),e.video.facingMode&&(n((function(e){return delete e.video.facingMode,e})),e.video.width&&e.video.height&&n((function(e){return se.Wd(e),delete e.video.facingMode,e}))),A.push({audio:e.audio,video:!0}),A},Qf:function(e){if(se.zd()){if(!e||!e.video)return!1;var t=e.video.width,n=e.video.height;if(!t||!n)return!1;if(t.ideal&&n.ideal&&t.ideal>n.ideal)return e.video.height=t,e.video.width=n,!0}return!1},ob:function(e){if(e.volume=0,se.Ka(e,"muted"),se.Qc()){if(1===e.volume){var t=function(){e.volume=0,window.removeEventListener("mousemove",t,!1),window.removeEventListener("touchstart",t,!1)};window.addEventListener("mousemove",t,!1),window.addEventListener("touchstart",t,!1)}setTimeout((function(){e.volume=0,se.Ka(e,"muted")}),5)}},Zd:function(e,t,n){return null===e?Promise.resolve():new Promise((function(o,A){if(e.srcObject&&e.srcObject.getVideoTracks){var i=e.srcObject.getVideoTracks();1!==i.length?A("INVALID_TRACKNUMBER"):(i=i[0],t?se.get(e,o,A,n):(i.stop(),o()))}else A("BAD_IMPLEMENTATION")}))},kd:function(e,t,n,o){function A(e){i||(i=!0,n(e))}var i=!1;return navigator.mediaDevices.getUserMedia(o).then((function(n){function o(){setTimeout((function(){if(e.currentTime){var o=e.videoWidth,r=e.videoHeight;if(0===o||0===r)A("VIDEO_NULLSIZE");else{o&&(e.style.width=o.toString()+"px"),r&&(e.style.height=r.toString()+"px");var s={re:null,Mf:null,mf:null};try{var a=n.getVideoTracks()[0];a&&(s.mf=a,s.re=a.getCapabilities(),s.Mf=a.getSettings())}catch(e){}se.se()?e.parentNode&&null!==e.parentNode?(i||t(e,n,s),setTimeout((function(){e.play()}),100)):(document.body.appendChild(e),se.ob(e),setTimeout((function(){e.style.transform="scale(0.0001,0.0001)",e.style.position="fixed",e.style.bottom="0px",e.style.right="0px",se.ob(e),setTimeout((function(){e.play(),i||t(e,n,s)}),100)}),80)):i||t(e,n,s)}}else A("VIDEO_NOTSTARTED")}),700)}void 0!==e.srcObject?e.srcObject=n:(e.src=window.URL.createObjectURL(n),e.videoStream=n),se.ob(e),e.addEventListener("loadeddata",(function t(){e.removeEventListener("loadeddata",t,!1);var n=e.play();se.ob(e),void 0===n?o():n.then((function(){o()})).catch((function(){A("VIDEO_PLAYPROMISEREJECTED")}))}),!1)})).catch((function(e){A(e)}))},We:function(e,t){var n=t||se.ld();return new Promise((function(t,o){se.get(n,t,o,e)}))},get:function(e,t,n,o){if(!e)return n&&n("VIDEO_NOTPROVIDED"),!1;if(!se.Sc())return n&&n("MEDIASTREAMAPI_NOTFOUND"),!1;if(o&&o.video){if(se.Pc()){var A=se.Ke();0!==A[0]&&(12>A[0]||12===A[0]&&2>A[1])&&se.Qf(o)}o.video.width&&o.video.width.ideal&&(e.style.width=o.video.width.ideal+"px"),o.video.height&&o.video.height.ideal&&(e.style.height=o.video.height.ideal+"px")}se.Ka(e,"autoplay"),se.Ka(e,"playsinline"),o&&o.audio?e.volume=0:se.Ka(e,"muted"),se.kd(e,t,(function(){!function o(A){if(0===A.length)n("INVALID_FALLBACKCONSTRAINTS");else{var i=A.shift();se.kd(e,t,(function(){o(A)}),i)}}(se.we(o))}),o)},Xe:function(e){if(!navigator.mediaDevices||!navigator.mediaDevices.enumerateDevices)return e(!1,"NOTSUPPORTED"),!1;navigator.mediaDevices.enumerateDevices().then((function(t){(t=t.filter((function(e){return e.kind&&-1!==e.kind.toLowerCase().indexOf("video")&&e.label&&e.deviceId})))&&t.length&&0<t.length?e(t,!1):e(!1,"NODEVICESFOUND")})).catch((function(){e(!1,"PROMISEREJECTED")}))},gg:function(e,t,n){var o={};o[t]=n,(t=[]).push(o),e.applyConstraints({advanced:t}).catch((function(){}))}},ae=function(){function e(t,n,o,A,i,r,s){if(!h)if(s===r.length)i();else{switch(r[s]){case"A":o();break;case"D":t();break;case"S":return void n().then((function(a,l){u.zb(),e(t,n,o,l?null:A,i,r,++s)})).catch((function(e){throw i(),e}));case"R":A&&A()}e(t,n,o,A,i,r,++s)}}var t={n:5,hc:1,Bd:0,ab:[35,49],Xa:[2,200],k:.7,Vf:200,uf:.05},n=-1,o=null,A=-1,i=-1,r=0,s=-1,a=-1,l=0,m=0,p=t.Xa[1],h=!0,u={Ue:function(){switch(n){case-1:return-1;case 0:return a+o.Bd;case 1:return l}},Lg:function(e){return Math.pow(Math.min(Math.max(s,0),o.n-1)/(o.n-1),e||1)},o:function(e){o=Object.assign({},t,e),s=a=o.hc,n=0,u.reset()},zb:function(e){e=(void 0===e?Date.now():e)||0;var t=Math.min(Math.max(e-m,o.Xa[0]),o.Xa[1]);p=t,m=e;var n=-1===A?0:o.k;A=Math.min(Math.max(1e3/t,5),120)*(1-n)+A*n,e-i>o.Vf&&5<++r&&(t=o.k,s=s*(1-t)+(A<o.ab[0]?a-1:A>o.ab[1]?a+1:a)*t,Math.abs(s-a)>1-o.uf&&(t=Math.min(Math.max(Math.round(s),0),o.n-1))!==a&&(s=a=t,A=(o.ab[1]-o.ab[0])/2),i=e)},oc:function(t,n,o,A,i,r){h=!1,e(t,n,o,A,i,r,0)},stop:function(){h=!0},qc:function(e){l=e,n=1},Ac:function(){n=0,u.reset()},reset:function(){p=t.Xa[1],i=A=-1,r=0},Ne:function(){return p}};return u}(),le=function(){function e(){n(u+p.fc),c.port.postMessage("DONE")}function t(){var e=p.ca;k.isEnabled&&(e=Math.max(e,k.ca)),E.Sa=I(0===e?n:o)}function n(e){G.za&&null!==h&&(e-=u,e=Math.min(Math.max(e,p.Vc[0]),p.Vc[1]),u+=e,i(),k.isEnabled&&k.Oa&&G.W&&u-k.bc>p.Fc&&(function(){k.Oa=!1;var e=k.ga,t=k.eb,n=k.fb,o=k.V;e.uniform1f(k.md,Math.random()),k.Aa?t.beginQueryEXT(o,n):e.beginQuery(o,n),e.drawElements(e.POINTS,1,e.UNSIGNED_SHORT,0),k.Aa?t.endQueryEXT(o):e.endQuery(o),W.flush(),new Promise((function(e,t){l((function(n){if(n){n=k.ga;var o=k.eb,A=k.fb;n=k.Aa?o.getQueryObjectEXT(A,o.QUERY_RESULT_EXT):n.getQueryParameter(A,n.QUERY_RESULT),e(n)}else t()}))})).then((function(e){if(e=p.ce*p.Dc*1e3/e,k.Cb=(k.Cb+1)%p.Da,k.cc[k.Cb]=e,++k.Ad>p.Da){k.lb.set(k.cc),k.lb.sort((function(e,t){return e-t})),e=k.lb[Math.floor(p.Da/2)],k.Za=Math.max(k.Za,e);var t=0;for(t=0;t<k.yc&&!(e>k.Za*(1-(p.Ec[t]+p.de*(t>=k.yb?1:-1))));++t)t===k.yc-1&&++t;t!==k.yb&&(console.log("THERMAL THROTTLING LEVEL = "+t.toString()),k.yb=t,k.ca=0===t?0:p.be[t-1],p.Cc&&p.Cc(t))}k.Oa=!0})).catch((function(){k.Oa=!0}))}(),k.bc=u),h(u))}function o(e){G.za&&(E.timeout=window.setTimeout(n.bind(null,e),p.ca))}function A(){h=null,G.za=!1,i()}function i(){E.Sa&&(window.cancelAnimationFrame(E.Sa),E.Sa=null),E.timeout&&(window.clearTimeout(E.timeout),E.timeout=null)}function r(e){e&&!G.W?(G.W=!0,d&&ae.Ac(),c.port.postMessage("STOP"),W.Yd(!0),t()):!e&&G.W&&(G.W=!1,d&&ae.qc(1),W.Yd(!1),c.port.postMessage("START"))}function s(e){e.target.hidden?f():g()}function a(e,t,n){return t=e.createShader(t),e.shaderSource(t,n),e.compileShader(t),t}function l(e){var t=k.ga,n=k.eb,o=k.fb;o=k.Aa?n.Ig(o,n.QUERY_RESULT_AVAILABLE_EXT):t.getQueryParameter(o,t.QUERY_RESULT_AVAILABLE),t=t.getParameter(n.GPU_DISJOINT_EXT),o?e(!t):setTimeout(l.bind(null,e),.1)}var m={ud:!0,Vc:[1,200],fc:20,ca:0,ee:!1,Dc:50,ce:240,Fc:3e3,Da:3,Ec:[.2,.35,.5],de:.05,be:[8,20,40],Cc:null},p=null,h=null,u=0,c=null,d=!1,I=null,G={oa:!1,W:!0,ac:!1,$b:!1,Zb:!1,za:!1},E={Sa:null,timeout:null},k={isEnabled:!1,Oa:!1,ga:null,eb:null,fb:null,V:null,md:null,Aa:!0,yb:0,yc:0,ca:0,bc:0,Ad:0,cc:null,lb:null,Cb:0,Za:0},g=r.bind(null,!0),f=r.bind(null,!1),H={o:function(t){if(p=Object.assign(m,t),Object.assign(G,{W:!0,oa:!0,za:!1}),I=window.requestPostAnimationFrame||window.requestAnimationFrame,p.ee){(t=document.createElement("canvas")).setAttribute("width","1"),t.setAttribute("height","1");var n={antialias:!1};if(n=(t=t.getContext("webgl2",n)||t.getContext("webgl",n)).getExtension("EXT_disjoint_timer_query")||t.getExtension("EXT_disjoint_timer_query_webgl2")){k.ga=t,k.eb=n,k.isEnabled=!0,k.Aa=!!n.beginQueryEXT;var o=a(t,t.VERTEX_SHADER,"attribute vec4 a0;void main(){gl_Position=a0;}"),A=a(t,t.FRAGMENT_SHADER,"precision lowp float;uniform float u37;void main(){vec4 a=u37*vec4(1.,2.,3.,4.);for(int b=0;b<666;b+=1)a=cos(a);gl_FragColor=a;}".replace("666",p.Dc.toString())),i=t.createProgram();t.attachShader(i,o),t.attachShader(i,A),t.linkProgram(i),o=t.getAttribLocation(i,"a0"),k.md=t.getUniformLocation(i,"u37"),t.useProgram(i),t.enableVertexAttribArray(o),i=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,new Float32Array([.5,.5,0,1]),t.STATIC_DRAW),t.vertexAttribPointer(o,4,t.FLOAT,!1,16,0),i=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array([0]),t.STATIC_DRAW),t.disable(t.DEPTH_TEST),t.disable(t.DITHER),t.disable(t.STENCIL_TEST),t.viewport(0,0,1,1),i=k.Aa?n.createQueryEXT():t.createQuery(),k.fb=i,k.V=n.TIME_ELAPSED_EXT||t.TIME_ELAPSED,k.yb=0,k.yc=p.Ec.length,k.ca=0,k.bc=-p.Fc,k.cc=new Float32Array(p.Da),k.lb=new Float32Array(p.Da),k.Za=0,k.Cb=0,k.Ad=0,k.Oa=!0}}if(p.ud){t=!1;try{if("undefined"==typeof SharedWorker){var r=URL.createObjectURL(new Blob(["let handler = null;\n      self.addEventListener('message', function(e){\n        if (handler !== null){\n          clearTimeout(handler);\n          handler = null;\n        }\n        switch (e.data) {\n          case 'START':\n          case 'DONE':\n            handler = setTimeout(function(){\n              self.postMessage('TICK');\n            }, "+p.fc.toString()+");\n            break;\n          case 'STOP':\n            break;\n        };\n      }, false);"],{type:"text/javascript"})),l=new Worker(r);l.addEventListener("message",e),c={Id:l,port:l},G.ac=!0}else{var h=URL.createObjectURL(new Blob(["let handler = null;\n      onconnect = function(e) {\n        const port = e.ports[0];\n        port.addEventListener('message', function(e) {\n          \n          if (handler !== null){\n            clearTimeout(handler);\n            handler = null;\n          }\n          switch (e.data) {\n            case 'START':\n            case 'DONE':\n              handler = setTimeout(function(){\n                port.postMessage('TICK');\n              }, "+p.fc.toString()+");\n              break;\n            case 'STOP':\n              break;\n          };\n          \n        });\n        \n        port.start();\n      } // end onconnect()"],{type:"text/javascript"})),u=new SharedWorker(h);u.port.start(),u.port.addEventListener("message",e),c={Id:u,port:u.port},G.$b=!0}t=!0}catch(e){}t&&("onvisibilitychange"in document?document.addEventListener("visibilitychange",s):(window.addEventListener("blur",f),window.addEventListener("focus",g)),G.Zb=!0)}d=void 0!==ae},m:function(){A(),G.Zb&&("onvisibilitychange"in document?document.removeEventListener("visibilitychange",s):(window.removeEventListener("blur",f),window.removeEventListener("focus",g)),G.Zb=!1),G.$b?(c.port.close(),G.$b=!1):G.ac&&(c.Id.terminate(),G.ac=!1),Object.assign(G,{W:!0,oa:!1,za:!1}),h=null},ph:function(){return G.W},update:function(e){Object.assign(p,e)},oc:function(e){G.oa||H.o({}),i(),G.za=!0,h=e,G.W&&t()},stop:A};return H}(),me=function(){var e={Ed:4,rb:[1.5,1.5,2],N:[.1,.1,.1],Md:1,C:-1,K:-1,Pf:2,tf:1,Od:!0,Ee:.8},t=null,n=[],o=[0],A=[.5,.5,1];return{o:function(o){t=Object.assign({},e,o),n.splice(0),o=t.rb[0]*t.N[0];var A=t.rb[1]*t.N[1],i=1/(1+t.rb[2]*t.N[2]),r=t.Md*Math.min(t.C,t.K),s=r/t.C;r/=t.K;var a=.5*t.Ee;a*=a;for(var l=0;l<t.Ed;++l){var m=Math.pow(i,l),p=s*m,h=r*m;m=p*t.tf;for(var u=p*o,c=h*A,d=1+(1-(p/=2)-p)/u,I=1+(1-(h/=2)-h)/c,G=0;G<I;++G)for(var E=h+G*c,k=E-.5,g=0;g<d;++g){var f=p+g*u,H=f-.5;H*H+k*k>a||n.push([f,E,m])}}t.Od&&n.sort((function(e,t){var n=e[0]-.5;e=e[1]-.5;var o=t[0]-.5;return n*n+e*e-(o*o+(t=t[1]-.5)*t)}))},get:function(e){var i=n.length;if(0===i)return A;for(;e>=o.length;)o.push(0);o[e]>=i&&(o[e]=0);var r=n[Math.floor(o[e])];return o[e]=(o[e]+1/t.Pf)%i,r},reset:function(){for(var e=n.length/o.length,t=0;t<o.length;++t)o[t]=Math.floor(t*e)}}}(),pe=function(){function e(e,t,n,o){return n>e?Math.max(0,e+t/2-(n-o/2)):Math.max(0,n+o/2-(e-t/2))}function t(e){return!o.rd(e)}var n={L:1,ec:.3,Pd:.3,rd:null,ff:!0},o=null,A=0,i=null,r=!1,s=0,a=0;return{o:function(e){o=Object.assign({},n,e),i=[0]},yd:function(){return 1!==o.L},hd:function(){return A},xd:function(){return r},na:function(){return o.L},ah:function(){return i},jf:function(e){return i.includes(e)},update:function(e,n){var A=i;if(A.length>e)A.splice(0,A.length-e);else for(;A.length<e;)A.push(0);if(1!==o.L)if(n.every(t)){n=s;for(var r=0;r<e;++r)A[r]=n,n=(n+1)%o.L;s=n}else{r=Math.round(o.Pd*e),r=Math.max(1,r);for(var a=s,l=0,m=0;l<e;++l){if(t(n[a])&&++m>r)do{++a===o.L&&(a=0)}while(t(n[a]));A[l]=a,a=(a+1)%o.L}s=a}},zb:function(e){return A=i[e],a=(.5+A)/o.L,r=i.lastIndexOf(A)===e,A},Nf:function(t,n){return 1!==o.L&&function(t,n,A){return t.some((function(i,r){return r!==n&&!((r=t[n]).pa>i.pa||3>i.pa||e(r.x,r.ja,i.x,i.ja)<o.ec*r.ja)&&e(r.y,r.ja*A,i.y,i.ja*A)>o.ec*r.ja*A}))}(t,A,n)},Xd:function(e){o.ff&&1===o.L||S.G(e,a)},De:function(e){for(var t,n=new Float32Array(e.length*o.L),A=0;A<o.L;++A)for(t=0;t<e.length;++t)n[A*e.length+t]=e[t];return n},Ob:function(e){for(var t=[],n=0;n<o.L;++n)t.push(JSON.parse(JSON.stringify(e)));return t}}}(),he={neuralNetworkPath:"NN_DEFAULT.json",ba:0,Cf:{threshold:1.2,nScaleLevels:2,scale0Factor:.8,nDetectsPerLoopRange:[2,12],overlapFactors:[2,2,3],scanCenterFirst:!0,nDetectsPerLoop:-1,multiDetectionThresholdFactors:[.5,.6],translationScalingFactors:[.3,.3,1],isCleanGLStateAtEachIteration:!0,animateProcessOrder:"DSAR"},Sf:50,qf:.4,pf:8,rf:.3,Of:{translationFactorRange:[.0015,.005],rotationFactorRange:[.003,.02],qualityFactorRange:[.9,.98],alphaRange:[.05,1],followZRotAlphaFactor:.8},Pa:[.65,1,.262],ge:.2,ie:2,he:.1,sf:8,Dd:1,He:L.nb.bind(null,.3,.7),Xf:20,Ud:3},ue={facingMode:"user",idealWidth:800,idealHeight:600,minWidth:480,maxWidth:1920,minHeight:480,maxHeight:1920,rotate:0,flipX:!1},ce={ic:-3,kf:-1,error:-2,ready:1,play:2,pause:3},de=ce.ic,Ie=null,Ge={hb:!1,tc:null,element:null,M:null,D:[0,0],v:[.5,0,0,.5],tb:0,Ja:null,gb:!1},Ee=null,ke={Ia:null,Eb:null,antialias:!0,Gc:"./",Ea:null,ea:null,ba:he.ba,Hd:he.ba,ib:!1,va:!0},ge=null,fe=null,He=null,Fe=1,Ce={pc:-1,Jb:-1},De=null,Je={C:0,K:0,D:[0,0],Na:null},ve={sa:null,buffer:null,N:null,Pa:null,Y:he.Dd,Nd:1,La:null},je=null,Ke=null,ye=[],be=[],qe={VERSION:"3.0.7",init:function(t){function n(){de!==ce.error&&2==++i&&(f(),k(),g(),Ee.Ia&&(de=ce.ready,Ee.Ia(!1,{GL:T,canvasElement:Ee.ea,videoTexture:Ie.M.get(),videoTransformMat2:Ie.v,maxFacesDetected:pe.na(),videoElement:Ie.element}),s()),A())}if(de!==ce.ic)return t.callbackReady&&t.callbackReady("ALREADY_INITIALIZED"),!1;if(de=ce.kf,Ie=Object.assign({},Ge),Ee=Object.assign({},ke),De=Object.assign({},Je),ve.Pa=he.Pa.slice(0),void 0!==t.antialias&&(Ee.antialias=t.antialias),t.callbackReady&&(Ee.Ia=t.callbackReady),t.callbackTrack&&(Ee.Eb=t.callbackTrack),t.nExpressions&&(ve.Y=t.nExpressions),t.expressionsEasings&&(ve.La=t.expressionsEasings),void 0!==t.animateDelay&&(Ee.ba=t.animateDelay),void 0!==t.NNCPath&&(Ee.Gc=t.NNCPath),void 0!==t.NNC&&(Ee.Ea=t.NNC),void 0!==t.followZRot&&(Ee.va=!!t.followZRot),!t.canvasId&&!t.canvas)return J("NO_CANVASID"),!1;if(Ee.ea=t.canvas?t.canvas:document.getElementById(t.canvasId),!Ee.ea)return J("INVALID_CANVASID"),!1;if(De.C=Ee.ea.width,De.K=Ee.ea.height,!De.C||!De.K)return J("INVALID_CANVASDIMENSIONS"),!1;fe=Object.create(he.Cf),t.scanSettings&&Object.assign(fe,t.scanSettings);var o=1;if(void 0!==t.maxFacesDetected&&(o=Math.max(1,t.maxFacesDetected)),o>he.pf)return J("MAXFACES_TOOHIGH"),!1;for(pe.o({L:o,ec:he.qf,Pd:he.rf,rd:function(e){return e.detected>fe.multiDetectionThresholdFactors[1]*fe.threshold}}),o=0;o<pe.na();++o)ye.push(new Float32Array(he.sf)),be.push(0);le.o({ud:t.isKeepRunningOnWinFocusLost||!1,ca:Ee.ba}),ae.o({hc:0,n:fe.nDetectsPerLoopRange[1]-fe.nDetectsPerLoopRange[0]+1,Bd:fe.nDetectsPerLoopRange[0]}),-1!==fe.nDetectsPerLoop?ae.qc(fe.nDetectsPerLoop):ae.Ac(),ve.N=fe.translationScalingFactors.slice(0),He=Object.create(he.Of),t.stabilizationSettings&&Object.assign(He,t.stabilizationSettings);var i=0;return t.videoSettings&&t.videoSettings.videoElement?C(t.videoSettings.videoElement,n):(t.videoSettings&&Object.assign(ue,t.videoSettings),D(t.onWebcamAsk,t.onWebcamGet,(function(e){C(e,n)}))),function(e){if(Ee.Ea)G("string"==typeof Ee.Ea?JSON.parse(Ee.Ea):Ee.Ea,e);else{var t=Ee.Gc;"JSON"!==t.toUpperCase().split(".").pop()&&(t+=he.neuralNetworkPath),w.get(t,(function(t){G(t=JSON.parse(t),e)}))}}((function(t){if(!N.o({Ua:Ee.ea,width:De.C,height:De.K,debug:!1,jc:function(){J("GLCONTEXT_LOST")},antialias:Ee.antialias,premultipliedAlpha:!0})&&(J("GL_INCOMPATIBLE"),1))return!1;ge=new e({mb:t.layers,nc:"gpuRawAvg",kc:E}),S.Kc([{id:"s54",name:"_",ta:"attribute vec2 a0;uniform mat2 u38;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=vec2(.5,.5)+u38*a0;}",Ta:["a0"],Ga:[2],h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",i:["u1","u38"],precision:"lowp"},{id:"s55",name:"_",h:"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",ta:"attribute vec2 a0;uniform sampler2D u39;uniform mat2 u38;uniform vec2 u40;uniform float u41,u42,u43;varying vec2 vv0;void main(){vec4 a=texture2D(u39,vec2(.17,u41));vec2 f=a.gb,g=a.a*u40,b=a0;b.x*=u43;float c=cos(u42),d=sin(u42);vec2 h=mat2(c,d,-d,c)*b,i=f+h*.5*g,j=i-.5;vv0=vec2(.5,.5)+2.*u38*j,gl_Position=vec4(a0,0.,1.);}",Ta:["a0"],Ga:[2],i:"u1 u39 u40 u41 u42 u43 u38".split(" "),precision:"lowp"},{id:"s56",name:"_",h:"uniform sampler2D u44,u39;uniform vec3 u45,u46;uniform float u47,u48,u41,u49,u42,u50;const vec4 e=vec4(.25,.25,.25,.25);void main(){vec4 d=texture2D(u44,vec2(.625,.625)),f=texture2D(u44,vec2(.875,.625)),a=texture2D(u39,vec2(.17,u41));float g=dot(d-f,e);bool h=g>u48;a.r<-.5?a.r+=1.:h?a.r=2.:a.r>u47?a.r=0.:a.r>1.9?a.r+=1.:0.,a.r=mix(-2.,a.r,u49);if(a.r<.9)a=vec4(1.,u45);else{a.r*=step(1.9,a.r);float i=dot(e,texture2D(u44,vec2(.875,.875))),j=dot(e,texture2D(u44,vec2(.125,.625))),k=dot(e,texture2D(u44,vec2(.375,.625))),b=cos(u42),c=sin(u42);vec2 l=mat2(b,c*u50,-c/u50,b)*vec2(i,j);a.gba+=vec3(l,k)*u46*a.a;}gl_FragColor=a;}",ta:"attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}",i:"u44 u39 u45 u47 u46 u49 u42 u50 u48 u41".split(" ")},{id:"s57",name:"_",ta:"attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}",h:"uniform sampler2D u44;uniform float u49;const vec4 e=vec4(.25,.25,.25,.25);const vec3 f=vec3(.5,.5,.5);void main(){float a=dot(e,texture2D(u44,vec2(.125,.875))),b=dot(e,texture2D(u44,vec2(.375,.875))),c=dot(e,texture2D(u44,vec2(.625,.875))),d=dot(e,texture2D(u44,vec2(.625,.625)));vec3 g=vec3(a,b,c)*.5+f;gl_FragColor=vec4(g,d*u49);}",i:["u44","u49"]},{id:"s58",name:"_",ta:"attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}",h:"uniform sampler2D u44;const vec4 e=vec4(.25,.25,.25,.25);void main(){float a=dot(e,texture2D(u44,vec2(.375,.375))),b=dot(e,texture2D(u44,vec2(.625,.375))),c=dot(e,texture2D(u44,vec2(.875,.375))),d=dot(e,texture2D(u44,vec2(.125,.125)));gl_FragColor=vec4(a,b,c,d);}",i:["u44"]},{id:"s53",name:"_",h:"uniform sampler2D u39;uniform vec2 u51;uniform float u52;varying vec2 vv0;void main(){float f=step(.5,mod(gl_FragCoord.y+1.5,2.)),c=step(.33,vv0.x);vec4 a=texture2D(u39,vv0+u51);a.a=mix(a.a*u52,a.a,c);vec4 d=floor(255.*a),g=255.*(255.*a-d),b=mix(d,g,f)/255.;b.x=mix(step(a.x,1.5),b.x,c),gl_FragColor=b;}",i:["u39","u52","u51"]}]),c(),ve.buffer=new Uint8Array(8*he.Ud*pe.na()),je=pe.Ob({Va:0,x:0,y:0,ja:1,rx:0,ry:0,Qa:0,cd:new Float32Array(ve.Y),pa:0}),Ke=pe.Ob({detected:0,x:0,y:0,s:1,xRaw:0,yRaw:0,sRaw:1,rx:0,ry:0,rz:0,expressions:new Float32Array(ve.Y)}),pe.Ob({dx:0,dy:0,Nb:0,Kb:0,Lb:0,Mb:0}),I(),d(),n()})),!0},destroy:function(){return le.m(),new Promise((function(e){qe.toggle_pause(!0,!0).finally((function(){ge&&ge.m(),N.m(),ge=Ke=je=null,ye.splice(0),be.splice(0),De.Na=null,ve.sa=null,Ie.M=null,de=ce.ic,e()})).catch((function(){}))}))},toggle_videoStream:function(e){return Ie.gb||!Ie.element?Promise.resolve():se.Zd(Ie.element,e,Ie.Ja)},toggle_pause:function(e,t){return o()?(t=t?qe.toggle_videoStream(!e):Promise.resolve(),e?i():t.then((function(){A()})),t):Promise.reject("NOT_READY")},update_videoSettings:function(e){return i(),new Promise((function(t,n){se.Zd(Ie.element,!1,Ie.Ja).then((function(){Object.assign(ue,e),D(null,null,(function(e){C(e,(function(){f(),g(),A(),t()}))}))})).catch(n)}))},toggle_slow:function(e){o()&&de===ce.play&&(e&&!Ee.ib?(Ee.Hd=Ee.ba,fe.nDetectsPerLoop=1,this.set_animateDelay(he.Zf),Ee.ib=!0):!e&&Ee.ib&&(fe.nDetectsPerLoop=-1,this.set_animateDelay(Ee.Hd),Ee.ib=!1))},set_animateDelay:function(e){Ee.ba=e,le.update({ca:Ee.ba})},resize:function(){if(!o())return!1;var e=Ee.ea.width,t=Ee.ea.height;return!(!F()&&e===De.C&&t===De.K||(De.C=e,De.K=t,S.P(),I(),d(),f(),g(),0))},set_inputTexture:function(e,t,n){Ie.D[0]=t,Ie.D[1]=n,Ie.M=X.instance({width:t,height:n,Vb:e}),Ie.hb=!0,f(),s(),g()},reset_GLState:function(){s(),De.Na.remove(),ve.sa.remove(),c()},render_video:function(){z.O(),S.set("s54"),T.viewport(0,0,De.C,De.K),Ie.M.g(0),_.l(!0,!0)},reset_inputTexture:function(){Ie.hb=!1,Ie.M=Ie.tc,F(),f(),g()},get_videoDevices:function(e){return se.Xe(e)},set_scanSettings:function(e){Object.assign(fe,e),-1!==fe.nDetectsPerLoop?ae.qc(fe.nDetectsPerLoop):ae.Ac(),I(),d()},set_stabilizationSettings:function(e){Object.assign(He,e)},set_videoOrientation:function(e,t){o()&&(ue.flipX=t,ue.rotate=e,f(),g())},update_videoElement:function(e,t){C(e||Ie.element,(function(){k(),f(),g(),t&&t()}))},create_new:function(){return t()}};return qe},n=t();e.exports=n},7192:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var o=n(4015),A=n.n(o),i=n(3645),r=n.n(i),s=n(1667),a=n.n(s),l=n(1690),m=r()(A()),p=a()(l.Z);m.push([e.id,"@font-face{font-family:Art;src:url("+p+")}*{box-sizing:border-box}#webcam{height:100vh;width:100vw;z-index:-2;border-radius:100%;border:25px solid black;background:white}#webcamCanvas{position:absolute;height:100vh;width:100vw;z-index:-1;border-radius:100%;display:none}.webgl{position:absolute;height:100vh;width:100vw}.title{font-size:6em;font-family:Art;position:absolute;color:#fff;top:14%;left:3%;height:20px;z-index:1;cursor:pointer;animation:pulse 2s infinite}.title2{font-size:6em;font-family:Art;position:absolute;color:#fff;top:14%;left:85%;height:20px;z-index:1;cursor:pointer;animation:pulse 2s infinite}.tp-dfwv{margin-top:auto;top:50%;animation:pulse 2s infinite}@keyframes pulse{0%{transform:scale(0.95)}50%{transform:scale(1)}100%{transform:scale(0.95)}}\n","",{version:3,sources:["webpack://./src/style.scss"],names:[],mappings:"AAAA,WACE,eAAgB,CAChB,2CAAqC,CAGvC,EACE,qBAAsB,CAEvB,QAIC,YAAa,CACb,WAAY,CACZ,UAAW,CACX,kBAAmB,CACnB,uBAAwB,CAExB,gBAAiB,CAElB,cAGC,iBAAkB,CAClB,YAAa,CACb,WAAY,CACZ,UAAW,CACX,kBAAmB,CACnB,YAAa,CAEd,OAIC,iBAAkB,CAClB,YAAa,CACb,WAAY,CACb,OAIC,aAAc,CACd,eAAgB,CAChB,iBAAkB,CAClB,UAA0B,CAE1B,OAAQ,CACR,OAAQ,CAER,WAAY,CACZ,SAAU,CACV,cAAe,CACf,2BAA4B,CAG7B,QAGC,aAAc,CACd,eAAgB,CAChB,iBAAkB,CAClB,UAA0B,CAE1B,OAAQ,CACR,QAAS,CAGT,WAAY,CACZ,SAAU,CACV,cAAe,CACf,2BAA4B,CAG7B,SAIC,eAAgB,CAChB,OAAQ,CACR,2BAA4B,CAC7B,iBAGA,GACC,qBAAsB,CAIvB,IACC,kBAAmB,CAIpB,KACC,qBAAsB,CAAA",sourcesContent:["@font-face {\n  font-family: Art;\n  src: url('../static/ArtDystopia.otf');\n}\n\n*{\n  box-sizing: border-box;\n\n}\n\n#webcam{\n  // position: absolute;\n  height: 100vh;\n  width: 100vw;\n  z-index: -2;\n  border-radius: 100%;\n  border: 25px solid black;\n  // visibility: hidden;\n  background: white;\n\n}\n\n#webcamCanvas{\n  position: absolute;\n  height: 100vh;\n  width: 100vw;\n  z-index: -1;\n  border-radius: 100%;\n  display: none;\n\n}\n\n\n.webgl{\n  position: absolute;\n  height: 100vh;\n  width: 100vw;\n}\n\n\n.title{\n  font-size: 6em;\n  font-family: Art;\n  position: absolute;\n  color: rgba(255,255,255,1);\n  // pointer-events: none;\n  top: 14%;\n  left: 3%;\n  // justify-content: center;\n  height: 20px;\n  z-index: 1;\n  cursor: pointer;\n  animation: pulse 2s infinite;\n\n\n}\n\n.title2{\n  font-size: 6em;\n  font-family: Art;\n  position: absolute;\n  color: rgba(255,255,255,1);\n  // pointer-events: none;\n  top: 14%;\n  left: 85%;\n  // justify-content: center;\n\n  height: 20px;\n  z-index: 1;\n  cursor: pointer;\n  animation: pulse 2s infinite;\n\n\n}\n\n\n.tp-dfwv{\n  margin-top: auto;\n  top: 50%;\n  animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n\t0% {\n\t\ttransform: scale(0.95);\n\n\t}\n\n\t50% {\n\t\ttransform: scale(1);\n\n\t}\n\n\t100% {\n\t\ttransform: scale(0.95);\n\n\t}\n}\n"],sourceRoot:""}]);const h=m},3645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=e(t);return t[2]?"@media ".concat(t[2]," {").concat(n,"}"):n})).join("")},t.i=function(e,n,o){"string"==typeof e&&(e=[[null,e,""]]);var A={};if(o)for(var i=0;i<this.length;i++){var r=this[i][0];null!=r&&(A[r]=!0)}for(var s=0;s<e.length;s++){var a=[].concat(e[s]);o&&A[a[0]]||(n&&(a[2]?a[2]="".concat(n," and ").concat(a[2]):a[2]=n),t.push(a))}},t}},4015:e=>{"use strict";function t(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,o=new Array(t);n<t;n++)o[n]=e[n];return o}e.exports=function(e){var n,o,A=(o=4,function(e){if(Array.isArray(e))return e}(n=e)||function(e,t){var n=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=n){var o,A,i=[],r=!0,s=!1;try{for(n=n.call(e);!(r=(o=n.next()).done)&&(i.push(o.value),!t||i.length!==t);r=!0);}catch(e){s=!0,A=e}finally{try{r||null==n.return||n.return()}finally{if(s)throw A}}return i}}(n,o)||function(e,n){if(e){if("string"==typeof e)return t(e,n);var o=Object.prototype.toString.call(e).slice(8,-1);return"Object"===o&&e.constructor&&(o=e.constructor.name),"Map"===o||"Set"===o?Array.from(e):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?t(e,n):void 0}}(n,o)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),i=A[1],r=A[3];if(!r)return i;if("function"==typeof btoa){var s=btoa(unescape(encodeURIComponent(JSON.stringify(r)))),a="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s),l="/*# ".concat(a," */"),m=r.sources.map((function(e){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(e," */")}));return[i].concat(m).concat([l]).join("\n")}return[i].join("\n")}},1667:e=>{"use strict";e.exports=function(e,t){return t||(t={}),"string"!=typeof(e=e&&e.__esModule?e.default:e)?e:(/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e)}},1690:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});const o=n.p+"assets/fonts/de8edaf30ec5885e87d650937c78210b.otf"},3720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function o(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=o;var A={},i={};function r(e,t){var n,o,r;return t?(r=0<=(e>>>=0)&&e<256)&&(o=i[e])?o:(n=a(e,(0|e)<0?-1:0,!0),r&&(i[e]=n),n):(r=-128<=(e|=0)&&e<128)&&(o=A[e])?o:(n=a(e,e<0?-1:0,!1),r&&(A[e]=n),n)}function s(e,t){if(isNaN(e))return t?G:I;if(t){if(e<0)return G;if(e>=u)return H}else{if(e<=-c)return F;if(e+1>=c)return f}return e<0?s(-e,t).neg():a(e%h|0,e/h|0,t)}function a(e,t,o){return new n(e,t,o)}n.fromInt=r,n.fromNumber=s,n.fromBits=a;var l=Math.pow;function m(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return I;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var o;if((o=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===o)return m(e.substring(1),t,n).neg();for(var A=s(l(n,8)),i=I,r=0;r<e.length;r+=8){var a=Math.min(8,e.length-r),p=parseInt(e.substring(r,r+a),n);if(a<8){var h=s(l(n,a));i=i.mul(h).add(s(p))}else i=(i=i.mul(A)).add(s(p))}return i.unsigned=t,i}function p(e,t){return"number"==typeof e?s(e,t):"string"==typeof e?m(e,t):a(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=m,n.fromValue=p;var h=4294967296,u=h*h,c=u/2,d=r(1<<24),I=r(0);n.ZERO=I;var G=r(0,!0);n.UZERO=G;var E=r(1);n.ONE=E;var k=r(1,!0);n.UONE=k;var g=r(-1);n.NEG_ONE=g;var f=a(-1,2147483647,!1);n.MAX_VALUE=f;var H=a(-1,-1,!0);n.MAX_UNSIGNED_VALUE=H;var F=a(0,-2147483648,!1);n.MIN_VALUE=F;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(F)){var t=s(e),n=this.div(t),o=n.mul(t).sub(this);return n.toString(e)+o.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var A=s(l(e,6),this.unsigned),i=this,r="";;){var a=i.div(A),m=(i.sub(a.mul(A)).toInt()>>>0).toString(e);if((i=a).isZero())return m+r;for(;m.length<6;)m="0"+m;r=""+m+r}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(F)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1==(1&this.low)},C.isEven=function(){return 0==(1&this.low)},C.equals=function(e){return o(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(o(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(F)?F:this.not().add(E)},C.neg=C.negate,C.add=function(e){o(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,A=this.low>>>16,i=65535&this.low,r=e.high>>>16,s=65535&e.high,l=e.low>>>16,m=0,h=0,u=0,c=0;return u+=(c+=i+(65535&e.low))>>>16,h+=(u+=A+l)>>>16,m+=(h+=n+s)>>>16,m+=t+r,a((u&=65535)<<16|(c&=65535),(m&=65535)<<16|(h&=65535),this.unsigned)},C.subtract=function(e){return o(e)||(e=p(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return I;if(o(e)||(e=p(e)),t)return a(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return I;if(this.eq(F))return e.isOdd()?F:I;if(e.eq(F))return this.isOdd()?F:I;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(d)&&e.lt(d))return s(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,A=65535&this.high,i=this.low>>>16,r=65535&this.low,l=e.high>>>16,m=65535&e.high,h=e.low>>>16,u=65535&e.low,c=0,G=0,E=0,k=0;return E+=(k+=r*u)>>>16,G+=(E+=i*u)>>>16,E&=65535,G+=(E+=r*h)>>>16,c+=(G+=A*u)>>>16,G&=65535,c+=(G+=i*h)>>>16,G&=65535,c+=(G+=r*m)>>>16,c+=n*u+A*h+i*m+r*l,a((E&=65535)<<16|(k&=65535),(c&=65535)<<16|(G&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(o(e)||(e=p(e)),e.isZero())throw Error("division by zero");var n,A,i;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?a((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?G:I;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return G;if(e.gt(this.shru(1)))return k;i=G}else{if(this.eq(F))return e.eq(E)||e.eq(g)?F:e.eq(F)?E:(n=this.shr(1).div(e).shl(1)).eq(I)?e.isNegative()?E:g:(A=this.sub(e.mul(n)),i=n.add(A.div(e)));if(e.eq(F))return this.unsigned?G:I;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=I}for(A=this;A.gte(e);){n=Math.max(1,Math.floor(A.toNumber()/e.toNumber()));for(var r=Math.ceil(Math.log(n)/Math.LN2),m=r<=48?1:l(2,r-48),h=s(n),u=h.mul(e);u.isNegative()||u.gt(A);)u=(h=s(n-=m,this.unsigned)).mul(e);h.isZero()&&(h=E),i=i.add(h),A=A.sub(u)}return i},C.div=C.divide,C.modulo=function(e){return o(e)||(e=p(e)),t?a((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return a(~this.low,~this.high,this.unsigned)},C.and=function(e){return o(e)||(e=p(e)),a(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return o(e)||(e=p(e)),a(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return o(e)||(e=p(e)),a(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return o(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?a(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):a(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return o(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?a(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):a(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(o(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?a(this.low>>>e|t<<32-e,t>>>e,this.unsigned):a(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,o){return o?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},6377:(e,t,n)=>{var o=n(4832),A=n(8652),i=n(801),r=n(2030),s=n(3618),a=n(9049),l=n(1971);l.alea=o,l.xor128=A,l.xorwow=i,l.xorshift7=r,l.xor4096=s,l.tychei=a,e.exports=l},4832:function(e,t,n){var o;!function(e,A,i){function r(e){var t,n=this,o=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var o=.02519603282416938*(t+=e.charCodeAt(n));o-=t=o>>>0,t=(o*=t)>>>0,t+=4294967296*(o-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=o(" "),n.s1=o(" "),n.s2=o(" "),n.s0-=o(e),n.s0<0&&(n.s0+=1),n.s1-=o(e),n.s1<0&&(n.s1+=1),n.s2-=o(e),n.s2<0&&(n.s2+=1),o=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var n=new r(e),o=t&&t.state,A=n.next;return A.int32=function(){return 4294967296*n.next()|0},A.double=function(){return A()+11102230246251565e-32*(2097152*A()|0)},A.quick=A,o&&("object"==typeof o&&s(o,n),A.state=function(){return s(n,{})}),A}A&&A.exports?A.exports=a:n.amdD&&n.amdO?void 0===(o=function(){return a}.call(t,n,t,A))||(A.exports=o):this.alea=a}(0,e=n.nmd(e),n.amdD)},9049:function(e,t,n){var o;!function(e,A,i){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,o=t.d,A=t.a;return e=e<<25^e>>>7^n,n=n-o|0,o=o<<24^o>>>8^A,A=A-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-o|0,t.d=o<<16^n>>>16^A,t.a=A-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var o=0;o<n.length+20;o++)t.b^=0|n.charCodeAt(o),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var n=new r(e),o=t&&t.state,A=function(){return(n.next()>>>0)/4294967296};return A.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},A.int32=n.next,A.quick=A,o&&("object"==typeof o&&s(o,n),A.state=function(){return s(n,{})}),A}A&&A.exports?A.exports=a:n.amdD&&n.amdO?void 0===(o=function(){return a}.call(t,n,t,A))||(A.exports=o):this.tychei=a}(0,e=n.nmd(e),n.amdD)},8652:function(e,t,n){var o;!function(e,A,i){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var o=0;o<n.length+64;o++)t.x^=0|n.charCodeAt(o),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var n=new r(e),o=t&&t.state,A=function(){return(n.next()>>>0)/4294967296};return A.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},A.int32=n.next,A.quick=A,o&&("object"==typeof o&&s(o,n),A.state=function(){return s(n,{})}),A}A&&A.exports?A.exports=a:n.amdD&&n.amdO?void 0===(o=function(){return a}.call(t,n,t,A))||(A.exports=o):this.xor128=a}(0,e=n.nmd(e),n.amdD)},3618:function(e,t,n){var o;!function(e,A,i){function r(e){var t=this;t.next=function(){var e,n,o=t.w,A=t.X,i=t.i;return t.w=o=o+1640531527|0,n=A[i+34&127],e=A[i=i+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=A[i]=n^e,t.i=i,n+(o^o>>>16)|0},function(e,t){var n,o,A,i,r,s=[],a=128;for(t===(0|t)?(o=t,t=null):(t+="\0",o=0,a=Math.max(a,t.length)),A=0,i=-32;i<a;++i)t&&(o^=t.charCodeAt((i+32)%t.length)),0===i&&(r=o),o^=o<<10,o^=o>>>15,o^=o<<4,o^=o>>>13,i>=0&&(r=r+1640531527|0,A=0==(n=s[127&i]^=o+r)?A+1:0);for(A>=128&&(s[127&(t&&t.length||0)]=-1),A=127,i=512;i>0;--i)o=s[A+34&127],n=s[A=A+1&127],o^=o<<13,n^=n<<17,o^=o>>>15,n^=n>>>12,s[A]=o^n;e.w=r,e.X=s,e.i=A}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){null==e&&(e=+new Date);var n=new r(e),o=t&&t.state,A=function(){return(n.next()>>>0)/4294967296};return A.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},A.int32=n.next,A.quick=A,o&&(o.X&&s(o,n),A.state=function(){return s(n,{})}),A}A&&A.exports?A.exports=a:n.amdD&&n.amdO?void 0===(o=function(){return a}.call(t,n,t,A))||(A.exports=o):this.xor4096=a}(0,e=n.nmd(e),n.amdD)},2030:function(e,t,n){var o;!function(e,A,i){function r(e){var t=this;t.next=function(){var e,n,o=t.x,A=t.i;return e=o[A],n=(e^=e>>>7)^e<<24,n^=(e=o[A+1&7])^e>>>10,n^=(e=o[A+3&7])^e>>>3,n^=(e=o[A+4&7])^e<<7,e=o[A+7&7],n^=(e^=e<<13)^e<<9,o[A]=n,t.i=A+1&7,n},function(e,t){var n,o=[];if(t===(0|t))o[0]=t;else for(t=""+t,n=0;n<t.length;++n)o[7&n]=o[7&n]<<15^t.charCodeAt(n)+o[n+1&7]<<13;for(;o.length<8;)o.push(0);for(n=0;n<8&&0===o[n];++n);for(8==n?o[7]=-1:o[n],e.x=o,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){null==e&&(e=+new Date);var n=new r(e),o=t&&t.state,A=function(){return(n.next()>>>0)/4294967296};return A.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},A.int32=n.next,A.quick=A,o&&(o.x&&s(o,n),A.state=function(){return s(n,{})}),A}A&&A.exports?A.exports=a:n.amdD&&n.amdO?void 0===(o=function(){return a}.call(t,n,t,A))||(A.exports=o):this.xorshift7=a}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var o;!function(e,A,i){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var o=0;o<n.length+64;o++)t.x^=0|n.charCodeAt(o),o==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var n=new r(e),o=t&&t.state,A=function(){return(n.next()>>>0)/4294967296};return A.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},A.int32=n.next,A.quick=A,o&&("object"==typeof o&&s(o,n),A.state=function(){return s(n,{})}),A}A&&A.exports?A.exports=a:n.amdD&&n.amdO?void 0===(o=function(){return a}.call(t,n,t,A))||(A.exports=o):this.xorwow=a}(0,e=n.nmd(e),n.amdD)},1971:(e,t,n)=>{var o;!function(A,i){var r,s=this,a=256,l=i.pow(a,6),m=i.pow(2,52),p=2*m,h=255;function u(e,t,n){var o=[],h=G(I((t=1==t?{entropy:!0}:t||{}).entropy?[e,E(A)]:null==e?function(){try{var e;return r&&(e=r.randomBytes)?e=e(a):(e=new Uint8Array(a),(s.crypto||s.msCrypto).getRandomValues(e)),E(e)}catch(e){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,E(A)]}}():e,3),o),u=new c(o),k=function(){for(var e=u.g(6),t=l,n=0;e<m;)e=(e+n)*a,t*=a,n=u.g(1);for(;e>=p;)e/=2,t/=2,n>>>=1;return(e+n)/t};return k.int32=function(){return 0|u.g(4)},k.quick=function(){return u.g(4)/4294967296},k.double=k,G(E(u.S),A),(t.pass||n||function(e,t,n,o){return o&&(o.S&&d(o,u),e.state=function(){return d(u,{})}),n?(i.random=e,t):e})(k,h,"global"in t?t.global:this==i,t.state)}function c(e){var t,n=e.length,o=this,A=0,i=o.i=o.j=0,r=o.S=[];for(n||(e=[n++]);A<a;)r[A]=A++;for(A=0;A<a;A++)r[A]=r[i=h&i+e[A%n]+(t=r[A])],r[i]=t;(o.g=function(e){for(var t,n=0,A=o.i,i=o.j,r=o.S;e--;)t=r[A=h&A+1],n=n*a+r[h&(r[A]=r[i=h&i+t])+(r[i]=t)];return o.i=A,o.j=i,n})(a)}function d(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function I(e,t){var n,o=[],A=typeof e;if(t&&"object"==A)for(n in e)try{o.push(I(e[n],t-1))}catch(e){}return o.length?o:"string"==A?e:e+"\0"}function G(e,t){for(var n,o=e+"",A=0;A<o.length;)t[h&A]=h&(n^=19*t[h&A])+o.charCodeAt(A++);return E(t)}function E(e){return String.fromCharCode.apply(0,e)}if(i.seedrandom=u,G(i.random(),A),e.exports){e.exports=u;try{r=n(5042)}catch(e){}}else void 0===(o=function(){return u}.call(t,n,t,e))||(e.exports=o)}([],Math)},3379:(e,t,n)=>{"use strict";var o,A=function(){var e={};return function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}e[t]=n}return e[t]}}(),i=[];function r(e){for(var t=-1,n=0;n<i.length;n++)if(i[n].identifier===e){t=n;break}return t}function s(e,t){for(var n={},o=[],A=0;A<e.length;A++){var s=e[A],a=t.base?s[0]+t.base:s[0],l=n[a]||0,m="".concat(a," ").concat(l);n[a]=l+1;var p=r(m),h={css:s[1],media:s[2],sourceMap:s[3]};-1!==p?(i[p].references++,i[p].updater(h)):i.push({identifier:m,updater:d(h,t),references:1}),o.push(m)}return o}function a(e){var t=document.createElement("style"),o=e.attributes||{};if(void 0===o.nonce){var i=n.nc;i&&(o.nonce=i)}if(Object.keys(o).forEach((function(e){t.setAttribute(e,o[e])})),"function"==typeof e.insert)e.insert(t);else{var r=A(e.insert||"head");if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(t)}return t}var l,m=(l=[],function(e,t){return l[e]=t,l.filter(Boolean).join("\n")});function p(e,t,n,o){var A=n?"":o.media?"@media ".concat(o.media," {").concat(o.css,"}"):o.css;if(e.styleSheet)e.styleSheet.cssText=m(t,A);else{var i=document.createTextNode(A),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(i,r[t]):e.appendChild(i)}}function h(e,t,n){var o=n.css,A=n.media,i=n.sourceMap;if(A?e.setAttribute("media",A):e.removeAttribute("media"),i&&"undefined"!=typeof btoa&&(o+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),e.styleSheet)e.styleSheet.cssText=o;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(o))}}var u=null,c=0;function d(e,t){var n,o,A;if(t.singleton){var i=c++;n=u||(u=a(t)),o=p.bind(null,n,i,!1),A=p.bind(null,n,i,!0)}else n=a(t),o=h.bind(null,n,t),A=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)};return o(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;o(e=t)}else A()}}e.exports=function(e,t){(t=t||{}).singleton||"boolean"==typeof t.singleton||(t.singleton=(void 0===o&&(o=Boolean(window&&document&&document.all&&!window.atob)),o));var n=s(e=e||[],t);return function(e){if(e=e||[],"[object Array]"===Object.prototype.toString.call(e)){for(var o=0;o<n.length;o++){var A=r(n[o]);i[A].references--}for(var a=s(e,t),l=0;l<n.length;l++){var m=r(n[l]);0===i[m].references&&(i[m].updater(),i.splice(m,1))}n=a}}}},2212:(e,t,n)=>{"use strict";n.r(t),n.d(t,{ACESFilmicToneMapping:()=>ne,AddEquation:()=>D,AddOperation:()=>Z,AdditiveAnimationBlendMode:()=>Wt,AdditiveBlending:()=>f,AlphaFormat:()=>Me,AlwaysDepth:()=>O,AlwaysStencilFunc:()=>Cn,AmbientLight:()=>pp,AmbientLightProbe:()=>xp,AnimationClip:()=>hm,AnimationLoader:()=>gm,AnimationMixer:()=>ph,AnimationObjectGroup:()=>lh,AnimationUtils:()=>$l,ArcCurve:()=>jm,ArrayCamera:()=>js,ArrowHelper:()=>tu,Audio:()=>Up,AudioAnalyser:()=>Qp,AudioContext:()=>yp,AudioListener:()=>Pp,AudioLoader:()=>bp,AxesHelper:()=>nu,AxisHelper:()=>$u,BackSide:()=>d,BasicDepthPacking:()=>An,BasicShadowMap:()=>m,BinaryTextureLoader:()=>Ac,Bone:()=>ha,BooleanKeyframeTrack:()=>im,BoundingBoxHelper:()=>ec,Box2:()=>fh,Box3:()=>eo,Box3Helper:()=>Qh,BoxBufferGeometry:()=>hi,BoxGeometry:()=>hi,BoxHelper:()=>Xh,BufferAttribute:()=>DA,BufferGeometry:()=>WA,BufferGeometryLoader:()=>kp,ByteType:()=>De,Cache:()=>cm,Camera:()=>Gi,CameraHelper:()=>Wh,CanvasRenderer:()=>rc,CanvasTexture:()=>Ra,CatmullRomCurve3:()=>Bm,CineonToneMapping:()=>te,CircleBufferGeometry:()=>Pa,CircleGeometry:()=>Pa,ClampToEdgeWrapping:()=>he,Clock:()=>Lp,Color:()=>fA,ColorKeyframeTrack:()=>rm,CompressedTexture:()=>Na,CompressedTextureLoader:()=>fm,ConeBufferGeometry:()=>Va,ConeGeometry:()=>Va,CubeCamera:()=>gi,CubeReflectionMapping:()=>ie,CubeRefractionMapping:()=>re,CubeTexture:()=>fi,CubeTextureLoader:()=>Fm,CubeUVReflectionMapping:()=>le,CubeUVRefractionMapping:()=>me,CubicBezierCurve:()=>Sm,CubicBezierCurve3:()=>Tm,CubicInterpolant:()=>tm,CullFaceBack:()=>s,CullFaceFront:()=>a,CullFaceFrontBack:()=>l,CullFaceNone:()=>r,Curve:()=>Jm,CurvePath:()=>Wm,CustomBlending:()=>C,CustomToneMapping:()=>oe,CylinderBufferGeometry:()=>Ua,CylinderGeometry:()=>Ua,Cylindrical:()=>kh,DataTexture:()=>Fi,DataTexture2DArray:()=>_i,DataTexture3D:()=>zi,DataTextureLoader:()=>Cm,DataUtils:()=>iu,DecrementStencilOp:()=>un,DecrementWrapStencilOp:()=>dn,DefaultLoadingManager:()=>Im,DepthFormat:()=>Oe,DepthStencilFormat:()=>Pe,DepthTexture:()=>Oa,DirectionalLight:()=>mp,DirectionalLightHelper:()=>Ph,DiscreteInterpolant:()=>om,DodecahedronBufferGeometry:()=>_a,DodecahedronGeometry:()=>_a,DoubleSide:()=>I,DstAlphaFactor:()=>M,DstColorFactor:()=>S,DynamicBufferAttribute:()=>Pu,DynamicCopyUsage:()=>qn,DynamicDrawUsage:()=>Jn,DynamicReadUsage:()=>Kn,EdgesGeometry:()=>Ya,EdgesHelper:()=>tc,EllipseCurve:()=>vm,EqualDepth:()=>V,EqualStencilFunc:()=>kn,EquirectangularReflectionMapping:()=>se,EquirectangularRefractionMapping:()=>ae,Euler:()=>Mo,EventDispatcher:()=>Mn,ExtrudeBufferGeometry:()=>Jl,ExtrudeGeometry:()=>Jl,FaceColors:()=>qu,FileLoader:()=>km,FlatShading:()=>G,Float16BufferAttribute:()=>xA,Float32Attribute:()=>Zu,Float32BufferAttribute:()=>BA,Float64Attribute:()=>Yu,Float64BufferAttribute:()=>wA,FloatType:()=>ye,Fog:()=>Ms,FogExp2:()=>ws,Font:()=>Jp,FontLoader:()=>jp,FrontSide:()=>c,Frustum:()=>Ji,GLBufferAttribute:()=>ch,GLSL1:()=>Bn,GLSL3:()=>wn,GammaEncoding:()=>Yt,GreaterDepth:()=>_,GreaterEqualDepth:()=>W,GreaterEqualStencilFunc:()=>Fn,GreaterStencilFunc:()=>fn,GridHelper:()=>Sh,Group:()=>Ks,HalfFloatType:()=>be,HemisphereLight:()=>Qm,HemisphereLightHelper:()=>Lh,HemisphereLightProbe:()=>qp,IcosahedronBufferGeometry:()=>jl,IcosahedronGeometry:()=>jl,ImageBitmapLoader:()=>Cp,ImageLoader:()=>Hm,ImageUtils:()=>Pn,ImmediateRenderObject:()=>Dh,IncrementStencilOp:()=>hn,IncrementWrapStencilOp:()=>cn,InstancedBufferAttribute:()=>Ep,InstancedBufferGeometry:()=>Gp,InstancedInterleavedBuffer:()=>uh,InstancedMesh:()=>ga,Int16Attribute:()=>_u,Int16BufferAttribute:()=>KA,Int32Attribute:()=>Xu,Int32BufferAttribute:()=>bA,Int8Attribute:()=>Uu,Int8BufferAttribute:()=>JA,IntType:()=>je,InterleavedBuffer:()=>Ss,InterleavedBufferAttribute:()=>Ns,Interpolant:()=>em,InterpolateDiscrete:()=>Tt,InterpolateLinear:()=>Nt,InterpolateSmooth:()=>Rt,InvertStencilOp:()=>In,JSONLoader:()=>sc,KeepStencilOp:()=>mn,KeyframeTrack:()=>Am,LOD:()=>ia,LatheBufferGeometry:()=>Kl,LatheGeometry:()=>Kl,Layers:()=>Lo,LensFlare:()=>lc,LessDepth:()=>P,LessEqualDepth:()=>U,LessEqualStencilFunc:()=>gn,LessStencilFunc:()=>En,Light:()=>Xm,LightProbe:()=>cp,Line:()=>va,Line3:()=>Ch,LineBasicMaterial:()=>fa,LineCurve:()=>Nm,LineCurve3:()=>Rm,LineDashedMaterial:()=>Zl,LineLoop:()=>ba,LinePieces:()=>yu,LineSegments:()=>ya,LineStrip:()=>Ku,LinearEncoding:()=>Qt,LinearFilter:()=>ke,LinearInterpolant:()=>nm,LinearMipMapLinearFilter:()=>Fe,LinearMipMapNearestFilter:()=>fe,LinearMipmapLinearFilter:()=>He,LinearMipmapNearestFilter:()=>ge,LinearToneMapping:()=>$,Loader:()=>Gm,LoaderUtils:()=>Ip,LoadingManager:()=>dm,LogLuvEncoding:()=>en,LoopOnce:()=>Mt,LoopPingPong:()=>St,LoopRepeat:()=>Lt,LuminanceAlphaFormat:()=>Ne,LuminanceFormat:()=>Te,MOUSE:()=>A,Material:()=>cA,MaterialLoader:()=>dp,Math:()=>Tn,MathUtils:()=>Tn,Matrix3:()=>Rn,Matrix4:()=>Jo,MaxEquation:()=>K,Mesh:()=>mi,MeshBasicMaterial:()=>HA,MeshDepthMaterial:()=>Hs,MeshDistanceMaterial:()=>Fs,MeshFaceMaterial:()=>Bu,MeshLambertMaterial:()=>Xl,MeshMatcapMaterial:()=>Ql,MeshNormalMaterial:()=>zl,MeshPhongMaterial:()=>Wl,MeshPhysicalMaterial:()=>Vl,MeshStandardMaterial:()=>Ul,MeshToonMaterial:()=>_l,MinEquation:()=>j,MirroredRepeatWrapping:()=>ue,MixOperation:()=>Q,MultiMaterial:()=>wu,MultiplyBlending:()=>F,MultiplyOperation:()=>X,NearestFilter:()=>ce,NearestMipMapLinearFilter:()=>Ee,NearestMipMapNearestFilter:()=>Ie,NearestMipmapLinearFilter:()=>Ge,NearestMipmapNearestFilter:()=>de,NeverDepth:()=>R,NeverStencilFunc:()=>Gn,NoBlending:()=>k,NoColors:()=>bu,NoToneMapping:()=>Y,NormalAnimationBlendMode:()=>Vt,NormalBlending:()=>g,NotEqualDepth:()=>z,NotEqualStencilFunc:()=>Hn,NumberKeyframeTrack:()=>sm,Object3D:()=>Zo,ObjectLoader:()=>gp,ObjectSpaceNormalMap:()=>an,OctahedronBufferGeometry:()=>yl,OctahedronGeometry:()=>yl,OneFactor:()=>b,OneMinusDstAlphaFactor:()=>L,OneMinusDstColorFactor:()=>T,OneMinusSrcAlphaFactor:()=>w,OneMinusSrcColorFactor:()=>x,OrthographicCamera:()=>ap,PCFShadowMap:()=>p,PCFSoftShadowMap:()=>h,PMREMGenerator:()=>Hu,ParametricBufferGeometry:()=>bl,ParametricGeometry:()=>bl,Particle:()=>Lu,ParticleBasicMaterial:()=>Nu,ParticleSystem:()=>Su,ParticleSystemMaterial:()=>Ru,Path:()=>_m,PerspectiveCamera:()=>Ei,Plane:()=>tA,PlaneBufferGeometry:()=>Ki,PlaneGeometry:()=>Ki,PlaneHelper:()=>Zh,PointCloud:()=>Mu,PointCloudMaterial:()=>Tu,PointLight:()=>sp,PointLightHelper:()=>xh,Points:()=>La,PointsMaterial:()=>qa,PolarGridHelper:()=>Th,PolyhedronBufferGeometry:()=>Wa,PolyhedronGeometry:()=>Wa,PositionalAudio:()=>Xp,PropertyBinding:()=>ah,PropertyMixer:()=>Zp,QuadraticBezierCurve:()=>Om,QuadraticBezierCurve3:()=>Pm,Quaternion:()=>Qn,QuaternionKeyframeTrack:()=>lm,QuaternionLinearInterpolant:()=>am,REVISION:()=>o,RGBADepthPacking:()=>rn,RGBAFormat:()=>Se,RGBAIntegerFormat:()=>Xe,RGBA_ASTC_10x10_Format:()=>Et,RGBA_ASTC_10x5_Format:()=>dt,RGBA_ASTC_10x6_Format:()=>It,RGBA_ASTC_10x8_Format:()=>Gt,RGBA_ASTC_12x10_Format:()=>kt,RGBA_ASTC_12x12_Format:()=>gt,RGBA_ASTC_4x4_Format:()=>st,RGBA_ASTC_5x4_Format:()=>at,RGBA_ASTC_5x5_Format:()=>lt,RGBA_ASTC_6x5_Format:()=>mt,RGBA_ASTC_6x6_Format:()=>pt,RGBA_ASTC_8x5_Format:()=>ht,RGBA_ASTC_8x6_Format:()=>ut,RGBA_ASTC_8x8_Format:()=>ct,RGBA_BPTC_Format:()=>ft,RGBA_ETC2_EAC_Format:()=>rt,RGBA_PVRTC_2BPPV1_Format:()=>ot,RGBA_PVRTC_4BPPV1_Format:()=>nt,RGBA_S3TC_DXT1_Format:()=>Ze,RGBA_S3TC_DXT3_Format:()=>Ye,RGBA_S3TC_DXT5_Format:()=>$e,RGBDEncoding:()=>on,RGBEEncoding:()=>$t,RGBEFormat:()=>Re,RGBFormat:()=>Le,RGBIntegerFormat:()=>ze,RGBM16Encoding:()=>nn,RGBM7Encoding:()=>tn,RGB_ETC1_Format:()=>At,RGB_ETC2_Format:()=>it,RGB_PVRTC_2BPPV1_Format:()=>tt,RGB_PVRTC_4BPPV1_Format:()=>et,RGB_S3TC_DXT1_Format:()=>Qe,RGFormat:()=>We,RGIntegerFormat:()=>_e,RawShaderMaterial:()=>Pl,Ray:()=>Do,Raycaster:()=>dh,RectAreaLight:()=>hp,RedFormat:()=>Ue,RedIntegerFormat:()=>Ve,ReinhardToneMapping:()=>ee,RepeatWrapping:()=>pe,ReplaceStencilOp:()=>pn,ReverseSubtractEquation:()=>v,RingBufferGeometry:()=>ql,RingGeometry:()=>ql,SRGB8_ALPHA8_ASTC_10x10_Format:()=>xt,SRGB8_ALPHA8_ASTC_10x5_Format:()=>yt,SRGB8_ALPHA8_ASTC_10x6_Format:()=>bt,SRGB8_ALPHA8_ASTC_10x8_Format:()=>qt,SRGB8_ALPHA8_ASTC_12x10_Format:()=>Bt,SRGB8_ALPHA8_ASTC_12x12_Format:()=>wt,SRGB8_ALPHA8_ASTC_4x4_Format:()=>Ht,SRGB8_ALPHA8_ASTC_5x4_Format:()=>Ft,SRGB8_ALPHA8_ASTC_5x5_Format:()=>Ct,SRGB8_ALPHA8_ASTC_6x5_Format:()=>Dt,SRGB8_ALPHA8_ASTC_6x6_Format:()=>Jt,SRGB8_ALPHA8_ASTC_8x5_Format:()=>vt,SRGB8_ALPHA8_ASTC_8x6_Format:()=>jt,SRGB8_ALPHA8_ASTC_8x8_Format:()=>Kt,Scene:()=>Ls,SceneUtils:()=>ac,ShaderChunk:()=>yi,ShaderLib:()=>qi,ShaderMaterial:()=>Ii,ShadowMaterial:()=>Ol,Shape:()=>zm,ShapeBufferGeometry:()=>xl,ShapeGeometry:()=>xl,ShapePath:()=>Dp,ShapeUtils:()=>Fl,ShortType:()=>Je,Skeleton:()=>da,SkeletonHelper:()=>bh,SkinnedMesh:()=>pa,SmoothShading:()=>E,Sphere:()=>Go,SphereBufferGeometry:()=>Bl,SphereGeometry:()=>Bl,Spherical:()=>Eh,SphericalHarmonics3:()=>up,SplineCurve:()=>Um,SpotLight:()=>np,SpotLightHelper:()=>vh,Sprite:()=>ta,SpriteMaterial:()=>Rs,SrcAlphaFactor:()=>B,SrcAlphaSaturateFactor:()=>N,SrcColorFactor:()=>q,StaticCopyUsage:()=>bn,StaticDrawUsage:()=>Dn,StaticReadUsage:()=>jn,StereoCamera:()=>Mp,StreamCopyUsage:()=>xn,StreamDrawUsage:()=>vn,StreamReadUsage:()=>yn,StringKeyframeTrack:()=>mm,SubtractEquation:()=>J,SubtractiveBlending:()=>H,TOUCH:()=>i,TangentSpaceNormalMap:()=>sn,TetrahedronBufferGeometry:()=>wl,TetrahedronGeometry:()=>wl,TextBufferGeometry:()=>Ml,TextGeometry:()=>Ml,Texture:()=>Vn,TextureLoader:()=>Dm,TorusBufferGeometry:()=>Ll,TorusGeometry:()=>Ll,TorusKnotBufferGeometry:()=>Sl,TorusKnotGeometry:()=>Sl,Triangle:()=>hA,TriangleFanDrawMode:()=>Xt,TriangleStripDrawMode:()=>zt,TrianglesDrawMode:()=>_t,TubeBufferGeometry:()=>Tl,TubeGeometry:()=>Tl,UVMapping:()=>Ae,Uint16Attribute:()=>zu,Uint16BufferAttribute:()=>yA,Uint32Attribute:()=>Qu,Uint32BufferAttribute:()=>qA,Uint8Attribute:()=>Vu,Uint8BufferAttribute:()=>vA,Uint8ClampedAttribute:()=>Wu,Uint8ClampedBufferAttribute:()=>jA,Uniform:()=>hh,UniformsLib:()=>bi,UniformsUtils:()=>di,UnsignedByteType:()=>Ce,UnsignedInt248Type:()=>we,UnsignedIntType:()=>Ke,UnsignedShort4444Type:()=>qe,UnsignedShort5551Type:()=>xe,UnsignedShort565Type:()=>Be,UnsignedShortType:()=>ve,VSMShadowMap:()=>u,Vector2:()=>Nn,Vector3:()=>Zn,Vector4:()=>_n,VectorKeyframeTrack:()=>pm,Vertex:()=>Ou,VertexColors:()=>xu,VideoTexture:()=>Ta,WebGL1Renderer:()=>Bs,WebGLCubeRenderTarget:()=>Hi,WebGLMultisampleRenderTarget:()=>Xn,WebGLRenderTarget:()=>zn,WebGLRenderTargetCube:()=>ic,WebGLRenderer:()=>xs,WebGLUtils:()=>vs,WireframeGeometry:()=>Nl,WireframeHelper:()=>nc,WrapAroundEnding:()=>Ut,XHRLoader:()=>oc,ZeroCurvatureEnding:()=>Ot,ZeroFactor:()=>y,ZeroSlopeEnding:()=>Pt,ZeroStencilOp:()=>ln,sRGBEncoding:()=>Zt});const o="126",A={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},i={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},r=0,s=1,a=2,l=3,m=0,p=1,h=2,u=3,c=0,d=1,I=2,G=1,E=2,k=0,g=1,f=2,H=3,F=4,C=5,D=100,J=101,v=102,j=103,K=104,y=200,b=201,q=202,x=203,B=204,w=205,M=206,L=207,S=208,T=209,N=210,R=0,O=1,P=2,U=3,V=4,W=5,_=6,z=7,X=0,Q=1,Z=2,Y=0,$=1,ee=2,te=3,ne=4,oe=5,Ae=300,ie=301,re=302,se=303,ae=304,le=306,me=307,pe=1e3,he=1001,ue=1002,ce=1003,de=1004,Ie=1004,Ge=1005,Ee=1005,ke=1006,ge=1007,fe=1007,He=1008,Fe=1008,Ce=1009,De=1010,Je=1011,ve=1012,je=1013,Ke=1014,ye=1015,be=1016,qe=1017,xe=1018,Be=1019,we=1020,Me=1021,Le=1022,Se=1023,Te=1024,Ne=1025,Re=Se,Oe=1026,Pe=1027,Ue=1028,Ve=1029,We=1030,_e=1031,ze=1032,Xe=1033,Qe=33776,Ze=33777,Ye=33778,$e=33779,et=35840,tt=35841,nt=35842,ot=35843,At=36196,it=37492,rt=37496,st=37808,at=37809,lt=37810,mt=37811,pt=37812,ht=37813,ut=37814,ct=37815,dt=37816,It=37817,Gt=37818,Et=37819,kt=37820,gt=37821,ft=36492,Ht=37840,Ft=37841,Ct=37842,Dt=37843,Jt=37844,vt=37845,jt=37846,Kt=37847,yt=37848,bt=37849,qt=37850,xt=37851,Bt=37852,wt=37853,Mt=2200,Lt=2201,St=2202,Tt=2300,Nt=2301,Rt=2302,Ot=2400,Pt=2401,Ut=2402,Vt=2500,Wt=2501,_t=0,zt=1,Xt=2,Qt=3e3,Zt=3001,Yt=3007,$t=3002,en=3003,tn=3004,nn=3005,on=3006,An=3200,rn=3201,sn=0,an=1,ln=0,mn=7680,pn=7681,hn=7682,un=7683,cn=34055,dn=34056,In=5386,Gn=512,En=513,kn=514,gn=515,fn=516,Hn=517,Fn=518,Cn=519,Dn=35044,Jn=35048,vn=35040,jn=35045,Kn=35049,yn=35041,bn=35046,qn=35050,xn=35042,Bn="100",wn="300 es";function Mn(){}Object.assign(Mn.prototype,{addEventListener:function(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)},hasEventListener:function(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)},removeEventListener:function(e,t){if(void 0===this._listeners)return;const n=this._listeners[e];if(void 0!==n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}},dispatchEvent:function(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const n=t.slice(0);for(let t=0,o=n.length;t<o;t++)n[t].call(this,e)}}});const Ln=[];for(let e=0;e<256;e++)Ln[e]=(e<16?"0":"")+e.toString(16);let Sn=1234567;const Tn={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,o=4294967295*Math.random()|0;return(Ln[255&e]+Ln[e>>8&255]+Ln[e>>16&255]+Ln[e>>24&255]+"-"+Ln[255&t]+Ln[t>>8&255]+"-"+Ln[t>>16&15|64]+Ln[t>>24&255]+"-"+Ln[63&n|128]+Ln[n>>8&255]+"-"+Ln[n>>16&255]+Ln[n>>24&255]+Ln[255&o]+Ln[o>>8&255]+Ln[o>>16&255]+Ln[o>>24&255]).toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,o,A){return o+(e-t)*(A-o)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},damp:function(e,t,n,o){return Tn.lerp(e,t,1-Math.exp(-n*o))},pingpong:function(e,t=1){return t-Math.abs(Tn.euclideanModulo(e,2*t)-t)},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return void 0!==e&&(Sn=e%2147483647),Sn=16807*Sn%2147483647,(Sn-1)/2147483646},degToRad:function(e){return e*Tn.DEG2RAD},radToDeg:function(e){return e*Tn.RAD2DEG},isPowerOfTwo:function(e){return 0==(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,o,A){const i=Math.cos,r=Math.sin,s=i(n/2),a=r(n/2),l=i((t+o)/2),m=r((t+o)/2),p=i((t-o)/2),h=r((t-o)/2),u=i((o-t)/2),c=r((o-t)/2);switch(A){case"XYX":e.set(s*m,a*p,a*h,s*l);break;case"YZY":e.set(a*h,s*m,a*p,s*l);break;case"ZXZ":e.set(a*p,a*h,s*m,s*l);break;case"XZX":e.set(s*m,a*c,a*u,s*l);break;case"YXY":e.set(a*u,s*m,a*c,s*l);break;case"ZYZ":e.set(a*c,a*u,s*m,s*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+A)}}};class Nn{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6],this.y=o[1]*t+o[4]*n+o[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),o=Math.sin(t),A=this.x-e.x,i=this.y-e.y;return this.x=A*n-i*o+e.x,this.y=A*o+i*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}Nn.prototype.isVector2=!0;class Rn{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,o,A,i,r,s,a){const l=this.elements;return l[0]=e,l[1]=o,l[2]=r,l[3]=t,l[4]=A,l[5]=s,l[6]=n,l[7]=i,l[8]=a,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,o=t.elements,A=this.elements,i=n[0],r=n[3],s=n[6],a=n[1],l=n[4],m=n[7],p=n[2],h=n[5],u=n[8],c=o[0],d=o[3],I=o[6],G=o[1],E=o[4],k=o[7],g=o[2],f=o[5],H=o[8];return A[0]=i*c+r*G+s*g,A[3]=i*d+r*E+s*f,A[6]=i*I+r*k+s*H,A[1]=a*c+l*G+m*g,A[4]=a*d+l*E+m*f,A[7]=a*I+l*k+m*H,A[2]=p*c+h*G+u*g,A[5]=p*d+h*E+u*f,A[8]=p*I+h*k+u*H,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],o=e[2],A=e[3],i=e[4],r=e[5],s=e[6],a=e[7],l=e[8];return t*i*l-t*r*a-n*A*l+n*r*s+o*A*a-o*i*s}invert(){const e=this.elements,t=e[0],n=e[1],o=e[2],A=e[3],i=e[4],r=e[5],s=e[6],a=e[7],l=e[8],m=l*i-r*a,p=r*s-l*A,h=a*A-i*s,u=t*m+n*p+o*h;if(0===u)return this.set(0,0,0,0,0,0,0,0,0);const c=1/u;return e[0]=m*c,e[1]=(o*a-l*n)*c,e[2]=(r*n-o*i)*c,e[3]=p*c,e[4]=(l*t-o*s)*c,e[5]=(o*A-r*t)*c,e[6]=h*c,e[7]=(n*s-a*t)*c,e[8]=(i*t-n*A)*c,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,o,A,i,r){const s=Math.cos(A),a=Math.sin(A);return this.set(n*s,n*a,-n*(s*i+a*r)+i+e,-o*a,o*s,-o*(-a*i+s*r)+r+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),o=this.elements,A=o[0],i=o[3],r=o[6],s=o[1],a=o[4],l=o[7];return o[0]=t*A+n*s,o[3]=t*i+n*a,o[6]=t*r+n*l,o[1]=-n*A+t*s,o[4]=-n*i+t*a,o[7]=-n*r+t*l,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}let On;Rn.prototype.isMatrix3=!0;const Pn={getDataURL:function(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===On&&(On=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),On.width=e.width,On.height=e.height;const n=On.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=On}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let Un=0;class Vn extends Mn{constructor(e=Vn.DEFAULT_IMAGE,t=Vn.DEFAULT_MAPPING,n=he,o=he,A=ke,i=He,r=Se,s=Ce,a=1,l=Qt){super(),Object.defineProperty(this,"id",{value:Un++}),this.uuid=Tn.generateUUID(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=o,this.magFilter=A,this.minFilter=i,this.anisotropy=a,this.format=r,this.internalFormat=null,this.type=s,this.offset=new Nn(0,0),this.repeat=new Nn(1,1),this.center=new Nn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Rn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=l,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const o=this.image;if(void 0===o.uuid&&(o.uuid=Tn.generateUUID()),!t&&void 0===e.images[o.uuid]){let t;if(Array.isArray(o)){t=[];for(let e=0,n=o.length;e<n;e++)o[e].isDataTexture?t.push(Wn(o[e].image)):t.push(Wn(o[e]))}else t=Wn(o);e.images[o.uuid]={uuid:o.uuid,url:t}}n.image=o.uuid}return t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Ae)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case pe:e.x=e.x-Math.floor(e.x);break;case he:e.x=e.x<0?0:1;break;case ue:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case pe:e.y=e.y-Math.floor(e.y);break;case he:e.y=e.y<0?0:1;break;case ue:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&this.version++}}function Wn(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?Pn.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Vn.DEFAULT_IMAGE=void 0,Vn.DEFAULT_MAPPING=Ae,Vn.prototype.isTexture=!0;class _n{constructor(e=0,t=0,n=0,o=1){this.x=e,this.y=t,this.z=n,this.w=o}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,o){return this.x=e,this.y=t,this.z=n,this.w=o,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,o=this.z,A=this.w,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*o+i[12]*A,this.y=i[1]*t+i[5]*n+i[9]*o+i[13]*A,this.z=i[2]*t+i[6]*n+i[10]*o+i[14]*A,this.w=i[3]*t+i[7]*n+i[11]*o+i[15]*A,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,o,A;const i=.01,r=.1,s=e.elements,a=s[0],l=s[4],m=s[8],p=s[1],h=s[5],u=s[9],c=s[2],d=s[6],I=s[10];if(Math.abs(l-p)<i&&Math.abs(m-c)<i&&Math.abs(u-d)<i){if(Math.abs(l+p)<r&&Math.abs(m+c)<r&&Math.abs(u+d)<r&&Math.abs(a+h+I-3)<r)return this.set(1,0,0,0),this;t=Math.PI;const e=(a+1)/2,s=(h+1)/2,G=(I+1)/2,E=(l+p)/4,k=(m+c)/4,g=(u+d)/4;return e>s&&e>G?e<i?(n=0,o=.707106781,A=.707106781):(n=Math.sqrt(e),o=E/n,A=k/n):s>G?s<i?(n=.707106781,o=0,A=.707106781):(o=Math.sqrt(s),n=E/o,A=g/o):G<i?(n=.707106781,o=.707106781,A=0):(A=Math.sqrt(G),n=k/A,o=g/A),this.set(n,o,A,t),this}let G=Math.sqrt((d-u)*(d-u)+(m-c)*(m-c)+(p-l)*(p-l));return Math.abs(G)<.001&&(G=1),this.x=(d-u)/G,this.y=(m-c)/G,this.z=(p-l)/G,this.w=Math.acos((a+h+I-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}_n.prototype.isVector4=!0;class zn extends Mn{constructor(e,t,n){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new _n(0,0,e,t),this.scissorTest=!1,this.viewport=new _n(0,0,e,t),n=n||{},this.texture=new Vn(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:ke,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}zn.prototype.isWebGLRenderTarget=!0;class Xn extends zn{constructor(e,t,n){super(e,t,n),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}Xn.prototype.isWebGLMultisampleRenderTarget=!0;class Qn{constructor(e=0,t=0,n=0,o=1){this._x=e,this._y=t,this._z=n,this._w=o}static slerp(e,t,n,o){return n.copy(e).slerp(t,o)}static slerpFlat(e,t,n,o,A,i,r){let s=n[o+0],a=n[o+1],l=n[o+2],m=n[o+3];const p=A[i+0],h=A[i+1],u=A[i+2],c=A[i+3];if(0===r)return e[t+0]=s,e[t+1]=a,e[t+2]=l,void(e[t+3]=m);if(1===r)return e[t+0]=p,e[t+1]=h,e[t+2]=u,void(e[t+3]=c);if(m!==c||s!==p||a!==h||l!==u){let e=1-r;const t=s*p+a*h+l*u+m*c,n=t>=0?1:-1,o=1-t*t;if(o>Number.EPSILON){const A=Math.sqrt(o),i=Math.atan2(A,t*n);e=Math.sin(e*i)/A,r=Math.sin(r*i)/A}const A=r*n;if(s=s*e+p*A,a=a*e+h*A,l=l*e+u*A,m=m*e+c*A,e===1-r){const e=1/Math.sqrt(s*s+a*a+l*l+m*m);s*=e,a*=e,l*=e,m*=e}}e[t]=s,e[t+1]=a,e[t+2]=l,e[t+3]=m}static multiplyQuaternionsFlat(e,t,n,o,A,i){const r=n[o],s=n[o+1],a=n[o+2],l=n[o+3],m=A[i],p=A[i+1],h=A[i+2],u=A[i+3];return e[t]=r*u+l*m+s*h-a*p,e[t+1]=s*u+l*p+a*m-r*h,e[t+2]=a*u+l*h+r*p-s*m,e[t+3]=l*u-r*m-s*p-a*h,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,o){return this._x=e,this._y=t,this._z=n,this._w=o,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,o=e._y,A=e._z,i=e._order,r=Math.cos,s=Math.sin,a=r(n/2),l=r(o/2),m=r(A/2),p=s(n/2),h=s(o/2),u=s(A/2);switch(i){case"XYZ":this._x=p*l*m+a*h*u,this._y=a*h*m-p*l*u,this._z=a*l*u+p*h*m,this._w=a*l*m-p*h*u;break;case"YXZ":this._x=p*l*m+a*h*u,this._y=a*h*m-p*l*u,this._z=a*l*u-p*h*m,this._w=a*l*m+p*h*u;break;case"ZXY":this._x=p*l*m-a*h*u,this._y=a*h*m+p*l*u,this._z=a*l*u+p*h*m,this._w=a*l*m-p*h*u;break;case"ZYX":this._x=p*l*m-a*h*u,this._y=a*h*m+p*l*u,this._z=a*l*u-p*h*m,this._w=a*l*m+p*h*u;break;case"YZX":this._x=p*l*m+a*h*u,this._y=a*h*m+p*l*u,this._z=a*l*u-p*h*m,this._w=a*l*m-p*h*u;break;case"XZY":this._x=p*l*m-a*h*u,this._y=a*h*m-p*l*u,this._z=a*l*u+p*h*m,this._w=a*l*m+p*h*u;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+i)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,o=Math.sin(n);return this._x=e.x*o,this._y=e.y*o,this._z=e.z*o,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],o=t[4],A=t[8],i=t[1],r=t[5],s=t[9],a=t[2],l=t[6],m=t[10],p=n+r+m;if(p>0){const e=.5/Math.sqrt(p+1);this._w=.25/e,this._x=(l-s)*e,this._y=(A-a)*e,this._z=(i-o)*e}else if(n>r&&n>m){const e=2*Math.sqrt(1+n-r-m);this._w=(l-s)/e,this._x=.25*e,this._y=(o+i)/e,this._z=(A+a)/e}else if(r>m){const e=2*Math.sqrt(1+r-n-m);this._w=(A-a)/e,this._x=(o+i)/e,this._y=.25*e,this._z=(s+l)/e}else{const e=2*Math.sqrt(1+m-n-r);this._w=(i-o)/e,this._x=(A+a)/e,this._y=(s+l)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<1e-6?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Tn.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const o=Math.min(1,t/n);return this.slerp(e,o),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,o=e._y,A=e._z,i=e._w,r=t._x,s=t._y,a=t._z,l=t._w;return this._x=n*l+i*r+o*a-A*s,this._y=o*l+i*s+A*r-n*a,this._z=A*l+i*a+n*s-o*r,this._w=i*l-n*r-o*s-A*a,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,o=this._y,A=this._z,i=this._w;let r=i*e._w+n*e._x+o*e._y+A*e._z;if(r<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,r=-r):this.copy(e),r>=1)return this._w=i,this._x=n,this._y=o,this._z=A,this;const s=1-r*r;if(s<=Number.EPSILON){const e=1-t;return this._w=e*i+t*this._w,this._x=e*n+t*this._x,this._y=e*o+t*this._y,this._z=e*A+t*this._z,this.normalize(),this._onChangeCallback(),this}const a=Math.sqrt(s),l=Math.atan2(a,r),m=Math.sin((1-t)*l)/a,p=Math.sin(t*l)/a;return this._w=i*m+this._w*p,this._x=n*m+this._x*p,this._y=o*m+this._y*p,this._z=A*m+this._z*p,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Qn.prototype.isQuaternion=!0;class Zn{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion($n.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion($n.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,o=this.z,A=e.elements;return this.x=A[0]*t+A[3]*n+A[6]*o,this.y=A[1]*t+A[4]*n+A[7]*o,this.z=A[2]*t+A[5]*n+A[8]*o,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,o=this.z,A=e.elements,i=1/(A[3]*t+A[7]*n+A[11]*o+A[15]);return this.x=(A[0]*t+A[4]*n+A[8]*o+A[12])*i,this.y=(A[1]*t+A[5]*n+A[9]*o+A[13])*i,this.z=(A[2]*t+A[6]*n+A[10]*o+A[14])*i,this}applyQuaternion(e){const t=this.x,n=this.y,o=this.z,A=e.x,i=e.y,r=e.z,s=e.w,a=s*t+i*o-r*n,l=s*n+r*t-A*o,m=s*o+A*n-i*t,p=-A*t-i*n-r*o;return this.x=a*s+p*-A+l*-r-m*-i,this.y=l*s+p*-i+m*-A-a*-r,this.z=m*s+p*-r+a*-i-l*-A,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,o=this.z,A=e.elements;return this.x=A[0]*t+A[4]*n+A[8]*o,this.y=A[1]*t+A[5]*n+A[9]*o,this.z=A[2]*t+A[6]*n+A[10]*o,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,o=e.y,A=e.z,i=t.x,r=t.y,s=t.z;return this.x=o*s-A*r,this.y=A*i-n*s,this.z=n*r-o*i,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Yn.copy(this).projectOnVector(e),this.sub(Yn)}reflect(e){return this.sub(Yn.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Tn.clamp(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,o=this.z-e.z;return t*t+n*n+o*o}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const o=Math.sin(t)*e;return this.x=o*Math.sin(n),this.y=Math.cos(t)*e,this.z=o*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),o=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=o,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}Zn.prototype.isVector3=!0;const Yn=new Zn,$n=new Qn;class eo{constructor(e=new Zn(1/0,1/0,1/0),t=new Zn(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,o=1/0,A=-1/0,i=-1/0,r=-1/0;for(let s=0,a=e.length;s<a;s+=3){const a=e[s],l=e[s+1],m=e[s+2];a<t&&(t=a),l<n&&(n=l),m<o&&(o=m),a>A&&(A=a),l>i&&(i=l),m>r&&(r=m)}return this.min.set(t,n,o),this.max.set(A,i,r),this}setFromBufferAttribute(e){let t=1/0,n=1/0,o=1/0,A=-1/0,i=-1/0,r=-1/0;for(let s=0,a=e.count;s<a;s++){const a=e.getX(s),l=e.getY(s),m=e.getZ(s);a<t&&(t=a),l<n&&(n=l),m<o&&(o=m),a>A&&(A=a),l>i&&(i=l),m>r&&(r=m)}return this.min.set(t,n,o),this.max.set(A,i,r),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=no.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return void 0===e&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new Zn),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new Zn),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;void 0!==t&&(null===t.boundingBox&&t.computeBoundingBox(),oo.copy(t.boundingBox),oo.applyMatrix4(e.matrixWorld),this.union(oo));const n=e.children;for(let e=0,t=n.length;e<t;e++)this.expandByObject(n[e]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new Zn),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,no),no.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(mo),po.subVectors(this.max,mo),Ao.subVectors(e.a,mo),io.subVectors(e.b,mo),ro.subVectors(e.c,mo),so.subVectors(io,Ao),ao.subVectors(ro,io),lo.subVectors(Ao,ro);let t=[0,-so.z,so.y,0,-ao.z,ao.y,0,-lo.z,lo.y,so.z,0,-so.x,ao.z,0,-ao.x,lo.z,0,-lo.x,-so.y,so.x,0,-ao.y,ao.x,0,-lo.y,lo.x,0];return!!co(t,Ao,io,ro,po)&&(t=[1,0,0,0,1,0,0,0,1],!!co(t,Ao,io,ro,po)&&(ho.crossVectors(so,ao),t=[ho.x,ho.y,ho.z],co(t,Ao,io,ro,po)))}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new Zn),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return no.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return void 0===e&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(no).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(to[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),to[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),to[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),to[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),to[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),to[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),to[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),to[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(to)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}eo.prototype.isBox3=!0;const to=[new Zn,new Zn,new Zn,new Zn,new Zn,new Zn,new Zn,new Zn],no=new Zn,oo=new eo,Ao=new Zn,io=new Zn,ro=new Zn,so=new Zn,ao=new Zn,lo=new Zn,mo=new Zn,po=new Zn,ho=new Zn,uo=new Zn;function co(e,t,n,o,A){for(let i=0,r=e.length-3;i<=r;i+=3){uo.fromArray(e,i);const r=A.x*Math.abs(uo.x)+A.y*Math.abs(uo.y)+A.z*Math.abs(uo.z),s=t.dot(uo),a=n.dot(uo),l=o.dot(uo);if(Math.max(-Math.max(s,a,l),Math.min(s,a,l))>r)return!1}return!0}const Io=new eo;class Go{constructor(e=new Zn,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):Io.setFromPoints(e).getCenter(n);let o=0;for(let t=0,A=e.length;t<A;t++)o=Math.max(o,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(o),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return void 0===t&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new Zn),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return void 0===e&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new eo),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Eo=new Zn,ko=new Zn,go=new Zn,fo=new Zn,Ho=new Zn,Fo=new Zn,Co=new Zn;class Do{constructor(e=new Zn,t=new Zn(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return void 0===t&&(console.warn("THREE.Ray: .at() target is now required"),t=new Zn),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Eo)),this}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new Zn),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Eo.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Eo.copy(this.direction).multiplyScalar(t).add(this.origin),Eo.distanceToSquared(e))}distanceSqToSegment(e,t,n,o){ko.copy(e).add(t).multiplyScalar(.5),go.copy(t).sub(e).normalize(),fo.copy(this.origin).sub(ko);const A=.5*e.distanceTo(t),i=-this.direction.dot(go),r=fo.dot(this.direction),s=-fo.dot(go),a=fo.lengthSq(),l=Math.abs(1-i*i);let m,p,h,u;if(l>0)if(m=i*s-r,p=i*r-s,u=A*l,m>=0)if(p>=-u)if(p<=u){const e=1/l;m*=e,p*=e,h=m*(m+i*p+2*r)+p*(i*m+p+2*s)+a}else p=A,m=Math.max(0,-(i*p+r)),h=-m*m+p*(p+2*s)+a;else p=-A,m=Math.max(0,-(i*p+r)),h=-m*m+p*(p+2*s)+a;else p<=-u?(m=Math.max(0,-(-i*A+r)),p=m>0?-A:Math.min(Math.max(-A,-s),A),h=-m*m+p*(p+2*s)+a):p<=u?(m=0,p=Math.min(Math.max(-A,-s),A),h=p*(p+2*s)+a):(m=Math.max(0,-(i*A+r)),p=m>0?A:Math.min(Math.max(-A,-s),A),h=-m*m+p*(p+2*s)+a);else p=i>0?-A:A,m=Math.max(0,-(i*p+r)),h=-m*m+p*(p+2*s)+a;return n&&n.copy(this.direction).multiplyScalar(m).add(this.origin),o&&o.copy(go).multiplyScalar(p).add(ko),h}intersectSphere(e,t){Eo.subVectors(e.center,this.origin);const n=Eo.dot(this.direction),o=Eo.dot(Eo)-n*n,A=e.radius*e.radius;if(o>A)return null;const i=Math.sqrt(A-o),r=n-i,s=n+i;return r<0&&s<0?null:r<0?this.at(s,t):this.at(r,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,o,A,i,r,s;const a=1/this.direction.x,l=1/this.direction.y,m=1/this.direction.z,p=this.origin;return a>=0?(n=(e.min.x-p.x)*a,o=(e.max.x-p.x)*a):(n=(e.max.x-p.x)*a,o=(e.min.x-p.x)*a),l>=0?(A=(e.min.y-p.y)*l,i=(e.max.y-p.y)*l):(A=(e.max.y-p.y)*l,i=(e.min.y-p.y)*l),n>i||A>o?null:((A>n||n!=n)&&(n=A),(i<o||o!=o)&&(o=i),m>=0?(r=(e.min.z-p.z)*m,s=(e.max.z-p.z)*m):(r=(e.max.z-p.z)*m,s=(e.min.z-p.z)*m),n>s||r>o?null:((r>n||n!=n)&&(n=r),(s<o||o!=o)&&(o=s),o<0?null:this.at(n>=0?n:o,t)))}intersectsBox(e){return null!==this.intersectBox(e,Eo)}intersectTriangle(e,t,n,o,A){Ho.subVectors(t,e),Fo.subVectors(n,e),Co.crossVectors(Ho,Fo);let i,r=this.direction.dot(Co);if(r>0){if(o)return null;i=1}else{if(!(r<0))return null;i=-1,r=-r}fo.subVectors(this.origin,e);const s=i*this.direction.dot(Fo.crossVectors(fo,Fo));if(s<0)return null;const a=i*this.direction.dot(Ho.cross(fo));if(a<0)return null;if(s+a>r)return null;const l=-i*fo.dot(Co);return l<0?null:this.at(l/r,A)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Jo{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,o,A,i,r,s,a,l,m,p,h,u,c,d){const I=this.elements;return I[0]=e,I[4]=t,I[8]=n,I[12]=o,I[1]=A,I[5]=i,I[9]=r,I[13]=s,I[2]=a,I[6]=l,I[10]=m,I[14]=p,I[3]=h,I[7]=u,I[11]=c,I[15]=d,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Jo).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,o=1/vo.setFromMatrixColumn(e,0).length(),A=1/vo.setFromMatrixColumn(e,1).length(),i=1/vo.setFromMatrixColumn(e,2).length();return t[0]=n[0]*o,t[1]=n[1]*o,t[2]=n[2]*o,t[3]=0,t[4]=n[4]*A,t[5]=n[5]*A,t[6]=n[6]*A,t[7]=0,t[8]=n[8]*i,t[9]=n[9]*i,t[10]=n[10]*i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,o=e.y,A=e.z,i=Math.cos(n),r=Math.sin(n),s=Math.cos(o),a=Math.sin(o),l=Math.cos(A),m=Math.sin(A);if("XYZ"===e.order){const e=i*l,n=i*m,o=r*l,A=r*m;t[0]=s*l,t[4]=-s*m,t[8]=a,t[1]=n+o*a,t[5]=e-A*a,t[9]=-r*s,t[2]=A-e*a,t[6]=o+n*a,t[10]=i*s}else if("YXZ"===e.order){const e=s*l,n=s*m,o=a*l,A=a*m;t[0]=e+A*r,t[4]=o*r-n,t[8]=i*a,t[1]=i*m,t[5]=i*l,t[9]=-r,t[2]=n*r-o,t[6]=A+e*r,t[10]=i*s}else if("ZXY"===e.order){const e=s*l,n=s*m,o=a*l,A=a*m;t[0]=e-A*r,t[4]=-i*m,t[8]=o+n*r,t[1]=n+o*r,t[5]=i*l,t[9]=A-e*r,t[2]=-i*a,t[6]=r,t[10]=i*s}else if("ZYX"===e.order){const e=i*l,n=i*m,o=r*l,A=r*m;t[0]=s*l,t[4]=o*a-n,t[8]=e*a+A,t[1]=s*m,t[5]=A*a+e,t[9]=n*a-o,t[2]=-a,t[6]=r*s,t[10]=i*s}else if("YZX"===e.order){const e=i*s,n=i*a,o=r*s,A=r*a;t[0]=s*l,t[4]=A-e*m,t[8]=o*m+n,t[1]=m,t[5]=i*l,t[9]=-r*l,t[2]=-a*l,t[6]=n*m+o,t[10]=e-A*m}else if("XZY"===e.order){const e=i*s,n=i*a,o=r*s,A=r*a;t[0]=s*l,t[4]=-m,t[8]=a*l,t[1]=e*m+A,t[5]=i*l,t[9]=n*m-o,t[2]=o*m-n,t[6]=r*l,t[10]=A*m+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Ko,e,yo)}lookAt(e,t,n){const o=this.elements;return xo.subVectors(e,t),0===xo.lengthSq()&&(xo.z=1),xo.normalize(),bo.crossVectors(n,xo),0===bo.lengthSq()&&(1===Math.abs(n.z)?xo.x+=1e-4:xo.z+=1e-4,xo.normalize(),bo.crossVectors(n,xo)),bo.normalize(),qo.crossVectors(xo,bo),o[0]=bo.x,o[4]=qo.x,o[8]=xo.x,o[1]=bo.y,o[5]=qo.y,o[9]=xo.y,o[2]=bo.z,o[6]=qo.z,o[10]=xo.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,o=t.elements,A=this.elements,i=n[0],r=n[4],s=n[8],a=n[12],l=n[1],m=n[5],p=n[9],h=n[13],u=n[2],c=n[6],d=n[10],I=n[14],G=n[3],E=n[7],k=n[11],g=n[15],f=o[0],H=o[4],F=o[8],C=o[12],D=o[1],J=o[5],v=o[9],j=o[13],K=o[2],y=o[6],b=o[10],q=o[14],x=o[3],B=o[7],w=o[11],M=o[15];return A[0]=i*f+r*D+s*K+a*x,A[4]=i*H+r*J+s*y+a*B,A[8]=i*F+r*v+s*b+a*w,A[12]=i*C+r*j+s*q+a*M,A[1]=l*f+m*D+p*K+h*x,A[5]=l*H+m*J+p*y+h*B,A[9]=l*F+m*v+p*b+h*w,A[13]=l*C+m*j+p*q+h*M,A[2]=u*f+c*D+d*K+I*x,A[6]=u*H+c*J+d*y+I*B,A[10]=u*F+c*v+d*b+I*w,A[14]=u*C+c*j+d*q+I*M,A[3]=G*f+E*D+k*K+g*x,A[7]=G*H+E*J+k*y+g*B,A[11]=G*F+E*v+k*b+g*w,A[15]=G*C+E*j+k*q+g*M,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],o=e[8],A=e[12],i=e[1],r=e[5],s=e[9],a=e[13],l=e[2],m=e[6],p=e[10],h=e[14];return e[3]*(+A*s*m-o*a*m-A*r*p+n*a*p+o*r*h-n*s*h)+e[7]*(+t*s*h-t*a*p+A*i*p-o*i*h+o*a*l-A*s*l)+e[11]*(+t*a*m-t*r*h-A*i*m+n*i*h+A*r*l-n*a*l)+e[15]*(-o*r*l-t*s*m+t*r*p+o*i*m-n*i*p+n*s*l)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const o=this.elements;return e.isVector3?(o[12]=e.x,o[13]=e.y,o[14]=e.z):(o[12]=e,o[13]=t,o[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],o=e[2],A=e[3],i=e[4],r=e[5],s=e[6],a=e[7],l=e[8],m=e[9],p=e[10],h=e[11],u=e[12],c=e[13],d=e[14],I=e[15],G=m*d*a-c*p*a+c*s*h-r*d*h-m*s*I+r*p*I,E=u*p*a-l*d*a-u*s*h+i*d*h+l*s*I-i*p*I,k=l*c*a-u*m*a+u*r*h-i*c*h-l*r*I+i*m*I,g=u*m*s-l*c*s-u*r*p+i*c*p+l*r*d-i*m*d,f=t*G+n*E+o*k+A*g;if(0===f)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const H=1/f;return e[0]=G*H,e[1]=(c*p*A-m*d*A-c*o*h+n*d*h+m*o*I-n*p*I)*H,e[2]=(r*d*A-c*s*A+c*o*a-n*d*a-r*o*I+n*s*I)*H,e[3]=(m*s*A-r*p*A-m*o*a+n*p*a+r*o*h-n*s*h)*H,e[4]=E*H,e[5]=(l*d*A-u*p*A+u*o*h-t*d*h-l*o*I+t*p*I)*H,e[6]=(u*s*A-i*d*A-u*o*a+t*d*a+i*o*I-t*s*I)*H,e[7]=(i*p*A-l*s*A+l*o*a-t*p*a-i*o*h+t*s*h)*H,e[8]=k*H,e[9]=(u*m*A-l*c*A-u*n*h+t*c*h+l*n*I-t*m*I)*H,e[10]=(i*c*A-u*r*A+u*n*a-t*c*a-i*n*I+t*r*I)*H,e[11]=(l*r*A-i*m*A-l*n*a+t*m*a+i*n*h-t*r*h)*H,e[12]=g*H,e[13]=(l*c*o-u*m*o+u*n*p-t*c*p-l*n*d+t*m*d)*H,e[14]=(u*r*o-i*c*o-u*n*s+t*c*s+i*n*d-t*r*d)*H,e[15]=(i*m*o-l*r*o+l*n*s-t*m*s-i*n*p+t*r*p)*H,this}scale(e){const t=this.elements,n=e.x,o=e.y,A=e.z;return t[0]*=n,t[4]*=o,t[8]*=A,t[1]*=n,t[5]*=o,t[9]*=A,t[2]*=n,t[6]*=o,t[10]*=A,t[3]*=n,t[7]*=o,t[11]*=A,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],o=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,o))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),o=Math.sin(t),A=1-n,i=e.x,r=e.y,s=e.z,a=A*i,l=A*r;return this.set(a*i+n,a*r-o*s,a*s+o*r,0,a*r+o*s,l*r+n,l*s-o*i,0,a*s-o*r,l*s+o*i,A*s*s+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this}compose(e,t,n){const o=this.elements,A=t._x,i=t._y,r=t._z,s=t._w,a=A+A,l=i+i,m=r+r,p=A*a,h=A*l,u=A*m,c=i*l,d=i*m,I=r*m,G=s*a,E=s*l,k=s*m,g=n.x,f=n.y,H=n.z;return o[0]=(1-(c+I))*g,o[1]=(h+k)*g,o[2]=(u-E)*g,o[3]=0,o[4]=(h-k)*f,o[5]=(1-(p+I))*f,o[6]=(d+G)*f,o[7]=0,o[8]=(u+E)*H,o[9]=(d-G)*H,o[10]=(1-(p+c))*H,o[11]=0,o[12]=e.x,o[13]=e.y,o[14]=e.z,o[15]=1,this}decompose(e,t,n){const o=this.elements;let A=vo.set(o[0],o[1],o[2]).length();const i=vo.set(o[4],o[5],o[6]).length(),r=vo.set(o[8],o[9],o[10]).length();this.determinant()<0&&(A=-A),e.x=o[12],e.y=o[13],e.z=o[14],jo.copy(this);const s=1/A,a=1/i,l=1/r;return jo.elements[0]*=s,jo.elements[1]*=s,jo.elements[2]*=s,jo.elements[4]*=a,jo.elements[5]*=a,jo.elements[6]*=a,jo.elements[8]*=l,jo.elements[9]*=l,jo.elements[10]*=l,t.setFromRotationMatrix(jo),n.x=A,n.y=i,n.z=r,this}makePerspective(e,t,n,o,A,i){void 0===i&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const r=this.elements,s=2*A/(t-e),a=2*A/(n-o),l=(t+e)/(t-e),m=(n+o)/(n-o),p=-(i+A)/(i-A),h=-2*i*A/(i-A);return r[0]=s,r[4]=0,r[8]=l,r[12]=0,r[1]=0,r[5]=a,r[9]=m,r[13]=0,r[2]=0,r[6]=0,r[10]=p,r[14]=h,r[3]=0,r[7]=0,r[11]=-1,r[15]=0,this}makeOrthographic(e,t,n,o,A,i){const r=this.elements,s=1/(t-e),a=1/(n-o),l=1/(i-A),m=(t+e)*s,p=(n+o)*a,h=(i+A)*l;return r[0]=2*s,r[4]=0,r[8]=0,r[12]=-m,r[1]=0,r[5]=2*a,r[9]=0,r[13]=-p,r[2]=0,r[6]=0,r[10]=-2*l,r[14]=-h,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Jo.prototype.isMatrix4=!0;const vo=new Zn,jo=new Jo,Ko=new Zn(0,0,0),yo=new Zn(1,1,1),bo=new Zn,qo=new Zn,xo=new Zn,Bo=new Jo,wo=new Qn;class Mo{constructor(e=0,t=0,n=0,o=Mo.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=o}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,o){return this._x=e,this._y=t,this._z=n,this._order=o||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,n){const o=Tn.clamp,A=e.elements,i=A[0],r=A[4],s=A[8],a=A[1],l=A[5],m=A[9],p=A[2],h=A[6],u=A[10];switch(t=t||this._order){case"XYZ":this._y=Math.asin(o(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-m,u),this._z=Math.atan2(-r,i)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-o(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(s,u),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-p,i),this._z=0);break;case"ZXY":this._x=Math.asin(o(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-p,u),this._z=Math.atan2(-r,l)):(this._y=0,this._z=Math.atan2(a,i));break;case"ZYX":this._y=Math.asin(-o(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(h,u),this._z=Math.atan2(a,i)):(this._x=0,this._z=Math.atan2(-r,l));break;case"YZX":this._z=Math.asin(o(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-m,l),this._y=Math.atan2(-p,i)):(this._x=0,this._y=Math.atan2(s,u));break;case"XZY":this._z=Math.asin(-o(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(s,i)):(this._x=Math.atan2(-m,u),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return Bo.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Bo,t,n)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return wo.setFromEuler(this),this.setFromQuaternion(wo,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new Zn(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Mo.prototype.isEuler=!0,Mo.DefaultOrder="XYZ",Mo.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Lo{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!=(this.mask&e.mask)}}let So=0;const To=new Zn,No=new Qn,Ro=new Jo,Oo=new Zn,Po=new Zn,Uo=new Zn,Vo=new Qn,Wo=new Zn(1,0,0),_o=new Zn(0,1,0),zo=new Zn(0,0,1),Xo={type:"added"},Qo={type:"removed"};function Zo(){Object.defineProperty(this,"id",{value:So++}),this.uuid=Tn.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Zo.DefaultUp.clone();const e=new Zn,t=new Mo,n=new Qn,o=new Zn(1,1,1);t._onChange((function(){n.setFromEuler(t,!1)})),n._onChange((function(){t.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:o},modelViewMatrix:{value:new Jo},normalMatrix:{value:new Rn}}),this.matrix=new Jo,this.matrixWorld=new Jo,this.matrixAutoUpdate=Zo.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Lo,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}Zo.DefaultUp=new Zn(0,1,0),Zo.DefaultMatrixAutoUpdate=!0,Zo.prototype=Object.assign(Object.create(Mn.prototype),{constructor:Zo,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return No.setFromAxisAngle(e,t),this.quaternion.multiply(No),this},rotateOnWorldAxis:function(e,t){return No.setFromAxisAngle(e,t),this.quaternion.premultiply(No),this},rotateX:function(e){return this.rotateOnAxis(Wo,e)},rotateY:function(e){return this.rotateOnAxis(_o,e)},rotateZ:function(e){return this.rotateOnAxis(zo,e)},translateOnAxis:function(e,t){return To.copy(e).applyQuaternion(this.quaternion),this.position.add(To.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(Wo,e)},translateY:function(e){return this.translateOnAxis(_o,e)},translateZ:function(e){return this.translateOnAxis(zo,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(Ro.copy(this.matrixWorld).invert())},lookAt:function(e,t,n){e.isVector3?Oo.copy(e):Oo.set(e,t,n);const o=this.parent;this.updateWorldMatrix(!0,!1),Po.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ro.lookAt(Po,Oo,this.up):Ro.lookAt(Oo,Po,this.up),this.quaternion.setFromRotationMatrix(Ro),o&&(Ro.extractRotation(o.matrixWorld),No.setFromRotationMatrix(Ro),this.quaternion.premultiply(No.invert()))},add:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Xo)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Qo)),this},clear:function(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Qo)}return this.children.length=0,this},attach:function(e){return this.updateWorldMatrix(!0,!1),Ro.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),Ro.multiply(e.parent.matrixWorld)),e.applyMatrix4(Ro),this.add(e),e.updateWorldMatrix(!1,!0),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,o=this.children.length;n<o;n++){const o=this.children[n].getObjectByProperty(e,t);if(void 0!==o)return o}},getWorldPosition:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new Zn),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Qn),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Po,e,Uo),e},getWorldScale:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new Zn),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Po,Vo,e),e},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new Zn),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].traverse(e)},traverseVisible:function(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const o={};function A(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(o.uuid=this.uuid,o.type=this.type,""!==this.name&&(o.name=this.name),!0===this.castShadow&&(o.castShadow=!0),!0===this.receiveShadow&&(o.receiveShadow=!0),!1===this.visible&&(o.visible=!1),!1===this.frustumCulled&&(o.frustumCulled=!1),0!==this.renderOrder&&(o.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(o.userData=this.userData),o.layers=this.layers.mask,o.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(o.matrixAutoUpdate=!1),this.isInstancedMesh&&(o.type="InstancedMesh",o.count=this.count,o.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){o.geometry=A(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,o=n.length;t<o;t++){const o=n[t];A(e.shapes,o)}else A(e.shapes,n)}}if(this.isSkinnedMesh&&(o.bindMode=this.bindMode,o.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(A(e.skeletons,this.skeleton),o.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,o=this.material.length;n<o;n++)t.push(A(e.materials,this.material[n]));o.material=t}else o.material=A(e.materials,this.material);if(this.children.length>0){o.children=[];for(let t=0;t<this.children.length;t++)o.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){o.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];o.animations.push(A(e.animations,n))}}if(t){const t=i(e.geometries),o=i(e.materials),A=i(e.textures),r=i(e.images),s=i(e.shapes),a=i(e.skeletons),l=i(e.animations);t.length>0&&(n.geometries=t),o.length>0&&(n.materials=o),A.length>0&&(n.textures=A),r.length>0&&(n.images=r),s.length>0&&(n.shapes=s),a.length>0&&(n.skeletons=a),l.length>0&&(n.animations=l)}return n.object=o,n;function i(e){const t=[];for(const n in e){const o=e[n];delete o.metadata,t.push(o)}return t}},clone:function(e){return(new this.constructor).copy(this,e)},copy:function(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}});const Yo=new Zn,$o=new Zn,eA=new Rn;class tA{constructor(e=new Zn(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,o){return this.normal.set(e,t,n),this.constant=o,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const o=Yo.subVectors(n,t).cross($o.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(o,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return void 0===t&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new Zn),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){void 0===t&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new Zn);const n=e.delta(Yo),o=this.normal.dot(n);if(0===o)return 0===this.distanceToPoint(e.start)?t.copy(e.start):void 0;const A=-(e.start.dot(this.normal)+this.constant)/o;return A<0||A>1?void 0:t.copy(n).multiplyScalar(A).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return void 0===e&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new Zn),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||eA.getNormalMatrix(e),o=this.coplanarPoint(Yo).applyMatrix4(e),A=this.normal.applyMatrix3(n).normalize();return this.constant=-o.dot(A),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}tA.prototype.isPlane=!0;const nA=new Zn,oA=new Zn,AA=new Zn,iA=new Zn,rA=new Zn,sA=new Zn,aA=new Zn,lA=new Zn,mA=new Zn,pA=new Zn;class hA{constructor(e=new Zn,t=new Zn,n=new Zn){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,o){void 0===o&&(console.warn("THREE.Triangle: .getNormal() target is now required"),o=new Zn),o.subVectors(n,t),nA.subVectors(e,t),o.cross(nA);const A=o.lengthSq();return A>0?o.multiplyScalar(1/Math.sqrt(A)):o.set(0,0,0)}static getBarycoord(e,t,n,o,A){nA.subVectors(o,t),oA.subVectors(n,t),AA.subVectors(e,t);const i=nA.dot(nA),r=nA.dot(oA),s=nA.dot(AA),a=oA.dot(oA),l=oA.dot(AA),m=i*a-r*r;if(void 0===A&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),A=new Zn),0===m)return A.set(-2,-1,-1);const p=1/m,h=(a*s-r*l)*p,u=(i*l-r*s)*p;return A.set(1-h-u,u,h)}static containsPoint(e,t,n,o){return this.getBarycoord(e,t,n,o,iA),iA.x>=0&&iA.y>=0&&iA.x+iA.y<=1}static getUV(e,t,n,o,A,i,r,s){return this.getBarycoord(e,t,n,o,iA),s.set(0,0),s.addScaledVector(A,iA.x),s.addScaledVector(i,iA.y),s.addScaledVector(r,iA.z),s}static isFrontFacing(e,t,n,o){return nA.subVectors(n,t),oA.subVectors(e,t),nA.cross(oA).dot(o)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,o){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[o]),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return nA.subVectors(this.c,this.b),oA.subVectors(this.a,this.b),.5*nA.cross(oA).length()}getMidpoint(e){return void 0===e&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new Zn),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return hA.getNormal(this.a,this.b,this.c,e)}getPlane(e){return void 0===e&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new tA),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return hA.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,o,A){return hA.getUV(e,this.a,this.b,this.c,t,n,o,A)}containsPoint(e){return hA.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return hA.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new Zn);const n=this.a,o=this.b,A=this.c;let i,r;rA.subVectors(o,n),sA.subVectors(A,n),lA.subVectors(e,n);const s=rA.dot(lA),a=sA.dot(lA);if(s<=0&&a<=0)return t.copy(n);mA.subVectors(e,o);const l=rA.dot(mA),m=sA.dot(mA);if(l>=0&&m<=l)return t.copy(o);const p=s*m-l*a;if(p<=0&&s>=0&&l<=0)return i=s/(s-l),t.copy(n).addScaledVector(rA,i);pA.subVectors(e,A);const h=rA.dot(pA),u=sA.dot(pA);if(u>=0&&h<=u)return t.copy(A);const c=h*a-s*u;if(c<=0&&a>=0&&u<=0)return r=a/(a-u),t.copy(n).addScaledVector(sA,r);const d=l*u-h*m;if(d<=0&&m-l>=0&&h-u>=0)return aA.subVectors(A,o),r=(m-l)/(m-l+(h-u)),t.copy(o).addScaledVector(aA,r);const I=1/(d+c+p);return i=c*I,r=p*I,t.copy(n).addScaledVector(rA,i).addScaledVector(sA,r)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let uA=0;function cA(){Object.defineProperty(this,"id",{value:uA++}),this.uuid=Tn.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=g,this.side=c,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=B,this.blendDst=w,this.blendEquation=D,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=U,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Cn,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=mn,this.stencilZFail=mn,this.stencilZPass=mn,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}cA.prototype=Object.assign(Object.create(Mn.prototype),{constructor:cA,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===G;continue}const o=this[t];void 0!==o?o&&o.isColor?o.set(n):o&&o.isVector3&&n&&n.isVector3?o.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function o(e){const t=[];for(const n in e){const o=e[n];delete o.metadata,t.push(o)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==g&&(n.blending=this.blending),this.side!==c&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=o(e.textures),A=o(e.images);t.length>0&&(n.textures=t),A.length>0&&(n.images=A)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let o=0;o!==e;++o)n[o]=t[o].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(cA.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}});const dA={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},IA={h:0,s:0,l:0},GA={h:0,s:0,l:0};function EA(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function kA(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function gA(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}class fA{constructor(e,t,n){return void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Tn.euclideanModulo(e,1),t=Tn.clamp(t,0,1),n=Tn.clamp(n,0,1),0===t)this.r=this.g=this.b=n;else{const o=n<=.5?n*(1+t):n+t-n*t,A=2*n-o;this.r=EA(A,o,e+1/3),this.g=EA(A,o,e),this.b=EA(A,o,e-1/3)}return this}setStyle(e){function t(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const o=n[1],A=n[2];switch(o){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(A))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,t(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(A))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,t(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(A)){const n=parseFloat(e[1])/360,o=parseInt(e[2],10)/100,A=parseInt(e[3],10)/100;return t(e[4]),this.setHSL(n,o,A)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=n[1],t=e.length;if(3===t)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,this;if(6===t)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=dA[e];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=kA(e.r),this.g=kA(e.g),this.b=kA(e.b),this}copyLinearToSRGB(e){return this.r=gA(e.r),this.g=gA(e.g),this.b=gA(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,o=this.b,A=Math.max(t,n,o),i=Math.min(t,n,o);let r,s;const a=(i+A)/2;if(i===A)r=0,s=0;else{const e=A-i;switch(s=a<=.5?e/(A+i):e/(2-A-i),A){case t:r=(n-o)/e+(n<o?6:0);break;case n:r=(o-t)/e+2;break;case o:r=(t-n)/e+4}r/=6}return e.h=r,e.s=s,e.l=a,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(IA),IA.h+=e,IA.s+=t,IA.l+=n,this.setHSL(IA.h,IA.s,IA.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(IA),e.getHSL(GA);const n=Tn.lerp(IA.h,GA.h,t),o=Tn.lerp(IA.s,GA.s,t),A=Tn.lerp(IA.l,GA.l,t);return this.setHSL(n,o,A),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}fA.NAMES=dA,fA.prototype.isColor=!0,fA.prototype.r=1,fA.prototype.g=1,fA.prototype.b=1;class HA extends cA{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new fA(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=X,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this}}HA.prototype.isMeshBasicMaterial=!0;const FA=new Zn,CA=new Nn;function DA(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=Dn,this.updateRange={offset:0,count:-1},this.version=0}function JA(e,t,n){DA.call(this,new Int8Array(e),t,n)}function vA(e,t,n){DA.call(this,new Uint8Array(e),t,n)}function jA(e,t,n){DA.call(this,new Uint8ClampedArray(e),t,n)}function KA(e,t,n){DA.call(this,new Int16Array(e),t,n)}function yA(e,t,n){DA.call(this,new Uint16Array(e),t,n)}function bA(e,t,n){DA.call(this,new Int32Array(e),t,n)}function qA(e,t,n){DA.call(this,new Uint32Array(e),t,n)}function xA(e,t,n){DA.call(this,new Uint16Array(e),t,n)}function BA(e,t,n){DA.call(this,new Float32Array(e),t,n)}function wA(e,t,n){DA.call(this,new Float64Array(e),t,n)}function MA(e){if(0===e.length)return-1/0;let t=e[0];for(let n=1,o=e.length;n<o;++n)e[n]>t&&(t=e[n]);return t}Object.defineProperty(DA.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(DA.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let o=0,A=this.itemSize;o<A;o++)this.array[e+o]=t.array[n+o];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let o=0,A=e.length;o<A;o++){let A=e[o];void 0===A&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",o),A=new fA),t[n++]=A.r,t[n++]=A.g,t[n++]=A.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let o=0,A=e.length;o<A;o++){let A=e[o];void 0===A&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",o),A=new Nn),t[n++]=A.x,t[n++]=A.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let o=0,A=e.length;o<A;o++){let A=e[o];void 0===A&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",o),A=new Zn),t[n++]=A.x,t[n++]=A.y,t[n++]=A.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let o=0,A=e.length;o<A;o++){let A=e[o];void 0===A&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",o),A=new _n),t[n++]=A.x,t[n++]=A.y,t[n++]=A.z,t[n++]=A.w}return this},applyMatrix3:function(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)CA.fromBufferAttribute(this,t),CA.applyMatrix3(e),this.setXY(t,CA.x,CA.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)FA.fromBufferAttribute(this,t),FA.applyMatrix3(e),this.setXYZ(t,FA.x,FA.y,FA.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)FA.x=this.getX(t),FA.y=this.getY(t),FA.z=this.getZ(t),FA.applyMatrix4(e),this.setXYZ(t,FA.x,FA.y,FA.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)FA.x=this.getX(t),FA.y=this.getY(t),FA.z=this.getZ(t),FA.applyNormalMatrix(e),this.setXYZ(t,FA.x,FA.y,FA.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)FA.x=this.getX(t),FA.y=this.getY(t),FA.z=this.getZ(t),FA.transformDirection(e),this.setXYZ(t,FA.x,FA.y,FA.z);return this},set:function(e,t=0){return this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,o){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=o,this},setXYZW:function(e,t,n,o,A){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=o,this.array[e+3]=A,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),JA.prototype=Object.create(DA.prototype),JA.prototype.constructor=JA,vA.prototype=Object.create(DA.prototype),vA.prototype.constructor=vA,jA.prototype=Object.create(DA.prototype),jA.prototype.constructor=jA,KA.prototype=Object.create(DA.prototype),KA.prototype.constructor=KA,yA.prototype=Object.create(DA.prototype),yA.prototype.constructor=yA,bA.prototype=Object.create(DA.prototype),bA.prototype.constructor=bA,qA.prototype=Object.create(DA.prototype),qA.prototype.constructor=qA,xA.prototype=Object.create(DA.prototype),xA.prototype.constructor=xA,xA.prototype.isFloat16BufferAttribute=!0,BA.prototype=Object.create(DA.prototype),BA.prototype.constructor=BA,wA.prototype=Object.create(DA.prototype),wA.prototype.constructor=wA;const LA={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function SA(e,t){return new LA[e](t)}let TA=0;const NA=new Jo,RA=new Zo,OA=new Zn,PA=new eo,UA=new eo,VA=new Zn;function WA(){Object.defineProperty(this,"id",{value:TA++}),this.uuid=Tn.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}WA.prototype=Object.assign(Object.create(Mn.prototype),{constructor:WA,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){return Array.isArray(e)?this.index=new(MA(e)>65535?qA:yA)(e,1):this.index=e,this},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},hasAttribute:function(e){return void 0!==this.attributes[e]},addGroup:function(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new Rn).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(e),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(e){return NA.makeRotationX(e),this.applyMatrix4(NA),this},rotateY:function(e){return NA.makeRotationY(e),this.applyMatrix4(NA),this},rotateZ:function(e){return NA.makeRotationZ(e),this.applyMatrix4(NA),this},translate:function(e,t,n){return NA.makeTranslation(e,t,n),this.applyMatrix4(NA),this},scale:function(e,t,n){return NA.makeScale(e,t,n),this.applyMatrix4(NA),this},lookAt:function(e){return RA.lookAt(e),RA.updateMatrix(),this.applyMatrix4(RA.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(OA).negate(),this.translate(OA.x,OA.y,OA.z),this},setFromPoints:function(e){const t=[];for(let n=0,o=e.length;n<o;n++){const o=e[n];t.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new BA(t,3)),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new eo);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Zn(-1/0,-1/0,-1/0),new Zn(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];PA.setFromBufferAttribute(n),this.morphTargetsRelative?(VA.addVectors(this.boundingBox.min,PA.min),this.boundingBox.expandByPoint(VA),VA.addVectors(this.boundingBox.max,PA.max),this.boundingBox.expandByPoint(VA)):(this.boundingBox.expandByPoint(PA.min),this.boundingBox.expandByPoint(PA.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Go);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Zn,1/0);if(e){const n=this.boundingSphere.center;if(PA.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];UA.setFromBufferAttribute(n),this.morphTargetsRelative?(VA.addVectors(PA.min,UA.min),PA.expandByPoint(VA),VA.addVectors(PA.max,UA.max),PA.expandByPoint(VA)):(PA.expandByPoint(UA.min),PA.expandByPoint(UA.max))}PA.getCenter(n);let o=0;for(let t=0,A=e.count;t<A;t++)VA.fromBufferAttribute(e,t),o=Math.max(o,n.distanceToSquared(VA));if(t)for(let A=0,i=t.length;A<i;A++){const i=t[A],r=this.morphTargetsRelative;for(let t=0,A=i.count;t<A;t++)VA.fromBufferAttribute(i,t),r&&(OA.fromBufferAttribute(e,t),VA.add(OA)),o=Math.max(o,n.distanceToSquared(VA))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,o=t.position.array,A=t.normal.array,i=t.uv.array,r=o.length/3;void 0===t.tangent&&this.setAttribute("tangent",new DA(new Float32Array(4*r),4));const s=t.tangent.array,a=[],l=[];for(let e=0;e<r;e++)a[e]=new Zn,l[e]=new Zn;const m=new Zn,p=new Zn,h=new Zn,u=new Nn,c=new Nn,d=new Nn,I=new Zn,G=new Zn;function E(e,t,n){m.fromArray(o,3*e),p.fromArray(o,3*t),h.fromArray(o,3*n),u.fromArray(i,2*e),c.fromArray(i,2*t),d.fromArray(i,2*n),p.sub(m),h.sub(m),c.sub(u),d.sub(u);const A=1/(c.x*d.y-d.x*c.y);isFinite(A)&&(I.copy(p).multiplyScalar(d.y).addScaledVector(h,-c.y).multiplyScalar(A),G.copy(h).multiplyScalar(c.x).addScaledVector(p,-d.x).multiplyScalar(A),a[e].add(I),a[t].add(I),a[n].add(I),l[e].add(G),l[t].add(G),l[n].add(G))}let k=this.groups;0===k.length&&(k=[{start:0,count:n.length}]);for(let e=0,t=k.length;e<t;++e){const t=k[e],o=t.start;for(let e=o,A=o+t.count;e<A;e+=3)E(n[e+0],n[e+1],n[e+2])}const g=new Zn,f=new Zn,H=new Zn,F=new Zn;function C(e){H.fromArray(A,3*e),F.copy(H);const t=a[e];g.copy(t),g.sub(H.multiplyScalar(H.dot(t))).normalize(),f.crossVectors(F,t);const n=f.dot(l[e])<0?-1:1;s[4*e]=g.x,s[4*e+1]=g.y,s[4*e+2]=g.z,s[4*e+3]=n}for(let e=0,t=k.length;e<t;++e){const t=k[e],o=t.start;for(let e=o,A=o+t.count;e<A;e+=3)C(n[e+0]),C(n[e+1]),C(n[e+2])}},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new DA(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const o=new Zn,A=new Zn,i=new Zn,r=new Zn,s=new Zn,a=new Zn,l=new Zn,m=new Zn;if(e)for(let p=0,h=e.count;p<h;p+=3){const h=e.getX(p+0),u=e.getX(p+1),c=e.getX(p+2);o.fromBufferAttribute(t,h),A.fromBufferAttribute(t,u),i.fromBufferAttribute(t,c),l.subVectors(i,A),m.subVectors(o,A),l.cross(m),r.fromBufferAttribute(n,h),s.fromBufferAttribute(n,u),a.fromBufferAttribute(n,c),r.add(l),s.add(l),a.add(l),n.setXYZ(h,r.x,r.y,r.z),n.setXYZ(u,s.x,s.y,s.z),n.setXYZ(c,a.x,a.y,a.z)}else for(let e=0,r=t.count;e<r;e+=3)o.fromBufferAttribute(t,e+0),A.fromBufferAttribute(t,e+1),i.fromBufferAttribute(t,e+2),l.subVectors(i,A),m.subVectors(o,A),l.cross(m),n.setXYZ(e+0,l.x,l.y,l.z),n.setXYZ(e+1,l.x,l.y,l.z),n.setXYZ(e+2,l.x,l.y,l.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const o in n){if(void 0===e.attributes[o])continue;const A=n[o].array,i=e.attributes[o],r=i.array,s=i.itemSize*t,a=Math.min(r.length,A.length-s);for(let e=0,t=s;e<a;e++,t++)A[t]=r[e]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)VA.fromBufferAttribute(e,t),VA.normalize(),e.setXYZ(t,VA.x,VA.y,VA.z)},toNonIndexed:function(){function e(e,t){const n=e.array,o=e.itemSize,A=e.normalized,i=new n.constructor(t.length*o);let r=0,s=0;for(let e=0,A=t.length;e<A;e++){r=t[e]*o;for(let e=0;e<o;e++)i[s++]=n[r++]}return new DA(i,o,A)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new WA,n=this.index.array,o=this.attributes;for(const A in o){const i=e(o[A],n);t.setAttribute(A,i)}const A=this.morphAttributes;for(const o in A){const i=[],r=A[o];for(let t=0,o=r.length;t<o;t++){const o=e(r[t],n);i.push(o)}t.morphAttributes[o]=i}t.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let e=0,n=i.length;e<n;e++){const n=i[e];t.addGroup(n.start,n.count,n.materialIndex)}return t},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const o=n[t],A=o.toJSON(e.data);""!==o.name&&(A.name=o.name),e.data.attributes[t]=A}const o={};let A=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],i=[];for(let t=0,o=n.length;t<o;t++){const o=n[t],A=o.toJSON(e.data);""!==o.name&&(A.name=o.name),i.push(A)}i.length>0&&(o[t]=i,A=!0)}A&&(e.data.morphAttributes=o,e.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(e.data.groups=JSON.parse(JSON.stringify(i)));const r=this.boundingSphere;return null!==r&&(e.data.boundingSphere={center:r.center.toArray(),radius:r.radius}),e},clone:function(){return(new WA).copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const o=e.attributes;for(const e in o){const n=o[e];this.setAttribute(e,n.clone(t))}const A=e.morphAttributes;for(const e in A){const n=[],o=A[e];for(let e=0,A=o.length;e<A;e++)n.push(o[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const i=e.groups;for(let e=0,t=i.length;e<t;e++){const t=i[e];this.addGroup(t.start,t.count,t.materialIndex)}const r=e.boundingBox;null!==r&&(this.boundingBox=r.clone());const s=e.boundingSphere;return null!==s&&(this.boundingSphere=s.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const _A=new Jo,zA=new Do,XA=new Go,QA=new Zn,ZA=new Zn,YA=new Zn,$A=new Zn,ei=new Zn,ti=new Zn,ni=new Zn,oi=new Zn,Ai=new Zn,ii=new Nn,ri=new Nn,si=new Nn,ai=new Zn,li=new Zn;function mi(e=new WA,t=new HA){Zo.call(this),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}function pi(e,t,n,o,A,i,r,s,a,l,m,p){QA.fromBufferAttribute(A,l),ZA.fromBufferAttribute(A,m),YA.fromBufferAttribute(A,p);const h=e.morphTargetInfluences;if(t.morphTargets&&i&&h){ni.set(0,0,0),oi.set(0,0,0),Ai.set(0,0,0);for(let e=0,t=i.length;e<t;e++){const t=h[e],n=i[e];0!==t&&($A.fromBufferAttribute(n,l),ei.fromBufferAttribute(n,m),ti.fromBufferAttribute(n,p),r?(ni.addScaledVector($A,t),oi.addScaledVector(ei,t),Ai.addScaledVector(ti,t)):(ni.addScaledVector($A.sub(QA),t),oi.addScaledVector(ei.sub(ZA),t),Ai.addScaledVector(ti.sub(YA),t)))}QA.add(ni),ZA.add(oi),YA.add(Ai)}e.isSkinnedMesh&&t.skinning&&(e.boneTransform(l,QA),e.boneTransform(m,ZA),e.boneTransform(p,YA));const u=function(e,t,n,o,A,i,r,s){let a;if(a=t.side===d?o.intersectTriangle(r,i,A,!0,s):o.intersectTriangle(A,i,r,t.side!==I,s),null===a)return null;li.copy(s),li.applyMatrix4(e.matrixWorld);const l=n.ray.origin.distanceTo(li);return l<n.near||l>n.far?null:{distance:l,point:li.clone(),object:e}}(e,t,n,o,QA,ZA,YA,ai);if(u){s&&(ii.fromBufferAttribute(s,l),ri.fromBufferAttribute(s,m),si.fromBufferAttribute(s,p),u.uv=hA.getUV(ai,QA,ZA,YA,ii,ri,si,new Nn)),a&&(ii.fromBufferAttribute(a,l),ri.fromBufferAttribute(a,m),si.fromBufferAttribute(a,p),u.uv2=hA.getUV(ai,QA,ZA,YA,ii,ri,si,new Nn));const e={a:l,b:m,c:p,normal:new Zn,materialIndex:0};hA.getNormal(QA,ZA,YA,e.normal),u.face=e}return u}mi.prototype=Object.assign(Object.create(Zo.prototype),{constructor:mi,isMesh:!0,copy:function(e){return Zo.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,o=this.material,A=this.matrixWorld;if(void 0===o)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),XA.copy(n.boundingSphere),XA.applyMatrix4(A),!1===e.ray.intersectsSphere(XA))return;if(_A.copy(A).invert(),zA.copy(e.ray).applyMatrix4(_A),null!==n.boundingBox&&!1===zA.intersectsBox(n.boundingBox))return;let i;if(n.isBufferGeometry){const A=n.index,r=n.attributes.position,s=n.morphAttributes.position,a=n.morphTargetsRelative,l=n.attributes.uv,m=n.attributes.uv2,p=n.groups,h=n.drawRange;if(null!==A)if(Array.isArray(o))for(let n=0,u=p.length;n<u;n++){const u=p[n],c=o[u.materialIndex];for(let n=Math.max(u.start,h.start),o=Math.min(u.start+u.count,h.start+h.count);n<o;n+=3){const o=A.getX(n),p=A.getX(n+1),h=A.getX(n+2);i=pi(this,c,e,zA,r,s,a,l,m,o,p,h),i&&(i.faceIndex=Math.floor(n/3),i.face.materialIndex=u.materialIndex,t.push(i))}}else for(let n=Math.max(0,h.start),p=Math.min(A.count,h.start+h.count);n<p;n+=3){const p=A.getX(n),h=A.getX(n+1),u=A.getX(n+2);i=pi(this,o,e,zA,r,s,a,l,m,p,h,u),i&&(i.faceIndex=Math.floor(n/3),t.push(i))}else if(void 0!==r)if(Array.isArray(o))for(let n=0,A=p.length;n<A;n++){const A=p[n],u=o[A.materialIndex];for(let n=Math.max(A.start,h.start),o=Math.min(A.start+A.count,h.start+h.count);n<o;n+=3)i=pi(this,u,e,zA,r,s,a,l,m,n,n+1,n+2),i&&(i.faceIndex=Math.floor(n/3),i.face.materialIndex=A.materialIndex,t.push(i))}else for(let n=Math.max(0,h.start),A=Math.min(r.count,h.start+h.count);n<A;n+=3)i=pi(this,o,e,zA,r,s,a,l,m,n,n+1,n+2),i&&(i.faceIndex=Math.floor(n/3),t.push(i))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});class hi extends WA{constructor(e=1,t=1,n=1,o=1,A=1,i=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:o,heightSegments:A,depthSegments:i};const r=this;o=Math.floor(o),A=Math.floor(A),i=Math.floor(i);const s=[],a=[],l=[],m=[];let p=0,h=0;function u(e,t,n,o,A,i,u,c,d,I,G){const E=i/d,k=u/I,g=i/2,f=u/2,H=c/2,F=d+1,C=I+1;let D=0,J=0;const v=new Zn;for(let i=0;i<C;i++){const r=i*k-f;for(let s=0;s<F;s++){const p=s*E-g;v[e]=p*o,v[t]=r*A,v[n]=H,a.push(v.x,v.y,v.z),v[e]=0,v[t]=0,v[n]=c>0?1:-1,l.push(v.x,v.y,v.z),m.push(s/d),m.push(1-i/I),D+=1}}for(let e=0;e<I;e++)for(let t=0;t<d;t++){const n=p+t+F*e,o=p+t+F*(e+1),A=p+(t+1)+F*(e+1),i=p+(t+1)+F*e;s.push(n,o,i),s.push(o,A,i),J+=6}r.addGroup(h,J,G),h+=J,p+=D}u("z","y","x",-1,-1,n,t,e,i,A,0),u("z","y","x",1,-1,n,t,-e,i,A,1),u("x","z","y",1,1,e,n,t,o,i,2),u("x","z","y",1,-1,e,n,-t,o,i,3),u("x","y","z",1,-1,e,t,n,o,A,4),u("x","y","z",-1,-1,e,t,-n,o,A,5),this.setIndex(s),this.setAttribute("position",new BA(a,3)),this.setAttribute("normal",new BA(l,3)),this.setAttribute("uv",new BA(m,2))}}function ui(e){const t={};for(const n in e){t[n]={};for(const o in e[n]){const A=e[n][o];A&&(A.isColor||A.isMatrix3||A.isMatrix4||A.isVector2||A.isVector3||A.isVector4||A.isTexture||A.isQuaternion)?t[n][o]=A.clone():Array.isArray(A)?t[n][o]=A.slice():t[n][o]=A}}return t}function ci(e){const t={};for(let n=0;n<e.length;n++){const o=ui(e[n]);for(const e in o)t[e]=o[e]}return t}const di={clone:ui,merge:ci};function Ii(e){cA.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function Gi(){Zo.call(this),this.type="Camera",this.matrixWorldInverse=new Jo,this.projectionMatrix=new Jo,this.projectionMatrixInverse=new Jo}function Ei(e=50,t=1,n=.1,o=2e3){Gi.call(this),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=o,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}Ii.prototype=Object.create(cA.prototype),Ii.prototype.constructor=Ii,Ii.prototype.isShaderMaterial=!0,Ii.prototype.copy=function(e){return cA.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ui(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this},Ii.prototype.toJSON=function(e){const t=cA.prototype.toJSON.call(this,e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const o=this.uniforms[n].value;o&&o.isTexture?t.uniforms[n]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[n]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[n]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[n]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[n]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[n]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[n]={type:"m4",value:o.toArray()}:t.uniforms[n]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t},Gi.prototype=Object.assign(Object.create(Zo.prototype),{constructor:Gi,isCamera:!0,copy:function(e,t){return Zo.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new Zn),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){Zo.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(e,t){Zo.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),Ei.prototype=Object.assign(Object.create(Gi.prototype),{constructor:Ei,isPerspectiveCamera:!0,copy:function(e,t){return Gi.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=2*Tn.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(.5*Tn.DEG2RAD*this.fov);return.5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*Tn.RAD2DEG*Math.atan(Math.tan(.5*Tn.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,o,A,i){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=o,this.view.width=A,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=this.near;let t=e*Math.tan(.5*Tn.DEG2RAD*this.fov)/this.zoom,n=2*t,o=this.aspect*n,A=-.5*o;const i=this.view;if(null!==this.view&&this.view.enabled){const e=i.fullWidth,r=i.fullHeight;A+=i.offsetX*o/e,t-=i.offsetY*n/r,o*=i.width/e,n*=i.height/r}const r=this.filmOffset;0!==r&&(A+=e*r/this.getFilmWidth()),this.projectionMatrix.makePerspective(A,A+o,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=Zo.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const ki=90;class gi extends Zo{constructor(e,t,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const o=new Ei(ki,1,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new Zn(1,0,0)),this.add(o);const A=new Ei(ki,1,e,t);A.layers=this.layers,A.up.set(0,-1,0),A.lookAt(new Zn(-1,0,0)),this.add(A);const i=new Ei(ki,1,e,t);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new Zn(0,1,0)),this.add(i);const r=new Ei(ki,1,e,t);r.layers=this.layers,r.up.set(0,0,-1),r.lookAt(new Zn(0,-1,0)),this.add(r);const s=new Ei(ki,1,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new Zn(0,0,1)),this.add(s);const a=new Ei(ki,1,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new Zn(0,0,-1)),this.add(a)}update(e,t){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[o,A,i,r,s,a]=this.children,l=e.xr.enabled,m=e.getRenderTarget();e.xr.enabled=!1;const p=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,o),e.setRenderTarget(n,1),e.render(t,A),e.setRenderTarget(n,2),e.render(t,i),e.setRenderTarget(n,3),e.render(t,r),e.setRenderTarget(n,4),e.render(t,s),n.texture.generateMipmaps=p,e.setRenderTarget(n,5),e.render(t,a),e.setRenderTarget(m),e.xr.enabled=l}}class fi extends Vn{constructor(e,t,n,o,A,i,r,s,a,l){super(e=void 0!==e?e:[],t=void 0!==t?t:ie,n,o,A,i,r=void 0!==r?r:Le,s,a,l),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}fi.prototype.isCubeTexture=!0;class Hi extends zn{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),super(e,e,t),t=t||{},this.texture=new fi(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:ke,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Se,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={tEquirect:{value:null}},o="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",A="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",i=new hi(5,5,5),r=new Ii({name:"CubemapFromEquirect",uniforms:ui(n),vertexShader:o,fragmentShader:A,side:d,blending:k});r.uniforms.tEquirect.value=t;const s=new mi(i,r),a=t.minFilter;return t.minFilter===He&&(t.minFilter=ke),new gi(1,10,this).update(e,s),t.minFilter=a,s.geometry.dispose(),s.material.dispose(),this}clear(e,t,n,o){const A=e.getRenderTarget();for(let A=0;A<6;A++)e.setRenderTarget(this,A),e.clear(t,n,o);e.setRenderTarget(A)}}Hi.prototype.isWebGLCubeRenderTarget=!0;class Fi extends Vn{constructor(e,t,n,o,A,i,r,s,a,l,m,p){super(null,i,r,s,a,l,o,A,m,p),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=void 0!==a?a:ce,this.minFilter=void 0!==l?l:ce,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Fi.prototype.isDataTexture=!0;const Ci=new Go,Di=new Zn;class Ji{constructor(e=new tA,t=new tA,n=new tA,o=new tA,A=new tA,i=new tA){this.planes=[e,t,n,o,A,i]}set(e,t,n,o,A,i){const r=this.planes;return r[0].copy(e),r[1].copy(t),r[2].copy(n),r[3].copy(o),r[4].copy(A),r[5].copy(i),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,o=n[0],A=n[1],i=n[2],r=n[3],s=n[4],a=n[5],l=n[6],m=n[7],p=n[8],h=n[9],u=n[10],c=n[11],d=n[12],I=n[13],G=n[14],E=n[15];return t[0].setComponents(r-o,m-s,c-p,E-d).normalize(),t[1].setComponents(r+o,m+s,c+p,E+d).normalize(),t[2].setComponents(r+A,m+a,c+h,E+I).normalize(),t[3].setComponents(r-A,m-a,c-h,E-I).normalize(),t[4].setComponents(r-i,m-l,c-u,E-G).normalize(),t[5].setComponents(r+i,m+l,c+u,E+G).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),Ci.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Ci)}intersectsSprite(e){return Ci.center.set(0,0,0),Ci.radius=.7071067811865476,Ci.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ci)}intersectsSphere(e){const t=this.planes,n=e.center,o=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<o)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const o=t[n];if(Di.x=o.normal.x>0?e.max.x:e.min.x,Di.y=o.normal.y>0?e.max.y:e.min.y,Di.z=o.normal.z>0?e.max.z:e.min.z,o.distanceToPoint(Di)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function vi(){let e=null,t=!1,n=null,o=null;function A(t,i){n(t,i),o=e.requestAnimationFrame(A)}return{start:function(){!0!==t&&null!==n&&(o=e.requestAnimationFrame(A),t=!0)},stop:function(){e.cancelAnimationFrame(o),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function ji(e,t){const n=t.isWebGL2,o=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),o.get(e)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=o.get(t);n&&(e.deleteBuffer(n.buffer),o.delete(t))},update:function(t,A){if(t.isGLBufferAttribute){const e=o.get(t);return void((!e||e.version<t.version)&&o.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version}))}t.isInterleavedBufferAttribute&&(t=t.data);const i=o.get(t);void 0===i?o.set(t,function(t,o){const A=t.array,i=t.usage,r=e.createBuffer();e.bindBuffer(o,r),e.bufferData(o,A,i),t.onUploadCallback();let s=5126;return A instanceof Float32Array?s=5126:A instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):A instanceof Uint16Array?t.isFloat16BufferAttribute?n?s=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):s=5123:A instanceof Int16Array?s=5122:A instanceof Uint32Array?s=5125:A instanceof Int32Array?s=5124:A instanceof Int8Array?s=5120:A instanceof Uint8Array&&(s=5121),{buffer:r,type:s,bytesPerElement:A.BYTES_PER_ELEMENT,version:t.version}}(t,A)):i.version<t.version&&(function(t,o,A){const i=o.array,r=o.updateRange;e.bindBuffer(A,t),-1===r.count?e.bufferSubData(A,0,i):(n?e.bufferSubData(A,r.offset*i.BYTES_PER_ELEMENT,i,r.offset,r.count):e.bufferSubData(A,r.offset*i.BYTES_PER_ELEMENT,i.subarray(r.offset,r.offset+r.count)),r.count=-1)}(i.buffer,t,A),i.version=t.version)}}}class Ki extends WA{constructor(e=1,t=1,n=1,o=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:o};const A=e/2,i=t/2,r=Math.floor(n),s=Math.floor(o),a=r+1,l=s+1,m=e/r,p=t/s,h=[],u=[],c=[],d=[];for(let e=0;e<l;e++){const t=e*p-i;for(let n=0;n<a;n++){const o=n*m-A;u.push(o,-t,0),c.push(0,0,1),d.push(n/r),d.push(1-e/s)}}for(let e=0;e<s;e++)for(let t=0;t<r;t++){const n=t+a*e,o=t+a*(e+1),A=t+1+a*(e+1),i=t+1+a*e;h.push(n,o,i),h.push(o,A,i)}this.setIndex(h),this.setAttribute("position",new BA(u,3)),this.setAttribute("normal",new BA(c,3)),this.setAttribute("uv",new BA(d,2))}}const yi={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},bi={common:{diffuse:{value:new fA(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Rn},uv2Transform:{value:new Rn},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Nn(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new fA(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new fA(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Rn}},sprite:{diffuse:{value:new fA(15658734)},opacity:{value:1},center:{value:new Nn(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Rn}}},qi={basic:{uniforms:ci([bi.common,bi.specularmap,bi.envmap,bi.aomap,bi.lightmap,bi.fog]),vertexShader:yi.meshbasic_vert,fragmentShader:yi.meshbasic_frag},lambert:{uniforms:ci([bi.common,bi.specularmap,bi.envmap,bi.aomap,bi.lightmap,bi.emissivemap,bi.fog,bi.lights,{emissive:{value:new fA(0)}}]),vertexShader:yi.meshlambert_vert,fragmentShader:yi.meshlambert_frag},phong:{uniforms:ci([bi.common,bi.specularmap,bi.envmap,bi.aomap,bi.lightmap,bi.emissivemap,bi.bumpmap,bi.normalmap,bi.displacementmap,bi.fog,bi.lights,{emissive:{value:new fA(0)},specular:{value:new fA(1118481)},shininess:{value:30}}]),vertexShader:yi.meshphong_vert,fragmentShader:yi.meshphong_frag},standard:{uniforms:ci([bi.common,bi.envmap,bi.aomap,bi.lightmap,bi.emissivemap,bi.bumpmap,bi.normalmap,bi.displacementmap,bi.roughnessmap,bi.metalnessmap,bi.fog,bi.lights,{emissive:{value:new fA(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:yi.meshphysical_vert,fragmentShader:yi.meshphysical_frag},toon:{uniforms:ci([bi.common,bi.aomap,bi.lightmap,bi.emissivemap,bi.bumpmap,bi.normalmap,bi.displacementmap,bi.gradientmap,bi.fog,bi.lights,{emissive:{value:new fA(0)}}]),vertexShader:yi.meshtoon_vert,fragmentShader:yi.meshtoon_frag},matcap:{uniforms:ci([bi.common,bi.bumpmap,bi.normalmap,bi.displacementmap,bi.fog,{matcap:{value:null}}]),vertexShader:yi.meshmatcap_vert,fragmentShader:yi.meshmatcap_frag},points:{uniforms:ci([bi.points,bi.fog]),vertexShader:yi.points_vert,fragmentShader:yi.points_frag},dashed:{uniforms:ci([bi.common,bi.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:yi.linedashed_vert,fragmentShader:yi.linedashed_frag},depth:{uniforms:ci([bi.common,bi.displacementmap]),vertexShader:yi.depth_vert,fragmentShader:yi.depth_frag},normal:{uniforms:ci([bi.common,bi.bumpmap,bi.normalmap,bi.displacementmap,{opacity:{value:1}}]),vertexShader:yi.normal_vert,fragmentShader:yi.normal_frag},sprite:{uniforms:ci([bi.sprite,bi.fog]),vertexShader:yi.sprite_vert,fragmentShader:yi.sprite_frag},background:{uniforms:{uvTransform:{value:new Rn},t2D:{value:null}},vertexShader:yi.background_vert,fragmentShader:yi.background_frag},cube:{uniforms:ci([bi.envmap,{opacity:{value:1}}]),vertexShader:yi.cube_vert,fragmentShader:yi.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:yi.equirect_vert,fragmentShader:yi.equirect_frag},distanceRGBA:{uniforms:ci([bi.common,bi.displacementmap,{referencePosition:{value:new Zn},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:yi.distanceRGBA_vert,fragmentShader:yi.distanceRGBA_frag},shadow:{uniforms:ci([bi.lights,bi.fog,{color:{value:new fA(0)},opacity:{value:1}}]),vertexShader:yi.shadow_vert,fragmentShader:yi.shadow_frag}};function xi(e,t,n,o,A){const i=new fA(0);let r,s,a=0,l=null,m=0,p=null;function h(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,A)}return{getClearColor:function(){return i},setClearColor:function(e,t=1){i.set(e),a=t,h(i,a)},getClearAlpha:function(){return a},setClearAlpha:function(e){a=e,h(i,a)},render:function(n,A,u,I){let G=!0===A.isScene?A.background:null;G&&G.isTexture&&(G=t.get(G));const E=e.xr,k=E.getSession&&E.getSession();k&&"additive"===k.environmentBlendMode&&(G=null),null===G?h(i,a):G&&G.isColor&&(h(G,1),I=!0),(e.autoClear||I)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),G&&(G.isCubeTexture||G.isWebGLCubeRenderTarget||G.mapping===le)?(void 0===s&&(s=new mi(new hi(1,1,1),new Ii({name:"BackgroundCubeMaterial",uniforms:ui(qi.cube.uniforms),vertexShader:qi.cube.vertexShader,fragmentShader:qi.cube.fragmentShader,side:d,depthTest:!1,depthWrite:!1,fog:!1})),s.geometry.deleteAttribute("normal"),s.geometry.deleteAttribute("uv"),s.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(s.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),o.update(s)),G.isWebGLCubeRenderTarget&&(G=G.texture),s.material.uniforms.envMap.value=G,s.material.uniforms.flipEnvMap.value=G.isCubeTexture&&G._needsFlipEnvMap?-1:1,l===G&&m===G.version&&p===e.toneMapping||(s.material.needsUpdate=!0,l=G,m=G.version,p=e.toneMapping),n.unshift(s,s.geometry,s.material,0,0,null)):G&&G.isTexture&&(void 0===r&&(r=new mi(new Ki(2,2),new Ii({name:"BackgroundMaterial",uniforms:ui(qi.background.uniforms),vertexShader:qi.background.vertexShader,fragmentShader:qi.background.fragmentShader,side:c,depthTest:!1,depthWrite:!1,fog:!1})),r.geometry.deleteAttribute("normal"),Object.defineProperty(r.material,"map",{get:function(){return this.uniforms.t2D.value}}),o.update(r)),r.material.uniforms.t2D.value=G,!0===G.matrixAutoUpdate&&G.updateMatrix(),r.material.uniforms.uvTransform.value.copy(G.matrix),l===G&&m===G.version&&p===e.toneMapping||(r.material.needsUpdate=!0,l=G,m=G.version,p=e.toneMapping),n.unshift(r,r.geometry,r.material,0,0,null))}}}function Bi(e,t,n,o){const A=e.getParameter(34921),i=o.isWebGL2?null:t.get("OES_vertex_array_object"),r=o.isWebGL2||null!==i,s={},a=h(null);let l=a;function m(t){return o.isWebGL2?e.bindVertexArray(t):i.bindVertexArrayOES(t)}function p(t){return o.isWebGL2?e.deleteVertexArray(t):i.deleteVertexArrayOES(t)}function h(e){const t=[],n=[],o=[];for(let e=0;e<A;e++)t[e]=0,n[e]=0,o[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:o,object:e,attributes:{},index:null}}function u(){const e=l.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function c(e){d(e,0)}function d(n,A){const i=l.newAttributes,r=l.enabledAttributes,s=l.attributeDivisors;i[n]=1,0===r[n]&&(e.enableVertexAttribArray(n),r[n]=1),s[n]!==A&&((o.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[o.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,A),s[n]=A)}function I(){const t=l.newAttributes,n=l.enabledAttributes;for(let o=0,A=n.length;o<A;o++)n[o]!==t[o]&&(e.disableVertexAttribArray(o),n[o]=0)}function G(t,n,A,i,r,s){!0!==o.isWebGL2||5124!==A&&5125!==A?e.vertexAttribPointer(t,n,A,i,r,s):e.vertexAttribIPointer(t,n,A,r,s)}function E(){k(),l!==a&&(l=a,m(l.object))}function k(){a.geometry=null,a.program=null,a.wireframe=!1}return{setup:function(A,a,p,E,k){let g=!1;if(r){const t=function(t,n,A){const r=!0===A.wireframe;let a=s[t.id];void 0===a&&(a={},s[t.id]=a);let l=a[n.id];void 0===l&&(l={},a[n.id]=l);let m=l[r];return void 0===m&&(m=h(o.isWebGL2?e.createVertexArray():i.createVertexArrayOES()),l[r]=m),m}(E,p,a);l!==t&&(l=t,m(l.object)),g=function(e,t){const n=l.attributes,o=e.attributes;let A=0;for(const e in o){const t=n[e],i=o[e];if(void 0===t)return!0;if(t.attribute!==i)return!0;if(t.data!==i.data)return!0;A++}return l.attributesNum!==A||l.index!==t}(E,k),g&&function(e,t){const n={},o=e.attributes;let A=0;for(const e in o){const t=o[e],i={};i.attribute=t,t.data&&(i.data=t.data),n[e]=i,A++}l.attributes=n,l.attributesNum=A,l.index=t}(E,k)}else{const e=!0===a.wireframe;l.geometry===E.id&&l.program===p.id&&l.wireframe===e||(l.geometry=E.id,l.program=p.id,l.wireframe=e,g=!0)}!0===A.isInstancedMesh&&(g=!0),null!==k&&n.update(k,34963),g&&(function(A,i,r,s){if(!1===o.isWebGL2&&(A.isInstancedMesh||s.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;u();const a=s.attributes,l=r.getAttributes(),m=i.defaultAttributeValues;for(const t in l){const o=l[t];if(o>=0){const i=a[t];if(void 0!==i){const t=i.normalized,A=i.itemSize,r=n.get(i);if(void 0===r)continue;const a=r.buffer,l=r.type,m=r.bytesPerElement;if(i.isInterleavedBufferAttribute){const n=i.data,r=n.stride,p=i.offset;n&&n.isInstancedInterleavedBuffer?(d(o,n.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=n.meshPerAttribute*n.count)):c(o),e.bindBuffer(34962,a),G(o,A,l,t,r*m,p*m)}else i.isInstancedBufferAttribute?(d(o,i.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=i.meshPerAttribute*i.count)):c(o),e.bindBuffer(34962,a),G(o,A,l,t,0,0)}else if("instanceMatrix"===t){const t=n.get(A.instanceMatrix);if(void 0===t)continue;const i=t.buffer,r=t.type;d(o+0,1),d(o+1,1),d(o+2,1),d(o+3,1),e.bindBuffer(34962,i),e.vertexAttribPointer(o+0,4,r,!1,64,0),e.vertexAttribPointer(o+1,4,r,!1,64,16),e.vertexAttribPointer(o+2,4,r,!1,64,32),e.vertexAttribPointer(o+3,4,r,!1,64,48)}else if("instanceColor"===t){const t=n.get(A.instanceColor);if(void 0===t)continue;const i=t.buffer,r=t.type;d(o,1),e.bindBuffer(34962,i),e.vertexAttribPointer(o,3,r,!1,12,0)}else if(void 0!==m){const n=m[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(o,n);break;case 3:e.vertexAttrib3fv(o,n);break;case 4:e.vertexAttrib4fv(o,n);break;default:e.vertexAttrib1fv(o,n)}}}}I()}(A,a,p,E),null!==k&&e.bindBuffer(34963,n.get(k).buffer))},reset:E,resetDefaultState:k,dispose:function(){E();for(const e in s){const t=s[e];for(const e in t){const n=t[e];for(const e in n)p(n[e].object),delete n[e];delete t[e]}delete s[e]}},releaseStatesOfGeometry:function(e){if(void 0===s[e.id])return;const t=s[e.id];for(const e in t){const n=t[e];for(const e in n)p(n[e].object),delete n[e];delete t[e]}delete s[e.id]},releaseStatesOfProgram:function(e){for(const t in s){const n=s[t];if(void 0===n[e.id])continue;const o=n[e.id];for(const e in o)p(o[e].object),delete o[e];delete n[e.id]}},initAttributes:u,enableAttribute:c,disableUnusedAttributes:I}}function wi(e,t,n,o){const A=o.isWebGL2;let i;this.setMode=function(e){i=e},this.render=function(t,o){e.drawArrays(i,t,o),n.update(o,i,1)},this.renderInstances=function(o,r,s){if(0===s)return;let a,l;if(A)a=e,l="drawArraysInstanced";else if(a=t.get("ANGLE_instanced_arrays"),l="drawArraysInstancedANGLE",null===a)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");a[l](i,o,r,s),n.update(r,i,s)}}function Mi(e,t,n){let o;function A(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const i="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let r=void 0!==n.precision?n.precision:"highp";const s=A(r);s!==r&&(console.warn("THREE.WebGLRenderer:",r,"not supported, using",s,"instead."),r=s);const a=!0===n.logarithmicDepthBuffer,l=e.getParameter(34930),m=e.getParameter(35660),p=e.getParameter(3379),h=e.getParameter(34076),u=e.getParameter(34921),c=e.getParameter(36347),d=e.getParameter(36348),I=e.getParameter(36349),G=m>0,E=i||t.has("OES_texture_float");return{isWebGL2:i,getMaxAnisotropy:function(){if(void 0!==o)return o;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");o=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else o=0;return o},getMaxPrecision:A,precision:r,logarithmicDepthBuffer:a,maxTextures:l,maxVertexTextures:m,maxTextureSize:p,maxCubemapSize:h,maxAttributes:u,maxVertexUniforms:c,maxVaryings:d,maxFragmentUniforms:I,vertexTextures:G,floatFragmentTextures:E,floatVertexTextures:G&&E,maxSamples:i?e.getParameter(36183):0}}function Li(e){const t=this;let n=null,o=0,A=!1,i=!1;const r=new tA,s=new Rn,a={value:null,needsUpdate:!1};function l(){a.value!==n&&(a.value=n,a.needsUpdate=o>0),t.numPlanes=o,t.numIntersection=0}function m(e,n,o,A){const i=null!==e?e.length:0;let l=null;if(0!==i){if(l=a.value,!0!==A||null===l){const t=o+4*i,A=n.matrixWorldInverse;s.getNormalMatrix(A),(null===l||l.length<t)&&(l=new Float32Array(t));for(let t=0,n=o;t!==i;++t,n+=4)r.copy(e[t]).applyMatrix4(A,s),r.normal.toArray(l,n),l[n+3]=r.constant}a.value=l,a.needsUpdate=!0}return t.numPlanes=i,t.numIntersection=0,l}this.uniform=a,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,i){const r=0!==e.length||t||0!==o||A;return A=t,n=m(e,i,0),o=e.length,r},this.beginShadows=function(){i=!0,m(null)},this.endShadows=function(){i=!1,l()},this.setState=function(t,r,s){const p=t.clippingPlanes,h=t.clipIntersection,u=t.clipShadows,c=e.get(t);if(!A||null===p||0===p.length||i&&!u)i?m(null):l();else{const e=i?0:o,t=4*e;let A=c.clippingState||null;a.value=A,A=m(p,r,t,s);for(let e=0;e!==t;++e)A[e]=n[e];c.clippingState=A,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=e}}}function Si(e){let t=new WeakMap;function n(e,t){return t===se?e.mapping=ie:t===ae&&(e.mapping=re),e}function o(e){const n=e.target;n.removeEventListener("dispose",o);const A=t.get(n);void 0!==A&&(t.delete(n),A.dispose())}return{get:function(A){if(A&&A.isTexture){const i=A.mapping;if(i===se||i===ae){if(t.has(A))return n(t.get(A).texture,A.mapping);{const i=A.image;if(i&&i.height>0){const r=e.getRenderTarget(),s=new Hi(i.height/2);return s.fromEquirectangularTexture(e,A),t.set(A,s),e.setRenderTarget(r),A.addEventListener("dispose",o),n(s.texture,A.mapping)}return null}}}return A},dispose:function(){t=new WeakMap}}}function Ti(e){const t={};function n(n){if(void 0!==t[n])return t[n];let o;switch(n){case"WEBGL_depth_texture":o=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=e.getExtension(n)}return t[n]=o,o}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function Ni(e,t,n,o){const A={},i=new WeakMap;function r(e){const s=e.target;null!==s.index&&t.remove(s.index);for(const e in s.attributes)t.remove(s.attributes[e]);s.removeEventListener("dispose",r),delete A[s.id];const a=i.get(s);a&&(t.remove(a),i.delete(s)),o.releaseStatesOfGeometry(s),!0===s.isInstancedBufferGeometry&&delete s._maxInstanceCount,n.memory.geometries--}function s(e){const n=[],o=e.index,A=e.attributes.position;let r=0;if(null!==o){const e=o.array;r=o.version;for(let t=0,o=e.length;t<o;t+=3){const o=e[t+0],A=e[t+1],i=e[t+2];n.push(o,A,A,i,i,o)}}else{const e=A.array;r=A.version;for(let t=0,o=e.length/3-1;t<o;t+=3){const e=t+0,o=t+1,A=t+2;n.push(e,o,o,A,A,e)}}const s=new(MA(n)>65535?qA:yA)(n,1);s.version=r;const a=i.get(e);a&&t.remove(a),i.set(e,s)}return{get:function(e,t){return!0===A[t.id]||(t.addEventListener("dispose",r),A[t.id]=!0,n.memory.geometries++),t},update:function(e){const n=e.attributes;for(const e in n)t.update(n[e],34962);const o=e.morphAttributes;for(const e in o){const n=o[e];for(let e=0,o=n.length;e<o;e++)t.update(n[e],34962)}},getWireframeAttribute:function(e){const t=i.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&s(e)}else s(e);return i.get(e)}}}function Ri(e,t,n,o){const A=o.isWebGL2;let i,r,s;this.setMode=function(e){i=e},this.setIndex=function(e){r=e.type,s=e.bytesPerElement},this.render=function(t,o){e.drawElements(i,o,r,t*s),n.update(o,i,1)},this.renderInstances=function(o,a,l){if(0===l)return;let m,p;if(A)m=e,p="drawElementsInstanced";else if(m=t.get("ANGLE_instanced_arrays"),p="drawElementsInstancedANGLE",null===m)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");m[p](i,a,r,o*s,l),n.update(a,i,l)}}function Oi(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,n,o){switch(t.calls++,n){case 4:t.triangles+=o*(e/3);break;case 1:t.lines+=o*(e/2);break;case 3:t.lines+=o*(e-1);break;case 2:t.lines+=o*e;break;case 0:t.points+=o*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function Pi(e,t){return e[0]-t[0]}function Ui(e,t){return Math.abs(t[1])-Math.abs(e[1])}function Vi(e){const t={},n=new Float32Array(8),o=[];for(let e=0;e<8;e++)o[e]=[e,0];return{update:function(A,i,r,s){const a=A.morphTargetInfluences,l=void 0===a?0:a.length;let m=t[i.id];if(void 0===m){m=[];for(let e=0;e<l;e++)m[e]=[e,0];t[i.id]=m}for(let e=0;e<l;e++){const t=m[e];t[0]=e,t[1]=a[e]}m.sort(Ui);for(let e=0;e<8;e++)e<l&&m[e][1]?(o[e][0]=m[e][0],o[e][1]=m[e][1]):(o[e][0]=Number.MAX_SAFE_INTEGER,o[e][1]=0);o.sort(Pi);const p=r.morphTargets&&i.morphAttributes.position,h=r.morphNormals&&i.morphAttributes.normal;let u=0;for(let e=0;e<8;e++){const t=o[e],A=t[0],r=t[1];A!==Number.MAX_SAFE_INTEGER&&r?(p&&i.getAttribute("morphTarget"+e)!==p[A]&&i.setAttribute("morphTarget"+e,p[A]),h&&i.getAttribute("morphNormal"+e)!==h[A]&&i.setAttribute("morphNormal"+e,h[A]),n[e]=r,u+=r):(p&&!0===i.hasAttribute("morphTarget"+e)&&i.deleteAttribute("morphTarget"+e),h&&!0===i.hasAttribute("morphNormal"+e)&&i.deleteAttribute("morphNormal"+e),n[e]=0)}const c=i.morphTargetsRelative?1:1-u;s.getUniforms().setValue(e,"morphTargetBaseInfluence",c),s.getUniforms().setValue(e,"morphTargetInfluences",n)}}}function Wi(e,t,n,o){let A=new WeakMap;function i(e){const t=e.target;t.removeEventListener("dispose",i),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:function(e){const r=o.render.frame,s=e.geometry,a=t.get(e,s);return A.get(a)!==r&&(t.update(a),A.set(a,r)),e.isInstancedMesh&&(!1===e.hasEventListener("dispose",i)&&e.addEventListener("dispose",i),n.update(e.instanceMatrix,34962),null!==e.instanceColor&&n.update(e.instanceColor,34962)),a},dispose:function(){A=new WeakMap}}}qi.physical={uniforms:ci([qi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Nn(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new fA(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:yi.meshphysical_vert,fragmentShader:yi.meshphysical_frag};class _i extends Vn{constructor(e=null,t=1,n=1,o=1){super(null),this.image={data:e,width:t,height:n,depth:o},this.magFilter=ce,this.minFilter=ce,this.wrapR=he,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}_i.prototype.isDataTexture2DArray=!0;class zi extends Vn{constructor(e=null,t=1,n=1,o=1){super(null),this.image={data:e,width:t,height:n,depth:o},this.magFilter=ce,this.minFilter=ce,this.wrapR=he,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}zi.prototype.isDataTexture3D=!0;const Xi=new Vn,Qi=new _i,Zi=new zi,Yi=new fi,$i=[],er=[],tr=new Float32Array(16),nr=new Float32Array(9),or=new Float32Array(4);function Ar(e,t,n){const o=e[0];if(o<=0||o>0)return e;const A=t*n;let i=$i[A];if(void 0===i&&(i=new Float32Array(A),$i[A]=i),0!==t){o.toArray(i,0);for(let o=1,A=0;o!==t;++o)A+=n,e[o].toArray(i,A)}return i}function ir(e,t){if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}function rr(e,t){for(let n=0,o=t.length;n<o;n++)e[n]=t[n]}function sr(e,t){let n=er[t];void 0===n&&(n=new Int32Array(t),er[t]=n);for(let o=0;o!==t;++o)n[o]=e.allocateTextureUnit();return n}function ar(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function lr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(ir(n,t))return;e.uniform2fv(this.addr,t),rr(n,t)}}function mr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(ir(n,t))return;e.uniform3fv(this.addr,t),rr(n,t)}}function pr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(ir(n,t))return;e.uniform4fv(this.addr,t),rr(n,t)}}function hr(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(ir(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),rr(n,t)}else{if(ir(n,o))return;or.set(o),e.uniformMatrix2fv(this.addr,!1,or),rr(n,o)}}function ur(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(ir(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),rr(n,t)}else{if(ir(n,o))return;nr.set(o),e.uniformMatrix3fv(this.addr,!1,nr),rr(n,o)}}function cr(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(ir(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),rr(n,t)}else{if(ir(n,o))return;tr.set(o),e.uniformMatrix4fv(this.addr,!1,tr),rr(n,o)}}function dr(e,t,n){const o=this.cache,A=n.allocateTextureUnit();o[0]!==A&&(e.uniform1i(this.addr,A),o[0]=A),n.safeSetTexture2D(t||Xi,A)}function Ir(e,t,n){const o=this.cache,A=n.allocateTextureUnit();o[0]!==A&&(e.uniform1i(this.addr,A),o[0]=A),n.setTexture2DArray(t||Qi,A)}function Gr(e,t,n){const o=this.cache,A=n.allocateTextureUnit();o[0]!==A&&(e.uniform1i(this.addr,A),o[0]=A),n.setTexture3D(t||Zi,A)}function Er(e,t,n){const o=this.cache,A=n.allocateTextureUnit();o[0]!==A&&(e.uniform1i(this.addr,A),o[0]=A),n.safeSetTextureCube(t||Yi,A)}function kr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function gr(e,t){const n=this.cache;ir(n,t)||(e.uniform2iv(this.addr,t),rr(n,t))}function fr(e,t){const n=this.cache;ir(n,t)||(e.uniform3iv(this.addr,t),rr(n,t))}function Hr(e,t){const n=this.cache;ir(n,t)||(e.uniform4iv(this.addr,t),rr(n,t))}function Fr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function Cr(e,t){e.uniform1fv(this.addr,t)}function Dr(e,t){e.uniform1iv(this.addr,t)}function Jr(e,t){e.uniform2iv(this.addr,t)}function vr(e,t){e.uniform3iv(this.addr,t)}function jr(e,t){e.uniform4iv(this.addr,t)}function Kr(e,t){const n=Ar(t,this.size,2);e.uniform2fv(this.addr,n)}function yr(e,t){const n=Ar(t,this.size,3);e.uniform3fv(this.addr,n)}function br(e,t){const n=Ar(t,this.size,4);e.uniform4fv(this.addr,n)}function qr(e,t){const n=Ar(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function xr(e,t){const n=Ar(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function Br(e,t){const n=Ar(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function wr(e,t,n){const o=t.length,A=sr(n,o);e.uniform1iv(this.addr,A);for(let e=0;e!==o;++e)n.safeSetTexture2D(t[e]||Xi,A[e])}function Mr(e,t,n){const o=t.length,A=sr(n,o);e.uniform1iv(this.addr,A);for(let e=0;e!==o;++e)n.safeSetTextureCube(t[e]||Yi,A[e])}function Lr(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function(e){switch(e){case 5126:return ar;case 35664:return lr;case 35665:return mr;case 35666:return pr;case 35674:return hr;case 35675:return ur;case 35676:return cr;case 5124:case 35670:return kr;case 35667:case 35671:return gr;case 35668:case 35672:return fr;case 35669:case 35673:return Hr;case 5125:return Fr;case 35678:case 36198:case 36298:case 36306:case 35682:return dr;case 35679:case 36299:case 36307:return Gr;case 35680:case 36300:case 36308:case 36293:return Er;case 36289:case 36303:case 36311:case 36292:return Ir}}(t.type)}function Sr(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function(e){switch(e){case 5126:return Cr;case 35664:return Kr;case 35665:return yr;case 35666:return br;case 35674:return qr;case 35675:return xr;case 35676:return Br;case 5124:case 35670:return Dr;case 35667:case 35671:return Jr;case 35668:case 35672:return vr;case 35669:case 35673:return jr;case 35678:case 36198:case 36298:case 36306:case 35682:return wr;case 35680:case 36300:case 36308:case 36293:return Mr}}(t.type)}function Tr(e){this.id=e,this.seq=[],this.map={}}Sr.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),rr(t,e)},Tr.prototype.setValue=function(e,t,n){const o=this.seq;for(let A=0,i=o.length;A!==i;++A){const i=o[A];i.setValue(e,t[i.id],n)}};const Nr=/(\w+)(\])?(\[|\.)?/g;function Rr(e,t){e.seq.push(t),e.map[t.id]=t}function Or(e,t,n){const o=e.name,A=o.length;for(Nr.lastIndex=0;;){const i=Nr.exec(o),r=Nr.lastIndex;let s=i[1];const a="]"===i[2],l=i[3];if(a&&(s|=0),void 0===l||"["===l&&r+2===A){Rr(n,void 0===l?new Lr(s,e,t):new Sr(s,e,t));break}{let e=n.map[s];void 0===e&&(e=new Tr(s),Rr(n,e)),n=e}}}function Pr(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let o=0;o<n;++o){const n=e.getActiveUniform(t,o);Or(n,e.getUniformLocation(t,n.name),this)}}function Ur(e,t,n){const o=e.createShader(t);return e.shaderSource(o,n),e.compileShader(o),o}Pr.prototype.setValue=function(e,t,n,o){const A=this.map[t];void 0!==A&&A.setValue(e,n,o)},Pr.prototype.setOptional=function(e,t,n){const o=t[n];void 0!==o&&this.setValue(e,n,o)},Pr.upload=function(e,t,n,o){for(let A=0,i=t.length;A!==i;++A){const i=t[A],r=n[i.id];!1!==r.needsUpdate&&i.setValue(e,r.value,o)}},Pr.seqWithValue=function(e,t){const n=[];for(let o=0,A=e.length;o!==A;++o){const A=e[o];A.id in t&&n.push(A)}return n};let Vr=0;function Wr(e){switch(e){case Qt:return["Linear","( value )"];case Zt:return["sRGB","( value )"];case $t:return["RGBE","( value )"];case tn:return["RGBM","( value, 7.0 )"];case nn:return["RGBM","( value, 16.0 )"];case on:return["RGBD","( value, 256.0 )"];case Yt:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case en:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function _r(e,t,n){const o=e.getShaderParameter(t,35713),A=e.getShaderInfoLog(t).trim();return o&&""===A?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+A+function(e){const t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join("\n")}(e.getShaderSource(t))}function zr(e,t){const n=Wr(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Xr(e,t){const n=Wr(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Qr(e,t){let n;switch(t){case $:n="Linear";break;case ee:n="Reinhard";break;case te:n="OptimizedCineon";break;case ne:n="ACESFilmic";break;case oe:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Zr(e){return""!==e}function Yr(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function $r(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const es=/^[ \t]*#include +<([\w\d./]+)>/gm;function ts(e){return e.replace(es,ns)}function ns(e,t){const n=yi[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return ts(n)}const os=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,As=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function is(e){return e.replace(As,ss).replace(os,rs)}function rs(e,t,n,o){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),ss(0,t,n,o)}function ss(e,t,n,o){let A="";for(let e=parseInt(t);e<parseInt(n);e++)A+=o.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return A}function as(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function ls(e,t,n,o){const A=e.getContext(),i=n.defines;let r=n.vertexShader,s=n.fragmentShader;const a=function(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===p?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===h?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===u&&(t="SHADOWMAP_TYPE_VSM"),t}(n),l=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case ie:case re:t="ENVMAP_TYPE_CUBE";break;case le:case me:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),m=function(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case re:case me:t="ENVMAP_MODE_REFRACTION"}return t}(n),c=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case X:t="ENVMAP_BLENDING_MULTIPLY";break;case Q:t="ENVMAP_BLENDING_MIX";break;case Z:t="ENVMAP_BLENDING_ADD"}return t}(n),d=e.gammaFactor>0?e.gammaFactor:1,I=n.isWebGL2?"":function(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Zr).join("\n")}(n),G=function(e){const t=[];for(const n in e){const o=e[n];!1!==o&&t.push("#define "+n+" "+o)}return t.join("\n")}(i),E=A.createProgram();let k,g,f=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(k=[G].filter(Zr).join("\n"),k.length>0&&(k+="\n"),g=[I,G].filter(Zr).join("\n"),g.length>0&&(g+="\n")):(k=[as(n),"#define SHADER_NAME "+n.shaderName,G,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+m:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+a:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Zr).join("\n"),g=[I,as(n),"#define SHADER_NAME "+n.shaderName,G,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+l:"",n.envMap?"#define "+m:"",n.envMap?"#define "+c:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+a:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==Y?"#define TONE_MAPPING":"",n.toneMapping!==Y?yi.tonemapping_pars_fragment:"",n.toneMapping!==Y?Qr("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",yi.encodings_pars_fragment,n.map?zr("mapTexelToLinear",n.mapEncoding):"",n.matcap?zr("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?zr("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?zr("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?zr("lightMapTexelToLinear",n.lightMapEncoding):"",Xr("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Zr).join("\n")),r=ts(r),r=Yr(r,n),r=$r(r,n),s=ts(s),s=Yr(s,n),s=$r(s,n),r=is(r),s=is(s),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(f="#version 300 es\n",k=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+k,g=["#define varying in",n.glslVersion===wn?"":"out highp vec4 pc_fragColor;",n.glslVersion===wn?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+g);const H=f+g+s,F=Ur(A,35633,f+k+r),C=Ur(A,35632,H);if(A.attachShader(E,F),A.attachShader(E,C),void 0!==n.index0AttributeName?A.bindAttribLocation(E,0,n.index0AttributeName):!0===n.morphTargets&&A.bindAttribLocation(E,0,"position"),A.linkProgram(E),e.debug.checkShaderErrors){const e=A.getProgramInfoLog(E).trim(),t=A.getShaderInfoLog(F).trim(),n=A.getShaderInfoLog(C).trim();let o=!0,i=!0;if(!1===A.getProgramParameter(E,35714)){o=!1;const t=_r(A,F,"vertex"),n=_r(A,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",A.getError(),"35715",A.getProgramParameter(E,35715),"gl.getProgramInfoLog",e,t,n)}else""!==e?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",e):""!==t&&""!==n||(i=!1);i&&(this.diagnostics={runnable:o,programLog:e,vertexShader:{log:t,prefix:k},fragmentShader:{log:n,prefix:g}})}let D,J;return A.deleteShader(F),A.deleteShader(C),this.getUniforms=function(){return void 0===D&&(D=new Pr(A,E)),D},this.getAttributes=function(){return void 0===J&&(J=function(e,t){const n={},o=e.getProgramParameter(t,35721);for(let A=0;A<o;A++){const o=e.getActiveAttrib(t,A).name;n[o]=e.getAttribLocation(t,o)}return n}(A,E)),J},this.destroy=function(){o.releaseStatesOfProgram(this),A.deleteProgram(E),this.program=void 0},this.name=n.shaderName,this.id=Vr++,this.cacheKey=t,this.usedTimes=1,this.program=E,this.vertexShader=F,this.fragmentShader=C,this}function ms(e,t,n,o,A,i){const r=[],s=o.isWebGL2,a=o.logarithmicDepthBuffer,l=o.floatVertexTextures,m=o.maxVertexUniforms,p=o.vertexTextures;let h=o.precision;const u={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},c=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function G(e){let t;return e&&e.isTexture?t=e.encoding:e&&e.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),t=e.texture.encoding):t=Qt,t}return{getParameters:function(A,r,c,E,k){const g=E.fog,f=A.isMeshStandardMaterial?E.environment:null,H=t.get(A.envMap||f),F=u[A.type],C=k.isSkinnedMesh?function(e){const t=e.skeleton.bones;if(l)return 1024;{const e=m,n=Math.floor((e-20)/4),o=Math.min(n,t.length);return o<t.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+t.length+" bones. This GPU supports "+o+"."),0):o}}(k):0;let D,J;if(null!==A.precision&&(h=o.getMaxPrecision(A.precision),h!==A.precision&&console.warn("THREE.WebGLProgram.getParameters:",A.precision,"not supported, using",h,"instead.")),F){const e=qi[F];D=e.vertexShader,J=e.fragmentShader}else D=A.vertexShader,J=A.fragmentShader;const v=e.getRenderTarget();return{isWebGL2:s,shaderID:F,shaderName:A.type,vertexShader:D,fragmentShader:J,defines:A.defines,isRawShaderMaterial:!0===A.isRawShaderMaterial,glslVersion:A.glslVersion,precision:h,instancing:!0===k.isInstancedMesh,instancingColor:!0===k.isInstancedMesh&&null!==k.instanceColor,supportsVertexTextures:p,outputEncoding:null!==v?G(v.texture):e.outputEncoding,map:!!A.map,mapEncoding:G(A.map),matcap:!!A.matcap,matcapEncoding:G(A.matcap),envMap:!!H,envMapMode:H&&H.mapping,envMapEncoding:G(H),envMapCubeUV:!!H&&(H.mapping===le||H.mapping===me),lightMap:!!A.lightMap,lightMapEncoding:G(A.lightMap),aoMap:!!A.aoMap,emissiveMap:!!A.emissiveMap,emissiveMapEncoding:G(A.emissiveMap),bumpMap:!!A.bumpMap,normalMap:!!A.normalMap,objectSpaceNormalMap:A.normalMapType===an,tangentSpaceNormalMap:A.normalMapType===sn,clearcoatMap:!!A.clearcoatMap,clearcoatRoughnessMap:!!A.clearcoatRoughnessMap,clearcoatNormalMap:!!A.clearcoatNormalMap,displacementMap:!!A.displacementMap,roughnessMap:!!A.roughnessMap,metalnessMap:!!A.metalnessMap,specularMap:!!A.specularMap,alphaMap:!!A.alphaMap,gradientMap:!!A.gradientMap,sheen:!!A.sheen,transmissionMap:!!A.transmissionMap,combine:A.combine,vertexTangents:A.normalMap&&A.vertexTangents,vertexColors:A.vertexColors,vertexUvs:!!(A.map||A.bumpMap||A.normalMap||A.specularMap||A.alphaMap||A.emissiveMap||A.roughnessMap||A.metalnessMap||A.clearcoatMap||A.clearcoatRoughnessMap||A.clearcoatNormalMap||A.displacementMap||A.transmissionMap),uvsVertexOnly:!(A.map||A.bumpMap||A.normalMap||A.specularMap||A.alphaMap||A.emissiveMap||A.roughnessMap||A.metalnessMap||A.clearcoatNormalMap||A.transmissionMap||!A.displacementMap),fog:!!g,useFog:A.fog,fogExp2:g&&g.isFogExp2,flatShading:!!A.flatShading,sizeAttenuation:A.sizeAttenuation,logarithmicDepthBuffer:a,skinning:A.skinning&&C>0,maxBones:C,useVertexTexture:l,morphTargets:A.morphTargets,morphNormals:A.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:r.directional.length,numPointLights:r.point.length,numSpotLights:r.spot.length,numRectAreaLights:r.rectArea.length,numHemiLights:r.hemi.length,numDirLightShadows:r.directionalShadowMap.length,numPointLightShadows:r.pointShadowMap.length,numSpotLightShadows:r.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:A.dithering,shadowMapEnabled:e.shadowMap.enabled&&c.length>0,shadowMapType:e.shadowMap.type,toneMapping:A.toneMapped?e.toneMapping:Y,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:A.premultipliedAlpha,alphaTest:A.alphaTest,doubleSided:A.side===I,flipSided:A.side===d,depthPacking:void 0!==A.depthPacking&&A.depthPacking,index0AttributeName:A.index0AttributeName,extensionDerivatives:A.extensions&&A.extensions.derivatives,extensionFragDepth:A.extensions&&A.extensions.fragDepth,extensionDrawBuffers:A.extensions&&A.extensions.drawBuffers,extensionShaderTextureLOD:A.extensions&&A.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||n.has("EXT_shader_texture_lod"),customProgramCacheKey:A.customProgramCacheKey()}},getProgramCacheKey:function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.fragmentShader),n.push(t.vertexShader)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);if(!1===t.isRawShaderMaterial){for(let e=0;e<c.length;e++)n.push(t[c[e]]);n.push(e.outputEncoding),n.push(e.gammaFactor)}return n.push(t.customProgramCacheKey),n.join()},getUniforms:function(e){const t=u[e.type];let n;if(t){const e=qi[t];n=di.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram:function(t,n){let o;for(let e=0,t=r.length;e<t;e++){const t=r[e];if(t.cacheKey===n){o=t,++o.usedTimes;break}}return void 0===o&&(o=new ls(e,n,t,A),r.push(o)),o},releaseProgram:function(e){if(0==--e.usedTimes){const t=r.indexOf(e);r[t]=r[r.length-1],r.pop(),e.destroy()}},programs:r}}function ps(){let e=new WeakMap;return{get:function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,o){e.get(t)[n]=o},dispose:function(){e=new WeakMap}}}function hs(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function us(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function cs(e){const t=[];let n=0;const o=[],A=[],i={id:-1};function r(o,A,r,s,a,l){let m=t[n];const p=e.get(r);return void 0===m?(m={id:o.id,object:o,geometry:A,material:r,program:p.program||i,groupOrder:s,renderOrder:o.renderOrder,z:a,group:l},t[n]=m):(m.id=o.id,m.object=o,m.geometry=A,m.material=r,m.program=p.program||i,m.groupOrder=s,m.renderOrder=o.renderOrder,m.z=a,m.group=l),n++,m}return{opaque:o,transparent:A,init:function(){n=0,o.length=0,A.length=0},push:function(e,t,n,i,s,a){const l=r(e,t,n,i,s,a);(!0===n.transparent?A:o).push(l)},unshift:function(e,t,n,i,s,a){const l=r(e,t,n,i,s,a);(!0===n.transparent?A:o).unshift(l)},finish:function(){for(let e=n,o=t.length;e<o;e++){const n=t[e];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(e,t){o.length>1&&o.sort(e||hs),A.length>1&&A.sort(t||us)}}}function ds(e){let t=new WeakMap;return{get:function(n,o){let A;return!1===t.has(n)?(A=new cs(e),t.set(n,[A])):o>=t.get(n).length?(A=new cs(e),t.get(n).push(A)):A=t.get(n)[o],A},dispose:function(){t=new WeakMap}}}function Is(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new Zn,color:new fA};break;case"SpotLight":n={position:new Zn,direction:new Zn,color:new fA,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Zn,color:new fA,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Zn,skyColor:new fA,groundColor:new fA};break;case"RectAreaLight":n={color:new fA,position:new Zn,halfWidth:new Zn,halfHeight:new Zn}}return e[t.id]=n,n}}}let Gs=0;function Es(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function ks(e,t){const n=new Is,o=function(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Nn};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Nn,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),A={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)A.probe.push(new Zn);const i=new Zn,r=new Jo,s=new Jo;return{setup:function(i){let r=0,s=0,a=0;for(let e=0;e<9;e++)A.probe[e].set(0,0,0);let l=0,m=0,p=0,h=0,u=0,c=0,d=0,I=0;i.sort(Es);for(let e=0,t=i.length;e<t;e++){const t=i[e],G=t.color,E=t.intensity,k=t.distance,g=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)r+=G.r*E,s+=G.g*E,a+=G.b*E;else if(t.isLightProbe)for(let e=0;e<9;e++)A.probe[e].addScaledVector(t.sh.coefficients[e],E);else if(t.isDirectionalLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity),t.castShadow){const e=t.shadow,n=o.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,A.directionalShadow[l]=n,A.directionalShadowMap[l]=g,A.directionalShadowMatrix[l]=t.shadow.matrix,c++}A.directional[l]=e,l++}else if(t.isSpotLight){const e=n.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(G).multiplyScalar(E),e.distance=k,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,n=o.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,A.spotShadow[p]=n,A.spotShadowMap[p]=g,A.spotShadowMatrix[p]=t.shadow.matrix,I++}A.spot[p]=e,p++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(G).multiplyScalar(E),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),A.rectArea[h]=e,h++}else if(t.isPointLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,n=o.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,n.shadowCameraNear=e.camera.near,n.shadowCameraFar=e.camera.far,A.pointShadow[m]=n,A.pointShadowMap[m]=g,A.pointShadowMatrix[m]=t.shadow.matrix,d++}A.point[m]=e,m++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(E),e.groundColor.copy(t.groundColor).multiplyScalar(E),A.hemi[u]=e,u++}}h>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(A.rectAreaLTC1=bi.LTC_FLOAT_1,A.rectAreaLTC2=bi.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(A.rectAreaLTC1=bi.LTC_HALF_1,A.rectAreaLTC2=bi.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),A.ambient[0]=r,A.ambient[1]=s,A.ambient[2]=a;const G=A.hash;G.directionalLength===l&&G.pointLength===m&&G.spotLength===p&&G.rectAreaLength===h&&G.hemiLength===u&&G.numDirectionalShadows===c&&G.numPointShadows===d&&G.numSpotShadows===I||(A.directional.length=l,A.spot.length=p,A.rectArea.length=h,A.point.length=m,A.hemi.length=u,A.directionalShadow.length=c,A.directionalShadowMap.length=c,A.pointShadow.length=d,A.pointShadowMap.length=d,A.spotShadow.length=I,A.spotShadowMap.length=I,A.directionalShadowMatrix.length=c,A.pointShadowMatrix.length=d,A.spotShadowMatrix.length=I,G.directionalLength=l,G.pointLength=m,G.spotLength=p,G.rectAreaLength=h,G.hemiLength=u,G.numDirectionalShadows=c,G.numPointShadows=d,G.numSpotShadows=I,A.version=Gs++)},setupView:function(e,t){let n=0,o=0,a=0,l=0,m=0;const p=t.matrixWorldInverse;for(let t=0,h=e.length;t<h;t++){const h=e[t];if(h.isDirectionalLight){const e=A.directional[n];e.direction.setFromMatrixPosition(h.matrixWorld),i.setFromMatrixPosition(h.target.matrixWorld),e.direction.sub(i),e.direction.transformDirection(p),n++}else if(h.isSpotLight){const e=A.spot[a];e.position.setFromMatrixPosition(h.matrixWorld),e.position.applyMatrix4(p),e.direction.setFromMatrixPosition(h.matrixWorld),i.setFromMatrixPosition(h.target.matrixWorld),e.direction.sub(i),e.direction.transformDirection(p),a++}else if(h.isRectAreaLight){const e=A.rectArea[l];e.position.setFromMatrixPosition(h.matrixWorld),e.position.applyMatrix4(p),s.identity(),r.copy(h.matrixWorld),r.premultiply(p),s.extractRotation(r),e.halfWidth.set(.5*h.width,0,0),e.halfHeight.set(0,.5*h.height,0),e.halfWidth.applyMatrix4(s),e.halfHeight.applyMatrix4(s),l++}else if(h.isPointLight){const e=A.point[o];e.position.setFromMatrixPosition(h.matrixWorld),e.position.applyMatrix4(p),o++}else if(h.isHemisphereLight){const e=A.hemi[m];e.direction.setFromMatrixPosition(h.matrixWorld),e.direction.transformDirection(p),e.direction.normalize(),m++}}},state:A}}function gs(e,t){const n=new ks(e,t),o=[],A=[];return{init:function(){o.length=0,A.length=0},state:{lightsArray:o,shadowsArray:A,lights:n},setupLights:function(){n.setup(o)},setupLightsView:function(e){n.setupView(o,e)},pushLight:function(e){o.push(e)},pushShadow:function(e){A.push(e)}}}function fs(e,t){let n=new WeakMap;return{get:function(o,A=0){let i;return!1===n.has(o)?(i=new gs(e,t),n.set(o,[i])):A>=n.get(o).length?(i=new gs(e,t),n.get(o).push(i)):i=n.get(o)[A],i},dispose:function(){n=new WeakMap}}}class Hs extends cA{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=An,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Hs.prototype.isMeshDepthMaterial=!0;class Fs extends cA{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new Zn,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function Cs(e,t,n){let o=new Ji;const A=new Nn,i=new Nn,r=new _n,s=[],a=[],l={},m={0:d,1:c,2:I},h=new Ii({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new Nn},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),G=h.clone();G.defines.HORIZONTAL_PASS=1;const E=new WA;E.setAttribute("position",new DA(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new mi(E,h),f=this;function H(n,o){const A=t.update(g);h.uniforms.shadow_pass.value=n.map.texture,h.uniforms.resolution.value=n.mapSize,h.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(o,null,A,h,g,null),G.uniforms.shadow_pass.value=n.mapPass.texture,G.uniforms.resolution.value=n.mapSize,G.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(o,null,A,G,g,null)}function F(e,t,n){const o=e<<0|t<<1|n<<2;let A=s[o];return void 0===A&&(A=new Hs({depthPacking:rn,morphTargets:e,skinning:t}),s[o]=A),A}function C(e,t,n){const o=e<<0|t<<1|n<<2;let A=a[o];return void 0===A&&(A=new Fs({morphTargets:e,skinning:t}),a[o]=A),A}function D(t,n,o,A,i,r,s){let a=null,p=F,h=t.customDepthMaterial;if(!0===A.isPointLight&&(p=C,h=t.customDistanceMaterial),void 0===h){let e=!1;!0===o.morphTargets&&(e=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let A=!1;!0===t.isSkinnedMesh&&(!0===o.skinning?A=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t)),a=p(e,A,!0===t.isInstancedMesh)}else a=h;if(e.localClippingEnabled&&!0===o.clipShadows&&0!==o.clippingPlanes.length){const e=a.uuid,t=o.uuid;let n=l[e];void 0===n&&(n={},l[e]=n);let A=n[t];void 0===A&&(A=a.clone(),n[t]=A),a=A}return a.visible=o.visible,a.wireframe=o.wireframe,a.side=s===u?null!==o.shadowSide?o.shadowSide:o.side:null!==o.shadowSide?o.shadowSide:m[o.side],a.clipShadows=o.clipShadows,a.clippingPlanes=o.clippingPlanes,a.clipIntersection=o.clipIntersection,a.wireframeLinewidth=o.wireframeLinewidth,a.linewidth=o.linewidth,!0===A.isPointLight&&!0===a.isMeshDistanceMaterial&&(a.referencePosition.setFromMatrixPosition(A.matrixWorld),a.nearDistance=i,a.farDistance=r),a}function J(n,A,i,r,s){if(!1===n.visible)return;if(n.layers.test(A.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&s===u)&&(!n.frustumCulled||o.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,n.matrixWorld);const o=t.update(n),A=n.material;if(Array.isArray(A)){const t=o.groups;for(let a=0,l=t.length;a<l;a++){const l=t[a],m=A[l.materialIndex];if(m&&m.visible){const t=D(n,o,m,r,i.near,i.far,s);e.renderBufferDirect(i,null,o,t,n,l)}}}else if(A.visible){const t=D(n,o,A,r,i.near,i.far,s);e.renderBufferDirect(i,null,o,t,n,null)}}const a=n.children;for(let e=0,t=a.length;e<t;e++)J(a[e],A,i,r,s)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=p,this.render=function(t,s,a){if(!1===f.enabled)return;if(!1===f.autoUpdate&&!1===f.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget(),m=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),h=e.state;h.setBlending(k),h.buffers.color.setClear(1,1,1,1),h.buffers.depth.setTest(!0),h.setScissorTest(!1);for(let l=0,m=t.length;l<m;l++){const m=t[l],p=m.shadow;if(void 0===p){console.warn("THREE.WebGLShadowMap:",m,"has no shadow.");continue}if(!1===p.autoUpdate&&!1===p.needsUpdate)continue;A.copy(p.mapSize);const c=p.getFrameExtents();if(A.multiply(c),i.copy(p.mapSize),(A.x>n||A.y>n)&&(A.x>n&&(i.x=Math.floor(n/c.x),A.x=i.x*c.x,p.mapSize.x=i.x),A.y>n&&(i.y=Math.floor(n/c.y),A.y=i.y*c.y,p.mapSize.y=i.y)),null===p.map&&!p.isPointLightShadow&&this.type===u){const e={minFilter:ke,magFilter:ke,format:Se};p.map=new zn(A.x,A.y,e),p.map.texture.name=m.name+".shadowMap",p.mapPass=new zn(A.x,A.y,e),p.camera.updateProjectionMatrix()}if(null===p.map){const e={minFilter:ce,magFilter:ce,format:Se};p.map=new zn(A.x,A.y,e),p.map.texture.name=m.name+".shadowMap",p.camera.updateProjectionMatrix()}e.setRenderTarget(p.map),e.clear();const d=p.getViewportCount();for(let e=0;e<d;e++){const t=p.getViewport(e);r.set(i.x*t.x,i.y*t.y,i.x*t.z,i.y*t.w),h.viewport(r),p.updateMatrices(m,e),o=p.getFrustum(),J(s,a,p.camera,m,this.type)}p.isPointLightShadow||this.type!==u||H(p,a),p.needsUpdate=!1}f.needsUpdate=!1,e.setRenderTarget(l,m,p)}}function Ds(e,t,n){const o=n.isWebGL2,A=new function(){let t=!1;const n=new _n;let o=null;const A=new _n(0,0,0,0);return{setMask:function(n){o===n||t||(e.colorMask(n,n,n,n),o=n)},setLocked:function(e){t=e},setClear:function(t,o,i,r,s){!0===s&&(t*=r,o*=r,i*=r),n.set(t,o,i,r),!1===A.equals(n)&&(e.clearColor(t,o,i,r),A.copy(n))},reset:function(){t=!1,o=null,A.set(-1,0,0,0)}}},i=new function(){let t=!1,n=null,o=null,A=null;return{setTest:function(e){e?ce(2929):de(2929)},setMask:function(o){n===o||t||(e.depthMask(o),n=o)},setFunc:function(t){if(o!==t){if(t)switch(t){case R:e.depthFunc(512);break;case O:e.depthFunc(519);break;case P:e.depthFunc(513);break;case U:e.depthFunc(515);break;case V:e.depthFunc(514);break;case W:e.depthFunc(518);break;case _:e.depthFunc(516);break;case z:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);o=t}},setLocked:function(e){t=e},setClear:function(t){A!==t&&(e.clearDepth(t),A=t)},reset:function(){t=!1,n=null,o=null,A=null}}},l=new function(){let t=!1,n=null,o=null,A=null,i=null,r=null,s=null,a=null,l=null;return{setTest:function(e){t||(e?ce(2960):de(2960))},setMask:function(o){n===o||t||(e.stencilMask(o),n=o)},setFunc:function(t,n,r){o===t&&A===n&&i===r||(e.stencilFunc(t,n,r),o=t,A=n,i=r)},setOp:function(t,n,o){r===t&&s===n&&a===o||(e.stencilOp(t,n,o),r=t,s=n,a=o)},setLocked:function(e){t=e},setClear:function(t){l!==t&&(e.clearStencil(t),l=t)},reset:function(){t=!1,n=null,o=null,A=null,i=null,r=null,s=null,a=null,l=null}}};let m={},p=null,h=!1,u=null,c=null,G=null,E=null,X=null,Q=null,Z=null,Y=!1,$=null,ee=null,te=null,ne=null,oe=null;const Ae=e.getParameter(35661);let ie=!1,re=0;const se=e.getParameter(7938);-1!==se.indexOf("WebGL")?(re=parseFloat(/^WebGL (\d)/.exec(se)[1]),ie=re>=1):-1!==se.indexOf("OpenGL ES")&&(re=parseFloat(/^OpenGL ES (\d)/.exec(se)[1]),ie=re>=2);let ae=null,le={};const me=new _n,pe=new _n;function he(t,n,o){const A=new Uint8Array(4),i=e.createTexture();e.bindTexture(t,i),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let t=0;t<o;t++)e.texImage2D(n+t,0,6408,1,1,0,6408,5121,A);return i}const ue={};function ce(t){!0!==m[t]&&(e.enable(t),m[t]=!0)}function de(t){!1!==m[t]&&(e.disable(t),m[t]=!1)}ue[3553]=he(3553,3553,1),ue[34067]=he(34067,34069,6),A.setClear(0,0,0,1),i.setClear(1),l.setClear(0),ce(2929),i.setFunc(U),ke(!1),ge(s),ce(2884),Ee(k);const Ie={[D]:32774,[J]:32778,[v]:32779};if(o)Ie[j]=32775,Ie[K]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&(Ie[j]=e.MIN_EXT,Ie[K]=e.MAX_EXT)}const Ge={[y]:0,[b]:1,[q]:768,[B]:770,[N]:776,[S]:774,[M]:772,[x]:769,[w]:771,[T]:775,[L]:773};function Ee(t,n,o,A,i,r,s,a){if(t!==k){if(!1===h&&(ce(3042),h=!0),t===C)i=i||n,r=r||o,s=s||A,n===c&&i===X||(e.blendEquationSeparate(Ie[n],Ie[i]),c=n,X=i),o===G&&A===E&&r===Q&&s===Z||(e.blendFuncSeparate(Ge[o],Ge[A],Ge[r],Ge[s]),G=o,E=A,Q=r,Z=s),u=t,Y=null;else if(t!==u||a!==Y){if(c===D&&X===D||(e.blendEquation(32774),c=D,X=D),a)switch(t){case g:e.blendFuncSeparate(1,771,1,771);break;case f:e.blendFunc(1,1);break;case H:e.blendFuncSeparate(0,0,769,771);break;case F:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case g:e.blendFuncSeparate(770,771,1,771);break;case f:e.blendFunc(770,1);break;case H:e.blendFunc(0,769);break;case F:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}G=null,E=null,Q=null,Z=null,u=t,Y=a}}else!0===h&&(de(3042),h=!1)}function ke(t){$!==t&&(t?e.frontFace(2304):e.frontFace(2305),$=t)}function ge(t){t!==r?(ce(2884),t!==ee&&(t===s?e.cullFace(1029):t===a?e.cullFace(1028):e.cullFace(1032))):de(2884),ee=t}function fe(t,n,o){t?(ce(32823),ne===n&&oe===o||(e.polygonOffset(n,o),ne=n,oe=o)):de(32823)}function He(t){void 0===t&&(t=33984+Ae-1),ae!==t&&(e.activeTexture(t),ae=t)}return{buffers:{color:A,depth:i,stencil:l},enable:ce,disable:de,useProgram:function(t){return p!==t&&(e.useProgram(t),p=t,!0)},setBlending:Ee,setMaterial:function(e,t){e.side===I?de(2884):ce(2884);let n=e.side===d;t&&(n=!n),ke(n),e.blending===g&&!1===e.transparent?Ee(k):Ee(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),i.setFunc(e.depthFunc),i.setTest(e.depthTest),i.setMask(e.depthWrite),A.setMask(e.colorWrite);const o=e.stencilWrite;l.setTest(o),o&&(l.setMask(e.stencilWriteMask),l.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),l.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),fe(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits)},setFlipSided:ke,setCullFace:ge,setLineWidth:function(t){t!==te&&(ie&&e.lineWidth(t),te=t)},setPolygonOffset:fe,setScissorTest:function(e){e?ce(3089):de(3089)},activeTexture:He,bindTexture:function(t,n){null===ae&&He();let o=le[ae];void 0===o&&(o={type:void 0,texture:void 0},le[ae]=o),o.type===t&&o.texture===n||(e.bindTexture(t,n||ue[t]),o.type=t,o.texture=n)},unbindTexture:function(){const t=le[ae];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(t){!1===me.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),me.copy(t))},viewport:function(t){!1===pe.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),pe.copy(t))},reset:function(){e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),m={},ae=null,le={},p=null,h=!1,u=null,c=null,G=null,E=null,X=null,Q=null,Z=null,Y=!1,$=null,ee=null,te=null,ne=null,oe=null,A.reset(),i.reset(),l.reset()}}}function Js(e,t,n,o,A,i,r){const s=A.isWebGL2,a=A.maxTextures,l=A.maxCubemapSize,m=A.maxTextureSize,p=A.maxSamples,h=new WeakMap;let u,c=!1;try{c="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function d(e,t){return c?new OffscreenCanvas(e,t):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function I(e,t,n,o){let A=1;if((e.width>o||e.height>o)&&(A=o/Math.max(e.width,e.height)),A<1||!0===t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const o=t?Tn.floorPowerOfTwo:Math.floor,i=o(A*e.width),r=o(A*e.height);void 0===u&&(u=d(i,r));const s=n?d(i,r):u;return s.width=i,s.height=r,s.getContext("2d").drawImage(e,0,0,i,r),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+i+"x"+r+")."),s}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function G(e){return Tn.isPowerOfTwo(e.width)&&Tn.isPowerOfTwo(e.height)}function E(e,t){return e.generateMipmaps&&t&&e.minFilter!==ce&&e.minFilter!==ke}function k(t,n,A,i){e.generateMipmap(t),o.get(n).__maxMipLevel=Math.log2(Math.max(A,i))}function g(n,o,A){if(!1===s)return o;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let i=o;return 6403===o&&(5126===A&&(i=33326),5131===A&&(i=33325),5121===A&&(i=33321)),6407===o&&(5126===A&&(i=34837),5131===A&&(i=34843),5121===A&&(i=32849)),6408===o&&(5126===A&&(i=34836),5131===A&&(i=34842),5121===A&&(i=32856)),33325!==i&&33326!==i&&34842!==i&&34836!==i||t.get("EXT_color_buffer_float"),i}function f(e){return e===ce||e===de||e===Ge?9728:9729}function H(t){const n=t.target;n.removeEventListener("dispose",H),function(t){const n=o.get(t);void 0!==n.__webglInit&&(e.deleteTexture(n.__webglTexture),o.remove(t))}(n),n.isVideoTexture&&h.delete(n),r.memory.textures--}function F(t){const n=t.target;n.removeEventListener("dispose",F),function(t){const n=t.texture,A=o.get(t),i=o.get(n);if(t){if(void 0!==i.__webglTexture&&e.deleteTexture(i.__webglTexture),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(A.__webglFramebuffer[t]),A.__webglDepthbuffer&&e.deleteRenderbuffer(A.__webglDepthbuffer[t]);else e.deleteFramebuffer(A.__webglFramebuffer),A.__webglDepthbuffer&&e.deleteRenderbuffer(A.__webglDepthbuffer),A.__webglMultisampledFramebuffer&&e.deleteFramebuffer(A.__webglMultisampledFramebuffer),A.__webglColorRenderbuffer&&e.deleteRenderbuffer(A.__webglColorRenderbuffer),A.__webglDepthRenderbuffer&&e.deleteRenderbuffer(A.__webglDepthRenderbuffer);o.remove(n),o.remove(t)}}(n),r.memory.textures--}let C=0;function D(e,t){const A=o.get(e);if(e.isVideoTexture&&function(e){const t=r.render.frame;h.get(e)!==t&&(h.set(e,t),e.update())}(e),e.version>0&&A.__version!==e.version){const n=e.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void b(A,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t),n.bindTexture(3553,A.__webglTexture)}function J(t,A){const r=o.get(t);t.version>0&&r.__version!==t.version?function(t,o,A){if(6!==o.image.length)return;y(t,o),n.activeTexture(33984+A),n.bindTexture(34067,t.__webglTexture),e.pixelStorei(37440,o.flipY),e.pixelStorei(37441,o.premultiplyAlpha),e.pixelStorei(3317,o.unpackAlignment),e.pixelStorei(37443,0);const r=o&&(o.isCompressedTexture||o.image[0].isCompressedTexture),a=o.image[0]&&o.image[0].isDataTexture,m=[];for(let e=0;e<6;e++)m[e]=r||a?a?o.image[e].image:o.image[e]:I(o.image[e],!1,!0,l);const p=m[0],h=G(p)||s,u=i.convert(o.format),c=i.convert(o.type),d=g(o.internalFormat,u,c);let f;if(K(34067,o,h),r){for(let e=0;e<6;e++){f=m[e].mipmaps;for(let t=0;t<f.length;t++){const A=f[t];o.format!==Se&&o.format!==Le?null!==u?n.compressedTexImage2D(34069+e,t,d,A.width,A.height,0,A.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+e,t,d,A.width,A.height,0,u,c,A.data)}}t.__maxMipLevel=f.length-1}else{f=o.mipmaps;for(let e=0;e<6;e++)if(a){n.texImage2D(34069+e,0,d,m[e].width,m[e].height,0,u,c,m[e].data);for(let t=0;t<f.length;t++){const o=f[t].image[e].image;n.texImage2D(34069+e,t+1,d,o.width,o.height,0,u,c,o.data)}}else{n.texImage2D(34069+e,0,d,u,c,m[e]);for(let t=0;t<f.length;t++){const o=f[t];n.texImage2D(34069+e,t+1,d,u,c,o.image[e])}}t.__maxMipLevel=f.length}E(o,h)&&k(34067,o,p.width,p.height),t.__version=o.version,o.onUpdate&&o.onUpdate(o)}(r,t,A):(n.activeTexture(33984+A),n.bindTexture(34067,r.__webglTexture))}const v={[pe]:10497,[he]:33071,[ue]:33648},j={[ce]:9728,[de]:9984,[Ge]:9986,[ke]:9729,[ge]:9985,[He]:9987};function K(n,i,r){if(r?(e.texParameteri(n,10242,v[i.wrapS]),e.texParameteri(n,10243,v[i.wrapT]),32879!==n&&35866!==n||e.texParameteri(n,32882,v[i.wrapR]),e.texParameteri(n,10240,j[i.magFilter]),e.texParameteri(n,10241,j[i.minFilter])):(e.texParameteri(n,10242,33071),e.texParameteri(n,10243,33071),32879!==n&&35866!==n||e.texParameteri(n,32882,33071),i.wrapS===he&&i.wrapT===he||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,10240,f(i.magFilter)),e.texParameteri(n,10241,f(i.minFilter)),i.minFilter!==ce&&i.minFilter!==ke&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){const r=t.get("EXT_texture_filter_anisotropic");if(i.type===ye&&!1===t.has("OES_texture_float_linear"))return;if(!1===s&&i.type===be&&!1===t.has("OES_texture_half_float_linear"))return;(i.anisotropy>1||o.get(i).__currentAnisotropy)&&(e.texParameterf(n,r.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(i.anisotropy,A.getMaxAnisotropy())),o.get(i).__currentAnisotropy=i.anisotropy)}}function y(t,n){void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",H),t.__webglTexture=e.createTexture(),r.memory.textures++)}function b(t,o,A){let r=3553;o.isDataTexture2DArray&&(r=35866),o.isDataTexture3D&&(r=32879),y(t,o),n.activeTexture(33984+A),n.bindTexture(r,t.__webglTexture),e.pixelStorei(37440,o.flipY),e.pixelStorei(37441,o.premultiplyAlpha),e.pixelStorei(3317,o.unpackAlignment),e.pixelStorei(37443,0);const a=function(e){return!s&&(e.wrapS!==he||e.wrapT!==he||e.minFilter!==ce&&e.minFilter!==ke)}(o)&&!1===G(o.image),l=I(o.image,a,!1,m),p=G(l)||s,h=i.convert(o.format);let u,c=i.convert(o.type),d=g(o.internalFormat,h,c);K(r,o,p);const f=o.mipmaps;if(o.isDepthTexture)d=6402,s?d=o.type===ye?36012:o.type===Ke?33190:o.type===we?35056:33189:o.type===ye&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),o.format===Oe&&6402===d&&o.type!==ve&&o.type!==Ke&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),o.type=ve,c=i.convert(o.type)),o.format===Pe&&6402===d&&(d=34041,o.type!==we&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),o.type=we,c=i.convert(o.type))),n.texImage2D(3553,0,d,l.width,l.height,0,h,c,null);else if(o.isDataTexture)if(f.length>0&&p){for(let e=0,t=f.length;e<t;e++)u=f[e],n.texImage2D(3553,e,d,u.width,u.height,0,h,c,u.data);o.generateMipmaps=!1,t.__maxMipLevel=f.length-1}else n.texImage2D(3553,0,d,l.width,l.height,0,h,c,l.data),t.__maxMipLevel=0;else if(o.isCompressedTexture){for(let e=0,t=f.length;e<t;e++)u=f[e],o.format!==Se&&o.format!==Le?null!==h?n.compressedTexImage2D(3553,e,d,u.width,u.height,0,u.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,e,d,u.width,u.height,0,h,c,u.data);t.__maxMipLevel=f.length-1}else if(o.isDataTexture2DArray)n.texImage3D(35866,0,d,l.width,l.height,l.depth,0,h,c,l.data),t.__maxMipLevel=0;else if(o.isDataTexture3D)n.texImage3D(32879,0,d,l.width,l.height,l.depth,0,h,c,l.data),t.__maxMipLevel=0;else if(f.length>0&&p){for(let e=0,t=f.length;e<t;e++)u=f[e],n.texImage2D(3553,e,d,h,c,u);o.generateMipmaps=!1,t.__maxMipLevel=f.length-1}else n.texImage2D(3553,0,d,h,c,l),t.__maxMipLevel=0;E(o,p)&&k(r,o,l.width,l.height),t.__version=o.version,o.onUpdate&&o.onUpdate(o)}function q(t,A,r,s){const a=A.texture,l=i.convert(a.format),m=i.convert(a.type),p=g(a.internalFormat,l,m);32879===s||35866===s?n.texImage3D(s,0,p,A.width,A.height,A.depth,0,l,m,null):n.texImage2D(s,0,p,A.width,A.height,0,l,m,null),e.bindFramebuffer(36160,t),e.framebufferTexture2D(36160,r,s,o.get(a).__webglTexture,0),e.bindFramebuffer(36160,null)}function x(t,n,o){if(e.bindRenderbuffer(36161,t),n.depthBuffer&&!n.stencilBuffer){let A=33189;if(o){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===ye?A=36012:t.type===Ke&&(A=33190));const o=B(n);e.renderbufferStorageMultisample(36161,o,A,n.width,n.height)}else e.renderbufferStorage(36161,A,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){if(o){const t=B(n);e.renderbufferStorageMultisample(36161,t,35056,n.width,n.height)}else e.renderbufferStorage(36161,34041,n.width,n.height);e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=n.texture,A=i.convert(t.format),r=i.convert(t.type),s=g(t.internalFormat,A,r);if(o){const t=B(n);e.renderbufferStorageMultisample(36161,t,s,n.width,n.height)}else e.renderbufferStorage(36161,s,n.width,n.height)}e.bindRenderbuffer(36161,null)}function B(e){return s&&e.isWebGLMultisampleRenderTarget?Math.min(p,e.samples):0}let w=!1,M=!1;this.allocateTextureUnit=function(){const e=C;return e>=a&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+a),C+=1,e},this.resetTextureUnits=function(){C=0},this.setTexture2D=D,this.setTexture2DArray=function(e,t){const A=o.get(e);e.version>0&&A.__version!==e.version?b(A,e,t):(n.activeTexture(33984+t),n.bindTexture(35866,A.__webglTexture))},this.setTexture3D=function(e,t){const A=o.get(e);e.version>0&&A.__version!==e.version?b(A,e,t):(n.activeTexture(33984+t),n.bindTexture(32879,A.__webglTexture))},this.setTextureCube=J,this.setupRenderTarget=function(t){const A=t.texture,a=o.get(t),l=o.get(A);t.addEventListener("dispose",F),l.__webglTexture=e.createTexture(),r.memory.textures++;const m=!0===t.isWebGLCubeRenderTarget,p=!0===t.isWebGLMultisampleRenderTarget,h=A.isDataTexture3D||A.isDataTexture2DArray,u=G(t)||s;if(!s||A.format!==Le||A.type!==ye&&A.type!==be||(A.format=Se,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),m){a.__webglFramebuffer=[];for(let t=0;t<6;t++)a.__webglFramebuffer[t]=e.createFramebuffer()}else if(a.__webglFramebuffer=e.createFramebuffer(),p)if(s){a.__webglMultisampledFramebuffer=e.createFramebuffer(),a.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,a.__webglColorRenderbuffer);const n=i.convert(A.format),o=i.convert(A.type),r=g(A.internalFormat,n,o),s=B(t);e.renderbufferStorageMultisample(36161,s,r,t.width,t.height),e.bindFramebuffer(36160,a.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,a.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),t.depthBuffer&&(a.__webglDepthRenderbuffer=e.createRenderbuffer(),x(a.__webglDepthRenderbuffer,t,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(m){n.bindTexture(34067,l.__webglTexture),K(34067,A,u);for(let e=0;e<6;e++)q(a.__webglFramebuffer[e],t,36064,34069+e);E(A,u)&&k(34067,A,t.width,t.height),n.bindTexture(34067,null)}else{let e=3553;h&&(s?e=A.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),n.bindTexture(e,l.__webglTexture),K(e,A,u),q(a.__webglFramebuffer,t,36064,e),E(A,u)&&k(3553,A,t.width,t.height),n.bindTexture(3553,null)}t.depthBuffer&&function(t){const n=o.get(t),A=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture){if(A)throw new Error("target.depthTexture not supported in Cube render targets");!function(t,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");o.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),D(n.depthTexture,0);const A=o.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===Oe)e.framebufferTexture2D(36160,36096,3553,A,0);else{if(n.depthTexture.format!==Pe)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,A,0)}}(n.__webglFramebuffer,t)}else if(A){n.__webglDepthbuffer=[];for(let o=0;o<6;o++)e.bindFramebuffer(36160,n.__webglFramebuffer[o]),n.__webglDepthbuffer[o]=e.createRenderbuffer(),x(n.__webglDepthbuffer[o],t,!1)}else e.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=e.createRenderbuffer(),x(n.__webglDepthbuffer,t,!1);e.bindFramebuffer(36160,null)}(t)},this.updateRenderTargetMipmap=function(e){const t=e.texture;if(E(t,G(e)||s)){const A=e.isWebGLCubeRenderTarget?34067:3553,i=o.get(t).__webglTexture;n.bindTexture(A,i),k(A,t,e.width,e.height),n.bindTexture(A,null)}},this.updateMultisampleRenderTarget=function(t){if(t.isWebGLMultisampleRenderTarget)if(s){const n=o.get(t);e.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,n.__webglFramebuffer);const A=t.width,i=t.height;let r=16384;t.depthBuffer&&(r|=256),t.stencilBuffer&&(r|=1024),e.blitFramebuffer(0,0,A,i,0,0,A,i,r,9728),e.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(e,t){e&&e.isWebGLRenderTarget&&(!1===w&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),w=!0),e=e.texture),D(e,t)},this.safeSetTextureCube=function(e,t){e&&e.isWebGLCubeRenderTarget&&(!1===M&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),M=!0),e=e.texture),J(e,t)}}function vs(e,t,n){const o=n.isWebGL2;return{convert:function(e){let n;if(e===Ce)return 5121;if(e===qe)return 32819;if(e===xe)return 32820;if(e===Be)return 33635;if(e===De)return 5120;if(e===Je)return 5122;if(e===ve)return 5123;if(e===je)return 5124;if(e===Ke)return 5125;if(e===ye)return 5126;if(e===be)return o?5131:(n=t.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(e===Me)return 6406;if(e===Le)return 6407;if(e===Se)return 6408;if(e===Te)return 6409;if(e===Ne)return 6410;if(e===Oe)return 6402;if(e===Pe)return 34041;if(e===Ue)return 6403;if(e===Ve)return 36244;if(e===We)return 33319;if(e===_e)return 33320;if(e===ze)return 36248;if(e===Xe)return 36249;if(e===Qe||e===Ze||e===Ye||e===$e){if(n=t.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(e===Qe)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===Ze)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===Ye)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===$e)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===et||e===tt||e===nt||e===ot){if(n=t.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(e===et)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===tt)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===nt)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===ot)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===At)return n=t.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((e===it||e===rt)&&(n=t.get("WEBGL_compressed_texture_etc"),null!==n)){if(e===it)return n.COMPRESSED_RGB8_ETC2;if(e===rt)return n.COMPRESSED_RGBA8_ETC2_EAC}return e===st||e===at||e===lt||e===mt||e===pt||e===ht||e===ut||e===ct||e===dt||e===It||e===Gt||e===Et||e===kt||e===gt||e===Ht||e===Ft||e===Ct||e===Dt||e===Jt||e===vt||e===jt||e===Kt||e===yt||e===bt||e===qt||e===xt||e===Bt||e===wt?(n=t.get("WEBGL_compressed_texture_astc"),null!==n?e:null):e===ft?(n=t.get("EXT_texture_compression_bptc"),null!==n?e:null):e===we?o?34042:(n=t.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function js(e=[]){Ei.call(this),this.cameras=e}Fs.prototype.isMeshDistanceMaterial=!0,js.prototype=Object.assign(Object.create(Ei.prototype),{constructor:js,isArrayCamera:!0});class Ks extends Zo{constructor(){super(),this.type="Group"}}function ys(){this._targetRay=null,this._grip=null,this._hand=null}function bs(e,t){const n=this;let o=null,A=1,i=null,r="local-floor",s=null;const a=[],l=new Map,m=new Ei;m.layers.enable(1),m.viewport=new _n;const p=new Ei;p.layers.enable(2),p.viewport=new _n;const h=[m,p],u=new js;u.layers.enable(1),u.layers.enable(2);let c=null,d=null;function I(e){const t=l.get(e.inputSource);t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function G(){l.forEach((function(e,t){e.disconnect(t)})),l.clear(),c=null,d=null,e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),F.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function E(e){const t=o.inputSources;for(let e=0;e<a.length;e++)l.set(t[e],a[e]);for(let t=0;t<e.removed.length;t++){const n=e.removed[t],o=l.get(n);o&&(o.dispatchEvent({type:"disconnected",data:n}),l.delete(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t],o=l.get(n);o&&o.dispatchEvent({type:"connected",data:n})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=a[e];return void 0===t&&(t=new ys,a[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=a[e];return void 0===t&&(t=new ys,a[e]=t),t.getGripSpace()},this.getHand=function(e){let t=a[e];return void 0===t&&(t=new ys,a[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){A=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){r=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i},this.getSession=function(){return o},this.setSession=async function(e){if(o=e,null!==o){o.addEventListener("select",I),o.addEventListener("selectstart",I),o.addEventListener("selectend",I),o.addEventListener("squeeze",I),o.addEventListener("squeezestart",I),o.addEventListener("squeezeend",I),o.addEventListener("end",G),o.addEventListener("inputsourceschange",E);const e=t.getContextAttributes();!0!==e.xrCompatible&&await t.makeXRCompatible();const s={antialias:e.antialias,alpha:e.alpha,depth:e.depth,stencil:e.stencil,framebufferScaleFactor:A},a=new XRWebGLLayer(o,t,s);o.updateRenderState({baseLayer:a}),i=await o.requestReferenceSpace(r),F.setContext(o),F.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const k=new Zn,g=new Zn;function f(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.getCamera=function(e){u.near=p.near=m.near=e.near,u.far=p.far=m.far=e.far,c===u.near&&d===u.far||(o.updateRenderState({depthNear:u.near,depthFar:u.far}),c=u.near,d=u.far);const t=e.parent,n=u.cameras;f(u,t);for(let e=0;e<n.length;e++)f(n[e],t);e.matrixWorld.copy(u.matrixWorld),e.matrix.copy(u.matrix),e.matrix.decompose(e.position,e.quaternion,e.scale);const A=e.children;for(let e=0,t=A.length;e<t;e++)A[e].updateMatrixWorld(!0);return 2===n.length?function(e,t,n){k.setFromMatrixPosition(t.matrixWorld),g.setFromMatrixPosition(n.matrixWorld);const o=k.distanceTo(g),A=t.projectionMatrix.elements,i=n.projectionMatrix.elements,r=A[14]/(A[10]-1),s=A[14]/(A[10]+1),a=(A[9]+1)/A[5],l=(A[9]-1)/A[5],m=(A[8]-1)/A[0],p=(i[8]+1)/i[0],h=r*m,u=r*p,c=o/(-m+p),d=c*-m;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(d),e.translateZ(c),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const I=r+c,G=s+c,E=h-d,f=u+(o-d),H=a*s/G*I,F=l*s/G*I;e.projectionMatrix.makePerspective(E,f,H,F,I,G)}(u,m,p):u.projectionMatrix.copy(m.projectionMatrix),u};let H=null;const F=new vi;F.setAnimationLoop((function(t,n){if(s=n.getViewerPose(i),null!==s){const t=s.views,n=o.renderState.baseLayer;e.setFramebuffer(n.framebuffer);let A=!1;t.length!==u.cameras.length&&(u.cameras.length=0,A=!0);for(let e=0;e<t.length;e++){const o=t[e],i=n.getViewport(o),r=h[e];r.matrix.fromArray(o.transform.matrix),r.projectionMatrix.fromArray(o.projectionMatrix),r.viewport.set(i.x,i.y,i.width,i.height),0===e&&u.matrix.copy(r.matrix),!0===A&&u.cameras.push(r)}}const A=o.inputSources;for(let e=0;e<a.length;e++){const t=a[e],o=A[e];t.update(o,n,i)}H&&H(t,n)})),this.setAnimationLoop=function(e){H=e},this.dispose=function(){}}function qs(e){function t(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map),n.alphaMap&&(t.alphaMap.value=n.alphaMap),n.specularMap&&(t.specularMap.value=n.specularMap);const o=e.get(n).envMap;if(o){t.envMap.value=o,t.flipEnvMap.value=o.isCubeTexture&&o._needsFlipEnvMap?-1:1,t.reflectivity.value=n.reflectivity,t.refractionRatio.value=n.refractionRatio;const A=e.get(o).__maxMipLevel;void 0!==A&&(t.maxMipLevel.value=A)}let A,i;n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity),n.map?A=n.map:n.specularMap?A=n.specularMap:n.displacementMap?A=n.displacementMap:n.normalMap?A=n.normalMap:n.bumpMap?A=n.bumpMap:n.roughnessMap?A=n.roughnessMap:n.metalnessMap?A=n.metalnessMap:n.alphaMap?A=n.alphaMap:n.emissiveMap?A=n.emissiveMap:n.clearcoatMap?A=n.clearcoatMap:n.clearcoatNormalMap?A=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(A=n.clearcoatRoughnessMap),void 0!==A&&(A.isWebGLRenderTarget&&(A=A.texture),!0===A.matrixAutoUpdate&&A.updateMatrix(),t.uvTransform.value.copy(A.matrix)),n.aoMap?i=n.aoMap:n.lightMap&&(i=n.lightMap),void 0!==i&&(i.isWebGLRenderTarget&&(i=i.texture),!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uv2Transform.value.copy(i.matrix))}function n(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap),n.bumpMap&&(t.bumpMap.value=n.bumpMap,t.bumpScale.value=n.bumpScale,n.side===d&&(t.bumpScale.value*=-1)),n.normalMap&&(t.normalMap.value=n.normalMap,t.normalScale.value.copy(n.normalScale),n.side===d&&t.normalScale.value.negate()),n.displacementMap&&(t.displacementMap.value=n.displacementMap,t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias),e.get(n).envMap&&(t.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function(e,o,A,i){o.isMeshBasicMaterial?t(e,o):o.isMeshLambertMaterial?(t(e,o),function(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}(e,o)):o.isMeshToonMaterial?(t(e,o),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===d&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===d&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,o)):o.isMeshPhongMaterial?(t(e,o),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===d&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===d&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,o)):o.isMeshStandardMaterial?(t(e,o),o.isMeshPhysicalMaterial?function(e,t){n(e,t),e.reflectivity.value=t.reflectivity,e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.sheen&&e.sheen.value.copy(t.sheen),t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,t.side===d&&e.clearcoatNormalScale.value.negate()),e.transmission.value=t.transmission,t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap)}(e,o):n(e,o)):o.isMeshMatcapMaterial?(t(e,o),function(e,t){t.matcap&&(e.matcap.value=t.matcap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===d&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===d&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,o)):o.isMeshDepthMaterial?(t(e,o),function(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,o)):o.isMeshDistanceMaterial?(t(e,o),function(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,o)):o.isMeshNormalMaterial?(t(e,o),function(e,t){t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===d&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===d&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,o)):o.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,o),o.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,o)):o.isPointsMaterial?function(e,t,n,o){let A;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*o,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?A=t.map:t.alphaMap&&(A=t.alphaMap),void 0!==A&&(!0===A.matrixAutoUpdate&&A.updateMatrix(),e.uvTransform.value.copy(A.matrix))}(e,o,A,i):o.isSpriteMaterial?function(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}(e,o):o.isShadowMaterial?(e.color.value.copy(o.color),e.opacity.value=o.opacity):o.isShaderMaterial&&(o.uniformsNeedUpdate=!1)}}}function xs(e){const t=void 0!==(e=e||{}).canvas?e.canvas:function(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}(),n=void 0!==e.context?e.context:null,o=void 0!==e.alpha&&e.alpha,A=void 0===e.depth||e.depth,i=void 0===e.stencil||e.stencil,r=void 0!==e.antialias&&e.antialias,s=void 0===e.premultipliedAlpha||e.premultipliedAlpha,a=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,l=void 0!==e.powerPreference?e.powerPreference:"default",m=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let p=null,h=null;const u=[],c=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Qt,this.physicallyCorrectLights=!1,this.toneMapping=Y,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const d=this;let I=!1,G=null,E=0,k=0,g=null,f=null,H=-1,F=null;const C=new _n,D=new _n;let J=null,v=t.width,j=t.height,K=1,y=null,b=null;const q=new _n(0,0,v,j),x=new _n(0,0,v,j);let B=!1;const w=new Ji;let M=!1,L=!1;const S=new Jo,T=new Zn,N={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function R(){return null===g?K:1}let O,P,U,V,W,_,z,X,Q,Z,$,ee,te,ne,oe,Ae,ie,re,se,ae,le,me=n;function pe(e,n){for(let o=0;o<e.length;o++){const A=e[o],i=t.getContext(A,n);if(null!==i)return i}return null}try{const e={alpha:o,depth:A,stencil:i,antialias:r,premultipliedAlpha:s,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:m};if(t.addEventListener("webglcontextlost",de,!1),t.addEventListener("webglcontextrestored",Ie,!1),null===me){const t=["webgl2","webgl","experimental-webgl"];if(!0===d.isWebGL1Renderer&&t.shift(),me=pe(t,e),null===me)throw pe(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===me.getShaderPrecisionFormat&&(me.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function he(){O=new Ti(me),P=new Mi(me,O,e),O.init(P),ae=new vs(me,O,P),U=new Ds(me,O,P),U.scissor(D.copy(x).multiplyScalar(K).floor()),U.viewport(C.copy(q).multiplyScalar(K).floor()),V=new Oi(me),W=new ps,_=new Js(me,O,U,W,P,ae,V),z=new Si(d),X=new ji(me,P),le=new Bi(me,O,X,P),Q=new Ni(me,X,V,le),Z=new Wi(me,Q,X,V),ie=new Vi(me),oe=new Li(W),$=new ms(d,z,O,P,le,oe),ee=new qs(W),te=new ds(W),ne=new fs(O,P),Ae=new xi(d,z,U,Z,s),re=new wi(me,O,V,P),se=new Ri(me,O,V,P),V.programs=$.programs,d.capabilities=P,d.extensions=O,d.properties=W,d.renderLists=te,d.state=U,d.info=V}he();const ue=new bs(d,me);this.xr=ue;const ce=new Cs(d,Z,P.maxTextureSize);function de(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),I=!0}function Ie(){console.log("THREE.WebGLRenderer: Context Restored."),I=!1,he()}function Ge(e){const t=e.target;t.removeEventListener("dispose",Ge),function(e){Ee(e),W.remove(e)}(t)}function Ee(e){const t=W.get(e).program;void 0!==t&&$.releaseProgram(t)}this.shadowMap=ce,this.getContext=function(){return me},this.getContextAttributes=function(){return me.getContextAttributes()},this.forceContextLoss=function(){const e=O.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=O.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return K},this.setPixelRatio=function(e){void 0!==e&&(K=e,this.setSize(v,j,!1))},this.getSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),e=new Nn),e.set(v,j)},this.setSize=function(e,n,o){ue.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(v=e,j=n,t.width=Math.floor(e*K),t.height=Math.floor(n*K),!1!==o&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),e=new Nn),e.set(v*K,j*K).floor()},this.setDrawingBufferSize=function(e,n,o){v=e,j=n,K=o,t.width=Math.floor(e*o),t.height=Math.floor(n*o),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),e=new _n),e.copy(C)},this.getViewport=function(e){return e.copy(q)},this.setViewport=function(e,t,n,o){e.isVector4?q.set(e.x,e.y,e.z,e.w):q.set(e,t,n,o),U.viewport(C.copy(q).multiplyScalar(K).floor())},this.getScissor=function(e){return e.copy(x)},this.setScissor=function(e,t,n,o){e.isVector4?x.set(e.x,e.y,e.z,e.w):x.set(e,t,n,o),U.scissor(D.copy(x).multiplyScalar(K).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(e){U.setScissorTest(B=e)},this.setOpaqueSort=function(e){y=e},this.setTransparentSort=function(e){b=e},this.getClearColor=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),e=new fA),e.copy(Ae.getClearColor())},this.setClearColor=function(){Ae.setClearColor.apply(Ae,arguments)},this.getClearAlpha=function(){return Ae.getClearAlpha()},this.setClearAlpha=function(){Ae.setClearAlpha.apply(Ae,arguments)},this.clear=function(e,t,n){let o=0;(void 0===e||e)&&(o|=16384),(void 0===t||t)&&(o|=256),(void 0===n||n)&&(o|=1024),me.clear(o)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",de,!1),t.removeEventListener("webglcontextrestored",Ie,!1),te.dispose(),ne.dispose(),W.dispose(),z.dispose(),Z.dispose(),le.dispose(),ue.dispose(),ge.stop()},this.renderBufferImmediate=function(e,t){le.initAttributes();const n=W.get(e);e.hasPositions&&!n.position&&(n.position=me.createBuffer()),e.hasNormals&&!n.normal&&(n.normal=me.createBuffer()),e.hasUvs&&!n.uv&&(n.uv=me.createBuffer()),e.hasColors&&!n.color&&(n.color=me.createBuffer());const o=t.getAttributes();e.hasPositions&&(me.bindBuffer(34962,n.position),me.bufferData(34962,e.positionArray,35048),le.enableAttribute(o.position),me.vertexAttribPointer(o.position,3,5126,!1,0,0)),e.hasNormals&&(me.bindBuffer(34962,n.normal),me.bufferData(34962,e.normalArray,35048),le.enableAttribute(o.normal),me.vertexAttribPointer(o.normal,3,5126,!1,0,0)),e.hasUvs&&(me.bindBuffer(34962,n.uv),me.bufferData(34962,e.uvArray,35048),le.enableAttribute(o.uv),me.vertexAttribPointer(o.uv,2,5126,!1,0,0)),e.hasColors&&(me.bindBuffer(34962,n.color),me.bufferData(34962,e.colorArray,35048),le.enableAttribute(o.color),me.vertexAttribPointer(o.color,3,5126,!1,0,0)),le.disableUnusedAttributes(),me.drawArrays(4,0,e.count),e.count=0},this.renderBufferDirect=function(e,t,n,o,A,i){null===t&&(t=N);const r=A.isMesh&&A.matrixWorld.determinant()<0,s=Je(e,t,o,A);U.setMaterial(o,r);let a=n.index;const l=n.attributes.position;if(null===a){if(void 0===l||0===l.count)return}else if(0===a.count)return;let m,p=1;!0===o.wireframe&&(a=Q.getWireframeAttribute(n),p=2),(o.morphTargets||o.morphNormals)&&ie.update(A,n,o,s),le.setup(A,o,s,n,a);let h=re;null!==a&&(m=X.get(a),h=se,h.setIndex(m));const u=null!==a?a.count:l.count,c=n.drawRange.start*p,d=n.drawRange.count*p,I=null!==i?i.start*p:0,G=null!==i?i.count*p:1/0,E=Math.max(c,I),k=Math.min(u,c+d,I+G)-1,g=Math.max(0,k-E+1);if(0!==g){if(A.isMesh)!0===o.wireframe?(U.setLineWidth(o.wireframeLinewidth*R()),h.setMode(1)):h.setMode(4);else if(A.isLine){let e=o.linewidth;void 0===e&&(e=1),U.setLineWidth(e*R()),A.isLineSegments?h.setMode(1):A.isLineLoop?h.setMode(2):h.setMode(3)}else A.isPoints?h.setMode(0):A.isSprite&&h.setMode(4);if(A.isInstancedMesh)h.renderInstances(E,g,A.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);h.renderInstances(E,g,e)}else h.render(E,g)}},this.compile=function(e,t){h=ne.get(e),h.init(),e.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&(h.pushLight(e),e.castShadow&&h.pushShadow(e))})),h.setupLights();const n=new WeakMap;e.traverse((function(t){const o=t.material;if(o)if(Array.isArray(o))for(let A=0;A<o.length;A++){const i=o[A];!1===n.has(i)&&(De(i,e,t),n.set(i))}else!1===n.has(o)&&(De(o,e,t),n.set(o))}))};let ke=null;const ge=new vi;function fe(e,t,n,o){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)h.pushLight(e),e.castShadow&&h.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||w.intersectsSprite(e)){o&&T.setFromMatrixPosition(e.matrixWorld).applyMatrix4(S);const t=Z.update(e),A=e.material;A.visible&&p.push(e,t,A,n,T.z,null)}}else if(e.isImmediateRenderObject)o&&T.setFromMatrixPosition(e.matrixWorld).applyMatrix4(S),p.push(e,null,e.material,n,T.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==V.render.frame&&(e.skeleton.update(),e.skeleton.frame=V.render.frame),!e.frustumCulled||w.intersectsObject(e))){o&&T.setFromMatrixPosition(e.matrixWorld).applyMatrix4(S);const t=Z.update(e),A=e.material;if(Array.isArray(A)){const o=t.groups;for(let i=0,r=o.length;i<r;i++){const r=o[i],s=A[r.materialIndex];s&&s.visible&&p.push(e,t,s,n,T.z,r)}}else A.visible&&p.push(e,t,A,n,T.z,null)}const A=e.children;for(let e=0,i=A.length;e<i;e++)fe(A[e],t,n,o)}function He(e,t,n){const o=!0===t.isScene?t.overrideMaterial:null;for(let A=0,i=e.length;A<i;A++){const i=e[A],r=i.object,s=i.geometry,a=null===o?i.material:o,l=i.group;if(n.isArrayCamera){const e=n.cameras;for(let n=0,o=e.length;n<o;n++){const o=e[n];r.layers.test(o.layers)&&(U.viewport(C.copy(o.viewport)),h.setupLightsView(o),Fe(r,t,o,s,a,l))}}else Fe(r,t,n,s,a,l)}}function Fe(e,t,n,o,A,i){if(e.onBeforeRender(d,t,n,o,A,i),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),e.isImmediateRenderObject){const o=Je(n,t,A,e);U.setMaterial(A),le.reset(),function(e,t){e.render((function(e){d.renderBufferImmediate(e,t)}))}(e,o)}else d.renderBufferDirect(n,t,o,A,e,i);e.onAfterRender(d,t,n,o,A,i)}function De(e,t,n){!0!==t.isScene&&(t=N);const o=W.get(e),A=h.state.lights,i=h.state.shadowsArray,r=A.state.version,s=$.getParameters(e,A.state,i,t,n),a=$.getProgramCacheKey(s);let l=o.program,m=!0;if(o.environment=e.isMeshStandardMaterial?t.environment:null,o.fog=t.fog,o.envMap=z.get(e.envMap||o.environment),void 0===l)e.addEventListener("dispose",Ge);else if(l.cacheKey!==a)Ee(e);else if(o.lightsStateVersion!==r)m=!1;else{if(void 0!==s.shaderID)return;m=!1}m&&(s.uniforms=$.getUniforms(e),e.onBeforeCompile(s,d),l=$.acquireProgram(s,a),o.program=l,o.uniforms=s.uniforms,o.outputEncoding=s.outputEncoding);const p=o.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(o.numClippingPlanes=oe.numPlanes,o.numIntersection=oe.numIntersection,p.clippingPlanes=oe.uniform),o.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),o.lightsStateVersion=r,o.needsLights&&(p.ambientLightColor.value=A.state.ambient,p.lightProbe.value=A.state.probe,p.directionalLights.value=A.state.directional,p.directionalLightShadows.value=A.state.directionalShadow,p.spotLights.value=A.state.spot,p.spotLightShadows.value=A.state.spotShadow,p.rectAreaLights.value=A.state.rectArea,p.ltc_1.value=A.state.rectAreaLTC1,p.ltc_2.value=A.state.rectAreaLTC2,p.pointLights.value=A.state.point,p.pointLightShadows.value=A.state.pointShadow,p.hemisphereLights.value=A.state.hemi,p.directionalShadowMap.value=A.state.directionalShadowMap,p.directionalShadowMatrix.value=A.state.directionalShadowMatrix,p.spotShadowMap.value=A.state.spotShadowMap,p.spotShadowMatrix.value=A.state.spotShadowMatrix,p.pointShadowMap.value=A.state.pointShadowMap,p.pointShadowMatrix.value=A.state.pointShadowMatrix);const u=o.program.getUniforms(),c=Pr.seqWithValue(u.seq,p);o.uniformsList=c}function Je(e,t,n,o){!0!==t.isScene&&(t=N),_.resetTextureUnits();const A=t.fog,i=n.isMeshStandardMaterial?t.environment:null,r=null===g?d.outputEncoding:g.texture.encoding,s=z.get(n.envMap||i),a=W.get(n),l=h.state.lights;if(!0===M&&(!0===L||e!==F)){const t=e===F&&n.id===H;oe.setState(n,e,t)}n.version===a.__version?n.fog&&a.fog!==A||a.environment!==i||a.needsLights&&a.lightsStateVersion!==l.state.version?De(n,t,o):void 0===a.numClippingPlanes||a.numClippingPlanes===oe.numPlanes&&a.numIntersection===oe.numIntersection?(a.outputEncoding!==r||a.envMap!==s)&&De(n,t,o):De(n,t,o):(De(n,t,o),a.__version=n.version);let m=!1,p=!1,u=!1;const c=a.program,I=c.getUniforms(),G=a.uniforms;if(U.useProgram(c.program)&&(m=!0,p=!0,u=!0),n.id!==H&&(H=n.id,p=!0),m||F!==e){if(I.setValue(me,"projectionMatrix",e.projectionMatrix),P.logarithmicDepthBuffer&&I.setValue(me,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),F!==e&&(F=e,p=!0,u=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const t=I.map.cameraPosition;void 0!==t&&t.setValue(me,T.setFromMatrixPosition(e.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&I.setValue(me,"isOrthographic",!0===e.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&I.setValue(me,"viewMatrix",e.matrixWorldInverse)}if(n.skinning){I.setOptional(me,o,"bindMatrix"),I.setOptional(me,o,"bindMatrixInverse");const e=o.skeleton;if(e){const t=e.bones;if(P.floatVertexTextures){if(null===e.boneTexture){let n=Math.sqrt(4*t.length);n=Tn.ceilPowerOfTwo(n),n=Math.max(n,4);const o=new Float32Array(n*n*4);o.set(e.boneMatrices);const A=new Fi(o,n,n,Se,ye);e.boneMatrices=o,e.boneTexture=A,e.boneTextureSize=n}I.setValue(me,"boneTexture",e.boneTexture,_),I.setValue(me,"boneTextureSize",e.boneTextureSize)}else I.setOptional(me,e,"boneMatrices")}}var E,k;return(p||a.receiveShadow!==o.receiveShadow)&&(a.receiveShadow=o.receiveShadow,I.setValue(me,"receiveShadow",o.receiveShadow)),p&&(I.setValue(me,"toneMappingExposure",d.toneMappingExposure),a.needsLights&&(k=u,(E=G).ambientLightColor.needsUpdate=k,E.lightProbe.needsUpdate=k,E.directionalLights.needsUpdate=k,E.directionalLightShadows.needsUpdate=k,E.pointLights.needsUpdate=k,E.pointLightShadows.needsUpdate=k,E.spotLights.needsUpdate=k,E.spotLightShadows.needsUpdate=k,E.rectAreaLights.needsUpdate=k,E.hemisphereLights.needsUpdate=k),A&&n.fog&&ee.refreshFogUniforms(G,A),ee.refreshMaterialUniforms(G,n,K,j),Pr.upload(me,a.uniformsList,G,_)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(Pr.upload(me,a.uniformsList,G,_),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&I.setValue(me,"center",o.center),I.setValue(me,"modelViewMatrix",o.modelViewMatrix),I.setValue(me,"normalMatrix",o.normalMatrix),I.setValue(me,"modelMatrix",o.matrixWorld),c}ge.setAnimationLoop((function(e){ue.isPresenting||ke&&ke(e)})),"undefined"!=typeof window&&ge.setContext(window),this.setAnimationLoop=function(e){ke=e,ue.setAnimationLoop(e),null===e?ge.stop():ge.start()},this.render=function(e,t){let n,o;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),o=arguments[3]),void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===I)return;le.resetDefaultState(),H=-1,F=null,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===ue.enabled&&!0===ue.isPresenting&&(t=ue.getCamera(t)),!0===e.isScene&&e.onBeforeRender(d,e,t,n||g),h=ne.get(e,c.length),h.init(),c.push(h),S.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),w.setFromProjectionMatrix(S),L=this.localClippingEnabled,M=oe.init(this.clippingPlanes,L,t),p=te.get(e,u.length),p.init(),u.push(p),fe(e,t,0,d.sortObjects),p.finish(),!0===d.sortObjects&&p.sort(y,b),!0===M&&oe.beginShadows();const A=h.state.shadowsArray;ce.render(A,e,t),h.setupLights(),h.setupLightsView(t),!0===M&&oe.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),Ae.render(p,e,t,o);const i=p.opaque,r=p.transparent;i.length>0&&He(i,e,t),r.length>0&&He(r,e,t),!0===e.isScene&&e.onAfterRender(d,e,t),null!==g&&(_.updateRenderTargetMipmap(g),_.updateMultisampleRenderTarget(g)),U.buffers.depth.setTest(!0),U.buffers.depth.setMask(!0),U.buffers.color.setMask(!0),U.setPolygonOffset(!1),c.pop(),h=c.length>0?c[c.length-1]:null,u.pop(),p=u.length>0?u[u.length-1]:null},this.setFramebuffer=function(e){G!==e&&null===g&&me.bindFramebuffer(36160,e),G=e},this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return k},this.getRenderTarget=function(){return g},this.setRenderTarget=function(e,t=0,n=0){g=e,E=t,k=n,e&&void 0===W.get(e).__webglFramebuffer&&_.setupRenderTarget(e);let o=G,A=!1,i=!1;if(e){const n=e.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(i=!0);const r=W.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(o=r[t],A=!0):o=e.isWebGLMultisampleRenderTarget?W.get(e).__webglMultisampledFramebuffer:r,C.copy(e.viewport),D.copy(e.scissor),J=e.scissorTest}else C.copy(q).multiplyScalar(K).floor(),D.copy(x).multiplyScalar(K).floor(),J=B;if(f!==o&&(me.bindFramebuffer(36160,o),f=o),U.viewport(C),U.scissor(D),U.setScissorTest(J),A){const o=W.get(e.texture);me.framebufferTexture2D(36160,36064,34069+t,o.__webglTexture,n)}else if(i){const o=W.get(e.texture),A=t||0;me.framebufferTextureLayer(36160,36064,o.__webglTexture,n||0,A)}},this.readRenderTargetPixels=function(e,t,n,o,A,i,r){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let s=W.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==r&&(s=s[r]),s){let r=!1;s!==f&&(me.bindFramebuffer(36160,s),r=!0);try{const s=e.texture,a=s.format,l=s.type;if(a!==Se&&ae.convert(a)!==me.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const m=l===be&&(O.has("EXT_color_buffer_half_float")||P.isWebGL2&&O.has("EXT_color_buffer_float"));if(!(l===Ce||ae.convert(l)===me.getParameter(35738)||l===ye&&(P.isWebGL2||O.has("OES_texture_float")||O.has("WEBGL_color_buffer_float"))||m))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===me.checkFramebufferStatus(36160)?t>=0&&t<=e.width-o&&n>=0&&n<=e.height-A&&me.readPixels(t,n,o,A,ae.convert(a),ae.convert(l),i):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{r&&me.bindFramebuffer(36160,f)}}},this.copyFramebufferToTexture=function(e,t,n=0){const o=Math.pow(2,-n),A=Math.floor(t.image.width*o),i=Math.floor(t.image.height*o),r=ae.convert(t.format);_.setTexture2D(t,0),me.copyTexImage2D(3553,n,r,e.x,e.y,A,i,0),U.unbindTexture()},this.copyTextureToTexture=function(e,t,n,o=0){const A=t.image.width,i=t.image.height,r=ae.convert(n.format),s=ae.convert(n.type);_.setTexture2D(n,0),me.pixelStorei(37440,n.flipY),me.pixelStorei(37441,n.premultiplyAlpha),me.pixelStorei(3317,n.unpackAlignment),t.isDataTexture?me.texSubImage2D(3553,o,e.x,e.y,A,i,r,s,t.image.data):t.isCompressedTexture?me.compressedTexSubImage2D(3553,o,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,r,t.mipmaps[0].data):me.texSubImage2D(3553,o,e.x,e.y,r,s,t.image),0===o&&n.generateMipmaps&&me.generateMipmap(3553),U.unbindTexture()},this.copyTextureToTexture3D=function(e,t,n,o,A=0){if(d.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const{width:i,height:r,data:s}=n.image,a=ae.convert(o.format),l=ae.convert(o.type);let m;if(o.isDataTexture3D)_.setTexture3D(o,0),m=32879;else{if(!o.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");_.setTexture2DArray(o,0),m=35866}me.pixelStorei(37440,o.flipY),me.pixelStorei(37441,o.premultiplyAlpha),me.pixelStorei(3317,o.unpackAlignment);const p=me.getParameter(3314),h=me.getParameter(32878),u=me.getParameter(3316),c=me.getParameter(3315),I=me.getParameter(32877);me.pixelStorei(3314,i),me.pixelStorei(32878,r),me.pixelStorei(3316,e.min.x),me.pixelStorei(3315,e.min.y),me.pixelStorei(32877,e.min.z),me.texSubImage3D(m,A,t.x,t.y,t.z,e.max.x-e.min.x+1,e.max.y-e.min.y+1,e.max.z-e.min.z+1,a,l,s),me.pixelStorei(3314,p),me.pixelStorei(32878,h),me.pixelStorei(3316,u),me.pixelStorei(3315,c),me.pixelStorei(32877,I),0===A&&o.generateMipmaps&&me.generateMipmap(m),U.unbindTexture()},this.initTexture=function(e){_.setTexture2D(e,0),U.unbindTexture()},this.resetState=function(){U.reset(),le.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Ks.prototype.isGroup=!0,Object.assign(ys.prototype,{constructor:ys,getHandSpace:function(){return null===this._hand&&(this._hand=new Ks,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new Ks,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new Ks,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(e,t,n){let o=null,A=null,i=null;const r=this._targetRay,s=this._grip,a=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState)if(a&&e.hand){i=!0;for(const o of e.hand.values()){const e=t.getJointPose(o,n);if(void 0===a.joints[o.jointName]){const e=new Ks;e.matrixAutoUpdate=!1,e.visible=!1,a.joints[o.jointName]=e,a.add(e)}const A=a.joints[o.jointName];null!==e&&(A.matrix.fromArray(e.transform.matrix),A.matrix.decompose(A.position,A.rotation,A.scale),A.jointRadius=e.radius),A.visible=null!==e}const o=a.joints["index-finger-tip"],A=a.joints["thumb-tip"],r=o.position.distanceTo(A.position),s=.02,l=.005;a.inputState.pinching&&r>s+l?(a.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!a.inputState.pinching&&r<=s-l&&(a.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==r&&(o=t.getPose(e.targetRaySpace,n),null!==o&&(r.matrix.fromArray(o.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale))),null!==s&&e.gripSpace&&(A=t.getPose(e.gripSpace,n),null!==A&&(s.matrix.fromArray(A.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale)));return null!==r&&(r.visible=null!==o),null!==s&&(s.visible=null!==A),null!==a&&(a.visible=null!==i),this}}),Object.assign(bs.prototype,Mn.prototype);class Bs extends xs{}Bs.prototype.isWebGL1Renderer=!0;class ws{constructor(e,t){this.name="",this.color=new fA(e),this.density=void 0!==t?t:25e-5}clone(){return new ws(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}ws.prototype.isFogExp2=!0;class Ms{constructor(e,t,n){this.name="",this.color=new fA(e),this.near=void 0!==t?t:1,this.far=void 0!==n?n:1e3}clone(){return new Ms(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}Ms.prototype.isFog=!0;class Ls extends Zo{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.background&&(t.object.background=this.background.toJSON(e)),null!==this.environment&&(t.object.environment=this.environment.toJSON(e)),null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}function Ss(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=Dn,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Tn.generateUUID()}Ls.prototype.isScene=!0,Object.defineProperty(Ss.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(Ss.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let o=0,A=this.stride;o<A;o++)this.array[e+o]=t.array[n+o];return this},set:function(e,t=0){return this.array.set(e,t),this},clone:function(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Tn.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new Ss(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);return t.setUsage(this.usage),t},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Tn.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Ts=new Zn;function Ns(e,t,n,o){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===o}Object.defineProperties(Ns.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(Ns.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)Ts.x=this.getX(t),Ts.y=this.getY(t),Ts.z=this.getZ(t),Ts.applyMatrix4(e),this.setXYZ(t,Ts.x,Ts.y,Ts.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,o){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=o,this},setXYZW:function(e,t,n,o,A){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=o,this.data.array[e+3]=A,this},clone:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new DA(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Ns(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});class Rs extends cA{constructor(e){super(),this.type="SpriteMaterial",this.color=new fA(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}let Os;Rs.prototype.isSpriteMaterial=!0;const Ps=new Zn,Us=new Zn,Vs=new Zn,Ws=new Nn,_s=new Nn,zs=new Jo,Xs=new Zn,Qs=new Zn,Zs=new Zn,Ys=new Nn,$s=new Nn,ea=new Nn;class ta extends Zo{constructor(e){if(super(),this.type="Sprite",void 0===Os){Os=new WA;const e=new Ss(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);Os.setIndex([0,1,2,0,2,3]),Os.setAttribute("position",new Ns(e,3,0,!1)),Os.setAttribute("uv",new Ns(e,2,3,!1))}this.geometry=Os,this.material=void 0!==e?e:new Rs,this.center=new Nn(.5,.5)}raycast(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Us.setFromMatrixScale(this.matrixWorld),zs.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Vs.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Us.multiplyScalar(-Vs.z);const n=this.material.rotation;let o,A;0!==n&&(A=Math.cos(n),o=Math.sin(n));const i=this.center;na(Xs.set(-.5,-.5,0),Vs,i,Us,o,A),na(Qs.set(.5,-.5,0),Vs,i,Us,o,A),na(Zs.set(.5,.5,0),Vs,i,Us,o,A),Ys.set(0,0),$s.set(1,0),ea.set(1,1);let r=e.ray.intersectTriangle(Xs,Qs,Zs,!1,Ps);if(null===r&&(na(Qs.set(-.5,.5,0),Vs,i,Us,o,A),$s.set(0,1),r=e.ray.intersectTriangle(Xs,Zs,Qs,!1,Ps),null===r))return;const s=e.ray.origin.distanceTo(Ps);s<e.near||s>e.far||t.push({distance:s,point:Ps.clone(),uv:hA.getUV(Ps,Xs,Qs,Zs,Ys,$s,ea,new Nn),face:null,object:this})}copy(e){return super.copy(e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function na(e,t,n,o,A,i){Ws.subVectors(e,n).addScalar(.5).multiply(o),void 0!==A?(_s.x=i*Ws.x-A*Ws.y,_s.y=A*Ws.x+i*Ws.y):_s.copy(Ws),e.copy(t),e.x+=_s.x,e.y+=_s.y,e.applyMatrix4(zs)}ta.prototype.isSprite=!0;const oa=new Zn,Aa=new Zn;class ia extends Zo{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const n=this.levels;let o;for(o=0;o<n.length&&!(t<n[o].distance);o++);return n.splice(o,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,o;for(n=1,o=t.length;n<o&&!(e<t[n].distance);n++);return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){oa.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(oa);this.getObjectForDistance(n).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){oa.setFromMatrixPosition(e.matrixWorld),Aa.setFromMatrixPosition(this.matrixWorld);const n=oa.distanceTo(Aa)/e.zoom;let o,A;for(t[0].object.visible=!0,o=1,A=t.length;o<A&&n>=t[o].distance;o++)t[o-1].object.visible=!1,t[o].object.visible=!0;for(this._currentLevel=o-1;o<A;o++)t[o].object.visible=!1}}toJSON(e){const t=super.toJSON(e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let e=0,o=n.length;e<o;e++){const o=n[e];t.object.levels.push({object:o.object.uuid,distance:o.distance})}return t}}const ra=new Zn,sa=new _n,aa=new _n,la=new Zn,ma=new Jo;function pa(e,t){mi.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Jo,this.bindMatrixInverse=new Jo}function ha(){Zo.call(this),this.type="Bone"}pa.prototype=Object.assign(Object.create(mi.prototype),{constructor:pa,isSkinnedMesh:!0,copy:function(e){return mi.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new _n,t=this.geometry.attributes.skinWeight;for(let n=0,o=t.count;n<o;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const o=1/e.manhattanLength();o!==1/0?e.multiplyScalar(o):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){mi.prototype.updateMatrixWorld.call(this,e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(e,t){const n=this.skeleton,o=this.geometry;sa.fromBufferAttribute(o.attributes.skinIndex,e),aa.fromBufferAttribute(o.attributes.skinWeight,e),ra.fromBufferAttribute(o.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){const o=aa.getComponent(e);if(0!==o){const A=sa.getComponent(e);ma.multiplyMatrices(n.bones[A].matrixWorld,n.boneInverses[A]),t.addScaledVector(la.copy(ra).applyMatrix4(ma),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}),ha.prototype=Object.assign(Object.create(Zo.prototype),{constructor:ha,isBone:!0});const ua=new Jo,ca=new Jo;class da{constructor(e=[],t=[]){this.uuid=Tn.generateUUID(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Jo)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Jo;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,o=this.boneTexture;for(let o=0,A=e.length;o<A;o++){const A=e[o]?e[o].matrixWorld:ca;ua.multiplyMatrices(A,t[o]),ua.toArray(n,16*o)}null!==o&&(o.needsUpdate=!0)}clone(){return new da(this.bones,this.boneInverses)}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,o=e.bones.length;n<o;n++){const o=e.bones[n];let A=t[o];void 0===A&&(console.warn("THREE.Skeleton: No bone found with UUID:",o),A=new ha),this.bones.push(A),this.boneInverses.push((new Jo).fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let o=0,A=t.length;o<A;o++){const A=t[o];e.bones.push(A.uuid);const i=n[o];e.boneInverses.push(i.toArray())}return e}}const Ia=new Jo,Ga=new Jo,Ea=[],ka=new mi;function ga(e,t,n){mi.call(this,e,t),this.instanceMatrix=new DA(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}ga.prototype=Object.assign(Object.create(mi.prototype),{constructor:ga,isInstancedMesh:!0,copy:function(e){return mi.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this},getColorAt:function(e,t){t.fromArray(this.instanceColor.array,3*e)},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){const n=this.matrixWorld,o=this.count;if(ka.geometry=this.geometry,ka.material=this.material,void 0!==ka.material)for(let A=0;A<o;A++){this.getMatrixAt(A,Ia),Ga.multiplyMatrices(n,Ia),ka.matrixWorld=Ga,ka.raycast(e,Ea);for(let e=0,n=Ea.length;e<n;e++){const n=Ea[e];n.instanceId=A,n.object=this,t.push(n)}Ea.length=0}},setColorAt:function(e,t){null===this.instanceColor&&(this.instanceColor=new DA(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});class fa extends cA{constructor(e){super(),this.type="LineBasicMaterial",this.color=new fA(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this}}fa.prototype.isLineBasicMaterial=!0;const Ha=new Zn,Fa=new Zn,Ca=new Jo,Da=new Do,Ja=new Go;function va(e=new WA,t=new fa){Zo.call(this),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}va.prototype=Object.assign(Object.create(Zo.prototype),{constructor:va,isLine:!0,copy:function(e){return Zo.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,o=t.count;e<o;e++)Ha.fromBufferAttribute(t,e-1),Fa.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=Ha.distanceTo(Fa);e.setAttribute("lineDistance",new BA(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(e,t){const n=this.geometry,o=this.matrixWorld,A=e.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),Ja.copy(n.boundingSphere),Ja.applyMatrix4(o),Ja.radius+=A,!1===e.ray.intersectsSphere(Ja))return;Ca.copy(o).invert(),Da.copy(e.ray).applyMatrix4(Ca);const i=A/((this.scale.x+this.scale.y+this.scale.z)/3),r=i*i,s=new Zn,a=new Zn,l=new Zn,m=new Zn,p=this.isLineSegments?2:1;if(n.isBufferGeometry){const o=n.index,A=n.attributes.position;if(null!==o){const n=o.array;for(let o=0,i=n.length-1;o<i;o+=p){const i=n[o],p=n[o+1];if(s.fromBufferAttribute(A,i),a.fromBufferAttribute(A,p),Da.distanceSqToSegment(s,a,m,l)>r)continue;m.applyMatrix4(this.matrixWorld);const h=e.ray.origin.distanceTo(m);h<e.near||h>e.far||t.push({distance:h,point:l.clone().applyMatrix4(this.matrixWorld),index:o,face:null,faceIndex:null,object:this})}}else for(let n=0,o=A.count-1;n<o;n+=p){if(s.fromBufferAttribute(A,n),a.fromBufferAttribute(A,n+1),Da.distanceSqToSegment(s,a,m,l)>r)continue;m.applyMatrix4(this.matrixWorld);const o=e.ray.origin.distanceTo(m);o<e.near||o>e.far||t.push({distance:o,point:l.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const ja=new Zn,Ka=new Zn;function ya(e,t){va.call(this,e,t),this.type="LineSegments"}ya.prototype=Object.assign(Object.create(va.prototype),{constructor:ya,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,o=t.count;e<o;e+=2)ja.fromBufferAttribute(t,e),Ka.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+ja.distanceTo(Ka);e.setAttribute("lineDistance",new BA(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});class ba extends va{constructor(e,t){super(e,t),this.type="LineLoop"}}ba.prototype.isLineLoop=!0;class qa extends cA{constructor(e){super(),this.type="PointsMaterial",this.color=new fA(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this}}qa.prototype.isPointsMaterial=!0;const xa=new Jo,Ba=new Do,wa=new Go,Ma=new Zn;function La(e=new WA,t=new qa){Zo.call(this),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}function Sa(e,t,n,o,A,i,r){const s=Ba.distanceSqToPoint(e);if(s<n){const n=new Zn;Ba.closestPointToPoint(e,n),n.applyMatrix4(o);const a=A.ray.origin.distanceTo(n);if(a<A.near||a>A.far)return;i.push({distance:a,distanceToRay:Math.sqrt(s),point:n,index:t,face:null,object:r})}}La.prototype=Object.assign(Object.create(Zo.prototype),{constructor:La,isPoints:!0,copy:function(e){return Zo.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,o=this.matrixWorld,A=e.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),wa.copy(n.boundingSphere),wa.applyMatrix4(o),wa.radius+=A,!1===e.ray.intersectsSphere(wa))return;xa.copy(o).invert(),Ba.copy(e.ray).applyMatrix4(xa);const i=A/((this.scale.x+this.scale.y+this.scale.z)/3),r=i*i;if(n.isBufferGeometry){const A=n.index,i=n.attributes.position;if(null!==A){const n=A.array;for(let A=0,s=n.length;A<s;A++){const s=n[A];Ma.fromBufferAttribute(i,s),Sa(Ma,s,r,o,e,t,this)}}else for(let n=0,A=i.count;n<A;n++)Ma.fromBufferAttribute(i,n),Sa(Ma,n,r,o,e,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});class Ta extends Vn{constructor(e,t,n,o,A,i,r,s,a){super(e,t,n,o,A,i,r,s,a),this.format=void 0!==r?r:Le,this.minFilter=void 0!==i?i:ke,this.magFilter=void 0!==A?A:ke,this.generateMipmaps=!1;const l=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback((function t(){l.needsUpdate=!0,e.requestVideoFrameCallback(t)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!1=="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Ta.prototype.isVideoTexture=!0;class Na extends Vn{constructor(e,t,n,o,A,i,r,s,a,l,m,p){super(null,i,r,s,a,l,o,A,m,p),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}Na.prototype.isCompressedTexture=!0;class Ra extends Vn{constructor(e,t,n,o,A,i,r,s,a){super(e,t,n,o,A,i,r,s,a),this.needsUpdate=!0}}Ra.prototype.isCanvasTexture=!0;class Oa extends Vn{constructor(e,t,n,o,A,i,r,s,a,l){if((l=void 0!==l?l:Oe)!==Oe&&l!==Pe)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&l===Oe&&(n=ve),void 0===n&&l===Pe&&(n=we),super(null,o,A,i,r,s,l,n,a),this.image={width:e,height:t},this.magFilter=void 0!==r?r:ce,this.minFilter=void 0!==s?s:ce,this.flipY=!1,this.generateMipmaps=!1}}Oa.prototype.isDepthTexture=!0;class Pa extends WA{constructor(e=1,t=8,n=0,o=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:o},t=Math.max(3,t);const A=[],i=[],r=[],s=[],a=new Zn,l=new Nn;i.push(0,0,0),r.push(0,0,1),s.push(.5,.5);for(let A=0,m=3;A<=t;A++,m+=3){const p=n+A/t*o;a.x=e*Math.cos(p),a.y=e*Math.sin(p),i.push(a.x,a.y,a.z),r.push(0,0,1),l.x=(i[m]/e+1)/2,l.y=(i[m+1]/e+1)/2,s.push(l.x,l.y)}for(let e=1;e<=t;e++)A.push(e,e+1,0);this.setIndex(A),this.setAttribute("position",new BA(i,3)),this.setAttribute("normal",new BA(r,3)),this.setAttribute("uv",new BA(s,2))}}class Ua extends WA{constructor(e=1,t=1,n=1,o=8,A=1,i=!1,r=0,s=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:o,heightSegments:A,openEnded:i,thetaStart:r,thetaLength:s};const a=this;o=Math.floor(o),A=Math.floor(A);const l=[],m=[],p=[],h=[];let u=0;const c=[],d=n/2;let I=0;function G(n){const A=u,i=new Nn,c=new Zn;let G=0;const E=!0===n?e:t,k=!0===n?1:-1;for(let e=1;e<=o;e++)m.push(0,d*k,0),p.push(0,k,0),h.push(.5,.5),u++;const g=u;for(let e=0;e<=o;e++){const t=e/o*s+r,n=Math.cos(t),A=Math.sin(t);c.x=E*A,c.y=d*k,c.z=E*n,m.push(c.x,c.y,c.z),p.push(0,k,0),i.x=.5*n+.5,i.y=.5*A*k+.5,h.push(i.x,i.y),u++}for(let e=0;e<o;e++){const t=A+e,o=g+e;!0===n?l.push(o,o+1,t):l.push(o+1,o,t),G+=3}a.addGroup(I,G,!0===n?1:2),I+=G}!function(){const i=new Zn,G=new Zn;let E=0;const k=(t-e)/n;for(let a=0;a<=A;a++){const l=[],I=a/A,E=I*(t-e)+e;for(let e=0;e<=o;e++){const t=e/o,A=t*s+r,a=Math.sin(A),c=Math.cos(A);G.x=E*a,G.y=-I*n+d,G.z=E*c,m.push(G.x,G.y,G.z),i.set(a,k,c).normalize(),p.push(i.x,i.y,i.z),h.push(t,1-I),l.push(u++)}c.push(l)}for(let e=0;e<o;e++)for(let t=0;t<A;t++){const n=c[t][e],o=c[t+1][e],A=c[t+1][e+1],i=c[t][e+1];l.push(n,o,i),l.push(o,A,i),E+=6}a.addGroup(I,E,0),I+=E}(),!1===i&&(e>0&&G(!0),t>0&&G(!1)),this.setIndex(l),this.setAttribute("position",new BA(m,3)),this.setAttribute("normal",new BA(p,3)),this.setAttribute("uv",new BA(h,2))}}class Va extends Ua{constructor(e=1,t=1,n=8,o=1,A=!1,i=0,r=2*Math.PI){super(0,e,t,n,o,A,i,r),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:o,openEnded:A,thetaStart:i,thetaLength:r}}}class Wa extends WA{constructor(e,t,n=1,o=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:o};const A=[],i=[];function r(e,t,n,o){const A=o+1,i=[];for(let o=0;o<=A;o++){i[o]=[];const r=e.clone().lerp(n,o/A),s=t.clone().lerp(n,o/A),a=A-o;for(let e=0;e<=a;e++)i[o][e]=0===e&&o===A?r:r.clone().lerp(s,e/a)}for(let e=0;e<A;e++)for(let t=0;t<2*(A-e)-1;t++){const n=Math.floor(t/2);t%2==0?(s(i[e][n+1]),s(i[e+1][n]),s(i[e][n])):(s(i[e][n+1]),s(i[e+1][n+1]),s(i[e+1][n]))}}function s(e){A.push(e.x,e.y,e.z)}function a(t,n){const o=3*t;n.x=e[o+0],n.y=e[o+1],n.z=e[o+2]}function l(e,t,n,o){o<0&&1===e.x&&(i[t]=e.x-1),0===n.x&&0===n.z&&(i[t]=o/2/Math.PI+.5)}function m(e){return Math.atan2(e.z,-e.x)}!function(e){const n=new Zn,o=new Zn,A=new Zn;for(let i=0;i<t.length;i+=3)a(t[i+0],n),a(t[i+1],o),a(t[i+2],A),r(n,o,A,e)}(o),function(e){const t=new Zn;for(let n=0;n<A.length;n+=3)t.x=A[n+0],t.y=A[n+1],t.z=A[n+2],t.normalize().multiplyScalar(e),A[n+0]=t.x,A[n+1]=t.y,A[n+2]=t.z}(n),function(){const e=new Zn;for(let n=0;n<A.length;n+=3){e.x=A[n+0],e.y=A[n+1],e.z=A[n+2];const o=m(e)/2/Math.PI+.5,r=(t=e,Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))/Math.PI+.5);i.push(o,1-r)}var t;(function(){const e=new Zn,t=new Zn,n=new Zn,o=new Zn,r=new Nn,s=new Nn,a=new Nn;for(let p=0,h=0;p<A.length;p+=9,h+=6){e.set(A[p+0],A[p+1],A[p+2]),t.set(A[p+3],A[p+4],A[p+5]),n.set(A[p+6],A[p+7],A[p+8]),r.set(i[h+0],i[h+1]),s.set(i[h+2],i[h+3]),a.set(i[h+4],i[h+5]),o.copy(e).add(t).add(n).divideScalar(3);const u=m(o);l(r,h+0,e,u),l(s,h+2,t,u),l(a,h+4,n,u)}})(),function(){for(let e=0;e<i.length;e+=6){const t=i[e+0],n=i[e+2],o=i[e+4],A=Math.max(t,n,o),r=Math.min(t,n,o);A>.9&&r<.1&&(t<.2&&(i[e+0]+=1),n<.2&&(i[e+2]+=1),o<.2&&(i[e+4]+=1))}}()}(),this.setAttribute("position",new BA(A,3)),this.setAttribute("normal",new BA(A.slice(),3)),this.setAttribute("uv",new BA(i,2)),0===o?this.computeVertexNormals():this.normalizeNormals()}}class _a extends Wa{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,o=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-o,-n,0,-o,n,0,o,-n,0,o,n,-o,-n,0,-o,n,0,o,-n,0,o,n,0,-n,0,-o,n,0,-o,-n,0,o,n,0,o],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const za=new Zn,Xa=new Zn,Qa=new Zn,Za=new hA;class Ya extends WA{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=void 0!==t?t:1,!0===e.isGeometry)return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const n=Math.pow(10,4),o=Math.cos(Tn.DEG2RAD*t),A=e.getIndex(),i=e.getAttribute("position"),r=A?A.count:i.count,s=[0,0,0],a=["a","b","c"],l=new Array(3),m={},p=[];for(let e=0;e<r;e+=3){A?(s[0]=A.getX(e),s[1]=A.getX(e+1),s[2]=A.getX(e+2)):(s[0]=e,s[1]=e+1,s[2]=e+2);const{a:t,b:r,c:h}=Za;if(t.fromBufferAttribute(i,s[0]),r.fromBufferAttribute(i,s[1]),h.fromBufferAttribute(i,s[2]),Za.getNormal(Qa),l[0]=`${Math.round(t.x*n)},${Math.round(t.y*n)},${Math.round(t.z*n)}`,l[1]=`${Math.round(r.x*n)},${Math.round(r.y*n)},${Math.round(r.z*n)}`,l[2]=`${Math.round(h.x*n)},${Math.round(h.y*n)},${Math.round(h.z*n)}`,l[0]!==l[1]&&l[1]!==l[2]&&l[2]!==l[0])for(let e=0;e<3;e++){const t=(e+1)%3,n=l[e],A=l[t],i=Za[a[e]],r=Za[a[t]],h=`${n}_${A}`,u=`${A}_${n}`;u in m&&m[u]?(Qa.dot(m[u].normal)<=o&&(p.push(i.x,i.y,i.z),p.push(r.x,r.y,r.z)),m[u]=null):h in m||(m[h]={index0:s[e],index1:s[t],normal:Qa.clone()})}}for(const e in m)if(m[e]){const{index0:t,index1:n}=m[e];za.fromBufferAttribute(i,t),Xa.fromBufferAttribute(i,n),p.push(za.x,za.y,za.z),p.push(Xa.x,Xa.y,Xa.z)}this.setAttribute("position",new BA(p,3))}}function $a(e,t,n,o,A){let i,r;if(A===function(e,t,n,o){let A=0;for(let i=t,r=n-o;i<n;i+=o)A+=(e[r]-e[i])*(e[i+1]+e[r+1]),r=i;return A}(e,t,n,o)>0)for(i=t;i<n;i+=o)r=gl(i,e[i],e[i+1],r);else for(i=n-o;i>=t;i-=o)r=gl(i,e[i],e[i+1],r);return r&&cl(r,r.next)&&(fl(r),r=r.next),r}function el(e,t){if(!e)return e;t||(t=e);let n,o=e;do{if(n=!1,o.steiner||!cl(o,o.next)&&0!==ul(o.prev,o,o.next))o=o.next;else{if(fl(o),o=t=o.prev,o===o.next)break;n=!0}}while(n||o!==t);return t}function tl(e,t,n,o,A,i,r){if(!e)return;!r&&i&&function(e,t,n,o){let A=e;do{null===A.z&&(A.z=ll(A.x,A.y,t,n,o)),A.prevZ=A.prev,A.nextZ=A.next,A=A.next}while(A!==e);A.prevZ.nextZ=null,A.prevZ=null,function(e){let t,n,o,A,i,r,s,a,l=1;do{for(n=e,e=null,i=null,r=0;n;){for(r++,o=n,s=0,t=0;t<l&&(s++,o=o.nextZ,o);t++);for(a=l;s>0||a>0&&o;)0!==s&&(0===a||!o||n.z<=o.z)?(A=n,n=n.nextZ,s--):(A=o,o=o.nextZ,a--),i?i.nextZ=A:e=A,A.prevZ=i,i=A;n=o}i.nextZ=null,l*=2}while(r>1)}(A)}(e,o,A,i);let s,a,l=e;for(;e.prev!==e.next;)if(s=e.prev,a=e.next,i?ol(e,o,A,i):nl(e))t.push(s.i/n),t.push(e.i/n),t.push(a.i/n),fl(e),e=a.next,l=a.next;else if((e=a)===l){r?1===r?tl(e=Al(el(e),t,n),t,n,o,A,i,2):2===r&&il(e,t,n,o,A,i):tl(el(e),t,n,o,A,i,1);break}}function nl(e){const t=e.prev,n=e,o=e.next;if(ul(t,n,o)>=0)return!1;let A=e.next.next;for(;A!==e.prev;){if(pl(t.x,t.y,n.x,n.y,o.x,o.y,A.x,A.y)&&ul(A.prev,A,A.next)>=0)return!1;A=A.next}return!0}function ol(e,t,n,o){const A=e.prev,i=e,r=e.next;if(ul(A,i,r)>=0)return!1;const s=A.x<i.x?A.x<r.x?A.x:r.x:i.x<r.x?i.x:r.x,a=A.y<i.y?A.y<r.y?A.y:r.y:i.y<r.y?i.y:r.y,l=A.x>i.x?A.x>r.x?A.x:r.x:i.x>r.x?i.x:r.x,m=A.y>i.y?A.y>r.y?A.y:r.y:i.y>r.y?i.y:r.y,p=ll(s,a,t,n,o),h=ll(l,m,t,n,o);let u=e.prevZ,c=e.nextZ;for(;u&&u.z>=p&&c&&c.z<=h;){if(u!==e.prev&&u!==e.next&&pl(A.x,A.y,i.x,i.y,r.x,r.y,u.x,u.y)&&ul(u.prev,u,u.next)>=0)return!1;if(u=u.prevZ,c!==e.prev&&c!==e.next&&pl(A.x,A.y,i.x,i.y,r.x,r.y,c.x,c.y)&&ul(c.prev,c,c.next)>=0)return!1;c=c.nextZ}for(;u&&u.z>=p;){if(u!==e.prev&&u!==e.next&&pl(A.x,A.y,i.x,i.y,r.x,r.y,u.x,u.y)&&ul(u.prev,u,u.next)>=0)return!1;u=u.prevZ}for(;c&&c.z<=h;){if(c!==e.prev&&c!==e.next&&pl(A.x,A.y,i.x,i.y,r.x,r.y,c.x,c.y)&&ul(c.prev,c,c.next)>=0)return!1;c=c.nextZ}return!0}function Al(e,t,n){let o=e;do{const A=o.prev,i=o.next.next;!cl(A,i)&&dl(A,o,o.next,i)&&El(A,i)&&El(i,A)&&(t.push(A.i/n),t.push(o.i/n),t.push(i.i/n),fl(o),fl(o.next),o=e=i),o=o.next}while(o!==e);return el(o)}function il(e,t,n,o,A,i){let r=e;do{let e=r.next.next;for(;e!==r.prev;){if(r.i!==e.i&&hl(r,e)){let s=kl(r,e);return r=el(r,r.next),s=el(s,s.next),tl(r,t,n,o,A,i),void tl(s,t,n,o,A,i)}e=e.next}r=r.next}while(r!==e)}function rl(e,t){return e.x-t.x}function sl(e,t){if(t=function(e,t){let n=t;const o=e.x,A=e.y;let i,r=-1/0;do{if(A<=n.y&&A>=n.next.y&&n.next.y!==n.y){const e=n.x+(A-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=o&&e>r){if(r=e,e===o){if(A===n.y)return n;if(A===n.next.y)return n.next}i=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!i)return null;if(o===r)return i;const s=i,a=i.x,l=i.y;let m,p=1/0;n=i;do{o>=n.x&&n.x>=a&&o!==n.x&&pl(A<l?o:r,A,a,l,A<l?r:o,A,n.x,n.y)&&(m=Math.abs(A-n.y)/(o-n.x),El(n,e)&&(m<p||m===p&&(n.x>i.x||n.x===i.x&&al(i,n)))&&(i=n,p=m)),n=n.next}while(n!==s);return i}(e,t),t){const n=kl(t,e);el(t,t.next),el(n,n.next)}}function al(e,t){return ul(e.prev,e,t.prev)<0&&ul(t.next,e,e.next)<0}function ll(e,t,n,o,A){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*A)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-o)*A)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function ml(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function pl(e,t,n,o,A,i,r,s){return(A-r)*(t-s)-(e-r)*(i-s)>=0&&(e-r)*(o-s)-(n-r)*(t-s)>=0&&(n-r)*(i-s)-(A-r)*(o-s)>=0}function hl(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&dl(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(El(e,t)&&El(t,e)&&function(e,t){let n=e,o=!1;const A=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&A<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(o=!o),n=n.next}while(n!==e);return o}(e,t)&&(ul(e.prev,e,t.prev)||ul(e,t.prev,t))||cl(e,t)&&ul(e.prev,e,e.next)>0&&ul(t.prev,t,t.next)>0)}function ul(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function cl(e,t){return e.x===t.x&&e.y===t.y}function dl(e,t,n,o){const A=Gl(ul(e,t,n)),i=Gl(ul(e,t,o)),r=Gl(ul(n,o,e)),s=Gl(ul(n,o,t));return A!==i&&r!==s||!(0!==A||!Il(e,n,t))||!(0!==i||!Il(e,o,t))||!(0!==r||!Il(n,e,o))||!(0!==s||!Il(n,t,o))}function Il(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function Gl(e){return e>0?1:e<0?-1:0}function El(e,t){return ul(e.prev,e,e.next)<0?ul(e,t,e.next)>=0&&ul(e,e.prev,t)>=0:ul(e,t,e.prev)<0||ul(e,e.next,t)<0}function kl(e,t){const n=new Hl(e.i,e.x,e.y),o=new Hl(t.i,t.x,t.y),A=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=A,A.prev=n,o.next=n,n.prev=o,i.next=o,o.prev=i,o}function gl(e,t,n,o){const A=new Hl(e,t,n);return o?(A.next=o.next,A.prev=o,o.next.prev=A,o.next=A):(A.prev=A,A.next=A),A}function fl(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Hl(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}const Fl={area:function(e){const t=e.length;let n=0;for(let o=t-1,A=0;A<t;o=A++)n+=e[o].x*e[A].y-e[A].x*e[o].y;return.5*n},isClockWise:function(e){return Fl.area(e)<0},triangulateShape:function(e,t){const n=[],o=[],A=[];Cl(e),Dl(n,e);let i=e.length;t.forEach(Cl);for(let e=0;e<t.length;e++)o.push(i),i+=t[e].length,Dl(n,t[e]);const r=function(e,t,n){n=n||2;const o=t&&t.length,A=o?t[0]*n:e.length;let i=$a(e,0,A,n,!0);const r=[];if(!i||i.next===i.prev)return r;let s,a,l,m,p,h,u;if(o&&(i=function(e,t,n,o){const A=[];let i,r,s,a,l;for(i=0,r=t.length;i<r;i++)s=t[i]*o,a=i<r-1?t[i+1]*o:e.length,l=$a(e,s,a,o,!1),l===l.next&&(l.steiner=!0),A.push(ml(l));for(A.sort(rl),i=0;i<A.length;i++)sl(A[i],n),n=el(n,n.next);return n}(e,t,i,n)),e.length>80*n){s=l=e[0],a=m=e[1];for(let t=n;t<A;t+=n)p=e[t],h=e[t+1],p<s&&(s=p),h<a&&(a=h),p>l&&(l=p),h>m&&(m=h);u=Math.max(l-s,m-a),u=0!==u?1/u:0}return tl(i,r,n,s,a,u),r}(n,o);for(let e=0;e<r.length;e+=3)A.push(r.slice(e,e+3));return A}};function Cl(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function Dl(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class Jl extends WA{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,o=[],A=[];for(let t=0,n=e.length;t<n;t++)i(e[t]);function i(e){const i=[],r=void 0!==t.curveSegments?t.curveSegments:12,s=void 0!==t.steps?t.steps:1;let a=void 0!==t.depth?t.depth:100,l=void 0===t.bevelEnabled||t.bevelEnabled,m=void 0!==t.bevelThickness?t.bevelThickness:6,p=void 0!==t.bevelSize?t.bevelSize:m-2,h=void 0!==t.bevelOffset?t.bevelOffset:0,u=void 0!==t.bevelSegments?t.bevelSegments:3;const c=t.extrudePath,d=void 0!==t.UVGenerator?t.UVGenerator:vl;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),a=t.amount);let I,G,E,k,g,f=!1;c&&(I=c.getSpacedPoints(s),f=!0,l=!1,G=c.computeFrenetFrames(s,!1),E=new Zn,k=new Zn,g=new Zn),l||(u=0,m=0,p=0,h=0);const H=e.extractPoints(r);let F=H.shape;const C=H.holes;if(!Fl.isClockWise(F)){F=F.reverse();for(let e=0,t=C.length;e<t;e++){const t=C[e];Fl.isClockWise(t)&&(C[e]=t.reverse())}}const D=Fl.triangulateShape(F,C),J=F;for(let e=0,t=C.length;e<t;e++){const t=C[e];F=F.concat(t)}function v(e,t,n){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(n).add(e)}const j=F.length,K=D.length;function y(e,t,n){let o,A,i;const r=e.x-t.x,s=e.y-t.y,a=n.x-e.x,l=n.y-e.y,m=r*r+s*s,p=r*l-s*a;if(Math.abs(p)>Number.EPSILON){const p=Math.sqrt(m),h=Math.sqrt(a*a+l*l),u=t.x-s/p,c=t.y+r/p,d=((n.x-l/h-u)*l-(n.y+a/h-c)*a)/(r*l-s*a);o=u+r*d-e.x,A=c+s*d-e.y;const I=o*o+A*A;if(I<=2)return new Nn(o,A);i=Math.sqrt(I/2)}else{let e=!1;r>Number.EPSILON?a>Number.EPSILON&&(e=!0):r<-Number.EPSILON?a<-Number.EPSILON&&(e=!0):Math.sign(s)===Math.sign(l)&&(e=!0),e?(o=-s,A=r,i=Math.sqrt(m)):(o=r,A=s,i=Math.sqrt(m/2))}return new Nn(o/i,A/i)}const b=[];for(let e=0,t=J.length,n=t-1,o=e+1;e<t;e++,n++,o++)n===t&&(n=0),o===t&&(o=0),b[e]=y(J[e],J[n],J[o]);const q=[];let x,B=b.concat();for(let e=0,t=C.length;e<t;e++){const t=C[e];x=[];for(let e=0,n=t.length,o=n-1,A=e+1;e<n;e++,o++,A++)o===n&&(o=0),A===n&&(A=0),x[e]=y(t[e],t[o],t[A]);q.push(x),B=B.concat(x)}for(let e=0;e<u;e++){const t=e/u,n=m*Math.cos(t*Math.PI/2),o=p*Math.sin(t*Math.PI/2)+h;for(let e=0,t=J.length;e<t;e++){const t=v(J[e],b[e],o);L(t.x,t.y,-n)}for(let e=0,t=C.length;e<t;e++){const t=C[e];x=q[e];for(let e=0,A=t.length;e<A;e++){const A=v(t[e],x[e],o);L(A.x,A.y,-n)}}}const w=p+h;for(let e=0;e<j;e++){const t=l?v(F[e],B[e],w):F[e];f?(k.copy(G.normals[0]).multiplyScalar(t.x),E.copy(G.binormals[0]).multiplyScalar(t.y),g.copy(I[0]).add(k).add(E),L(g.x,g.y,g.z)):L(t.x,t.y,0)}for(let e=1;e<=s;e++)for(let t=0;t<j;t++){const n=l?v(F[t],B[t],w):F[t];f?(k.copy(G.normals[e]).multiplyScalar(n.x),E.copy(G.binormals[e]).multiplyScalar(n.y),g.copy(I[e]).add(k).add(E),L(g.x,g.y,g.z)):L(n.x,n.y,a/s*e)}for(let e=u-1;e>=0;e--){const t=e/u,n=m*Math.cos(t*Math.PI/2),o=p*Math.sin(t*Math.PI/2)+h;for(let e=0,t=J.length;e<t;e++){const t=v(J[e],b[e],o);L(t.x,t.y,a+n)}for(let e=0,t=C.length;e<t;e++){const t=C[e];x=q[e];for(let e=0,A=t.length;e<A;e++){const A=v(t[e],x[e],o);f?L(A.x,A.y+I[s-1].y,I[s-1].x+n):L(A.x,A.y,a+n)}}}function M(e,t){let n=e.length;for(;--n>=0;){const o=n;let A=n-1;A<0&&(A=e.length-1);for(let e=0,n=s+2*u;e<n;e++){const n=j*e,i=j*(e+1);T(t+o+n,t+A+n,t+A+i,t+o+i)}}}function L(e,t,n){i.push(e),i.push(t),i.push(n)}function S(e,t,A){N(e),N(t),N(A);const i=o.length/3,r=d.generateTopUV(n,o,i-3,i-2,i-1);R(r[0]),R(r[1]),R(r[2])}function T(e,t,A,i){N(e),N(t),N(i),N(t),N(A),N(i);const r=o.length/3,s=d.generateSideWallUV(n,o,r-6,r-3,r-2,r-1);R(s[0]),R(s[1]),R(s[3]),R(s[1]),R(s[2]),R(s[3])}function N(e){o.push(i[3*e+0]),o.push(i[3*e+1]),o.push(i[3*e+2])}function R(e){A.push(e.x),A.push(e.y)}!function(){const e=o.length/3;if(l){let e=0,t=j*e;for(let e=0;e<K;e++){const n=D[e];S(n[2]+t,n[1]+t,n[0]+t)}e=s+2*u,t=j*e;for(let e=0;e<K;e++){const n=D[e];S(n[0]+t,n[1]+t,n[2]+t)}}else{for(let e=0;e<K;e++){const t=D[e];S(t[2],t[1],t[0])}for(let e=0;e<K;e++){const t=D[e];S(t[0]+j*s,t[1]+j*s,t[2]+j*s)}}n.addGroup(e,o.length/3-e,0)}(),function(){const e=o.length/3;let t=0;M(J,t),t+=J.length;for(let e=0,n=C.length;e<n;e++){const n=C[e];M(n,t),t+=n.length}n.addGroup(e,o.length/3-e,1)}()}this.setAttribute("position",new BA(o,3)),this.setAttribute("uv",new BA(A,2)),this.computeVertexNormals()}toJSON(){const e=WA.prototype.toJSON.call(this);return function(e,t,n){if(n.shapes=[],Array.isArray(e))for(let t=0,o=e.length;t<o;t++){const o=e[t];n.shapes.push(o.uuid)}else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,e)}}const vl={generateTopUV:function(e,t,n,o,A){const i=t[3*n],r=t[3*n+1],s=t[3*o],a=t[3*o+1],l=t[3*A],m=t[3*A+1];return[new Nn(i,r),new Nn(s,a),new Nn(l,m)]},generateSideWallUV:function(e,t,n,o,A,i){const r=t[3*n],s=t[3*n+1],a=t[3*n+2],l=t[3*o],m=t[3*o+1],p=t[3*o+2],h=t[3*A],u=t[3*A+1],c=t[3*A+2],d=t[3*i],I=t[3*i+1],G=t[3*i+2];return Math.abs(s-m)<.01?[new Nn(r,1-a),new Nn(l,1-p),new Nn(h,1-c),new Nn(d,1-G)]:[new Nn(s,1-a),new Nn(m,1-p),new Nn(u,1-c),new Nn(I,1-G)]}};class jl extends Wa{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class Kl extends WA{constructor(e,t=12,n=0,o=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:o},t=Math.floor(t),o=Tn.clamp(o,0,2*Math.PI);const A=[],i=[],r=[],s=1/t,a=new Zn,l=new Nn;for(let A=0;A<=t;A++){const m=n+A*s*o,p=Math.sin(m),h=Math.cos(m);for(let n=0;n<=e.length-1;n++)a.x=e[n].x*p,a.y=e[n].y,a.z=e[n].x*h,i.push(a.x,a.y,a.z),l.x=A/t,l.y=n/(e.length-1),r.push(l.x,l.y)}for(let n=0;n<t;n++)for(let t=0;t<e.length-1;t++){const o=t+n*e.length,i=o,r=o+e.length,s=o+e.length+1,a=o+1;A.push(i,r,a),A.push(r,s,a)}if(this.setIndex(A),this.setAttribute("position",new BA(i,3)),this.setAttribute("uv",new BA(r,2)),this.computeVertexNormals(),o===2*Math.PI){const n=this.attributes.normal.array,o=new Zn,A=new Zn,i=new Zn,r=t*e.length*3;for(let t=0,s=0;t<e.length;t++,s+=3)o.x=n[s+0],o.y=n[s+1],o.z=n[s+2],A.x=n[r+s+0],A.y=n[r+s+1],A.z=n[r+s+2],i.addVectors(o,A).normalize(),n[s+0]=n[r+s+0]=i.x,n[s+1]=n[r+s+1]=i.y,n[s+2]=n[r+s+2]=i.z}}}class yl extends Wa{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}function bl(e,t,n){WA.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n};const o=[],A=[],i=[],r=[],s=1e-5,a=new Zn,l=new Zn,m=new Zn,p=new Zn,h=new Zn;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const u=t+1;for(let o=0;o<=n;o++){const u=o/n;for(let n=0;n<=t;n++){const o=n/t;e(o,u,l),A.push(l.x,l.y,l.z),o-s>=0?(e(o-s,u,m),p.subVectors(l,m)):(e(o+s,u,m),p.subVectors(m,l)),u-s>=0?(e(o,u-s,m),h.subVectors(l,m)):(e(o,u+s,m),h.subVectors(m,l)),a.crossVectors(p,h).normalize(),i.push(a.x,a.y,a.z),r.push(o,u)}}for(let e=0;e<n;e++)for(let n=0;n<t;n++){const t=e*u+n,A=e*u+n+1,i=(e+1)*u+n+1,r=(e+1)*u+n;o.push(t,A,r),o.push(A,i,r)}this.setIndex(o),this.setAttribute("position",new BA(A,3)),this.setAttribute("normal",new BA(i,3)),this.setAttribute("uv",new BA(r,2))}bl.prototype=Object.create(WA.prototype),bl.prototype.constructor=bl;class ql extends WA{constructor(e=.5,t=1,n=8,o=1,A=0,i=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:o,thetaStart:A,thetaLength:i},n=Math.max(3,n);const r=[],s=[],a=[],l=[];let m=e;const p=(t-e)/(o=Math.max(1,o)),h=new Zn,u=new Nn;for(let e=0;e<=o;e++){for(let e=0;e<=n;e++){const o=A+e/n*i;h.x=m*Math.cos(o),h.y=m*Math.sin(o),s.push(h.x,h.y,h.z),a.push(0,0,1),u.x=(h.x/t+1)/2,u.y=(h.y/t+1)/2,l.push(u.x,u.y)}m+=p}for(let e=0;e<o;e++){const t=e*(n+1);for(let e=0;e<n;e++){const o=e+t,A=o,i=o+n+1,s=o+n+2,a=o+1;r.push(A,i,a),r.push(i,s,a)}}this.setIndex(r),this.setAttribute("position",new BA(s,3)),this.setAttribute("normal",new BA(a,3)),this.setAttribute("uv",new BA(l,2))}}class xl extends WA{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],o=[],A=[],i=[];let r=0,s=0;if(!1===Array.isArray(e))a(e);else for(let t=0;t<e.length;t++)a(e[t]),this.addGroup(r,s,t),r+=s,s=0;function a(e){const r=o.length/3,a=e.extractPoints(t);let l=a.shape;const m=a.holes;!1===Fl.isClockWise(l)&&(l=l.reverse());for(let e=0,t=m.length;e<t;e++){const t=m[e];!0===Fl.isClockWise(t)&&(m[e]=t.reverse())}const p=Fl.triangulateShape(l,m);for(let e=0,t=m.length;e<t;e++){const t=m[e];l=l.concat(t)}for(let e=0,t=l.length;e<t;e++){const t=l[e];o.push(t.x,t.y,0),A.push(0,0,1),i.push(t.x,t.y)}for(let e=0,t=p.length;e<t;e++){const t=p[e],o=t[0]+r,A=t[1]+r,i=t[2]+r;n.push(o,A,i),s+=3}}this.setIndex(n),this.setAttribute("position",new BA(o,3)),this.setAttribute("normal",new BA(A,3)),this.setAttribute("uv",new BA(i,2))}toJSON(){const e=WA.prototype.toJSON.call(this);return function(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,o=e.length;n<o;n++){const o=e[n];t.shapes.push(o.uuid)}else t.shapes.push(e.uuid);return t}(this.parameters.shapes,e)}}class Bl extends WA{constructor(e=1,t=8,n=6,o=0,A=2*Math.PI,i=0,r=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:o,phiLength:A,thetaStart:i,thetaLength:r},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const s=Math.min(i+r,Math.PI);let a=0;const l=[],m=new Zn,p=new Zn,h=[],u=[],c=[],d=[];for(let h=0;h<=n;h++){const I=[],G=h/n;let E=0;0==h&&0==i?E=.5/t:h==n&&s==Math.PI&&(E=-.5/t);for(let n=0;n<=t;n++){const s=n/t;m.x=-e*Math.cos(o+s*A)*Math.sin(i+G*r),m.y=e*Math.cos(i+G*r),m.z=e*Math.sin(o+s*A)*Math.sin(i+G*r),u.push(m.x,m.y,m.z),p.copy(m).normalize(),c.push(p.x,p.y,p.z),d.push(s+E,1-G),I.push(a++)}l.push(I)}for(let e=0;e<n;e++)for(let o=0;o<t;o++){const t=l[e][o+1],A=l[e][o],r=l[e+1][o],a=l[e+1][o+1];(0!==e||i>0)&&h.push(t,A,a),(e!==n-1||s<Math.PI)&&h.push(A,r,a)}this.setIndex(h),this.setAttribute("position",new BA(u,3)),this.setAttribute("normal",new BA(c,3)),this.setAttribute("uv",new BA(d,2))}}class wl extends Wa{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class Ml extends Jl{constructor(e,t={}){const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new WA;const o=n.generateShapes(e,t.size);t.depth=void 0!==t.height?t.height:50,void 0===t.bevelThickness&&(t.bevelThickness=10),void 0===t.bevelSize&&(t.bevelSize=8),void 0===t.bevelEnabled&&(t.bevelEnabled=!1),super(o,t),this.type="TextGeometry"}}class Ll extends WA{constructor(e=1,t=.4,n=8,o=6,A=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:o,arc:A},n=Math.floor(n),o=Math.floor(o);const i=[],r=[],s=[],a=[],l=new Zn,m=new Zn,p=new Zn;for(let i=0;i<=n;i++)for(let h=0;h<=o;h++){const u=h/o*A,c=i/n*Math.PI*2;m.x=(e+t*Math.cos(c))*Math.cos(u),m.y=(e+t*Math.cos(c))*Math.sin(u),m.z=t*Math.sin(c),r.push(m.x,m.y,m.z),l.x=e*Math.cos(u),l.y=e*Math.sin(u),p.subVectors(m,l).normalize(),s.push(p.x,p.y,p.z),a.push(h/o),a.push(i/n)}for(let e=1;e<=n;e++)for(let t=1;t<=o;t++){const n=(o+1)*e+t-1,A=(o+1)*(e-1)+t-1,r=(o+1)*(e-1)+t,s=(o+1)*e+t;i.push(n,A,s),i.push(A,r,s)}this.setIndex(i),this.setAttribute("position",new BA(r,3)),this.setAttribute("normal",new BA(s,3)),this.setAttribute("uv",new BA(a,2))}}class Sl extends WA{constructor(e=1,t=.4,n=64,o=8,A=2,i=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:o,p:A,q:i},n=Math.floor(n),o=Math.floor(o);const r=[],s=[],a=[],l=[],m=new Zn,p=new Zn,h=new Zn,u=new Zn,c=new Zn,d=new Zn,I=new Zn;for(let r=0;r<=n;++r){const E=r/n*A*Math.PI*2;G(E,A,i,e,h),G(E+.01,A,i,e,u),d.subVectors(u,h),I.addVectors(u,h),c.crossVectors(d,I),I.crossVectors(c,d),c.normalize(),I.normalize();for(let e=0;e<=o;++e){const A=e/o*Math.PI*2,i=-t*Math.cos(A),u=t*Math.sin(A);m.x=h.x+(i*I.x+u*c.x),m.y=h.y+(i*I.y+u*c.y),m.z=h.z+(i*I.z+u*c.z),s.push(m.x,m.y,m.z),p.subVectors(m,h).normalize(),a.push(p.x,p.y,p.z),l.push(r/n),l.push(e/o)}}for(let e=1;e<=n;e++)for(let t=1;t<=o;t++){const n=(o+1)*(e-1)+(t-1),A=(o+1)*e+(t-1),i=(o+1)*e+t,s=(o+1)*(e-1)+t;r.push(n,A,s),r.push(A,i,s)}function G(e,t,n,o,A){const i=Math.cos(e),r=Math.sin(e),s=n/t*e,a=Math.cos(s);A.x=o*(2+a)*.5*i,A.y=o*(2+a)*r*.5,A.z=o*Math.sin(s)*.5}this.setIndex(r),this.setAttribute("position",new BA(s,3)),this.setAttribute("normal",new BA(a,3)),this.setAttribute("uv",new BA(l,2))}}class Tl extends WA{constructor(e,t=64,n=1,o=8,A=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:o,closed:A};const i=e.computeFrenetFrames(t,A);this.tangents=i.tangents,this.normals=i.normals,this.binormals=i.binormals;const r=new Zn,s=new Zn,a=new Nn;let l=new Zn;const m=[],p=[],h=[],u=[];function c(A){l=e.getPointAt(A/t,l);const a=i.normals[A],h=i.binormals[A];for(let e=0;e<=o;e++){const t=e/o*Math.PI*2,A=Math.sin(t),i=-Math.cos(t);s.x=i*a.x+A*h.x,s.y=i*a.y+A*h.y,s.z=i*a.z+A*h.z,s.normalize(),p.push(s.x,s.y,s.z),r.x=l.x+n*s.x,r.y=l.y+n*s.y,r.z=l.z+n*s.z,m.push(r.x,r.y,r.z)}}!function(){for(let e=0;e<t;e++)c(e);c(!1===A?t:0),function(){for(let e=0;e<=t;e++)for(let n=0;n<=o;n++)a.x=e/t,a.y=n/o,h.push(a.x,a.y)}(),function(){for(let e=1;e<=t;e++)for(let t=1;t<=o;t++){const n=(o+1)*(e-1)+(t-1),A=(o+1)*e+(t-1),i=(o+1)*e+t,r=(o+1)*(e-1)+t;u.push(n,A,r),u.push(A,i,r)}}()}(),this.setIndex(u),this.setAttribute("position",new BA(m,3)),this.setAttribute("normal",new BA(p,3)),this.setAttribute("uv",new BA(h,2))}toJSON(){const e=WA.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class Nl extends WA{constructor(e){if(super(),this.type="WireframeGeometry",!0===e.isGeometry)return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const t=[],n=[0,0],o={},A=new Zn;if(null!==e.index){const i=e.attributes.position,r=e.index;let s=e.groups;0===s.length&&(s=[{start:0,count:r.count,materialIndex:0}]);for(let e=0,t=s.length;e<t;++e){const t=s[e],A=t.start;for(let e=A,i=A+t.count;e<i;e+=3)for(let t=0;t<3;t++){const A=r.getX(e+t),i=r.getX(e+(t+1)%3);n[0]=Math.min(A,i),n[1]=Math.max(A,i);const s=n[0]+","+n[1];void 0===o[s]&&(o[s]={index1:n[0],index2:n[1]})}}for(const e in o){const n=o[e];A.fromBufferAttribute(i,n.index1),t.push(A.x,A.y,A.z),A.fromBufferAttribute(i,n.index2),t.push(A.x,A.y,A.z)}}else{const n=e.attributes.position;for(let e=0,o=n.count/3;e<o;e++)for(let o=0;o<3;o++){const i=3*e+o;A.fromBufferAttribute(n,i),t.push(A.x,A.y,A.z);const r=3*e+(o+1)%3;A.fromBufferAttribute(n,r),t.push(A.x,A.y,A.z)}}this.setAttribute("position",new BA(t,3))}}var Rl=Object.freeze({__proto__:null,BoxGeometry:hi,BoxBufferGeometry:hi,CircleGeometry:Pa,CircleBufferGeometry:Pa,ConeGeometry:Va,ConeBufferGeometry:Va,CylinderGeometry:Ua,CylinderBufferGeometry:Ua,DodecahedronGeometry:_a,DodecahedronBufferGeometry:_a,EdgesGeometry:Ya,ExtrudeGeometry:Jl,ExtrudeBufferGeometry:Jl,IcosahedronGeometry:jl,IcosahedronBufferGeometry:jl,LatheGeometry:Kl,LatheBufferGeometry:Kl,OctahedronGeometry:yl,OctahedronBufferGeometry:yl,ParametricGeometry:bl,ParametricBufferGeometry:bl,PlaneGeometry:Ki,PlaneBufferGeometry:Ki,PolyhedronGeometry:Wa,PolyhedronBufferGeometry:Wa,RingGeometry:ql,RingBufferGeometry:ql,ShapeGeometry:xl,ShapeBufferGeometry:xl,SphereGeometry:Bl,SphereBufferGeometry:Bl,TetrahedronGeometry:wl,TetrahedronBufferGeometry:wl,TextGeometry:Ml,TextBufferGeometry:Ml,TorusGeometry:Ll,TorusBufferGeometry:Ll,TorusKnotGeometry:Sl,TorusKnotBufferGeometry:Sl,TubeGeometry:Tl,TubeBufferGeometry:Tl,WireframeGeometry:Nl});class Ol extends cA{constructor(e){super(),this.type="ShadowMaterial",this.color=new fA(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}Ol.prototype.isShadowMaterial=!0;class Pl extends Ii{constructor(e){super(e),this.type="RawShaderMaterial"}}function Ul(e){cA.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new fA(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=sn,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(e)}function Vl(e){Ul.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Nn(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=Tn.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}Pl.prototype.isRawShaderMaterial=!0,Ul.prototype=Object.create(cA.prototype),Ul.prototype.constructor=Ul,Ul.prototype.isMeshStandardMaterial=!0,Ul.prototype.copy=function(e){return cA.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this.vertexTangents=e.vertexTangents,this},Vl.prototype=Object.create(Ul.prototype),Vl.prototype.constructor=Vl,Vl.prototype.isMeshPhysicalMaterial=!0,Vl.prototype.copy=function(e){return Ul.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new fA).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this};class Wl extends cA{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new fA(16777215),this.specular=new fA(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=sn,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=X,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Wl.prototype.isMeshPhongMaterial=!0;class _l extends cA{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new fA(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=sn,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}_l.prototype.isMeshToonMaterial=!0;class zl extends cA{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=sn,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}zl.prototype.isMeshNormalMaterial=!0;class Xl extends cA{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new fA(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=X,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}Xl.prototype.isMeshLambertMaterial=!0;class Ql extends cA{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new fA(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=sn,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Ql.prototype.isMeshMatcapMaterial=!0;class Zl extends fa{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}Zl.prototype.isLineDashedMaterial=!0;var Yl=Object.freeze({__proto__:null,ShadowMaterial:Ol,SpriteMaterial:Rs,RawShaderMaterial:Pl,ShaderMaterial:Ii,PointsMaterial:qa,MeshPhysicalMaterial:Vl,MeshStandardMaterial:Ul,MeshPhongMaterial:Wl,MeshToonMaterial:_l,MeshNormalMaterial:zl,MeshLambertMaterial:Xl,MeshDepthMaterial:Hs,MeshDistanceMaterial:Fs,MeshBasicMaterial:HA,MeshMatcapMaterial:Ql,LineDashedMaterial:Zl,LineBasicMaterial:fa,Material:cA});const $l={arraySlice:function(e,t,n){return $l.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){const t=e.length,n=new Array(t);for(let e=0;e!==t;++e)n[e]=e;return n.sort((function(t,n){return e[t]-e[n]})),n},sortedArray:function(e,t,n){const o=e.length,A=new e.constructor(o);for(let i=0,r=0;r!==o;++i){const o=n[i]*t;for(let n=0;n!==t;++n)A[r++]=e[o+n]}return A},flattenJSON:function(e,t,n,o){let A=1,i=e[0];for(;void 0!==i&&void 0===i[o];)i=e[A++];if(void 0===i)return;let r=i[o];if(void 0!==r)if(Array.isArray(r))do{r=i[o],void 0!==r&&(t.push(i.time),n.push.apply(n,r)),i=e[A++]}while(void 0!==i);else if(void 0!==r.toArray)do{r=i[o],void 0!==r&&(t.push(i.time),r.toArray(n,n.length)),i=e[A++]}while(void 0!==i);else do{r=i[o],void 0!==r&&(t.push(i.time),n.push(r)),i=e[A++]}while(void 0!==i)},subclip:function(e,t,n,o,A=30){const i=e.clone();i.name=t;const r=[];for(let e=0;e<i.tracks.length;++e){const t=i.tracks[e],s=t.getValueSize(),a=[],l=[];for(let e=0;e<t.times.length;++e){const i=t.times[e]*A;if(!(i<n||i>=o)){a.push(t.times[e]);for(let n=0;n<s;++n)l.push(t.values[e*s+n])}}0!==a.length&&(t.times=$l.convertArray(a,t.times.constructor),t.values=$l.convertArray(l,t.values.constructor),r.push(t))}i.tracks=r;let s=1/0;for(let e=0;e<i.tracks.length;++e)s>i.tracks[e].times[0]&&(s=i.tracks[e].times[0]);for(let e=0;e<i.tracks.length;++e)i.tracks[e].shift(-1*s);return i.resetDuration(),i},makeClipAdditive:function(e,t=0,n=e,o=30){o<=0&&(o=30);const A=n.tracks.length,i=t/o;for(let t=0;t<A;++t){const o=n.tracks[t],A=o.ValueTypeName;if("bool"===A||"string"===A)continue;const r=e.tracks.find((function(e){return e.name===o.name&&e.ValueTypeName===A}));if(void 0===r)continue;let s=0;const a=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(s=a/3);let l=0;const m=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=m/3);const p=o.times.length-1;let h;if(i<=o.times[0]){const e=s,t=a-s;h=$l.arraySlice(o.values,e,t)}else if(i>=o.times[p]){const e=p*a+s,t=e+a-s;h=$l.arraySlice(o.values,e,t)}else{const e=o.createInterpolant(),t=s,n=a-s;e.evaluate(i),h=$l.arraySlice(e.resultBuffer,t,n)}"quaternion"===A&&(new Qn).fromArray(h).normalize().conjugate().toArray(h);const u=r.times.length;for(let e=0;e<u;++e){const t=e*m+l;if("quaternion"===A)Qn.multiplyQuaternionsFlat(r.values,t,h,0,r.values,t);else{const e=m-2*l;for(let n=0;n<e;++n)r.values[t+n]-=h[n]}}}return e.blendMode=Wt,e}};function em(e,t,n,o){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==o?o:new t.constructor(n),this.sampleValues=t,this.valueSize=n}function tm(e,t,n,o){em.call(this,e,t,n,o),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function nm(e,t,n,o){em.call(this,e,t,n,o)}function om(e,t,n,o){em.call(this,e,t,n,o)}Object.assign(em.prototype,{evaluate:function(e){const t=this.parameterPositions;let n=this._cachedIndex,o=t[n],A=t[n-1];e:{t:{let i;n:{o:if(!(e<o)){for(let i=n+2;;){if(void 0===o){if(e<A)break o;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,A)}if(n===i)break;if(A=o,o=t[++n],e<o)break t}i=t.length;break n}if(e>=A)break e;{const r=t[1];e<r&&(n=2,A=r);for(let i=n-2;;){if(void 0===A)return this._cachedIndex=0,this.beforeStart_(0,e,o);if(n===i)break;if(o=A,A=t[--n-1],e>=A)break t}i=n,n=0}}for(;n<i;){const o=n+i>>>1;e<t[o]?i=o:n=o+1}if(o=t[n],A=t[n-1],void 0===A)return this._cachedIndex=0,this.beforeStart_(0,e,o);if(void 0===o)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,A,e)}this._cachedIndex=n,this.intervalChanged_(n,A,o)}return this.interpolate_(n,A,e,o)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,o=this.valueSize,A=e*o;for(let e=0;e!==o;++e)t[e]=n[A+e];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(em.prototype,{beforeStart_:em.prototype.copySampleValue_,afterEnd_:em.prototype.copySampleValue_}),tm.prototype=Object.assign(Object.create(em.prototype),{constructor:tm,DefaultSettings_:{endingStart:Ot,endingEnd:Ot},intervalChanged_:function(e,t,n){const o=this.parameterPositions;let A=e-2,i=e+1,r=o[A],s=o[i];if(void 0===r)switch(this.getSettings_().endingStart){case Pt:A=e,r=2*t-n;break;case Ut:A=o.length-2,r=t+o[A]-o[A+1];break;default:A=e,r=n}if(void 0===s)switch(this.getSettings_().endingEnd){case Pt:i=e,s=2*n-t;break;case Ut:i=1,s=n+o[1]-o[0];break;default:i=e-1,s=t}const a=.5*(n-t),l=this.valueSize;this._weightPrev=a/(t-r),this._weightNext=a/(s-n),this._offsetPrev=A*l,this._offsetNext=i*l},interpolate_:function(e,t,n,o){const A=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r,a=s-r,l=this._offsetPrev,m=this._offsetNext,p=this._weightPrev,h=this._weightNext,u=(n-t)/(o-t),c=u*u,d=c*u,I=-p*d+2*p*c-p*u,G=(1+p)*d+(-1.5-2*p)*c+(-.5+p)*u+1,E=(-1-h)*d+(1.5+h)*c+.5*u,k=h*d-h*c;for(let e=0;e!==r;++e)A[e]=I*i[l+e]+G*i[a+e]+E*i[s+e]+k*i[m+e];return A}}),nm.prototype=Object.assign(Object.create(em.prototype),{constructor:nm,interpolate_:function(e,t,n,o){const A=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r,a=s-r,l=(n-t)/(o-t),m=1-l;for(let e=0;e!==r;++e)A[e]=i[a+e]*m+i[s+e]*l;return A}}),om.prototype=Object.assign(Object.create(em.prototype),{constructor:om,interpolate_:function(e){return this.copySampleValue_(e-1)}});class Am{constructor(e,t,n,o){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=$l.convertArray(t,this.TimeBufferType),this.values=$l.convertArray(n,this.ValueBufferType),this.setInterpolation(o||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:$l.convertArray(e.times,Array),values:$l.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new om(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new nm(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new tm(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Tt:t=this.InterpolantFactoryMethodDiscrete;break;case Nt:t=this.InterpolantFactoryMethodLinear;break;case Rt:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Tt;case this.InterpolantFactoryMethodLinear:return Nt;case this.InterpolantFactoryMethodSmooth:return Rt}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let n=0,o=t.length;n!==o;++n)t[n]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let n=0,o=t.length;n!==o;++n)t[n]*=e}return this}trim(e,t){const n=this.times,o=n.length;let A=0,i=o-1;for(;A!==o&&n[A]<e;)++A;for(;-1!==i&&n[i]>t;)--i;if(++i,0!==A||i!==o){A>=i&&(i=Math.max(i,1),A=i-1);const e=this.getValueSize();this.times=$l.arraySlice(n,A,i),this.values=$l.arraySlice(this.values,A*e,i*e)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,o=this.values,A=n.length;0===A&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let i=null;for(let t=0;t!==A;t++){const o=n[t];if("number"==typeof o&&isNaN(o)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,o),e=!1;break}if(null!==i&&i>o){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,o,i),e=!1;break}i=o}if(void 0!==o&&$l.isTypedArray(o))for(let t=0,n=o.length;t!==n;++t){const n=o[t];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,n),e=!1;break}}return e}optimize(){const e=$l.arraySlice(this.times),t=$l.arraySlice(this.values),n=this.getValueSize(),o=this.getInterpolation()===Rt,A=e.length-1;let i=1;for(let r=1;r<A;++r){let A=!1;const s=e[r];if(s!==e[r+1]&&(1!==r||s!==e[0]))if(o)A=!0;else{const e=r*n,o=e-n,i=e+n;for(let r=0;r!==n;++r){const n=t[e+r];if(n!==t[o+r]||n!==t[i+r]){A=!0;break}}}if(A){if(r!==i){e[i]=e[r];const o=r*n,A=i*n;for(let e=0;e!==n;++e)t[A+e]=t[o+e]}++i}}if(A>0){e[i]=e[A];for(let e=A*n,o=i*n,r=0;r!==n;++r)t[o+r]=t[e+r];++i}return i!==e.length?(this.times=$l.arraySlice(e,0,i),this.values=$l.arraySlice(t,0,i*n)):(this.times=e,this.values=t),this}clone(){const e=$l.arraySlice(this.times,0),t=$l.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}Am.prototype.TimeBufferType=Float32Array,Am.prototype.ValueBufferType=Float32Array,Am.prototype.DefaultInterpolation=Nt;class im extends Am{}im.prototype.ValueTypeName="bool",im.prototype.ValueBufferType=Array,im.prototype.DefaultInterpolation=Tt,im.prototype.InterpolantFactoryMethodLinear=void 0,im.prototype.InterpolantFactoryMethodSmooth=void 0;class rm extends Am{}rm.prototype.ValueTypeName="color";class sm extends Am{}function am(e,t,n,o){em.call(this,e,t,n,o)}sm.prototype.ValueTypeName="number",am.prototype=Object.assign(Object.create(em.prototype),{constructor:am,interpolate_:function(e,t,n,o){const A=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=(n-t)/(o-t);let a=e*r;for(let e=a+r;a!==e;a+=4)Qn.slerpFlat(A,0,i,a-r,i,a,s);return A}});class lm extends Am{InterpolantFactoryMethodLinear(e){return new am(this.times,this.values,this.getValueSize(),e)}}lm.prototype.ValueTypeName="quaternion",lm.prototype.DefaultInterpolation=Nt,lm.prototype.InterpolantFactoryMethodSmooth=void 0;class mm extends Am{}mm.prototype.ValueTypeName="string",mm.prototype.ValueBufferType=Array,mm.prototype.DefaultInterpolation=Tt,mm.prototype.InterpolantFactoryMethodLinear=void 0,mm.prototype.InterpolantFactoryMethodSmooth=void 0;class pm extends Am{}pm.prototype.ValueTypeName="vector";class hm{constructor(e,t=-1,n,o=Vt){this.name=e,this.tracks=n,this.duration=t,this.blendMode=o,this.uuid=Tn.generateUUID(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,o=1/(e.fps||1);for(let e=0,A=n.length;e!==A;++e)t.push(um(n[e]).scale(o));const A=new this(e.name,e.duration,t,e.blendMode);return A.uuid=e.uuid,A}static toJSON(e){const t=[],n=e.tracks,o={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let e=0,o=n.length;e!==o;++e)t.push(Am.toJSON(n[e]));return o}static CreateFromMorphTargetSequence(e,t,n,o){const A=t.length,i=[];for(let e=0;e<A;e++){let r=[],s=[];r.push((e+A-1)%A,e,(e+1)%A),s.push(0,1,0);const a=$l.getKeyframeOrder(r);r=$l.sortedArray(r,1,a),s=$l.sortedArray(s,1,a),o||0!==r[0]||(r.push(A),s.push(s[0])),i.push(new sm(".morphTargetInfluences["+t[e].name+"]",r,s).scale(1/n))}return new this(e,-1,i)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let e=0;e<n.length;e++)if(n[e].name===t)return n[e];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const o={},A=/^([\w-]*?)([\d]+)$/;for(let t=0,n=e.length;t<n;t++){const n=e[t],i=n.name.match(A);if(i&&i.length>1){const e=i[1];let t=o[e];t||(o[e]=t=[]),t.push(n)}}const i=[];for(const e in o)i.push(this.CreateFromMorphTargetSequence(e,o[e],t,n));return i}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(e,t,n,o,A){if(0!==n.length){const i=[],r=[];$l.flattenJSON(n,i,r,o),0!==i.length&&A.push(new e(t,i,r))}},o=[],A=e.name||"default",i=e.fps||30,r=e.blendMode;let s=e.length||-1;const a=e.hierarchy||[];for(let e=0;e<a.length;e++){const A=a[e].keys;if(A&&0!==A.length)if(A[0].morphTargets){const e={};let t;for(t=0;t<A.length;t++)if(A[t].morphTargets)for(let n=0;n<A[t].morphTargets.length;n++)e[A[t].morphTargets[n]]=-1;for(const n in e){const e=[],i=[];for(let o=0;o!==A[t].morphTargets.length;++o){const o=A[t];e.push(o.time),i.push(o.morphTarget===n?1:0)}o.push(new sm(".morphTargetInfluence["+n+"]",e,i))}s=e.length*(i||1)}else{const i=".bones["+t[e].name+"]";n(pm,i+".position",A,"pos",o),n(lm,i+".quaternion",A,"rot",o),n(pm,i+".scale",A,"scl",o)}}return 0===o.length?null:new this(A,s,o,r)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const n=this.tracks[t];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function um(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return sm;case"vector":case"vector2":case"vector3":case"vector4":return pm;case"color":return rm;case"quaternion":return lm;case"bool":case"boolean":return im;case"string":return mm}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){const t=[],n=[];$l.flattenJSON(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}const cm={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function dm(e,t,n){const o=this;let A,i=!1,r=0,s=0;const a=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){s++,!1===i&&void 0!==o.onStart&&o.onStart(e,r,s),i=!0},this.itemEnd=function(e){r++,void 0!==o.onProgress&&o.onProgress(e,r,s),r===s&&(i=!1,void 0!==o.onLoad&&o.onLoad())},this.itemError=function(e){void 0!==o.onError&&o.onError(e)},this.resolveURL=function(e){return A?A(e):e},this.setURLModifier=function(e){return A=e,this},this.addHandler=function(e,t){return a.push(e,t),this},this.removeHandler=function(e){const t=a.indexOf(e);return-1!==t&&a.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=a.length;t<n;t+=2){const n=a[t],o=a[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return o}return null}}const Im=new dm;function Gm(e){this.manager=void 0!==e?e:Im,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Gm.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise((function(o,A){n.load(e,o,t,A)}))},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const Em={};function km(e){Gm.call(this,e)}km.prototype=Object.assign(Object.create(Gm.prototype),{constructor:km,load:function(e,t,n,o){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const A=this,i=cm.get(e);if(void 0!==i)return A.manager.itemStart(e),setTimeout((function(){t&&t(i),A.manager.itemEnd(e)}),0),i;if(void 0!==Em[e])return void Em[e].push({onLoad:t,onProgress:n,onError:o});const r=e.match(/^data:(.*?)(;base64)?,(.*)$/);let s;if(r){const n=r[1],i=!!r[2];let s=r[3];s=decodeURIComponent(s),i&&(s=atob(s));try{let o;const i=(this.responseType||"").toLowerCase();switch(i){case"arraybuffer":case"blob":const e=new Uint8Array(s.length);for(let t=0;t<s.length;t++)e[t]=s.charCodeAt(t);o="blob"===i?new Blob([e.buffer],{type:n}):e.buffer;break;case"document":const t=new DOMParser;o=t.parseFromString(s,n);break;case"json":o=JSON.parse(s);break;default:o=s}setTimeout((function(){t&&t(o),A.manager.itemEnd(e)}),0)}catch(t){setTimeout((function(){o&&o(t),A.manager.itemError(e),A.manager.itemEnd(e)}),0)}}else{Em[e]=[],Em[e].push({onLoad:t,onProgress:n,onError:o}),s=new XMLHttpRequest,s.open("GET",e,!0),s.addEventListener("load",(function(t){const n=this.response,o=Em[e];if(delete Em[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),cm.add(e,n);for(let e=0,t=o.length;e<t;e++){const t=o[e];t.onLoad&&t.onLoad(n)}A.manager.itemEnd(e)}else{for(let e=0,n=o.length;e<n;e++){const n=o[e];n.onError&&n.onError(t)}A.manager.itemError(e),A.manager.itemEnd(e)}}),!1),s.addEventListener("progress",(function(t){const n=Em[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onProgress&&o.onProgress(t)}}),!1),s.addEventListener("error",(function(t){const n=Em[e];delete Em[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onError&&o.onError(t)}A.manager.itemError(e),A.manager.itemEnd(e)}),!1),s.addEventListener("abort",(function(t){const n=Em[e];delete Em[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onError&&o.onError(t)}A.manager.itemError(e),A.manager.itemEnd(e)}),!1),void 0!==this.responseType&&(s.responseType=this.responseType),void 0!==this.withCredentials&&(s.withCredentials=this.withCredentials),s.overrideMimeType&&s.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const e in this.requestHeader)s.setRequestHeader(e,this.requestHeader[e]);s.send(null)}return A.manager.itemStart(e),s},setResponseType:function(e){return this.responseType=e,this},setMimeType:function(e){return this.mimeType=e,this}});class gm extends Gm{constructor(e){super(e)}load(e,t,n,o){const A=this,i=new km(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,(function(n){try{t(A.parse(JSON.parse(n)))}catch(t){o?o(t):console.error(t),A.manager.itemError(e)}}),n,o)}parse(e){const t=[];for(let n=0;n<e.length;n++){const o=hm.parse(e[n]);t.push(o)}return t}}function fm(e){Gm.call(this,e)}fm.prototype=Object.assign(Object.create(Gm.prototype),{constructor:fm,load:function(e,t,n,o){const A=this,i=[],r=new Na,s=new km(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(A.withCredentials);let a=0;function l(l){s.load(e[l],(function(e){const n=A.parse(e,!0);i[l]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},a+=1,6===a&&(1===n.mipmapCount&&(r.minFilter=ke),r.image=i,r.format=n.format,r.needsUpdate=!0,t&&t(r))}),n,o)}if(Array.isArray(e))for(let t=0,n=e.length;t<n;++t)l(t);else s.load(e,(function(e){const n=A.parse(e,!0);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){i[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++)i[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]),i[t].format=n.format,i[t].width=n.width,i[t].height=n.height}r.image=i}else r.image.width=n.width,r.image.height=n.height,r.mipmaps=n.mipmaps;1===n.mipmapCount&&(r.minFilter=ke),r.format=n.format,r.needsUpdate=!0,t&&t(r)}),n,o);return r}});class Hm extends Gm{constructor(e){super(e)}load(e,t,n,o){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const A=this,i=cm.get(e);if(void 0!==i)return A.manager.itemStart(e),setTimeout((function(){t&&t(i),A.manager.itemEnd(e)}),0),i;const r=document.createElementNS("http://www.w3.org/1999/xhtml","img");function s(){r.removeEventListener("load",s,!1),r.removeEventListener("error",a,!1),cm.add(e,this),t&&t(this),A.manager.itemEnd(e)}function a(t){r.removeEventListener("load",s,!1),r.removeEventListener("error",a,!1),o&&o(t),A.manager.itemError(e),A.manager.itemEnd(e)}return r.addEventListener("load",s,!1),r.addEventListener("error",a,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(r.crossOrigin=this.crossOrigin),A.manager.itemStart(e),r.src=e,r}}class Fm extends Gm{constructor(e){super(e)}load(e,t,n,o){const A=new fi,i=new Hm(this.manager);i.setCrossOrigin(this.crossOrigin),i.setPath(this.path);let r=0;function s(n){i.load(e[n],(function(e){A.images[n]=e,r++,6===r&&(A.needsUpdate=!0,t&&t(A))}),void 0,o)}for(let t=0;t<e.length;++t)s(t);return A}}function Cm(e){Gm.call(this,e)}function Dm(e){Gm.call(this,e)}function Jm(){this.type="Curve",this.arcLengthDivisions=200}Cm.prototype=Object.assign(Object.create(Gm.prototype),{constructor:Cm,load:function(e,t,n,o){const A=this,i=new Fi,r=new km(this.manager);return r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setPath(this.path),r.setWithCredentials(A.withCredentials),r.load(e,(function(e){const n=A.parse(e);n&&(void 0!==n.image?i.image=n.image:void 0!==n.data&&(i.image.width=n.width,i.image.height=n.height,i.image.data=n.data),i.wrapS=void 0!==n.wrapS?n.wrapS:he,i.wrapT=void 0!==n.wrapT?n.wrapT:he,i.magFilter=void 0!==n.magFilter?n.magFilter:ke,i.minFilter=void 0!==n.minFilter?n.minFilter:ke,i.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(i.encoding=n.encoding),void 0!==n.flipY&&(i.flipY=n.flipY),void 0!==n.format&&(i.format=n.format),void 0!==n.type&&(i.type=n.type),void 0!==n.mipmaps&&(i.mipmaps=n.mipmaps,i.minFilter=He),1===n.mipmapCount&&(i.minFilter=ke),i.needsUpdate=!0,t&&t(i,n))}),n,o),i}}),Dm.prototype=Object.assign(Object.create(Gm.prototype),{constructor:Dm,load:function(e,t,n,o){const A=new Vn,i=new Hm(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(e,(function(n){A.image=n;const o=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);A.format=o?Le:Se,A.needsUpdate=!0,void 0!==t&&t(A)}),n,o),A}}),Object.assign(Jm.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(void 0===e&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,o=this.getPoint(0),A=0;t.push(0);for(let i=1;i<=e;i++)n=this.getPoint(i/e),A+=n.distanceTo(o),t.push(A),o=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let o=0;const A=n.length;let i;i=t||e*n[A-1];let r,s=0,a=A-1;for(;s<=a;)if(o=Math.floor(s+(a-s)/2),r=n[o]-i,r<0)s=o+1;else{if(!(r>0)){a=o;break}a=o-1}if(o=a,n[o]===i)return o/(A-1);const l=n[o];return(o+(i-l)/(n[o+1]-l))/(A-1)},getTangent:function(e,t){const n=1e-4;let o=e-n,A=e+n;o<0&&(o=0),A>1&&(A=1);const i=this.getPoint(o),r=this.getPoint(A),s=t||(i.isVector2?new Nn:new Zn);return s.copy(r).sub(i).normalize(),s},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new Zn,o=[],A=[],i=[],r=new Zn,s=new Jo;for(let t=0;t<=e;t++){const n=t/e;o[t]=this.getTangentAt(n,new Zn),o[t].normalize()}A[0]=new Zn,i[0]=new Zn;let a=Number.MAX_VALUE;const l=Math.abs(o[0].x),m=Math.abs(o[0].y),p=Math.abs(o[0].z);l<=a&&(a=l,n.set(1,0,0)),m<=a&&(a=m,n.set(0,1,0)),p<=a&&n.set(0,0,1),r.crossVectors(o[0],n).normalize(),A[0].crossVectors(o[0],r),i[0].crossVectors(o[0],A[0]);for(let t=1;t<=e;t++){if(A[t]=A[t-1].clone(),i[t]=i[t-1].clone(),r.crossVectors(o[t-1],o[t]),r.length()>Number.EPSILON){r.normalize();const e=Math.acos(Tn.clamp(o[t-1].dot(o[t]),-1,1));A[t].applyMatrix4(s.makeRotationAxis(r,e))}i[t].crossVectors(o[t],A[t])}if(!0===t){let t=Math.acos(Tn.clamp(A[0].dot(A[e]),-1,1));t/=e,o[0].dot(r.crossVectors(A[0],A[e]))>0&&(t=-t);for(let n=1;n<=e;n++)A[n].applyMatrix4(s.makeRotationAxis(o[n],t*n)),i[n].crossVectors(o[n],A[n])}return{tangents:o,normals:A,binormals:i}},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}});class vm extends Jm{constructor(e=0,t=0,n=1,o=1,A=0,i=2*Math.PI,r=!1,s=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=o,this.aStartAngle=A,this.aEndAngle=i,this.aClockwise=r,this.aRotation=s}getPoint(e,t){const n=t||new Nn,o=2*Math.PI;let A=this.aEndAngle-this.aStartAngle;const i=Math.abs(A)<Number.EPSILON;for(;A<0;)A+=o;for(;A>o;)A-=o;A<Number.EPSILON&&(A=i?0:o),!0!==this.aClockwise||i||(A===o?A=-o:A-=o);const r=this.aStartAngle+e*A;let s=this.aX+this.xRadius*Math.cos(r),a=this.aY+this.yRadius*Math.sin(r);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=s-this.aX,o=a-this.aY;s=n*e-o*t+this.aX,a=n*t+o*e+this.aY}return n.set(s,a)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}vm.prototype.isEllipseCurve=!0;class jm extends vm{constructor(e,t,n,o,A,i){super(e,t,n,n,o,A,i),this.type="ArcCurve"}}function Km(){let e=0,t=0,n=0,o=0;function A(A,i,r,s){e=A,t=r,n=-3*A+3*i-2*r-s,o=2*A-2*i+r+s}return{initCatmullRom:function(e,t,n,o,i){A(t,n,i*(n-e),i*(o-t))},initNonuniformCatmullRom:function(e,t,n,o,i,r,s){let a=(t-e)/i-(n-e)/(i+r)+(n-t)/r,l=(n-t)/r-(o-t)/(r+s)+(o-n)/s;a*=r,l*=r,A(t,n,a,l)},calc:function(A){const i=A*A;return e+t*A+n*i+o*(i*A)}}}jm.prototype.isArcCurve=!0;const ym=new Zn,bm=new Km,qm=new Km,xm=new Km;class Bm extends Jm{constructor(e=[],t=!1,n="centripetal",o=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=o}getPoint(e,t=new Zn){const n=t,o=this.points,A=o.length,i=(A-(this.closed?0:1))*e;let r,s,a=Math.floor(i),l=i-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/A)+1)*A:0===l&&a===A-1&&(a=A-2,l=1),this.closed||a>0?r=o[(a-1)%A]:(ym.subVectors(o[0],o[1]).add(o[0]),r=ym);const m=o[a%A],p=o[(a+1)%A];if(this.closed||a+2<A?s=o[(a+2)%A]:(ym.subVectors(o[A-1],o[A-2]).add(o[A-1]),s=ym),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(r.distanceToSquared(m),e),n=Math.pow(m.distanceToSquared(p),e),o=Math.pow(p.distanceToSquared(s),e);n<1e-4&&(n=1),t<1e-4&&(t=n),o<1e-4&&(o=n),bm.initNonuniformCatmullRom(r.x,m.x,p.x,s.x,t,n,o),qm.initNonuniformCatmullRom(r.y,m.y,p.y,s.y,t,n,o),xm.initNonuniformCatmullRom(r.z,m.z,p.z,s.z,t,n,o)}else"catmullrom"===this.curveType&&(bm.initCatmullRom(r.x,m.x,p.x,s.x,this.tension),qm.initCatmullRom(r.y,m.y,p.y,s.y,this.tension),xm.initCatmullRom(r.z,m.z,p.z,s.z,this.tension));return n.set(bm.calc(l),qm.calc(l),xm.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Zn).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function wm(e,t,n,o,A){const i=.5*(o-t),r=.5*(A-n),s=e*e;return(2*n-2*o+i+r)*(e*s)+(-3*n+3*o-2*i-r)*s+i*e+n}function Mm(e,t,n,o){return function(e,t){const n=1-e;return n*n*t}(e,t)+function(e,t){return 2*(1-e)*e*t}(e,n)+function(e,t){return e*e*t}(e,o)}function Lm(e,t,n,o,A){return function(e,t){const n=1-e;return n*n*n*t}(e,t)+function(e,t){const n=1-e;return 3*n*n*e*t}(e,n)+function(e,t){return 3*(1-e)*e*e*t}(e,o)+function(e,t){return e*e*e*t}(e,A)}Bm.prototype.isCatmullRomCurve3=!0;class Sm extends Jm{constructor(e=new Nn,t=new Nn,n=new Nn,o=new Nn){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=o}getPoint(e,t=new Nn){const n=t,o=this.v0,A=this.v1,i=this.v2,r=this.v3;return n.set(Lm(e,o.x,A.x,i.x,r.x),Lm(e,o.y,A.y,i.y,r.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Sm.prototype.isCubicBezierCurve=!0;class Tm extends Jm{constructor(e=new Zn,t=new Zn,n=new Zn,o=new Zn){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=o}getPoint(e,t=new Zn){const n=t,o=this.v0,A=this.v1,i=this.v2,r=this.v3;return n.set(Lm(e,o.x,A.x,i.x,r.x),Lm(e,o.y,A.y,i.y,r.y),Lm(e,o.z,A.z,i.z,r.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Tm.prototype.isCubicBezierCurve3=!0;class Nm extends Jm{constructor(e=new Nn,t=new Nn){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Nn){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new Nn;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Nm.prototype.isLineCurve=!0;class Rm extends Jm{constructor(e=new Zn,t=new Zn){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new Zn){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Om extends Jm{constructor(e=new Nn,t=new Nn,n=new Nn){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Nn){const n=t,o=this.v0,A=this.v1,i=this.v2;return n.set(Mm(e,o.x,A.x,i.x),Mm(e,o.y,A.y,i.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Om.prototype.isQuadraticBezierCurve=!0;class Pm extends Jm{constructor(e=new Zn,t=new Zn,n=new Zn){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Zn){const n=t,o=this.v0,A=this.v1,i=this.v2;return n.set(Mm(e,o.x,A.x,i.x),Mm(e,o.y,A.y,i.y),Mm(e,o.z,A.z,i.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Pm.prototype.isQuadraticBezierCurve3=!0;class Um extends Jm{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new Nn){const n=t,o=this.points,A=(o.length-1)*e,i=Math.floor(A),r=A-i,s=o[0===i?i:i-1],a=o[i],l=o[i>o.length-2?o.length-1:i+1],m=o[i>o.length-3?o.length-1:i+2];return n.set(wm(r,s.x,a.x,l.x,m.x),wm(r,s.y,a.y,l.y,m.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Nn).fromArray(n))}return this}}Um.prototype.isSplineCurve=!0;var Vm=Object.freeze({__proto__:null,ArcCurve:jm,CatmullRomCurve3:Bm,CubicBezierCurve:Sm,CubicBezierCurve3:Tm,EllipseCurve:vm,LineCurve:Nm,LineCurve3:Rm,QuadraticBezierCurve:Om,QuadraticBezierCurve3:Pm,SplineCurve:Um});class Wm extends Jm{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Nm(t,e))}getPoint(e){const t=e*this.getLength(),n=this.getCurveLengths();let o=0;for(;o<n.length;){if(n[o]>=t){const e=n[o]-t,A=this.curves[o],i=A.getLength(),r=0===i?0:1-e/i;return A.getPointAt(r)}o++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,o=this.curves.length;n<o;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let o=0,A=this.curves;o<A.length;o++){const i=A[o],r=i&&i.isEllipseCurve?2*e:i&&(i.isLineCurve||i.isLineCurve3)?1:i&&i.isSplineCurve?e*i.points.length:e,s=i.getPoints(r);for(let e=0;e<s.length;e++){const o=s[e];n&&n.equals(o)||(t.push(o),n=o)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new Vm[n.type]).fromJSON(n))}return this}}class _m extends Wm{constructor(e){super(),this.type="Path",this.currentPoint=new Nn,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new Nm(this.currentPoint.clone(),new Nn(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,o){const A=new Om(this.currentPoint.clone(),new Nn(e,t),new Nn(n,o));return this.curves.push(A),this.currentPoint.set(n,o),this}bezierCurveTo(e,t,n,o,A,i){const r=new Sm(this.currentPoint.clone(),new Nn(e,t),new Nn(n,o),new Nn(A,i));return this.curves.push(r),this.currentPoint.set(A,i),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new Um(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,o,A,i){const r=this.currentPoint.x,s=this.currentPoint.y;return this.absarc(e+r,t+s,n,o,A,i),this}absarc(e,t,n,o,A,i){return this.absellipse(e,t,n,n,o,A,i),this}ellipse(e,t,n,o,A,i,r,s){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absellipse(e+a,t+l,n,o,A,i,r,s),this}absellipse(e,t,n,o,A,i,r,s){const a=new vm(e,t,n,o,A,i,r,s);if(this.curves.length>0){const e=a.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(a);const l=a.getPoint(1);return this.currentPoint.copy(l),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class zm extends _m{constructor(e){super(e),this.uuid=Tn.generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,o=this.holes.length;n<o;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new _m).fromJSON(n))}return this}}class Xm extends Zo{constructor(e,t=1){super(),this.type="Light",this.color=new fA(e),this.intensity=t}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}Xm.prototype.isLight=!0;class Qm extends Xm{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(Zo.DefaultUp),this.updateMatrix(),this.groundColor=new fA(t)}copy(e){return Xm.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}Qm.prototype.isHemisphereLight=!0;const Zm=new Jo,Ym=new Zn,$m=new Zn;class ep{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new Nn(512,512),this.map=null,this.mapPass=null,this.matrix=new Jo,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ji,this._frameExtents=new Nn(1,1),this._viewportCount=1,this._viewports=[new _n(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;Ym.setFromMatrixPosition(e.matrixWorld),t.position.copy(Ym),$m.setFromMatrixPosition(e.target.matrixWorld),t.lookAt($m),t.updateMatrixWorld(),Zm.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Zm),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class tp extends ep{constructor(){super(new Ei(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,n=2*Tn.RAD2DEG*e.angle*this.focus,o=this.mapSize.width/this.mapSize.height,A=e.distance||t.far;n===t.fov&&o===t.aspect&&A===t.far||(t.fov=n,t.aspect=o,t.far=A,t.updateProjectionMatrix()),super.updateMatrices(e)}}tp.prototype.isSpotLightShadow=!0;class np extends Xm{constructor(e,t,n=0,o=Math.PI/3,A=0,i=1){super(e,t),this.type="SpotLight",this.position.copy(Zo.DefaultUp),this.updateMatrix(),this.target=new Zo,this.distance=n,this.angle=o,this.penumbra=A,this.decay=i,this.shadow=new tp}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}np.prototype.isSpotLight=!0;const op=new Jo,Ap=new Zn,ip=new Zn;class rp extends ep{constructor(){super(new Ei(90,1,.5,500)),this._frameExtents=new Nn(4,2),this._viewportCount=6,this._viewports=[new _n(2,1,1,1),new _n(0,1,1,1),new _n(3,1,1,1),new _n(1,1,1,1),new _n(3,0,1,1),new _n(1,0,1,1)],this._cubeDirections=[new Zn(1,0,0),new Zn(-1,0,0),new Zn(0,0,1),new Zn(0,0,-1),new Zn(0,1,0),new Zn(0,-1,0)],this._cubeUps=[new Zn(0,1,0),new Zn(0,1,0),new Zn(0,1,0),new Zn(0,1,0),new Zn(0,0,1),new Zn(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,o=this.matrix;Ap.setFromMatrixPosition(e.matrixWorld),n.position.copy(Ap),ip.copy(n.position),ip.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(ip),n.updateMatrixWorld(),o.makeTranslation(-Ap.x,-Ap.y,-Ap.z),op.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(op)}}rp.prototype.isPointLightShadow=!0;class sp extends Xm{constructor(e,t,n=0,o=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=o,this.shadow=new rp}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}sp.prototype.isPointLight=!0;class ap extends Gi{constructor(e=-1,t=1,n=1,o=-1,A=.1,i=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=o,this.near=A,this.far=i,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,n,o,A,i){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=o,this.view.width=A,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,o=(this.top+this.bottom)/2;let A=n-e,i=n+e,r=o+t,s=o-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;A+=e*this.view.offsetX,i=A+e*this.view.width,r-=t*this.view.offsetY,s=r-t*this.view.height}this.projectionMatrix.makeOrthographic(A,i,r,s,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=Zo.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}ap.prototype.isOrthographicCamera=!0;class lp extends ep{constructor(){super(new ap(-5,5,5,-5,.5,500))}}lp.prototype.isDirectionalLightShadow=!0;class mp extends Xm{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(Zo.DefaultUp),this.updateMatrix(),this.target=new Zo,this.shadow=new lp}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}mp.prototype.isDirectionalLight=!0;class pp extends Xm{constructor(e,t){super(e,t),this.type="AmbientLight"}}pp.prototype.isAmbientLight=!0;class hp extends Xm{constructor(e,t,n=10,o=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=o}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}hp.prototype.isRectAreaLight=!0;class up{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Zn)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,o=e.y,A=e.z,i=this.coefficients;return t.copy(i[0]).multiplyScalar(.282095),t.addScaledVector(i[1],.488603*o),t.addScaledVector(i[2],.488603*A),t.addScaledVector(i[3],.488603*n),t.addScaledVector(i[4],n*o*1.092548),t.addScaledVector(i[5],o*A*1.092548),t.addScaledVector(i[6],.315392*(3*A*A-1)),t.addScaledVector(i[7],n*A*1.092548),t.addScaledVector(i[8],.546274*(n*n-o*o)),t}getIrradianceAt(e,t){const n=e.x,o=e.y,A=e.z,i=this.coefficients;return t.copy(i[0]).multiplyScalar(.886227),t.addScaledVector(i[1],1.023328*o),t.addScaledVector(i[2],1.023328*A),t.addScaledVector(i[3],1.023328*n),t.addScaledVector(i[4],.858086*n*o),t.addScaledVector(i[5],.858086*o*A),t.addScaledVector(i[6],.743125*A*A-.247708),t.addScaledVector(i[7],.858086*n*A),t.addScaledVector(i[8],.429043*(n*n-o*o)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let o=0;o<9;o++)n[o].fromArray(e,t+3*o);return this}toArray(e=[],t=0){const n=this.coefficients;for(let o=0;o<9;o++)n[o].toArray(e,t+3*o);return e}static getBasisAt(e,t){const n=e.x,o=e.y,A=e.z;t[0]=.282095,t[1]=.488603*o,t[2]=.488603*A,t[3]=.488603*n,t[4]=1.092548*n*o,t[5]=1.092548*o*A,t[6]=.315392*(3*A*A-1),t[7]=1.092548*n*A,t[8]=.546274*(n*n-o*o)}}up.prototype.isSphericalHarmonics3=!0;class cp extends Xm{constructor(e=new up,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}cp.prototype.isLightProbe=!0;class dp extends Gm{constructor(e){super(e),this.textures={}}load(e,t,n,o){const A=this,i=new km(A.manager);i.setPath(A.path),i.setRequestHeader(A.requestHeader),i.setWithCredentials(A.withCredentials),i.load(e,(function(n){try{t(A.parse(JSON.parse(n)))}catch(t){o?o(t):console.error(t),A.manager.itemError(e)}}),n,o)}parse(e){const t=this.textures;function n(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const o=new Yl[e.type];if(void 0!==e.uuid&&(o.uuid=e.uuid),void 0!==e.name&&(o.name=e.name),void 0!==e.color&&void 0!==o.color&&o.color.setHex(e.color),void 0!==e.roughness&&(o.roughness=e.roughness),void 0!==e.metalness&&(o.metalness=e.metalness),void 0!==e.sheen&&(o.sheen=(new fA).setHex(e.sheen)),void 0!==e.emissive&&void 0!==o.emissive&&o.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==o.specular&&o.specular.setHex(e.specular),void 0!==e.shininess&&(o.shininess=e.shininess),void 0!==e.clearcoat&&(o.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(o.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(o.fog=e.fog),void 0!==e.flatShading&&(o.flatShading=e.flatShading),void 0!==e.blending&&(o.blending=e.blending),void 0!==e.combine&&(o.combine=e.combine),void 0!==e.side&&(o.side=e.side),void 0!==e.opacity&&(o.opacity=e.opacity),void 0!==e.transparent&&(o.transparent=e.transparent),void 0!==e.alphaTest&&(o.alphaTest=e.alphaTest),void 0!==e.depthTest&&(o.depthTest=e.depthTest),void 0!==e.depthWrite&&(o.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(o.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(o.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(o.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(o.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(o.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(o.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(o.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(o.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(o.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(o.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(o.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(o.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(o.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(o.rotation=e.rotation),1!==e.linewidth&&(o.linewidth=e.linewidth),void 0!==e.dashSize&&(o.dashSize=e.dashSize),void 0!==e.gapSize&&(o.gapSize=e.gapSize),void 0!==e.scale&&(o.scale=e.scale),void 0!==e.polygonOffset&&(o.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(o.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(o.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(o.skinning=e.skinning),void 0!==e.morphTargets&&(o.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(o.morphNormals=e.morphNormals),void 0!==e.dithering&&(o.dithering=e.dithering),void 0!==e.vertexTangents&&(o.vertexTangents=e.vertexTangents),void 0!==e.visible&&(o.visible=e.visible),void 0!==e.toneMapped&&(o.toneMapped=e.toneMapped),void 0!==e.userData&&(o.userData=e.userData),void 0!==e.vertexColors&&("number"==typeof e.vertexColors?o.vertexColors=e.vertexColors>0:o.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const t in e.uniforms){const A=e.uniforms[t];switch(o.uniforms[t]={},A.type){case"t":o.uniforms[t].value=n(A.value);break;case"c":o.uniforms[t].value=(new fA).setHex(A.value);break;case"v2":o.uniforms[t].value=(new Nn).fromArray(A.value);break;case"v3":o.uniforms[t].value=(new Zn).fromArray(A.value);break;case"v4":o.uniforms[t].value=(new _n).fromArray(A.value);break;case"m3":o.uniforms[t].value=(new Rn).fromArray(A.value);break;case"m4":o.uniforms[t].value=(new Jo).fromArray(A.value);break;default:o.uniforms[t].value=A.value}}if(void 0!==e.defines&&(o.defines=e.defines),void 0!==e.vertexShader&&(o.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(o.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const t in e.extensions)o.extensions[t]=e.extensions[t];if(void 0!==e.shading&&(o.flatShading=1===e.shading),void 0!==e.size&&(o.size=e.size),void 0!==e.sizeAttenuation&&(o.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(o.map=n(e.map)),void 0!==e.matcap&&(o.matcap=n(e.matcap)),void 0!==e.alphaMap&&(o.alphaMap=n(e.alphaMap)),void 0!==e.bumpMap&&(o.bumpMap=n(e.bumpMap)),void 0!==e.bumpScale&&(o.bumpScale=e.bumpScale),void 0!==e.normalMap&&(o.normalMap=n(e.normalMap)),void 0!==e.normalMapType&&(o.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),o.normalScale=(new Nn).fromArray(t)}return void 0!==e.displacementMap&&(o.displacementMap=n(e.displacementMap)),void 0!==e.displacementScale&&(o.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(o.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(o.roughnessMap=n(e.roughnessMap)),void 0!==e.metalnessMap&&(o.metalnessMap=n(e.metalnessMap)),void 0!==e.emissiveMap&&(o.emissiveMap=n(e.emissiveMap)),void 0!==e.emissiveIntensity&&(o.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(o.specularMap=n(e.specularMap)),void 0!==e.envMap&&(o.envMap=n(e.envMap)),void 0!==e.envMapIntensity&&(o.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(o.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(o.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(o.lightMap=n(e.lightMap)),void 0!==e.lightMapIntensity&&(o.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(o.aoMap=n(e.aoMap)),void 0!==e.aoMapIntensity&&(o.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(o.gradientMap=n(e.gradientMap)),void 0!==e.clearcoatMap&&(o.clearcoatMap=n(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(o.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(o.clearcoatNormalMap=n(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(o.clearcoatNormalScale=(new Nn).fromArray(e.clearcoatNormalScale)),void 0!==e.transmission&&(o.transmission=e.transmission),void 0!==e.transmissionMap&&(o.transmissionMap=n(e.transmissionMap)),o}setTextures(e){return this.textures=e,this}}const Ip={decodeText:function(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch(e){return t}},extractUrlBase:function(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}};function Gp(){WA.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function Ep(e,t,n,o){"number"==typeof n&&(o=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),DA.call(this,e,t,n),this.meshPerAttribute=o||1}Gp.prototype=Object.assign(Object.create(WA.prototype),{constructor:Gp,isInstancedBufferGeometry:!0,copy:function(e){return WA.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e=WA.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),Ep.prototype=Object.assign(Object.create(DA.prototype),{constructor:Ep,isInstancedBufferAttribute:!0,copy:function(e){return DA.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=DA.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}});class kp extends Gm{constructor(e){super(e)}load(e,t,n,o){const A=this,i=new km(A.manager);i.setPath(A.path),i.setRequestHeader(A.requestHeader),i.setWithCredentials(A.withCredentials),i.load(e,(function(n){try{t(A.parse(JSON.parse(n)))}catch(t){o?o(t):console.error(t),A.manager.itemError(e)}}),n,o)}parse(e){const t={},n={};function o(e,o){if(void 0!==t[o])return t[o];const A=e.interleavedBuffers[o],i=function(e,t){if(void 0!==n[t])return n[t];const o=e.arrayBuffers[t],A=new Uint32Array(o).buffer;return n[t]=A,A}(e,A.buffer),r=new Ss(SA(A.type,i),A.stride);return r.uuid=A.uuid,t[o]=r,r}const A=e.isInstancedBufferGeometry?new Gp:new WA,i=e.data.index;if(void 0!==i){const e=SA(i.type,i.array);A.setIndex(new DA(e,1))}const r=e.data.attributes;for(const t in r){const n=r[t];let i;if(n.isInterleavedBufferAttribute)i=new Ns(o(e.data,n.data),n.itemSize,n.offset,n.normalized);else{const e=SA(n.type,n.array);i=new(n.isInstancedBufferAttribute?Ep:DA)(e,n.itemSize,n.normalized)}void 0!==n.name&&(i.name=n.name),A.setAttribute(t,i)}const s=e.data.morphAttributes;if(s)for(const t in s){const n=s[t],i=[];for(let t=0,A=n.length;t<A;t++){const A=n[t];let r;r=A.isInterleavedBufferAttribute?new Ns(o(e.data,A.data),A.itemSize,A.offset,A.normalized):new DA(SA(A.type,A.array),A.itemSize,A.normalized),void 0!==A.name&&(r.name=A.name),i.push(r)}A.morphAttributes[t]=i}e.data.morphTargetsRelative&&(A.morphTargetsRelative=!0);const a=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==a)for(let e=0,t=a.length;e!==t;++e){const t=a[e];A.addGroup(t.start,t.count,t.materialIndex)}const l=e.data.boundingSphere;if(void 0!==l){const e=new Zn;void 0!==l.center&&e.fromArray(l.center),A.boundingSphere=new Go(e,l.radius)}return e.name&&(A.name=e.name),e.userData&&(A.userData=e.userData),A}}class gp extends Gm{constructor(e){super(e)}load(e,t,n,o){const A=this,i=""===this.path?Ip.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const r=new km(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,(function(n){let i=null;try{i=JSON.parse(n)}catch(t){return void 0!==o&&o(t),void console.error("THREE:ObjectLoader: Can't parse "+e+".",t.message)}const r=i.metadata;void 0!==r&&void 0!==r.type&&"geometry"!==r.type.toLowerCase()?A.parse(i,t):console.error("THREE.ObjectLoader: Can't load "+e)}),n,o)}parse(e,t){const n=this.parseAnimations(e.animations),o=this.parseShapes(e.shapes),A=this.parseGeometries(e.geometries,o),i=this.parseImages(e.images,(function(){void 0!==t&&t(a)})),r=this.parseTextures(e.textures,i),s=this.parseMaterials(e.materials,r),a=this.parseObject(e.object,A,s,n),l=this.parseSkeletons(e.skeletons,a);if(this.bindSkeletons(a,l),void 0!==t){let e=!1;for(const t in i)if(i[t]instanceof HTMLImageElement){e=!0;break}!1===e&&t(a)}return a}parseShapes(e){const t={};if(void 0!==e)for(let n=0,o=e.length;n<o;n++){const o=(new zm).fromJSON(e[n]);t[o.uuid]=o}return t}parseSkeletons(e,t){const n={},o={};if(t.traverse((function(e){e.isBone&&(o[e.uuid]=e)})),void 0!==e)for(let t=0,A=e.length;t<A;t++){const A=(new da).fromJSON(e[t],o);n[A.uuid]=A}return n}parseGeometries(e,t){const n={};let o;if(void 0!==e){const A=new kp;for(let i=0,r=e.length;i<r;i++){let r;const s=e[i];switch(s.type){case"PlaneGeometry":case"PlaneBufferGeometry":r=new Rl[s.type](s.width,s.height,s.widthSegments,s.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":r=new Rl[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":r=new Rl[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":r=new Rl[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":r=new Rl[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":r=new Rl[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":r=new Rl[s.type](s.radius,s.detail);break;case"RingGeometry":case"RingBufferGeometry":r=new Rl[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":r=new Rl[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":r=new Rl[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);break;case"TubeGeometry":case"TubeBufferGeometry":r=new Rl[s.type]((new Vm[s.path.type]).fromJSON(s.path),s.tubularSegments,s.radius,s.radialSegments,s.closed);break;case"LatheGeometry":case"LatheBufferGeometry":r=new Rl[s.type](s.points,s.segments,s.phiStart,s.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":r=new Rl[s.type](s.vertices,s.indices,s.radius,s.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":o=[];for(let e=0,n=s.shapes.length;e<n;e++){const n=t[s.shapes[e]];o.push(n)}r=new Rl[s.type](o,s.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":o=[];for(let e=0,n=s.shapes.length;e<n;e++){const n=t[s.shapes[e]];o.push(n)}const e=s.options.extrudePath;void 0!==e&&(s.options.extrudePath=(new Vm[e.type]).fromJSON(e)),r=new Rl[s.type](o,s.options);break;case"BufferGeometry":case"InstancedBufferGeometry":r=A.parse(s);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+s.type+'"');continue}r.uuid=s.uuid,void 0!==s.name&&(r.name=s.name),!0===r.isBufferGeometry&&void 0!==s.userData&&(r.userData=s.userData),n[s.uuid]=r}}return n}parseMaterials(e,t){const n={},o={};if(void 0!==e){const A=new dp;A.setTextures(t);for(let t=0,i=e.length;t<i;t++){const i=e[t];if("MultiMaterial"===i.type){const e=[];for(let t=0;t<i.materials.length;t++){const o=i.materials[t];void 0===n[o.uuid]&&(n[o.uuid]=A.parse(o)),e.push(n[o.uuid])}o[i.uuid]=e}else void 0===n[i.uuid]&&(n[i.uuid]=A.parse(i)),o[i.uuid]=n[i.uuid]}}return o}parseAnimations(e){const t={};if(void 0!==e)for(let n=0;n<e.length;n++){const o=e[n],A=hm.parse(o);t[A.uuid]=A}return t}parseImages(e,t){const n=this,o={};let A;function i(e){if("string"==typeof e){const t=e;return function(e){return n.manager.itemStart(e),A.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e),n.manager.itemEnd(e)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:n.resourcePath+t)}return e.data?{data:SA(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){const n=new dm(t);A=new Hm(n),A.setCrossOrigin(this.crossOrigin);for(let t=0,n=e.length;t<n;t++){const n=e[t],A=n.url;if(Array.isArray(A)){o[n.uuid]=[];for(let e=0,t=A.length;e<t;e++){const t=i(A[e]);null!==t&&(t instanceof HTMLImageElement?o[n.uuid].push(t):o[n.uuid].push(new Fi(t.data,t.width,t.height)))}}else{const e=i(n.url);null!==e&&(o[n.uuid]=e)}}}return o}parseTextures(e,t){function n(e,t){return"number"==typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const o={};if(void 0!==e)for(let A=0,i=e.length;A<i;A++){const i=e[A];let r;void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid),void 0===t[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);const s=t[i.image];Array.isArray(s)?(r=new fi(s),6===s.length&&(r.needsUpdate=!0)):(r=s&&s.data?new Fi(s.data,s.width,s.height):new Vn(s),s&&(r.needsUpdate=!0)),r.uuid=i.uuid,void 0!==i.name&&(r.name=i.name),void 0!==i.mapping&&(r.mapping=n(i.mapping,fp)),void 0!==i.offset&&r.offset.fromArray(i.offset),void 0!==i.repeat&&r.repeat.fromArray(i.repeat),void 0!==i.center&&r.center.fromArray(i.center),void 0!==i.rotation&&(r.rotation=i.rotation),void 0!==i.wrap&&(r.wrapS=n(i.wrap[0],Hp),r.wrapT=n(i.wrap[1],Hp)),void 0!==i.format&&(r.format=i.format),void 0!==i.type&&(r.type=i.type),void 0!==i.encoding&&(r.encoding=i.encoding),void 0!==i.minFilter&&(r.minFilter=n(i.minFilter,Fp)),void 0!==i.magFilter&&(r.magFilter=n(i.magFilter,Fp)),void 0!==i.anisotropy&&(r.anisotropy=i.anisotropy),void 0!==i.flipY&&(r.flipY=i.flipY),void 0!==i.premultiplyAlpha&&(r.premultiplyAlpha=i.premultiplyAlpha),void 0!==i.unpackAlignment&&(r.unpackAlignment=i.unpackAlignment),o[i.uuid]=r}return o}parseObject(e,t,n,o){let A,i,r;function s(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function a(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let o=0,A=e.length;o<A;o++){const A=e[o];void 0===n[A]&&console.warn("THREE.ObjectLoader: Undefined material",A),t.push(n[A])}return t}return void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),n[e]}}switch(e.type){case"Scene":A=new Ls,void 0!==e.background&&Number.isInteger(e.background)&&(A.background=new fA(e.background)),void 0!==e.fog&&("Fog"===e.fog.type?A.fog=new Ms(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(A.fog=new ws(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":A=new Ei(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(A.focus=e.focus),void 0!==e.zoom&&(A.zoom=e.zoom),void 0!==e.filmGauge&&(A.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(A.filmOffset=e.filmOffset),void 0!==e.view&&(A.view=Object.assign({},e.view));break;case"OrthographicCamera":A=new ap(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(A.zoom=e.zoom),void 0!==e.view&&(A.view=Object.assign({},e.view));break;case"AmbientLight":A=new pp(e.color,e.intensity);break;case"DirectionalLight":A=new mp(e.color,e.intensity);break;case"PointLight":A=new sp(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":A=new hp(e.color,e.intensity,e.width,e.height);break;case"SpotLight":A=new np(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":A=new Qm(e.color,e.groundColor,e.intensity);break;case"LightProbe":A=(new cp).fromJSON(e);break;case"SkinnedMesh":i=s(e.geometry),r=a(e.material),A=new pa(i,r),void 0!==e.bindMode&&(A.bindMode=e.bindMode),void 0!==e.bindMatrix&&A.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(A.skeleton=e.skeleton);break;case"Mesh":i=s(e.geometry),r=a(e.material),A=new mi(i,r);break;case"InstancedMesh":i=s(e.geometry),r=a(e.material);const t=e.count,n=e.instanceMatrix;A=new ga(i,r,t),A.instanceMatrix=new DA(new Float32Array(n.array),16);break;case"LOD":A=new ia;break;case"Line":A=new va(s(e.geometry),a(e.material));break;case"LineLoop":A=new ba(s(e.geometry),a(e.material));break;case"LineSegments":A=new ya(s(e.geometry),a(e.material));break;case"PointCloud":case"Points":A=new La(s(e.geometry),a(e.material));break;case"Sprite":A=new ta(a(e.material));break;case"Group":A=new Ks;break;case"Bone":A=new ha;break;default:A=new Zo}if(A.uuid=e.uuid,void 0!==e.name&&(A.name=e.name),void 0!==e.matrix?(A.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(A.matrixAutoUpdate=e.matrixAutoUpdate),A.matrixAutoUpdate&&A.matrix.decompose(A.position,A.quaternion,A.scale)):(void 0!==e.position&&A.position.fromArray(e.position),void 0!==e.rotation&&A.rotation.fromArray(e.rotation),void 0!==e.quaternion&&A.quaternion.fromArray(e.quaternion),void 0!==e.scale&&A.scale.fromArray(e.scale)),void 0!==e.castShadow&&(A.castShadow=e.castShadow),void 0!==e.receiveShadow&&(A.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(A.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(A.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(A.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&A.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(A.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(A.visible=e.visible),void 0!==e.frustumCulled&&(A.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(A.renderOrder=e.renderOrder),void 0!==e.userData&&(A.userData=e.userData),void 0!==e.layers&&(A.layers.mask=e.layers),void 0!==e.children){const i=e.children;for(let e=0;e<i.length;e++)A.add(this.parseObject(i[e],t,n,o))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const n=t[e];A.animations.push(o[n])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(A.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const n=t[e],o=A.getObjectByProperty("uuid",n.object);void 0!==o&&A.addLevel(o,n.distance)}}return A}bindSkeletons(e,t){0!==Object.keys(t).length&&e.traverse((function(e){if(!0===e.isSkinnedMesh&&void 0!==e.skeleton){const n=t[e.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(n,e.bindMatrix)}}))}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const fp={UVMapping:Ae,CubeReflectionMapping:ie,CubeRefractionMapping:re,EquirectangularReflectionMapping:se,EquirectangularRefractionMapping:ae,CubeUVReflectionMapping:le,CubeUVRefractionMapping:me},Hp={RepeatWrapping:pe,ClampToEdgeWrapping:he,MirroredRepeatWrapping:ue},Fp={NearestFilter:ce,NearestMipmapNearestFilter:de,NearestMipmapLinearFilter:Ge,LinearFilter:ke,LinearMipmapNearestFilter:ge,LinearMipmapLinearFilter:He};function Cp(e){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Gm.call(this,e),this.options={premultiplyAlpha:"none"}}Cp.prototype=Object.assign(Object.create(Gm.prototype),{constructor:Cp,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(e,t,n,o){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const A=this,i=cm.get(e);if(void 0!==i)return A.manager.itemStart(e),setTimeout((function(){t&&t(i),A.manager.itemEnd(e)}),0),i;const r={};r.credentials="anonymous"===this.crossOrigin?"same-origin":"include",r.headers=this.requestHeader,fetch(e,r).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(A.options,{colorSpaceConversion:"none"}))})).then((function(n){cm.add(e,n),t&&t(n),A.manager.itemEnd(e)})).catch((function(t){o&&o(t),A.manager.itemError(e),A.manager.itemEnd(e)})),A.manager.itemStart(e)}});class Dp{constructor(){this.type="ShapePath",this.color=new fA,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new _m,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,o){return this.currentPath.quadraticCurveTo(e,t,n,o),this}bezierCurveTo(e,t,n,o,A,i){return this.currentPath.bezierCurveTo(e,t,n,o,A,i),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(e){const t=[];for(let n=0,o=e.length;n<o;n++){const o=e[n],A=new zm;A.curves=o.curves,t.push(A)}return t}function o(e,t){const n=t.length;let o=!1;for(let A=n-1,i=0;i<n;A=i++){let n=t[A],r=t[i],s=r.x-n.x,a=r.y-n.y;if(Math.abs(a)>Number.EPSILON){if(a<0&&(n=t[i],s=-s,r=t[A],a=-a),e.y<n.y||e.y>r.y)continue;if(e.y===n.y){if(e.x===n.x)return!0}else{const t=a*(e.x-n.x)-s*(e.y-n.y);if(0===t)return!0;if(t<0)continue;o=!o}}else{if(e.y!==n.y)continue;if(r.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=r.x)return!0}}return o}const A=Fl.isClockWise,i=this.subPaths;if(0===i.length)return[];if(!0===t)return n(i);let r,s,a;const l=[];if(1===i.length)return s=i[0],a=new zm,a.curves=s.curves,l.push(a),l;let m=!A(i[0].getPoints());m=e?!m:m;const p=[],h=[];let u,c,d=[],I=0;h[I]=void 0,d[I]=[];for(let t=0,n=i.length;t<n;t++)s=i[t],u=s.getPoints(),r=A(u),r=e?!r:r,r?(!m&&h[I]&&I++,h[I]={s:new zm,p:u},h[I].s.curves=s.curves,m&&I++,d[I]=[]):d[I].push({h:s,p:u[0]});if(!h[0])return n(i);if(h.length>1){let e=!1;const t=[];for(let e=0,t=h.length;e<t;e++)p[e]=[];for(let n=0,A=h.length;n<A;n++){const A=d[n];for(let i=0;i<A.length;i++){const r=A[i];let s=!0;for(let A=0;A<h.length;A++)o(r.p,h[A].p)&&(n!==A&&t.push({froms:n,tos:A,hole:i}),s?(s=!1,p[A].push(r)):e=!0);s&&p[n].push(r)}}t.length>0&&(e||(d=p))}for(let e=0,t=h.length;e<t;e++){a=h[e].s,l.push(a),c=d[e];for(let e=0,t=c.length;e<t;e++)a.holes.push(c[e].h)}return l}}class Jp{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],o=function(e,t,n){const o=Array.from(e),A=t/n.resolution,i=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*A,r=[];let s=0,a=0;for(let e=0;e<o.length;e++){const t=o[e];if("\n"===t)s=0,a-=i;else{const e=vp(t,A,s,a,n);s+=e.offsetX,r.push(e.path)}}return r}(e,t,this.data);for(let e=0,t=o.length;e<t;e++)Array.prototype.push.apply(n,o[e].toShapes());return n}}function vp(e,t,n,o,A){const i=A.glyphs[e]||A.glyphs["?"];if(!i)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+A.familyName+".");const r=new Dp;let s,a,l,m,p,h,u,c;if(i.o){const e=i._cachedOutline||(i._cachedOutline=i.o.split(" "));for(let A=0,i=e.length;A<i;)switch(e[A++]){case"m":s=e[A++]*t+n,a=e[A++]*t+o,r.moveTo(s,a);break;case"l":s=e[A++]*t+n,a=e[A++]*t+o,r.lineTo(s,a);break;case"q":l=e[A++]*t+n,m=e[A++]*t+o,p=e[A++]*t+n,h=e[A++]*t+o,r.quadraticCurveTo(p,h,l,m);break;case"b":l=e[A++]*t+n,m=e[A++]*t+o,p=e[A++]*t+n,h=e[A++]*t+o,u=e[A++]*t+n,c=e[A++]*t+o,r.bezierCurveTo(p,h,u,c,l,m)}}return{offsetX:i.ha*t,path:r}}Jp.prototype.isFont=!0;class jp extends Gm{constructor(e){super(e)}load(e,t,n,o){const A=this,i=new km(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(A.withCredentials),i.load(e,(function(e){let n;try{n=JSON.parse(e)}catch(t){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(e.substring(65,e.length-2))}const o=A.parse(n);t&&t(o)}),n,o)}parse(e){return new Jp(e)}}let Kp;const yp={getContext:function(){return void 0===Kp&&(Kp=new(window.AudioContext||window.webkitAudioContext)),Kp},setContext:function(e){Kp=e}};class bp extends Gm{constructor(e){super(e)}load(e,t,n,o){const A=this,i=new km(this.manager);i.setResponseType("arraybuffer"),i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,(function(n){try{const e=n.slice(0);yp.getContext().decodeAudioData(e,(function(e){t(e)}))}catch(t){o?o(t):console.error(t),A.manager.itemError(e)}}),n,o)}}class qp extends cp{constructor(e,t,n=1){super(void 0,n);const o=(new fA).set(e),A=(new fA).set(t),i=new Zn(o.r,o.g,o.b),r=new Zn(A.r,A.g,A.b),s=Math.sqrt(Math.PI),a=s*Math.sqrt(.75);this.sh.coefficients[0].copy(i).add(r).multiplyScalar(s),this.sh.coefficients[1].copy(i).sub(r).multiplyScalar(a)}}qp.prototype.isHemisphereLightProbe=!0;class xp extends cp{constructor(e,t=1){super(void 0,t);const n=(new fA).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}xp.prototype.isAmbientLightProbe=!0;const Bp=new Jo,wp=new Jo;class Mp{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Ei,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Ei,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const n=e.projectionMatrix.clone(),o=t.eyeSep/2,A=o*t.near/t.focus,i=t.near*Math.tan(Tn.DEG2RAD*t.fov*.5)/t.zoom;let r,s;wp.elements[12]=-o,Bp.elements[12]=o,r=-i*t.aspect+A,s=i*t.aspect+A,n.elements[0]=2*t.near/(s-r),n.elements[8]=(s+r)/(s-r),this.cameraL.projectionMatrix.copy(n),r=-i*t.aspect-A,s=i*t.aspect-A,n.elements[0]=2*t.near/(s-r),n.elements[8]=(s+r)/(s-r),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(wp),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Bp)}}class Lp{constructor(e){this.autoStart=void 0===e||e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Sp(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Sp();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Sp(){return("undefined"==typeof performance?Date:performance).now()}const Tp=new Zn,Np=new Qn,Rp=new Zn,Op=new Zn;class Pp extends Zo{constructor(){super(),this.type="AudioListener",this.context=yp.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Lp}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Tp,Np,Rp),Op.set(0,0,-1).applyQuaternion(Np),t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Tp.x,e),t.positionY.linearRampToValueAtTime(Tp.y,e),t.positionZ.linearRampToValueAtTime(Tp.z,e),t.forwardX.linearRampToValueAtTime(Op.x,e),t.forwardY.linearRampToValueAtTime(Op.y,e),t.forwardZ.linearRampToValueAtTime(Op.z,e),t.upX.linearRampToValueAtTime(n.x,e),t.upY.linearRampToValueAtTime(n.y,e),t.upZ.linearRampToValueAtTime(n.z,e)}else t.setPosition(Tp.x,Tp.y,Tp.z),t.setOrientation(Op.x,Op.y,Op.z,n.x,n.y,n.z)}}class Up extends Zo{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Vp=new Zn,Wp=new Qn,_p=new Zn,zp=new Zn;class Xp extends Up{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Vp,Wp,_p),zp.set(0,0,1).applyQuaternion(Wp);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Vp.x,e),t.positionY.linearRampToValueAtTime(Vp.y,e),t.positionZ.linearRampToValueAtTime(Vp.z,e),t.orientationX.linearRampToValueAtTime(zp.x,e),t.orientationY.linearRampToValueAtTime(zp.y,e),t.orientationZ.linearRampToValueAtTime(zp.z,e)}else t.setPosition(Vp.x,Vp.y,Vp.z),t.setOrientation(zp.x,zp.y,zp.z)}}class Qp{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class Zp{constructor(e,t,n){let o,A,i;switch(this.binding=e,this.valueSize=n,t){case"quaternion":o=this._slerp,A=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":o=this._select,A=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:o=this._lerp,A=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=o,this._mixBufferRegionAdditive=A,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,o=this.valueSize,A=e*o+o;let i=this.cumulativeWeight;if(0===i){for(let e=0;e!==o;++e)n[A+e]=n[e];i=t}else{i+=t;const e=t/i;this._mixBufferRegion(n,A,0,e,o)}this.cumulativeWeight=i}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,o=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,o,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,o=e*t+t,A=this.cumulativeWeight,i=this.cumulativeWeightAdditive,r=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,A<1){const e=t*this._origIndex;this._mixBufferRegion(n,o,e,1-A,t)}i>0&&this._mixBufferRegionAdditive(n,o,this._addIndex*t,1,t);for(let e=t,A=t+t;e!==A;++e)if(n[e]!==n[e+t]){r.setValue(n,o);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,o=n*this._origIndex;e.getValue(t,o);for(let e=n,A=o;e!==A;++e)t[e]=t[o+e%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,o,A){if(o>=.5)for(let o=0;o!==A;++o)e[t+o]=e[n+o]}_slerp(e,t,n,o){Qn.slerpFlat(e,t,e,t,e,n,o)}_slerpAdditive(e,t,n,o,A){const i=this._workIndex*A;Qn.multiplyQuaternionsFlat(e,i,e,t,e,n),Qn.slerpFlat(e,t,e,t,e,i,o)}_lerp(e,t,n,o,A){const i=1-o;for(let r=0;r!==A;++r){const A=t+r;e[A]=e[A]*i+e[n+r]*o}}_lerpAdditive(e,t,n,o,A){for(let i=0;i!==A;++i){const A=t+i;e[A]=e[A]+e[n+i]*o}}}const Yp=new RegExp("[\\[\\]\\.:\\/]","g"),$p="[^\\[\\]\\.:\\/]",eh="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",th=/((?:WC+[\/:])*)/.source.replace("WC",$p),nh=/(WCOD+)?/.source.replace("WCOD",eh),oh=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",$p),Ah=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",$p),ih=new RegExp("^"+th+nh+oh+Ah+"$"),rh=["material","materials","bones"];function sh(e,t,n){const o=n||ah.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,o)}function ah(e,t,n){this.path=t,this.parsedPath=n||ah.parseTrackName(t),this.node=ah.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}Object.assign(sh.prototype,{getValue:function(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,o=this._bindings[n];void 0!==o&&o.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let o=this._targetGroup.nCachedObjects_,A=n.length;o!==A;++o)n[o].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}),Object.assign(ah,{Composite:sh,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new ah.Composite(e,t,n):new ah(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(Yp,"")},parseTrackName:function(e){const t=ih.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},o=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==o&&-1!==o){const e=n.nodeName.substring(o+1);-1!==rh.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,o),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(e){for(let o=0;o<e.length;o++){const A=e[o];if(A.name===t||A.uuid===t)return A;const i=n(A.children);if(i)return i}return null},o=n(e.children);if(o)return o}return null}}),Object.assign(ah.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const n=this.resolvedProperty;for(let o=0,A=n.length;o!==A;++o)e[t++]=n[o]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const n=this.resolvedProperty;for(let o=0,A=n.length;o!==A;++o)n[o]=e[t++]},function(e,t){const n=this.resolvedProperty;for(let o=0,A=n.length;o!==A;++o)n[o]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const n=this.resolvedProperty;for(let o=0,A=n.length;o!==A;++o)n[o]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let e=this.node;const t=this.parsedPath,n=t.objectName,o=t.propertyName;let A=t.propertyIndex;if(e||(e=ah.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let o=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===o){o=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==o){if(void 0===e[o])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[o]}}const i=e[o];if(void 0===i){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+o+" but it wasn't found.",e)}let r=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?r=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(r=this.Versioning.MatrixWorldNeedsUpdate);let s=this.BindingType.Direct;if(void 0!==A){if("morphTargetInfluences"===o){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[A]&&(A=e.morphTargetDictionary[A])}s=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=A}else void 0!==i.fromArray&&void 0!==i.toArray?(s=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(s=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=o;this.getValue=this.GetterByBindingType[s],this.setValue=this.SetterByBindingTypeAndVersioning[s][r]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(ah.prototype,{_getValue_unbound:ah.prototype.getValue,_setValue_unbound:ah.prototype.setValue});class lh{constructor(){this.uuid=Tn.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let t=0,n=arguments.length;t!==n;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,o=this._parsedPaths,A=this._bindings,i=A.length;let r,s=e.length,a=this.nCachedObjects_;for(let l=0,m=arguments.length;l!==m;++l){const m=arguments[l],p=m.uuid;let h=t[p];if(void 0===h){h=s++,t[p]=h,e.push(m);for(let e=0,t=i;e!==t;++e)A[e].push(new ah(m,n[e],o[e]))}else if(h<a){r=e[h];const s=--a,l=e[s];t[l.uuid]=h,e[h]=l,t[p]=s,e[s]=m;for(let e=0,t=i;e!==t;++e){const t=A[e],i=t[s];let r=t[h];t[h]=i,void 0===r&&(r=new ah(m,n[e],o[e])),t[s]=r}}else e[h]!==r&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=a}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,o=n.length;let A=this.nCachedObjects_;for(let i=0,r=arguments.length;i!==r;++i){const r=arguments[i],s=r.uuid,a=t[s];if(void 0!==a&&a>=A){const i=A++,l=e[i];t[l.uuid]=a,e[a]=l,t[s]=i,e[i]=r;for(let e=0,t=o;e!==t;++e){const t=n[e],o=t[i],A=t[a];t[a]=o,t[i]=A}}}this.nCachedObjects_=A}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,o=n.length;let A=this.nCachedObjects_,i=e.length;for(let r=0,s=arguments.length;r!==s;++r){const s=arguments[r].uuid,a=t[s];if(void 0!==a)if(delete t[s],a<A){const r=--A,s=e[r],l=--i,m=e[l];t[s.uuid]=a,e[a]=s,t[m.uuid]=r,e[r]=m,e.pop();for(let e=0,t=o;e!==t;++e){const t=n[e],o=t[r],A=t[l];t[a]=o,t[r]=A,t.pop()}}else{const A=--i,r=e[A];A>0&&(t[r.uuid]=a),e[a]=r,e.pop();for(let e=0,t=o;e!==t;++e){const t=n[e];t[a]=t[A],t.pop()}}}this.nCachedObjects_=A}subscribe_(e,t){const n=this._bindingsIndicesByPath;let o=n[e];const A=this._bindings;if(void 0!==o)return A[o];const i=this._paths,r=this._parsedPaths,s=this._objects,a=s.length,l=this.nCachedObjects_,m=new Array(a);o=A.length,n[e]=o,i.push(e),r.push(t),A.push(m);for(let n=l,o=s.length;n!==o;++n){const o=s[n];m[n]=new ah(o,e,t)}return m}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const o=this._paths,A=this._parsedPaths,i=this._bindings,r=i.length-1,s=i[r];t[e[r]]=n,i[n]=s,i.pop(),A[n]=A[r],A.pop(),o[n]=o[r],o.pop()}}}lh.prototype.isAnimationObjectGroup=!0;class mh{constructor(e,t,n=null,o=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=o;const A=t.tracks,i=A.length,r=new Array(i),s={endingStart:Ot,endingEnd:Ot};for(let e=0;e!==i;++e){const t=A[e].createInterpolant(null);r[e]=t,t.settings=s}this._interpolantSettings=s,this._interpolants=r,this._propertyBindings=new Array(i),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Lt,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const n=this._clip.duration,o=e._clip.duration,A=o/n,i=n/o;e.warp(1,A,t),this.warp(i,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const o=this._mixer,A=o.time,i=this.timeScale;let r=this._timeScaleInterpolant;null===r&&(r=o._lendControlInterpolant(),this._timeScaleInterpolant=r);const s=r.parameterPositions,a=r.sampleValues;return s[0]=A,s[1]=A+n,a[0]=e/i,a[1]=t/i,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,o){if(!this.enabled)return void this._updateWeight(e);const A=this._startTime;if(null!==A){const o=(e-A)*n;if(o<0||0===n)return;this._startTime=null,t=n*o}t*=this._updateTimeScale(e);const i=this._updateTime(t),r=this._updateWeight(e);if(r>0){const e=this._interpolants,t=this._propertyBindings;if(this.blendMode===Wt)for(let n=0,o=e.length;n!==o;++n)e[n].evaluate(i),t[n].accumulateAdditive(r);else for(let n=0,A=e.length;n!==A;++n)e[n].evaluate(i),t[n].accumulate(o,r)}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const o=n.evaluate(e)[0];t*=o,e>n.parameterPositions[1]&&(this.stopFading(),0===o&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let o=this.time+e,A=this._loopCount;const i=n===St;if(0===e)return-1===A?o:i&&1==(1&A)?t-o:o;if(n===Mt){-1===A&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(o>=t)o=t;else{if(!(o<0)){this.time=o;break e}o=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===A&&(e>=0?(A=0,this._setEndings(!0,0===this.repetitions,i)):this._setEndings(0===this.repetitions,!0,i)),o>=t||o<0){const n=Math.floor(o/t);o-=t*n,A+=Math.abs(n);const r=this.repetitions-A;if(r<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,o=e>0?t:0,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===r){const t=e<0;this._setEndings(t,!t,i)}else this._setEndings(!1,!1,i);this._loopCount=A,this.time=o,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=o;if(i&&1==(1&A))return t-o}return o}_setEndings(e,t,n){const o=this._interpolantSettings;n?(o.endingStart=Pt,o.endingEnd=Pt):(o.endingStart=e?this.zeroSlopeAtStart?Pt:Ot:Ut,o.endingEnd=t?this.zeroSlopeAtEnd?Pt:Ot:Ut)}_scheduleFading(e,t,n){const o=this._mixer,A=o.time;let i=this._weightInterpolant;null===i&&(i=o._lendControlInterpolant(),this._weightInterpolant=i);const r=i.parameterPositions,s=i.sampleValues;return r[0]=A,s[0]=t,r[1]=A+e,s[1]=n,this}}class ph extends Mn{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,o=e._clip.tracks,A=o.length,i=e._propertyBindings,r=e._interpolants,s=n.uuid,a=this._bindingsByRootAndName;let l=a[s];void 0===l&&(l={},a[s]=l);for(let e=0;e!==A;++e){const A=o[e],a=A.name;let m=l[a];if(void 0!==m)i[e]=m;else{if(m=i[e],void 0!==m){null===m._cacheIndex&&(++m.referenceCount,this._addInactiveBinding(m,s,a));continue}const o=t&&t._propertyBindings[e].binding.parsedPath;m=new Zp(ah.create(n,a,o),A.ValueTypeName,A.getValueSize()),++m.referenceCount,this._addInactiveBinding(m,s,a),i[e]=m}r[e].resultBuffer=m.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,o=this._actionsByClip[n];this._bindAction(e,o&&o.knownActions[0]),this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions}_addInactiveAction(e,t,n){const o=this._actions,A=this._actionsByClip;let i=A[t];if(void 0===i)i={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,A[t]=i;else{const t=i.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=o.length,o.push(e),i.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],o=e._cacheIndex;n._cacheIndex=o,t[o]=n,t.pop(),e._cacheIndex=null;const A=e._clip.uuid,i=this._actionsByClip,r=i[A],s=r.knownActions,a=s[s.length-1],l=e._byClipCacheIndex;a._byClipCacheIndex=l,s[l]=a,s.pop(),e._byClipCacheIndex=null,delete r.actionByRoot[(e._localRoot||this._root).uuid],0===s.length&&delete i[A],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,o=this._nActiveActions++,A=t[o];e._cacheIndex=o,t[o]=e,A._cacheIndex=n,t[n]=A}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,o=--this._nActiveActions,A=t[o];e._cacheIndex=o,t[o]=e,A._cacheIndex=n,t[n]=A}_addInactiveBinding(e,t,n){const o=this._bindingsByRootAndName,A=this._bindings;let i=o[t];void 0===i&&(i={},o[t]=i),i[n]=e,e._cacheIndex=A.length,A.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,o=n.rootNode.uuid,A=n.path,i=this._bindingsByRootAndName,r=i[o],s=t[t.length-1],a=e._cacheIndex;s._cacheIndex=a,t[a]=s,t.pop(),delete r[A],0===Object.keys(r).length&&delete i[o]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,o=this._nActiveBindings++,A=t[o];e._cacheIndex=o,t[o]=e,A._cacheIndex=n,t[n]=A}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,o=--this._nActiveBindings,A=t[o];e._cacheIndex=o,t[o]=e,A._cacheIndex=n,t[n]=A}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new nm(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,o=--this._nActiveControlInterpolants,A=t[o];e.__cacheIndex=o,t[o]=e,A.__cacheIndex=n,t[n]=A}clipAction(e,t,n){const o=t||this._root,A=o.uuid;let i="string"==typeof e?hm.findByName(o,e):e;const r=null!==i?i.uuid:e,s=this._actionsByClip[r];let a=null;if(void 0===n&&(n=null!==i?i.blendMode:Vt),void 0!==s){const e=s.actionByRoot[A];if(void 0!==e&&e.blendMode===n)return e;a=s.knownActions[0],null===i&&(i=a._clip)}if(null===i)return null;const l=new mh(this,i,t,n);return this._bindAction(l,a),this._addInactiveAction(l,r,A),l}existingAction(e,t){const n=t||this._root,o=n.uuid,A="string"==typeof e?hm.findByName(n,e):e,i=A?A.uuid:e,r=this._actionsByClip[i];return void 0!==r&&r.actionByRoot[o]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,o=this.time+=e,A=Math.sign(e),i=this._accuIndex^=1;for(let r=0;r!==n;++r)t[r]._update(o,e,A,i);const r=this._bindings,s=this._nActiveBindings;for(let e=0;e!==s;++e)r[e].apply(i);return this}setTime(e){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,o=this._actionsByClip,A=o[n];if(void 0!==A){const e=A.knownActions;for(let n=0,o=e.length;n!==o;++n){const o=e[n];this._deactivateAction(o);const A=o._cacheIndex,i=t[t.length-1];o._cacheIndex=null,o._byClipCacheIndex=null,i._cacheIndex=A,t[A]=i,t.pop(),this._removeInactiveBindingsForAction(o)}delete o[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const e in n){const o=n[e].actionByRoot[t];void 0!==o&&(this._deactivateAction(o),this._removeInactiveAction(o))}const o=this._bindingsByRootAndName[t];if(void 0!==o)for(const e in o){const t=o[e];t.restoreOriginalState(),this._removeInactiveBinding(t)}}uncacheAction(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}ph.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class hh{constructor(e){"string"==typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new hh(void 0===this.value.clone?this.value:this.value.clone())}}function uh(e,t,n){Ss.call(this,e,t),this.meshPerAttribute=n||1}function ch(e,t,n,o,A){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=o,this.count=A,this.version=0}function dh(e,t,n=0,o=1/0){this.ray=new Do(e,t),this.near=n,this.far=o,this.camera=null,this.layers=new Lo,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function Ih(e,t){return e.distance-t.distance}function Gh(e,t,n,o){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===o){const o=e.children;for(let e=0,A=o.length;e<A;e++)Gh(o[e],t,n,!0)}}uh.prototype=Object.assign(Object.create(Ss.prototype),{constructor:uh,isInstancedInterleavedBuffer:!0,copy:function(e){return Ss.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=Ss.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=Ss.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.defineProperty(ch.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(ch.prototype,{isGLBufferAttribute:!0,setBuffer:function(e){return this.buffer=e,this},setType:function(e,t){return this.type=e,this.elementSize=t,this},setItemSize:function(e){return this.itemSize=e,this},setCount:function(e){return this.count=e,this}}),Object.assign(dh.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},intersectObject:function(e,t=!1,n=[]){return Gh(e,this,n,t),n.sort(Ih),n},intersectObjects:function(e,t=!1,n=[]){for(let o=0,A=e.length;o<A;o++)Gh(e[o],this,n,t);return n.sort(Ih),n}});class Eh{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Tn.clamp(t/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class kh{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return(new this.constructor).copy(this)}}const gh=new Nn;class fh{constructor(e=new Nn(1/0,1/0),t=new Nn(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=gh.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return void 0===e&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new Nn),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new Nn),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new Nn),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new Nn),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return gh.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}fh.prototype.isBox2=!0;const Hh=new Zn,Fh=new Zn;class Ch{constructor(e=new Zn,t=new Zn){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return void 0===e&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new Zn),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return void 0===e&&(console.warn("THREE.Line3: .delta() target is now required"),e=new Zn),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return void 0===t&&(console.warn("THREE.Line3: .at() target is now required"),t=new Zn),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Hh.subVectors(e,this.start),Fh.subVectors(this.end,this.start);const n=Fh.dot(Fh);let o=Fh.dot(Hh)/n;return t&&(o=Tn.clamp(o,0,1)),o}closestPointToPoint(e,t,n){const o=this.closestPointToPointParameter(e,t);return void 0===n&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new Zn),this.delta(n).multiplyScalar(o).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}function Dh(e){Zo.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Dh.prototype=Object.create(Zo.prototype),Dh.prototype.constructor=Dh,Dh.prototype.isImmediateRenderObject=!0;const Jh=new Zn;class vh extends Zo{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new WA,o=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let e=0,t=1,n=32;e<n;e++,t++){const A=e/n*Math.PI*2,i=t/n*Math.PI*2;o.push(Math.cos(A),Math.sin(A),1,Math.cos(i),Math.sin(i),1)}n.setAttribute("position",new BA(o,3));const A=new fa({fog:!1,toneMapped:!1});this.cone=new ya(n,A),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Jh.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Jh),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const jh=new Zn,Kh=new Jo,yh=new Jo;class bh extends ya{constructor(e){const t=qh(e),n=new WA,o=[],A=[],i=new fA(0,0,1),r=new fA(0,1,0);for(let e=0;e<t.length;e++){const n=t[e];n.parent&&n.parent.isBone&&(o.push(0,0,0),o.push(0,0,0),A.push(i.r,i.g,i.b),A.push(r.r,r.g,r.b))}n.setAttribute("position",new BA(o,3)),n.setAttribute("color",new BA(A,3)),super(n,new fa({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,o=n.getAttribute("position");yh.copy(this.root.matrixWorld).invert();for(let e=0,n=0;e<t.length;e++){const A=t[e];A.parent&&A.parent.isBone&&(Kh.multiplyMatrices(yh,A.matrixWorld),jh.setFromMatrixPosition(Kh),o.setXYZ(n,jh.x,jh.y,jh.z),Kh.multiplyMatrices(yh,A.parent.matrixWorld),jh.setFromMatrixPosition(Kh),o.setXYZ(n+1,jh.x,jh.y,jh.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function qh(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,qh(e.children[n]));return t}class xh extends mi{constructor(e,t,n){super(new Bl(t,4,2),new HA({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Bh=new Zn,wh=new fA,Mh=new fA;class Lh extends Zo{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const o=new yl(t);o.rotateY(.5*Math.PI),this.material=new HA({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const A=o.getAttribute("position"),i=new Float32Array(3*A.count);o.setAttribute("color",new DA(i,3)),this.add(new mi(o,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");wh.copy(this.light.color),Mh.copy(this.light.groundColor);for(let e=0,n=t.count;e<n;e++){const o=e<n/2?wh:Mh;t.setXYZ(e,o.r,o.g,o.b)}t.needsUpdate=!0}e.lookAt(Bh.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Sh extends ya{constructor(e=10,t=10,n=4473924,o=8947848){n=new fA(n),o=new fA(o);const A=t/2,i=e/t,r=e/2,s=[],a=[];for(let e=0,l=0,m=-r;e<=t;e++,m+=i){s.push(-r,0,m,r,0,m),s.push(m,0,-r,m,0,r);const t=e===A?n:o;t.toArray(a,l),l+=3,t.toArray(a,l),l+=3,t.toArray(a,l),l+=3,t.toArray(a,l),l+=3}const l=new WA;l.setAttribute("position",new BA(s,3)),l.setAttribute("color",new BA(a,3)),super(l,new fa({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class Th extends ya{constructor(e=10,t=16,n=8,o=64,A=4473924,i=8947848){A=new fA(A),i=new fA(i);const r=[],s=[];for(let n=0;n<=t;n++){const o=n/t*(2*Math.PI),a=Math.sin(o)*e,l=Math.cos(o)*e;r.push(0,0,0),r.push(a,0,l);const m=1&n?A:i;s.push(m.r,m.g,m.b),s.push(m.r,m.g,m.b)}for(let t=0;t<=n;t++){const a=1&t?A:i,l=e-e/n*t;for(let e=0;e<o;e++){let t=e/o*(2*Math.PI),n=Math.sin(t)*l,A=Math.cos(t)*l;r.push(n,0,A),s.push(a.r,a.g,a.b),t=(e+1)/o*(2*Math.PI),n=Math.sin(t)*l,A=Math.cos(t)*l,r.push(n,0,A),s.push(a.r,a.g,a.b)}}const a=new WA;a.setAttribute("position",new BA(r,3)),a.setAttribute("color",new BA(s,3)),super(a,new fa({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const Nh=new Zn,Rh=new Zn,Oh=new Zn;class Ph extends Zo{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===t&&(t=1);let o=new WA;o.setAttribute("position",new BA([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const A=new fa({fog:!1,toneMapped:!1});this.lightPlane=new va(o,A),this.add(this.lightPlane),o=new WA,o.setAttribute("position",new BA([0,0,0,0,0,1],3)),this.targetLine=new va(o,A),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Nh.setFromMatrixPosition(this.light.matrixWorld),Rh.setFromMatrixPosition(this.light.target.matrixWorld),Oh.subVectors(Rh,Nh),this.lightPlane.lookAt(Rh),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Rh),this.targetLine.scale.z=Oh.length()}}const Uh=new Zn,Vh=new Gi;class Wh extends ya{constructor(e){const t=new WA,n=new fa({color:16777215,vertexColors:!0,toneMapped:!1}),o=[],A=[],i={},r=new fA(16755200),s=new fA(16711680),a=new fA(43775),l=new fA(16777215),m=new fA(3355443);function p(e,t,n){h(e,n),h(t,n)}function h(e,t){o.push(0,0,0),A.push(t.r,t.g,t.b),void 0===i[e]&&(i[e]=[]),i[e].push(o.length/3-1)}p("n1","n2",r),p("n2","n4",r),p("n4","n3",r),p("n3","n1",r),p("f1","f2",r),p("f2","f4",r),p("f4","f3",r),p("f3","f1",r),p("n1","f1",r),p("n2","f2",r),p("n3","f3",r),p("n4","f4",r),p("p","n1",s),p("p","n2",s),p("p","n3",s),p("p","n4",s),p("u1","u2",a),p("u2","u3",a),p("u3","u1",a),p("c","t",l),p("p","c",m),p("cn1","cn2",m),p("cn3","cn4",m),p("cf1","cf2",m),p("cf3","cf4",m),t.setAttribute("position",new BA(o,3)),t.setAttribute("color",new BA(A,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=i,this.update()}update(){const e=this.geometry,t=this.pointMap;Vh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),_h("c",t,e,Vh,0,0,-1),_h("t",t,e,Vh,0,0,1),_h("n1",t,e,Vh,-1,-1,-1),_h("n2",t,e,Vh,1,-1,-1),_h("n3",t,e,Vh,-1,1,-1),_h("n4",t,e,Vh,1,1,-1),_h("f1",t,e,Vh,-1,-1,1),_h("f2",t,e,Vh,1,-1,1),_h("f3",t,e,Vh,-1,1,1),_h("f4",t,e,Vh,1,1,1),_h("u1",t,e,Vh,.7,1.1,-1),_h("u2",t,e,Vh,-.7,1.1,-1),_h("u3",t,e,Vh,0,2,-1),_h("cf1",t,e,Vh,-1,0,1),_h("cf2",t,e,Vh,1,0,1),_h("cf3",t,e,Vh,0,-1,1),_h("cf4",t,e,Vh,0,1,1),_h("cn1",t,e,Vh,-1,0,-1),_h("cn2",t,e,Vh,1,0,-1),_h("cn3",t,e,Vh,0,-1,-1),_h("cn4",t,e,Vh,0,1,-1),e.getAttribute("position").needsUpdate=!0}}function _h(e,t,n,o,A,i,r){Uh.set(A,i,r).unproject(o);const s=t[e];if(void 0!==s){const e=n.getAttribute("position");for(let t=0,n=s.length;t<n;t++)e.setXYZ(s[t],Uh.x,Uh.y,Uh.z)}}const zh=new eo;class Xh extends ya{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new Float32Array(24),A=new WA;A.setIndex(new DA(n,1)),A.setAttribute("position",new DA(o,3)),super(A,new fa({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&zh.setFromObject(this.object),zh.isEmpty())return;const t=zh.min,n=zh.max,o=this.geometry.attributes.position,A=o.array;A[0]=n.x,A[1]=n.y,A[2]=n.z,A[3]=t.x,A[4]=n.y,A[5]=n.z,A[6]=t.x,A[7]=t.y,A[8]=n.z,A[9]=n.x,A[10]=t.y,A[11]=n.z,A[12]=n.x,A[13]=n.y,A[14]=t.z,A[15]=t.x,A[16]=n.y,A[17]=t.z,A[18]=t.x,A[19]=t.y,A[20]=t.z,A[21]=n.x,A[22]=t.y,A[23]=t.z,o.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return ya.prototype.copy.call(this,e),this.object=e.object,this}}class Qh extends ya{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new WA;o.setIndex(new DA(n,1)),o.setAttribute("position",new BA([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(o,new fa({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class Zh extends va{constructor(e,t=1,n=16776960){const o=n,A=new WA;A.setAttribute("position",new BA([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),A.computeBoundingSphere(),super(A,new fa({color:o,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const i=new WA;i.setAttribute("position",new BA([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),i.computeBoundingSphere(),this.add(new mi(i,new HA({color:o,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?d:c,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const Yh=new Zn;let $h,eu;class tu extends Zo{constructor(e=new Zn(0,0,1),t=new Zn(0,0,0),n=1,o=16776960,A=.2*n,i=.2*A){super(),this.type="ArrowHelper",void 0===$h&&($h=new WA,$h.setAttribute("position",new BA([0,0,0,0,1,0],3)),eu=new Ua(0,.5,1,5,1),eu.translate(0,-.5,0)),this.position.copy(t),this.line=new va($h,new fa({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new mi(eu,new HA({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,A,i)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Yh.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Yh,t)}}setLength(e,t=.2*e,n=.2*t){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class nu extends ya{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=new WA;n.setAttribute("position",new BA(t,3)),n.setAttribute("color",new BA([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new fa({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}}const ou=new Float32Array(1),Au=new Int32Array(ou.buffer),iu={toHalfFloat:function(e){ou[0]=e;const t=Au[0];let n=t>>16&32768,o=t>>12&2047;const A=t>>23&255;return A<103?n:A>142?(n|=31744,n|=(255==A?0:1)&&8388607&t,n):A<113?(o|=2048,n|=(o>>114-A)+(o>>113-A&1),n):(n|=A-112<<10|o>>1,n+=1&o,n)}},ru=Math.pow(2,8),su=[.125,.215,.35,.446,.526,.582],au=5+su.length,lu={[Qt]:0,[Zt]:1,[$t]:2,[tn]:3,[nn]:4,[on]:5,[Yt]:6},mu=new HA({side:d,depthWrite:!1,depthTest:!1}),pu=new mi(new hi,mu),hu=new ap,{_lodPlanes:uu,_sizeLods:cu,_sigmas:du}=Cu(),Iu=new fA;let Gu=null;const Eu=(1+Math.sqrt(5))/2,ku=1/Eu,gu=[new Zn(1,1,1),new Zn(-1,1,1),new Zn(1,1,-1),new Zn(-1,1,-1),new Zn(0,Eu,ku),new Zn(0,Eu,-ku),new Zn(ku,0,Eu),new Zn(-ku,0,Eu),new Zn(Eu,ku,0),new Zn(-Eu,ku,0)];function fu(e){const t=Math.max(e.r,e.g,e.b),n=Math.min(Math.max(Math.ceil(Math.log2(t)),-128),127);return e.multiplyScalar(Math.pow(2,-n)),(n+128)/255}class Hu{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=function(e){const t=new Float32Array(20),n=new Zn(0,1,0);return new Pl({name:"SphericalGaussianBlur",defines:{n:20},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:lu[Qt]},outputEncoding:{value:lu[Qt]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:k,depthTest:!1,depthWrite:!1})}(),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,o=100){Gu=this._renderer.getRenderTarget();const A=this._allocateTargets();return this._sceneToCubeUV(e,n,o,A),t>0&&this._blur(A,0,0,t),this._applyPMREM(A),this._cleanup(A),A}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=ju(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=vu(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let e=0;e<uu.length;e++)uu[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Gu),e.scissorTest=!1,Ju(e,0,0,e.width,e.height)}_fromTexture(e){Gu=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:ce,minFilter:ce,generateMipmaps:!1,type:Ce,format:Re,encoding:Fu(e)?e.encoding:$t,depthBuffer:!1},n=Du(t);return n.depthBuffer=!e,this._pingPongRenderTarget=Du(t),n}_compileMaterial(e){const t=new mi(uu[0],e);this._renderer.compile(t,hu)}_sceneToCubeUV(e,t,n,o){const A=new Ei(90,1,t,n),i=[1,-1,1,1,1,1],r=[1,1,1,-1,-1,-1],s=this._renderer,a=s.autoClear,l=s.outputEncoding,m=s.toneMapping;s.getClearColor(Iu),s.toneMapping=Y,s.outputEncoding=Qt,s.autoClear=!1;let p=!1;const h=e.background;if(h){if(h.isColor){mu.color.copy(h).convertSRGBToLinear(),e.background=null;const t=fu(mu.color);mu.opacity=t,p=!0}}else{mu.color.copy(Iu).convertSRGBToLinear();const e=fu(mu.color);mu.opacity=e,p=!0}for(let t=0;t<6;t++){const n=t%3;0==n?(A.up.set(0,i[t],0),A.lookAt(r[t],0,0)):1==n?(A.up.set(0,0,i[t]),A.lookAt(0,r[t],0)):(A.up.set(0,i[t],0),A.lookAt(0,0,r[t])),Ju(o,n*ru,t>2?ru:0,ru,ru),s.setRenderTarget(o),p&&s.render(pu,A),s.render(e,A)}s.toneMapping=m,s.outputEncoding=l,s.autoClear=a}_textureToCubeUV(e,t){const n=this._renderer;e.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=ju()):null==this._equirectShader&&(this._equirectShader=vu());const o=e.isCubeTexture?this._cubemapShader:this._equirectShader,A=new mi(uu[0],o),i=o.uniforms;i.envMap.value=e,e.isCubeTexture||i.texelSize.value.set(1/e.image.width,1/e.image.height),i.inputEncoding.value=lu[e.encoding],i.outputEncoding.value=lu[t.texture.encoding],Ju(t,0,0,3*ru,2*ru),n.setRenderTarget(t),n.render(A,hu)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let t=1;t<au;t++){const n=Math.sqrt(du[t]*du[t]-du[t-1]*du[t-1]),o=gu[(t-1)%gu.length];this._blur(e,t-1,t,n,o)}t.autoClear=n}_blur(e,t,n,o,A){const i=this._pingPongRenderTarget;this._halfBlur(e,i,t,n,o,"latitudinal",A),this._halfBlur(i,e,n,n,o,"longitudinal",A)}_halfBlur(e,t,n,o,A,i,r){const s=this._renderer,a=this._blurMaterial;"latitudinal"!==i&&"longitudinal"!==i&&console.error("blur direction must be either latitudinal or longitudinal!");const l=new mi(uu[o],a),m=a.uniforms,p=cu[n]-1,h=isFinite(A)?Math.PI/(2*p):2*Math.PI/39,u=A/h,c=isFinite(A)?1+Math.floor(3*u):20;c>20&&console.warn(`sigmaRadians, ${A}, is too large and will clip, as it requested ${c} samples when the maximum is set to 20`);const d=[];let I=0;for(let e=0;e<20;++e){const t=e/u,n=Math.exp(-t*t/2);d.push(n),0==e?I+=n:e<c&&(I+=2*n)}for(let e=0;e<d.length;e++)d[e]=d[e]/I;m.envMap.value=e.texture,m.samples.value=c,m.weights.value=d,m.latitudinal.value="latitudinal"===i,r&&(m.poleAxis.value=r),m.dTheta.value=h,m.mipInt.value=8-n,m.inputEncoding.value=lu[e.texture.encoding],m.outputEncoding.value=lu[e.texture.encoding];const G=cu[o];Ju(t,3*Math.max(0,ru-2*G),(0===o?0:2*ru)+2*G*(o>4?o-8+4:0),3*G,2*G),s.setRenderTarget(t),s.render(l,hu)}}function Fu(e){return void 0!==e&&e.type===Ce&&(e.encoding===Qt||e.encoding===Zt||e.encoding===Yt)}function Cu(){const e=[],t=[],n=[];let o=8;for(let A=0;A<au;A++){const i=Math.pow(2,o);t.push(i);let r=1/i;A>4?r=su[A-8+4-1]:0==A&&(r=0),n.push(r);const s=1/(i-1),a=-s/2,l=1+s/2,m=[a,a,l,a,l,l,a,a,l,l,a,l],p=6,h=6,u=3,c=2,d=1,I=new Float32Array(u*h*p),G=new Float32Array(c*h*p),E=new Float32Array(d*h*p);for(let e=0;e<p;e++){const t=e%3*2/3-1,n=e>2?0:-1,o=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];I.set(o,u*h*e),G.set(m,c*h*e);const A=[e,e,e,e,e,e];E.set(A,d*h*e)}const k=new WA;k.setAttribute("position",new DA(I,u)),k.setAttribute("uv",new DA(G,c)),k.setAttribute("faceIndex",new DA(E,d)),e.push(k),o>4&&o--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function Du(e){const t=new zn(3*ru,3*ru,e);return t.texture.mapping=le,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Ju(e,t,n,o,A){e.viewport.set(t,n,o,A),e.scissor.set(t,n,o,A)}function vu(){const e=new Nn(1,1);return new Pl({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:lu[Qt]},outputEncoding:{value:lu[Qt]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:k,depthTest:!1,depthWrite:!1})}function ju(){return new Pl({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:lu[Qt]},outputEncoding:{value:lu[Qt]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:k,depthTest:!1,depthWrite:!1})}const Ku=0,yu=1,bu=0,qu=1,xu=2;function Bu(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e}function wu(e=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e}function Mu(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new La(e,t)}function Lu(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new ta(e)}function Su(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new La(e,t)}function Tu(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new qa(e)}function Nu(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new qa(e)}function Ru(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new qa(e)}function Ou(e,t,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Zn(e,t,n)}function Pu(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new DA(e,t).setUsage(Jn)}function Uu(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new JA(e,t)}function Vu(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new vA(e,t)}function Wu(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new jA(e,t)}function _u(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new KA(e,t)}function zu(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new yA(e,t)}function Xu(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new bA(e,t)}function Qu(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new qA(e,t)}function Zu(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new BA(e,t)}function Yu(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new wA(e,t)}function $u(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new nu(e)}function ec(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Xh(e,t)}function tc(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new ya(new Ya(e.geometry),new fa({color:void 0!==t?t:16777215}))}function nc(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new ya(new Nl(e.geometry),new fa({color:void 0!==t?t:16777215}))}function oc(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new km(e)}function Ac(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new Cm(e)}function ic(e,t,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Hi(e,n)}function rc(){console.error("THREE.CanvasRenderer has been removed")}function sc(){console.error("THREE.JSONLoader has been removed.")}Jm.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Jm.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},_m.prototype.fromPoints=function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)},Sh.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},bh.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Gm.prototype.extractUrlBase=function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Ip.extractUrlBase(e)},Gm.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},fh.prototype.center=function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},fh.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},fh.prototype.isIntersectionBox=function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},fh.prototype.size=function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)},eo.prototype.center=function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},eo.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},eo.prototype.isIntersectionBox=function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},eo.prototype.isIntersectionSphere=function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},eo.prototype.size=function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)},Go.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Ji.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},Ch.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Tn.random16=function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},Tn.nearestPowerOfTwo=function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),Tn.floorPowerOfTwo(e)},Tn.nextPowerOfTwo=function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),Tn.ceilPowerOfTwo(e)},Rn.prototype.flattenToArrayOffset=function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},Rn.prototype.multiplyVector3=function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},Rn.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},Rn.prototype.applyToBufferAttribute=function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},Rn.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},Rn.prototype.getInverse=function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()},Jo.prototype.extractPosition=function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},Jo.prototype.flattenToArrayOffset=function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},Jo.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new Zn).setFromMatrixColumn(this,3)},Jo.prototype.setRotationFromQuaternion=function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},Jo.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Jo.prototype.multiplyVector3=function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Jo.prototype.multiplyVector4=function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Jo.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Jo.prototype.rotateAxis=function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},Jo.prototype.crossVector=function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Jo.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Jo.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Jo.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Jo.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Jo.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Jo.prototype.applyToBufferAttribute=function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Jo.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Jo.prototype.makeFrustum=function(e,t,n,o,A,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,o,n,A,i)},Jo.prototype.getInverse=function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()},tA.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},Qn.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},Qn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Do.prototype.isIntersectionBox=function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},Do.prototype.isIntersectionPlane=function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},Do.prototype.isIntersectionSphere=function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},hA.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},hA.prototype.barycoordFromPoint=function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},hA.prototype.midpoint=function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},hA.prototypenormal=function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},hA.prototype.plane=function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)},hA.barycoordFromPoint=function(e,t,n,o,A){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),hA.getBarycoord(e,t,n,o,A)},hA.normal=function(e,t,n,o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),hA.getNormal(e,t,n,o)},zm.prototype.extractAllPoints=function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},zm.prototype.extrude=function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Jl(this,e)},zm.prototype.makeGeometry=function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new xl(this,e)},Nn.prototype.fromAttribute=function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},Nn.prototype.distanceToManhattan=function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},Nn.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Zn.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},Zn.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},Zn.prototype.getPositionFromMatrix=function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},Zn.prototype.getScaleFromMatrix=function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},Zn.prototype.getColumnFromMatrix=function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},Zn.prototype.applyProjection=function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},Zn.prototype.fromAttribute=function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},Zn.prototype.distanceToManhattan=function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},Zn.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},_n.prototype.fromAttribute=function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},_n.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Zo.prototype.getChildByName=function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},Zo.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},Zo.prototype.translate=function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},Zo.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},Zo.prototype.applyMatrix=function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},Object.defineProperties(Zo.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),mi.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(mi.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),_t},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(ia.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(da.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),pa.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(Jm.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),Ei.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(Xm.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(DA.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Jn},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Jn)}}}),DA.prototype.setDynamic=function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?Jn:Dn),this},DA.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},DA.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},WA.prototype.addIndex=function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},WA.prototype.addAttribute=function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new DA(arguments[1],arguments[2])))},WA.prototype.addDrawCall=function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},WA.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},WA.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},WA.prototype.removeAttribute=function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},WA.prototype.applyMatrix=function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},Object.defineProperties(WA.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(Gp.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(dh.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(Ss.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Jn},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Ss.prototype.setDynamic=function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?Jn:Dn),this},Ss.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Jl.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Jl.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Jl.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},Ls.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Object.defineProperties(hh.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(cA.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new fA}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===G}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(Wl.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Vl.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(Ii.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),xs.prototype.clearTarget=function(e,t,n,o){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,o)},xs.prototype.animate=function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},xs.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},xs.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},xs.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},xs.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},xs.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},xs.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},xs.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},xs.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},xs.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},xs.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},xs.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},xs.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},xs.prototype.enableScissorTest=function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},xs.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},xs.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},xs.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},xs.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},xs.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},xs.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},xs.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},xs.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},xs.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},xs.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(xs.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?Zt:Qt}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(Cs.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(zn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Up.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return(new bp).load(e,(function(e){t.setBuffer(e)})),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),Qp.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},gi.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)},gi.prototype.clear=function(e,t,n,o){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,n,o)},Pn.crossOrigin=void 0,Pn.loadTexture=function(e,t,n,o){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const A=new Dm;A.setCrossOrigin(this.crossOrigin);const i=A.load(e,n,void 0,o);return t&&(i.mapping=t),i},Pn.loadTextureCube=function(e,t,n,o){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const A=new Fm;A.setCrossOrigin(this.crossOrigin);const i=A.load(e,n,void 0,o);return t&&(i.mapping=t),i},Pn.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Pn.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const ac={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function lc(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:o}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=o)},6498:function(e,t){!function(e){"use strict";class t{constructor(e){this.controller_=e}get disabled(){return this.controller_.viewProps.get("disabled")}set disabled(e){this.controller_.viewProps.set("disabled",e)}get hidden(){return this.controller_.viewProps.get("hidden")}set hidden(e){this.controller_.viewProps.set("hidden",e)}dispose(){this.controller_.viewProps.set("disposed",!0)}}class n{constructor(e){this.target=e}}class o extends n{constructor(e,t,n,o){super(e),this.value=t,this.presetKey=n,this.last=null==o||o}}class A extends n{constructor(e,t,n){super(e),this.value=t,this.presetKey=n}}class i extends n{constructor(e,t){super(e),this.expanded=t}}function r(e){return null==e}function s(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}const a={alreadydisposed:()=>"View has been already disposed",invalidparams:e=>`Invalid parameters for '${e.name}'`,nomatchingcontroller:e=>`No matching controller for '${e.key}'`,nomatchingview:e=>`No matching view for '${JSON.stringify(e.params)}'`,notbindable:()=>"Value is not bindable",propertynotfound:e=>`Property '${e.name}' not found`,shouldneverhappen:()=>"This error should never happen"};class l{constructor(e){var t;this.message=null!==(t=a[e.type](e.context))&&void 0!==t?t:"Unexpected error",this.name=this.constructor.name,this.stack=new Error(this.message).stack,this.type=e.type}static alreadyDisposed(){return new l({type:"alreadydisposed"})}static notBindable(){return new l({type:"notbindable"})}static propertyNotFound(e){return new l({type:"propertynotfound",context:{name:e}})}static shouldNeverHappen(){return new l({type:"shouldneverhappen"})}}class m{constructor(e,t,n){this.obj_=e,this.key_=t,this.presetKey_=null!=n?n:t}static isBindable(e){return null!==e&&"object"==typeof e}get key(){return this.key_}get presetKey(){return this.presetKey_}read(){return this.obj_[this.key_]}write(e){this.obj_[this.key_]=e}writeProperty(e,t){const n=this.read();if(!m.isBindable(n))throw l.notBindable();if(!(e in n))throw l.propertyNotFound(e);n[e]=t}}class p extends t{get label(){return this.controller_.props.get("label")}set label(e){this.controller_.props.set("label",e)}get title(){var e;return null!==(e=this.controller_.valueController.props.get("title"))&&void 0!==e?e:""}set title(e){this.controller_.valueController.props.set("title",e)}on(e,t){const o=t.bind(this);return this.controller_.valueController.emitter.on(e,(()=>{o(new n(this))})),this}}class h{constructor(){this.observers_={}}on(e,t){let n=this.observers_[e];return n||(n=this.observers_[e]=[]),n.push({handler:t}),this}off(e,t){const n=this.observers_[e];return n&&(this.observers_[e]=n.filter((e=>e.handler!==t))),this}emit(e,t){const n=this.observers_[e];n&&n.forEach((e=>{e.handler(t)}))}}const u="tp";function c(e){return(t,n)=>[u,"-",e,"v",t?`_${t}`:"",n?`-${n}`:""].join("")}function d(e){return e.rawValue}function I(e,t){var n,o;e.emitter.on("change",(n=d,o=t,e=>o(n(e)))),t(e.rawValue)}function G(e,t,n){I(e.value(t),n)}function E(e,t){return n=>{!function(e,t,n){n?e.classList.add(t):e.classList.remove(t)}(e,t,n)}}function k(e,t){I(e,(e=>{t.textContent=null!=e?e:""}))}const g=c("btn");class f{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(g()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("button");n.classList.add(g("b")),t.viewProps.bindDisabled(n),this.element.appendChild(n),this.buttonElement=n;const o=e.createElement("div");o.classList.add(g("t")),k(t.props.value("title"),o),this.buttonElement.appendChild(o)}}class H{constructor(e,t){this.emitter=new h,this.onClick_=this.onClick_.bind(this),this.props=t.props,this.viewProps=t.viewProps,this.view=new f(e,{props:this.props,viewProps:this.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class F{constructor(e,t){var n;this.constraint_=null==t?void 0:t.constraint,this.equals_=null!==(n=null==t?void 0:t.equals)&&void 0!==n?n:(e,t)=>e===t,this.emitter=new h,this.rawValue_=e}get constraint(){return this.constraint_}get rawValue(){return this.rawValue_}set rawValue(e){this.setRawValue(e,{forceEmit:!1,last:!0})}setRawValue(e,t){const n=null!=t?t:{forceEmit:!1,last:!0},o=this.constraint_?this.constraint_.constrain(e):e;(!this.equals_(this.rawValue_,o)||n.forceEmit)&&(this.emitter.emit("beforechange",{sender:this}),this.rawValue_=o,this.emitter.emit("change",{options:n,rawValue:o,sender:this}))}}class C{constructor(e){this.emitter=new h,this.value_=e}get rawValue(){return this.value_}set rawValue(e){this.setRawValue(e,{forceEmit:!1,last:!0})}setRawValue(e,t){const n=null!=t?t:{forceEmit:!1,last:!0};(this.value_!==e||n.forceEmit)&&(this.emitter.emit("beforechange",{sender:this}),this.value_=e,this.emitter.emit("change",{options:n,rawValue:this.value_,sender:this}))}}function D(e,t){const n=null==t?void 0:t.constraint,o=null==t?void 0:t.equals;return n||o?new F(e,t):new C(e)}class J{constructor(e){this.emitter=new h,this.valMap_=e;for(const e in this.valMap_)this.valMap_[e].emitter.on("change",(()=>{this.emitter.emit("change",{key:e,sender:this})}))}static createCore(e){return Object.keys(e).reduce(((t,n)=>Object.assign(t,{[n]:D(e[n])})),{})}static fromObject(e){const t=this.createCore(e);return new J(t)}get(e){return this.valMap_[e].rawValue}set(e,t){this.valMap_[e].rawValue=t}value(e){return this.valMap_[e]}}function v(e){return t=>n=>{if(!t&&void 0===n)return{succeeded:!1,value:void 0};if(t&&void 0===n)return{succeeded:!0,value:void 0};const o=e(n);return void 0!==o?{succeeded:!0,value:o}:{succeeded:!1,value:void 0}}}function j(e){return{custom:t=>v(t)(e),boolean:v((e=>"boolean"==typeof e?e:void 0))(e),number:v((e=>"number"==typeof e?e:void 0))(e),string:v((e=>"string"==typeof e?e:void 0))(e),function:v((e=>"function"==typeof e?e:void 0))(e),constant:t=>v((e=>e===t?t:void 0))(e),raw:v((e=>e))(e),object:t=>v((e=>{if(null!==(n=e)&&"object"==typeof n)return function(e,t){return Object.keys(t).reduce(((n,o)=>{if(void 0===n)return;const A=(0,t[o])(e[o]);return A.succeeded?Object.assign(Object.assign({},n),{[o]:A.value}):void 0}),{})}(e,t);var n}))(e),array:t=>v((e=>{if(Array.isArray(e))return n=t,e.reduce(((e,t)=>{if(void 0===e)return;const o=n(t);return o.succeeded&&void 0!==o.value?[...e,o.value]:void 0}),[]);var n}))(e)}}const K={optional:j(!0),required:j(!1)};function y(e,t){const n=K.required.object(t)(e);return n.succeeded?n.value:void 0}const b=c(""),q={veryfirst:"vfst",first:"fst",last:"lst",verylast:"vlst"};class x{constructor(e){this.parent_=null,this.blade=e.blade,this.view=e.view,this.viewProps=e.viewProps;const t=this.view.element;this.blade.value("positions").emitter.on("change",(()=>{["veryfirst","first","last","verylast"].forEach((e=>{t.classList.remove(b(void 0,q[e]))})),this.blade.get("positions").forEach((e=>{t.classList.add(b(void 0,q[e]))}))})),this.viewProps.handleDispose((()=>{!function(e){e&&e.parentElement&&e.parentElement.removeChild(e)}(t)}))}get parent(){return this.parent_}}const B="http://www.w3.org/2000/svg";function w(e){e.offsetHeight}function M(e){return void 0!==e.ontouchstart}function L(){return new Function("return this")()}function S(e){return"document"in L()?e.getContext("2d"):null}const T={check:'<path d="M2 8l4 4l8 -8"/>',dropdown:'<path d="M5 7h6l-3 3 z"/>',p2dpad:'<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'};function N(e,t){const n=e.createElementNS(B,"svg");return n.innerHTML=T[t],n}function R(e,t,n){e.insertBefore(t,e.children[n])}function O(e){e.parentElement&&e.parentElement.removeChild(e)}function P(e){for(;e.children.length>0;)e.removeChild(e.children[0])}function U(e){return e.relatedTarget?e.relatedTarget:"explicitOriginalTarget"in e?e.explicitOriginalTarget:null}const V=c("lbl");class W{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(V()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("div");n.classList.add(V("l")),G(t.props,"label",(t=>{r(t)?this.element.classList.add(V(void 0,"nol")):(this.element.classList.remove(V(void 0,"nol")),function(e){for(;e.childNodes.length>0;)e.removeChild(e.childNodes[0])}(n),n.appendChild(function(e,t){const n=e.createDocumentFragment();return t.split("\n").map((t=>e.createTextNode(t))).forEach(((t,o)=>{o>0&&n.appendChild(e.createElement("br")),n.appendChild(t)})),n}(e,t)))})),this.element.appendChild(n),this.labelElement=n;const o=e.createElement("div");o.classList.add(V("v")),this.element.appendChild(o),this.valueElement=o}}class _ extends x{constructor(e,t){const n=t.valueController.viewProps;super(Object.assign(Object.assign({},t),{view:new W(e,{props:t.props,viewProps:n}),viewProps:n})),this.props=t.props,this.valueController=t.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}const z={id:"button",type:"blade",accept(e){const t=K,n=y(e,{title:t.required.string,view:t.required.constant("button"),label:t.optional.string});return n?{params:n}:null},controller:e=>new _(e.document,{blade:e.blade,props:J.fromObject({label:e.params.label}),valueController:new H(e.document,{props:J.fromObject({title:e.params.title}),viewProps:e.viewProps})}),api:e=>e.controller instanceof _&&e.controller.valueController instanceof H?new p(e.controller):null};class X extends x{constructor(e){super(e),this.value=e.value}}function Q(){return new J({positions:D([],{equals:s})})}class Z extends J{constructor(e){super(e)}static create(e){const t={completed:!0,expanded:e,expandedHeight:null,shouldFixHeight:!1,temporaryExpanded:null},n=J.createCore(t);return new Z(n)}get styleExpanded(){var e;return null!==(e=this.get("temporaryExpanded"))&&void 0!==e?e:this.get("expanded")}get styleHeight(){if(!this.styleExpanded)return"0";const e=this.get("expandedHeight");return this.get("shouldFixHeight")&&!r(e)?`${e}px`:"auto"}bindExpandedClass(e,t){G(this,"expanded",(()=>{this.styleExpanded?e.classList.add(t):e.classList.remove(t)}))}}function Y(e,t){t.style.height=e.styleHeight}function $(e,t){e.value("expanded").emitter.on("beforechange",(()=>{e.set("completed",!1),r(e.get("expandedHeight"))&&e.set("expandedHeight",function(e,t){let n=0;return function(e,t){const n=e.style.transition;e.style.transition="none",t(),e.style.transition=n}(t,(()=>{e.set("expandedHeight",null),e.set("temporaryExpanded",!0),w(t),n=t.clientHeight,e.set("temporaryExpanded",null),w(t)})),n}(e,t)),e.set("shouldFixHeight",!0),w(t)})),e.emitter.on("change",(()=>{Y(e,t)})),Y(e,t),t.addEventListener("transitionend",(t=>{"height"===t.propertyName&&(e.set("shouldFixHeight",!1),e.set("expandedHeight",null),e.set("completed",!0))}))}class ee extends t{constructor(e,t){super(e),this.rackApi_=t}}class te{constructor(e){this.emitter=new h,this.items_=[],this.cache_=new Set,this.onSubListAdd_=this.onSubListAdd_.bind(this),this.onSubListRemove_=this.onSubListRemove_.bind(this),this.extract_=e}get items(){return this.items_}allItems(){return Array.from(this.cache_)}find(e){for(const t of this.allItems())if(e(t))return t;return null}includes(e){return this.cache_.has(e)}add(e,t){if(this.includes(e))throw l.shouldNeverHappen();const n=void 0!==t?t:this.items_.length;this.items_.splice(n,0,e),this.cache_.add(e);const o=this.extract_(e);o&&(o.emitter.on("add",this.onSubListAdd_),o.emitter.on("remove",this.onSubListRemove_),o.allItems().forEach((e=>{this.cache_.add(e)}))),this.emitter.emit("add",{index:n,item:e,root:this,target:this})}remove(e){const t=this.items_.indexOf(e);if(t<0)return;this.items_.splice(t,1),this.cache_.delete(e);const n=this.extract_(e);n&&(n.emitter.off("add",this.onSubListAdd_),n.emitter.off("remove",this.onSubListRemove_)),this.emitter.emit("remove",{index:t,item:e,root:this,target:this})}onSubListAdd_(e){this.cache_.add(e.item),this.emitter.emit("add",{index:e.index,item:e.item,root:this,target:e.target})}onSubListRemove_(e){this.cache_.delete(e.item),this.emitter.emit("remove",{index:e.index,item:e.item,root:this,target:e.target})}}class ne extends t{constructor(e){super(e),this.onBindingChange_=this.onBindingChange_.bind(this),this.emitter_=new h,this.controller_.binding.emitter.on("change",this.onBindingChange_)}get label(){return this.controller_.props.get("label")}set label(e){this.controller_.props.set("label",e)}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}refresh(){this.controller_.binding.read()}onBindingChange_(e){const t=e.sender.target.read();this.emitter_.emit("change",{event:new o(this,t,this.controller_.binding.target.presetKey,e.options.last)})}}class oe extends _{constructor(e,t){super(e,t),this.binding=t.binding}}class Ae extends t{constructor(e){super(e),this.onBindingUpdate_=this.onBindingUpdate_.bind(this),this.emitter_=new h,this.controller_.binding.emitter.on("update",this.onBindingUpdate_)}get label(){return this.controller_.props.get("label")}set label(e){this.controller_.props.set("label",e)}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}refresh(){this.controller_.binding.read()}onBindingUpdate_(e){const t=e.sender.target.read();this.emitter_.emit("update",{event:new A(this,t,this.controller_.binding.target.presetKey)})}}class ie extends _{constructor(e,t){super(e,t),this.binding=t.binding,this.viewProps.bindDisabled(this.binding.ticker),this.viewProps.handleDispose((()=>{this.binding.dispose()}))}}function re(e){return e instanceof le?e.apiSet_:e instanceof ee?e.rackApi_.apiSet_:null}function se(e,t){const n=e.find((e=>e.controller_===t));if(!n)throw l.shouldNeverHappen();return n}function ae(e,t,n){if(!m.isBindable(e))throw l.notBindable();return new m(e,t,n)}class le extends t{constructor(e,t){super(e),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this),this.onRackInputChange_=this.onRackInputChange_.bind(this),this.onRackMonitorUpdate_=this.onRackMonitorUpdate_.bind(this),this.emitter_=new h,this.apiSet_=new te(re),this.pool_=t;const n=this.controller_.rack;n.emitter.on("add",this.onRackAdd_),n.emitter.on("remove",this.onRackRemove_),n.emitter.on("inputchange",this.onRackInputChange_),n.emitter.on("monitorupdate",this.onRackMonitorUpdate_),n.children.forEach((e=>{this.setUpApi_(e)}))}get children(){return this.controller_.rack.children.map((e=>se(this.apiSet_,e)))}addInput(e,t,n){const o=n||{},A=this.controller_.view.element.ownerDocument,i=this.pool_.createInput(A,ae(e,t,o.presetKey),o),r=new ne(i);return this.add(r,o.index)}addMonitor(e,t,n){const o=n||{},A=this.controller_.view.element.ownerDocument,i=this.pool_.createMonitor(A,ae(e,t),o),r=new Ae(i);return this.add(r,o.index)}addFolder(e){return function(e,t){return e.addBlade(Object.assign(Object.assign({},t),{view:"folder"}))}(this,e)}addButton(e){return function(e,t){return e.addBlade(Object.assign(Object.assign({},t),{view:"button"}))}(this,e)}addSeparator(e){return function(e,t){const n=t||{};return e.addBlade(Object.assign(Object.assign({},n),{view:"separator"}))}(this,e)}addTab(e){return function(e,t){return e.addBlade(Object.assign(Object.assign({},t),{view:"tab"}))}(this,e)}add(e,t){this.controller_.rack.add(e.controller_,t);const n=this.apiSet_.find((t=>t.controller_===e.controller_));return n&&this.apiSet_.remove(n),this.apiSet_.add(e),e}remove(e){this.controller_.rack.remove(e.controller_)}addBlade(e){const t=this.controller_.view.element.ownerDocument,n=this.pool_.createBlade(t,e),o=this.pool_.createBladeApi(n);return this.add(o,e.index)}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}setUpApi_(e){this.apiSet_.find((t=>t.controller_===e))||this.apiSet_.add(this.pool_.createBladeApi(e))}onRackAdd_(e){this.setUpApi_(e.bladeController)}onRackRemove_(e){if(e.isRoot){const t=se(this.apiSet_,e.bladeController);this.apiSet_.remove(t)}}onRackInputChange_(e){const t=e.bladeController;if(t instanceof oe){const n=se(this.apiSet_,t),A=t.binding;this.emitter_.emit("change",{event:new o(n,A.target.read(),A.target.presetKey,e.options.last)})}else if(t instanceof X){const n=se(this.apiSet_,t);this.emitter_.emit("change",{event:new o(n,t.value.rawValue,void 0,e.options.last)})}}onRackMonitorUpdate_(e){if(!(e.bladeController instanceof ie))throw l.shouldNeverHappen();const t=se(this.apiSet_,e.bladeController),n=e.bladeController.binding;this.emitter_.emit("update",{event:new A(t,n.target.read(),n.target.presetKey)})}}class me extends ee{constructor(e,t){super(e,new le(e.rackController,t)),this.emitter_=new h,this.controller_.foldable.value("expanded").emitter.on("change",(e=>{this.emitter_.emit("fold",{event:new i(this,e.sender.rawValue)})})),this.rackApi_.on("change",(e=>{this.emitter_.emit("change",{event:e})})),this.rackApi_.on("update",(e=>{this.emitter_.emit("update",{event:e})}))}get expanded(){return this.controller_.foldable.get("expanded")}set expanded(e){this.controller_.foldable.set("expanded",e)}get title(){return this.controller_.props.get("title")}set title(e){this.controller_.props.set("title",e)}get children(){return this.rackApi_.children}addInput(e,t,n){return this.rackApi_.addInput(e,t,n)}addMonitor(e,t,n){return this.rackApi_.addMonitor(e,t,n)}addFolder(e){return this.rackApi_.addFolder(e)}addButton(e){return this.rackApi_.addButton(e)}addSeparator(e){return this.rackApi_.addSeparator(e)}addTab(e){return this.rackApi_.addTab(e)}add(e,t){return this.rackApi_.add(e,t)}remove(e){this.rackApi_.remove(e)}addBlade(e){return this.rackApi_.addBlade(e)}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}}class pe extends x{constructor(e){super({blade:e.blade,view:e.view,viewProps:e.rackController.viewProps}),this.rackController=e.rackController}}class he{constructor(e,t){const n=c(t.viewName);this.element=e.createElement("div"),this.element.classList.add(n()),t.viewProps.bindClassModifiers(this.element)}}function ue(e){return e instanceof Ie?e.rack:e instanceof pe?e.rackController.rack:null}function ce(e){const t=ue(e);return t?t.bcSet_:null}class de{constructor(e){var t;this.onBladePositionsChange_=this.onBladePositionsChange_.bind(this),this.onSetAdd_=this.onSetAdd_.bind(this),this.onSetRemove_=this.onSetRemove_.bind(this),this.onChildDispose_=this.onChildDispose_.bind(this),this.onChildPositionsChange_=this.onChildPositionsChange_.bind(this),this.onChildInputChange_=this.onChildInputChange_.bind(this),this.onChildMonitorUpdate_=this.onChildMonitorUpdate_.bind(this),this.onChildValueChange_=this.onChildValueChange_.bind(this),this.onChildViewPropsChange_=this.onChildViewPropsChange_.bind(this),this.onDescendantLayout_=this.onDescendantLayout_.bind(this),this.onDescendantInputChange_=this.onDescendantInputChange_.bind(this),this.onDescendantMonitorUpdate_=this.onDescendantMonitorUpdate_.bind(this),this.emitter=new h,this.blade_=null!=e?e:null,null===(t=this.blade_)||void 0===t||t.value("positions").emitter.on("change",this.onBladePositionsChange_),this.bcSet_=new te(ce),this.bcSet_.emitter.on("add",this.onSetAdd_),this.bcSet_.emitter.on("remove",this.onSetRemove_)}get children(){return this.bcSet_.items}add(e,t){e.parent&&e.parent.remove(e),e.parent_=this,this.bcSet_.add(e,t)}remove(e){e.parent_=null,this.bcSet_.remove(e)}find(e){return this.bcSet_.allItems().filter((t=>t instanceof e))}onSetAdd_(e){this.updatePositions_();const t=e.target===e.root;if(this.emitter.emit("add",{bladeController:e.item,index:e.index,isRoot:t,sender:this}),!t)return;const n=e.item;if(n.viewProps.emitter.on("change",this.onChildViewPropsChange_),n.blade.value("positions").emitter.on("change",this.onChildPositionsChange_),n.viewProps.handleDispose(this.onChildDispose_),n instanceof oe)n.binding.emitter.on("change",this.onChildInputChange_);else if(n instanceof ie)n.binding.emitter.on("update",this.onChildMonitorUpdate_);else if(n instanceof X)n.value.emitter.on("change",this.onChildValueChange_);else{const e=ue(n);if(e){const t=e.emitter;t.on("layout",this.onDescendantLayout_),t.on("inputchange",this.onDescendantInputChange_),t.on("monitorupdate",this.onDescendantMonitorUpdate_)}}}onSetRemove_(e){this.updatePositions_();const t=e.target===e.root;if(this.emitter.emit("remove",{bladeController:e.item,isRoot:t,sender:this}),!t)return;const n=e.item;if(n instanceof oe)n.binding.emitter.off("change",this.onChildInputChange_);else if(n instanceof ie)n.binding.emitter.off("update",this.onChildMonitorUpdate_);else if(n instanceof X)n.value.emitter.off("change",this.onChildValueChange_);else{const e=ue(n);if(e){const t=e.emitter;t.off("layout",this.onDescendantLayout_),t.off("inputchange",this.onDescendantInputChange_),t.off("monitorupdate",this.onDescendantMonitorUpdate_)}}}updatePositions_(){const e=this.bcSet_.items.filter((e=>!e.viewProps.get("hidden"))),t=e[0],n=e[e.length-1];this.bcSet_.items.forEach((e=>{const o=[];e===t&&(o.push("first"),this.blade_&&!this.blade_.get("positions").includes("veryfirst")||o.push("veryfirst")),e===n&&(o.push("last"),this.blade_&&!this.blade_.get("positions").includes("verylast")||o.push("verylast")),e.blade.set("positions",o)}))}onChildPositionsChange_(){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildViewPropsChange_(e){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildDispose_(){this.bcSet_.items.filter((e=>e.viewProps.get("disposed"))).forEach((e=>{this.bcSet_.remove(e)}))}onChildInputChange_(e){const t=function(e,t){for(let n=0;n<e.length;n++){const o=e[n];if(o instanceof oe&&o.binding===t)return o}return null}(this.find(oe),e.sender);if(!t)throw l.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:t,options:e.options,sender:this})}onChildMonitorUpdate_(e){const t=function(e,t){for(let n=0;n<e.length;n++){const o=e[n];if(o instanceof ie&&o.binding===t)return o}return null}(this.find(ie),e.sender);if(!t)throw l.shouldNeverHappen();this.emitter.emit("monitorupdate",{bladeController:t,sender:this})}onChildValueChange_(e){const t=function(e,t){for(let n=0;n<e.length;n++){const o=e[n];if(o instanceof X&&o.value===t)return o}return null}(this.find(X),e.sender);if(!t)throw l.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:t,options:e.options,sender:this})}onDescendantLayout_(e){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onDescendantInputChange_(e){this.emitter.emit("inputchange",{bladeController:e.bladeController,options:e.options,sender:this})}onDescendantMonitorUpdate_(e){this.emitter.emit("monitorupdate",{bladeController:e.bladeController,sender:this})}onBladePositionsChange_(){this.updatePositions_()}}class Ie extends x{constructor(e,t){super(Object.assign(Object.assign({},t),{view:new he(e,{viewName:"brk",viewProps:t.viewProps})})),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this);const n=new de(t.root?void 0:t.blade);n.emitter.on("add",this.onRackAdd_),n.emitter.on("remove",this.onRackRemove_),this.rack=n,this.viewProps.handleDispose((()=>{for(let e=this.rack.children.length-1;e>=0;e--)this.rack.children[e].viewProps.set("disposed",!0)}))}onRackAdd_(e){e.isRoot&&R(this.view.element,e.bladeController.view.element,e.index)}onRackRemove_(e){e.isRoot&&O(e.bladeController.view.element)}}const Ge=c("cnt");class Ee{constructor(e,t){this.className_=c(t.viewName||"fld"),this.element=e.createElement("div"),this.element.classList.add(this.className_(),Ge()),t.viewProps.bindClassModifiers(this.element),this.foldable_=t.foldable,this.foldable_.bindExpandedClass(this.element,this.className_(void 0,"expanded")),G(this.foldable_,"completed",E(this.element,this.className_(void 0,"cpl")));const n=e.createElement("button");n.classList.add(this.className_("b")),G(t.props,"title",(e=>{r(e)?this.element.classList.add(this.className_(void 0,"not")):this.element.classList.remove(this.className_(void 0,"not"))})),t.viewProps.bindDisabled(n),this.element.appendChild(n),this.buttonElement=n;const o=e.createElement("div");o.classList.add(this.className_("t")),k(t.props.value("title"),o),this.buttonElement.appendChild(o),this.titleElement=o;const A=e.createElement("div");A.classList.add(this.className_("m")),this.buttonElement.appendChild(A);const i=t.containerElement;i.classList.add(this.className_("c")),this.element.appendChild(i),this.containerElement=i}}class ke extends pe{constructor(e,t){var n;const o=Z.create(null===(n=t.expanded)||void 0===n||n),A=new Ie(e,{blade:t.blade,root:t.root,viewProps:t.viewProps});super(Object.assign(Object.assign({},t),{rackController:A,view:new Ee(e,{containerElement:A.view.element,foldable:o,props:t.props,viewName:t.root?"rot":void 0,viewProps:t.viewProps})})),this.onTitleClick_=this.onTitleClick_.bind(this),this.props=t.props,this.foldable=o,$(this.foldable,this.view.containerElement),this.view.buttonElement.addEventListener("click",this.onTitleClick_)}get document(){return this.view.element.ownerDocument}onTitleClick_(){this.foldable.set("expanded",!this.foldable.get("expanded"))}}const ge={id:"folder",type:"blade",accept(e){const t=K,n=y(e,{title:t.required.string,view:t.required.constant("folder"),expanded:t.optional.boolean});return n?{params:n}:null},controller:e=>new ke(e.document,{blade:e.blade,expanded:e.params.expanded,props:J.fromObject({title:e.params.title}),viewProps:e.viewProps}),api:e=>e.controller instanceof ke?new me(e.controller,e.pool):null};class fe extends X{constructor(e,t){const n=t.valueController.viewProps;super(Object.assign(Object.assign({},t),{value:t.valueController.value,view:new W(e,{props:t.props,viewProps:n}),viewProps:n})),this.props=t.props,this.valueController=t.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}class He extends t{}const Fe=c("spr");class Ce{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(Fe()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("hr");n.classList.add(Fe("r")),this.element.appendChild(n)}}class De extends x{constructor(e,t){super(Object.assign(Object.assign({},t),{view:new Ce(e,{viewProps:t.viewProps})}))}}const Je={id:"separator",type:"blade",accept(e){const t=y(e,{view:K.required.constant("separator")});return t?{params:t}:null},controller:e=>new De(e.document,{blade:e.blade,viewProps:e.viewProps}),api:e=>e.controller instanceof De?new He(e.controller):null},ve=c("");function je(e,t){return E(e,ve(void 0,t))}class Ke extends J{constructor(e){super(e)}static create(e){var t,n;const o=null!=e?e:{},A={disabled:null!==(t=o.disabled)&&void 0!==t&&t,disposed:!1,hidden:null!==(n=o.hidden)&&void 0!==n&&n},i=J.createCore(A);return new Ke(i)}bindClassModifiers(e){G(this,"disabled",je(e,"disabled")),G(this,"hidden",je(e,"hidden"))}bindDisabled(e){G(this,"disabled",(t=>{e.disabled=t}))}bindTabIndex(e){G(this,"disabled",(t=>{e.tabIndex=t?-1:0}))}handleDispose(e){this.value("disposed").emitter.on("change",(t=>{t&&e()}))}}const ye=c("tbi");class be{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(ye()),t.viewProps.bindClassModifiers(this.element),G(t.props,"selected",(e=>{e?this.element.classList.add(ye(void 0,"sel")):this.element.classList.remove(ye(void 0,"sel"))}));const n=e.createElement("button");n.classList.add(ye("b")),t.viewProps.bindDisabled(n),this.element.appendChild(n),this.buttonElement=n;const o=e.createElement("div");o.classList.add(ye("t")),k(t.props.value("title"),o),this.buttonElement.appendChild(o),this.titleElement=o}}class qe{constructor(e,t){this.emitter=new h,this.onClick_=this.onClick_.bind(this),this.props=t.props,this.viewProps=t.viewProps,this.view=new be(e,{props:t.props,viewProps:t.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class xe{constructor(e,t){this.onItemClick_=this.onItemClick_.bind(this),this.ic_=new qe(e,{props:t.itemProps,viewProps:Ke.create()}),this.ic_.emitter.on("click",this.onItemClick_),this.cc_=new Ie(e,{blade:Q(),viewProps:Ke.create()}),this.props=t.props,G(this.props,"selected",(e=>{this.itemController.props.set("selected",e),this.contentController.viewProps.set("hidden",!e)}))}get itemController(){return this.ic_}get contentController(){return this.cc_}onItemClick_(){this.props.set("selected",!0)}}class Be{constructor(e,t){this.controller_=e,this.rackApi_=t}get title(){var e;return null!==(e=this.controller_.itemController.props.get("title"))&&void 0!==e?e:""}set title(e){this.controller_.itemController.props.set("title",e)}get selected(){return this.controller_.props.get("selected")}set selected(e){this.controller_.props.set("selected",e)}get children(){return this.rackApi_.children}addButton(e){return this.rackApi_.addButton(e)}addFolder(e){return this.rackApi_.addFolder(e)}addSeparator(e){return this.rackApi_.addSeparator(e)}addTab(e){return this.rackApi_.addTab(e)}add(e,t){this.rackApi_.add(e,t)}remove(e){this.rackApi_.remove(e)}addInput(e,t,n){return this.rackApi_.addInput(e,t,n)}addMonitor(e,t,n){return this.rackApi_.addMonitor(e,t,n)}addBlade(e){return this.rackApi_.addBlade(e)}}class we extends ee{constructor(e,t){super(e,new le(e.rackController,t)),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.emitter_=new h,this.pageApiMap_=new Map,this.rackApi_.on("change",(e=>{this.emitter_.emit("change",{event:e})})),this.rackApi_.on("update",(e=>{this.emitter_.emit("update",{event:e})})),this.controller_.pageSet.emitter.on("add",this.onPageAdd_),this.controller_.pageSet.emitter.on("remove",this.onPageRemove_),this.controller_.pageSet.items.forEach((e=>{this.setUpPageApi_(e)}))}get pages(){return this.controller_.pageSet.items.map((e=>{const t=this.pageApiMap_.get(e);if(!t)throw l.shouldNeverHappen();return t}))}addPage(e){const t=this.controller_.view.element.ownerDocument,n=new xe(t,{itemProps:J.fromObject({selected:!1,title:e.title}),props:J.fromObject({selected:!1})});this.controller_.add(n,e.index);const o=this.pageApiMap_.get(n);if(!o)throw l.shouldNeverHappen();return o}removePage(e){this.controller_.remove(e)}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}setUpPageApi_(e){const t=this.rackApi_.apiSet_.find((t=>t.controller_===e.contentController));if(!t)throw l.shouldNeverHappen();const n=new Be(e,t);this.pageApiMap_.set(e,n)}onPageAdd_(e){this.setUpPageApi_(e.item)}onPageRemove_(e){if(!this.pageApiMap_.get(e.item))throw l.shouldNeverHappen();this.pageApiMap_.delete(e.item)}}const Me=c("tab");class Le{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(Me(),Ge()),t.viewProps.bindClassModifiers(this.element),I(t.empty,E(this.element,Me(void 0,"nop")));const n=e.createElement("div");n.classList.add(Me("i")),this.element.appendChild(n),this.itemsElement=n;const o=t.contentsElement;o.classList.add(Me("c")),this.element.appendChild(o),this.contentsElement=o}}class Se extends pe{constructor(e,t){const n=new Ie(e,{blade:t.blade,viewProps:t.viewProps}),o=D(!0);super({blade:t.blade,rackController:n,view:new Le(e,{contentsElement:n.view.element,empty:o,viewProps:t.viewProps})}),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.onPageSelectedChange_=this.onPageSelectedChange_.bind(this),this.pageSet_=new te((()=>null)),this.pageSet_.emitter.on("add",this.onPageAdd_),this.pageSet_.emitter.on("remove",this.onPageRemove_),this.empty_=o,this.applyPages_()}get pageSet(){return this.pageSet_}add(e,t){this.pageSet_.add(e,null!=t?t:this.pageSet_.items.length)}remove(e){this.pageSet_.remove(this.pageSet_.items[e])}applyPages_(){this.keepSelection_(),this.empty_.rawValue=0===this.pageSet_.items.length}onPageAdd_(e){const t=e.item;R(this.view.itemsElement,t.itemController.view.element,e.index),this.rackController.rack.add(t.contentController,e.index),t.props.value("selected").emitter.on("change",this.onPageSelectedChange_),this.applyPages_()}onPageRemove_(e){const t=e.item;O(t.itemController.view.element),this.rackController.rack.remove(t.contentController),t.props.value("selected").emitter.off("change",this.onPageSelectedChange_),this.applyPages_()}keepSelection_(){if(0===this.pageSet_.items.length)return;const e=this.pageSet_.items.findIndex((e=>e.props.get("selected")));e<0?this.pageSet_.items.forEach(((e,t)=>{e.props.set("selected",0===t)})):this.pageSet_.items.forEach(((t,n)=>{t.props.set("selected",n===e)}))}onPageSelectedChange_(e){if(e.rawValue){const t=this.pageSet_.items.findIndex((t=>t.props.value("selected")===e.sender));this.pageSet_.items.forEach(((e,n)=>{e.props.set("selected",n===t)}))}else this.keepSelection_()}}const Te={id:"tab",type:"blade",accept(e){const t=K,n=y(e,{pages:t.required.array(t.required.object({title:t.required.string})),view:t.required.constant("tab")});return n&&0!==n.pages.length?{params:n}:null},controller(e){const t=new Se(e.document,{blade:e.blade,viewProps:e.viewProps});return e.params.pages.forEach((n=>{const o=new xe(e.document,{itemProps:J.fromObject({selected:!1,title:n.title}),props:J.fromObject({selected:!1})});t.add(o)})),t},api:e=>e.controller instanceof Se?new we(e.controller,e.pool):null};class Ne{constructor(){this.disabled=!1,this.emitter=new h}dispose(){}tick(){this.disabled||this.emitter.emit("tick",{sender:this})}}class Re{constructor(e,t){this.disabled_=!1,this.timerId_=null,this.onTick_=this.onTick_.bind(this),this.doc_=e,this.emitter=new h,this.interval_=t,this.setTimer_()}get disabled(){return this.disabled_}set disabled(e){this.disabled_=e,this.disabled_?this.clearTimer_():this.setTimer_()}dispose(){this.clearTimer_()}clearTimer_(){if(null===this.timerId_)return;const e=this.doc_.defaultView;e&&e.clearInterval(this.timerId_),this.timerId_=null}setTimer_(){if(this.clearTimer_(),this.interval_<=0)return;const e=this.doc_.defaultView;e&&(this.timerId_=e.setInterval(this.onTick_,this.interval_))}onTick_(){this.disabled_||this.emitter.emit("tick",{sender:this})}}class Oe{constructor(e){this.constraints=e}constrain(e){return this.constraints.reduce(((e,t)=>t.constrain(e)),e)}}function Pe(e,t){if(e instanceof t)return e;if(e instanceof Oe){const n=e.constraints.reduce(((e,n)=>e||(n instanceof t?n:null)),null);if(n)return n}return null}class Ue{constructor(e){this.options=e}constrain(e){const t=this.options;return 0===t.length||t.filter((t=>t.value===e)).length>0?e:t[0].value}}class Ve{constructor(e){this.maxValue=e.max,this.minValue=e.min}constrain(e){let t=e;return r(this.minValue)||(t=Math.max(t,this.minValue)),r(this.maxValue)||(t=Math.min(t,this.maxValue)),t}}class We{constructor(e){this.step=e}constrain(e){return(e<0?-Math.round(-e/this.step):Math.round(e/this.step))*this.step}}const _e=c("lst");class ze{constructor(e,t){this.onValueChange_=this.onValueChange_.bind(this),this.props_=t.props,this.element=e.createElement("div"),this.element.classList.add(_e()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("select");n.classList.add(_e("s")),G(this.props_,"options",(t=>{P(n),t.forEach(((t,o)=>{const A=e.createElement("option");A.dataset.index=String(o),A.textContent=t.text,A.value=String(t.value),n.appendChild(A)}))})),t.viewProps.bindDisabled(n),this.element.appendChild(n),this.selectElement=n;const o=e.createElement("div");o.classList.add(_e("m")),o.appendChild(N(e,"dropdown")),this.element.appendChild(o),t.value.emitter.on("change",this.onValueChange_),this.value_=t.value,this.update_()}update_(){this.selectElement.value=String(this.value_.rawValue)}onValueChange_(){this.update_()}}class Xe{constructor(e,t){this.onSelectChange_=this.onSelectChange_.bind(this),this.props=t.props,this.value=t.value,this.viewProps=t.viewProps,this.view=new ze(e,{props:this.props,value:this.value,viewProps:this.viewProps}),this.view.selectElement.addEventListener("change",this.onSelectChange_)}onSelectChange_(e){const t=e.currentTarget.selectedOptions.item(0);if(!t)return;const n=Number(t.dataset.index);this.value.rawValue=this.props.get("options")[n].value}}const Qe=c("pop");class Ze{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(Qe()),t.viewProps.bindClassModifiers(this.element),I(t.shows,E(this.element,Qe(void 0,"v")))}}class Ye{constructor(e,t){this.shows=D(!1),this.viewProps=t.viewProps,this.view=new Ze(e,{shows:this.shows,viewProps:this.viewProps})}}const $e=c("txt");class et{constructor(e,t){this.onChange_=this.onChange_.bind(this),this.element=e.createElement("div"),this.element.classList.add($e()),t.viewProps.bindClassModifiers(this.element),this.props_=t.props,this.props_.emitter.on("change",this.onChange_);const n=e.createElement("input");n.classList.add($e("i")),n.type="text",t.viewProps.bindDisabled(n),this.element.appendChild(n),this.inputElement=n,t.value.emitter.on("change",this.onChange_),this.value_=t.value,this.refresh()}refresh(){const e=this.props_.get("formatter");this.inputElement.value=e(this.value_.rawValue)}onChange_(){this.refresh()}}class tt{constructor(e,t){this.onInputChange_=this.onInputChange_.bind(this),this.parser_=t.parser,this.props=t.props,this.value=t.value,this.viewProps=t.viewProps,this.view=new et(e,{props:t.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(e){const t=e.currentTarget.value,n=this.parser_(t);r(n)||(this.value.rawValue=n),this.view.refresh()}}function nt(e){return"false"!==e&&!!e}function ot(e){return function(e){return String(e)}(e)}class At{constructor(e){this.text=e}evaluate(){return Number(this.text)}toString(){return this.text}}const it={"**":(e,t)=>Math.pow(e,t),"*":(e,t)=>e*t,"/":(e,t)=>e/t,"%":(e,t)=>e%t,"+":(e,t)=>e+t,"-":(e,t)=>e-t,"<<":(e,t)=>e<<t,">>":(e,t)=>e>>t,">>>":(e,t)=>e>>>t,"&":(e,t)=>e&t,"^":(e,t)=>e^t,"|":(e,t)=>e|t};class rt{constructor(e,t,n){this.left=t,this.operator=e,this.right=n}evaluate(){const e=it[this.operator];if(!e)throw new Error(`unexpected binary operator: '${this.operator}`);return e(this.left.evaluate(),this.right.evaluate())}toString(){return["b(",this.left.toString(),this.operator,this.right.toString(),")"].join(" ")}}const st={"+":e=>e,"-":e=>-e,"~":e=>~e};class at{constructor(e,t){this.operator=e,this.expression=t}evaluate(){const e=st[this.operator];if(!e)throw new Error(`unexpected unary operator: '${this.operator}`);return e(this.expression.evaluate())}toString(){return["u(",this.operator,this.expression.toString(),")"].join(" ")}}function lt(e){return(t,n)=>{for(let o=0;o<e.length;o++){const A=e[o](t,n);if(""!==A)return A}return""}}function mt(e,t){var n;const o=e.substr(t).match(/^\s+/);return null!==(n=o&&o[0])&&void 0!==n?n:""}function pt(e,t){var n;const o=e.substr(t).match(/^[0-9]+/);return null!==(n=o&&o[0])&&void 0!==n?n:""}function ht(e,t){const n=e.substr(t,1);if(t+=1,"e"!==n.toLowerCase())return"";const o=function(e,t){const n=pt(e,t);if(""!==n)return n;const o=e.substr(t,1);if("-"!==o&&"+"!==o)return"";const A=pt(e,t+=1);return""===A?"":o+A}(e,t);return""===o?"":n+o}function ut(e,t){const n=e.substr(t,1);if("0"===n)return n;const o=function(e,t){const n=e.substr(t,1);return n.match(/^[1-9]$/)?n:""}(e,t);return t+=o.length,""===o?"":o+pt(e,t)}const ct=lt([function(e,t){const n=ut(e,t);if(t+=n.length,""===n)return"";const o=e.substr(t,1);if(t+=o.length,"."!==o)return"";const A=pt(e,t);return n+o+A+ht(e,t+=A.length)},function(e,t){const n=e.substr(t,1);if(t+=n.length,"."!==n)return"";const o=pt(e,t);return t+=o.length,""===o?"":n+o+ht(e,t)},function(e,t){const n=ut(e,t);return t+=n.length,""===n?"":n+ht(e,t)}]);const dt=lt([function(e,t){const n=e.substr(t,2);if(t+=n.length,"0b"!==n.toLowerCase())return"";const o=function(e,t){var n;const o=e.substr(t).match(/^[01]+/);return null!==(n=o&&o[0])&&void 0!==n?n:""}(e,t);return""===o?"":n+o},function(e,t){const n=e.substr(t,2);if(t+=n.length,"0o"!==n.toLowerCase())return"";const o=function(e,t){var n;const o=e.substr(t).match(/^[0-7]+/);return null!==(n=o&&o[0])&&void 0!==n?n:""}(e,t);return""===o?"":n+o},function(e,t){const n=e.substr(t,2);if(t+=n.length,"0x"!==n.toLowerCase())return"";const o=function(e,t){var n;const o=e.substr(t).match(/^[0-9a-f]+/i);return null!==(n=o&&o[0])&&void 0!==n?n:""}(e,t);return""===o?"":n+o}]),It=lt([dt,ct]);function Gt(e,t){return function(e,t){const n=It(e,t);return t+=n.length,""===n?null:{evaluable:new At(n),cursor:t}}(e,t)||function(e,t){const n=e.substr(t,1);if(t+=n.length,"("!==n)return null;const o=gt(e,t);if(!o)return null;t=o.cursor,t+=mt(e,t).length;const A=e.substr(t,1);return t+=A.length,")"!==A?null:{evaluable:o.evaluable,cursor:t}}(e,t)}function Et(e,t,n){n+=mt(t,n).length;const o=e.filter((e=>t.startsWith(e,n)))[0];return o?(n+=o.length,{cursor:n+=mt(t,n).length,operator:o}):null}const kt=[["**"],["*","/","%"],["+","-"],["<<",">>>",">>"],["&"],["^"],["|"]].reduce(((e,t)=>function(e,t){return(n,o)=>{const A=e(n,o);if(!A)return null;o=A.cursor;let i=A.evaluable;for(;;){const A=Et(t,n,o);if(!A)break;o=A.cursor;const r=e(n,o);if(!r)return null;o=r.cursor,i=new rt(A.operator,i,r.evaluable)}return i?{cursor:o,evaluable:i}:null}}(e,t)),(function e(t,n){const o=Gt(t,n);if(o)return o;const A=t.substr(n,1);if(n+=A.length,"+"!==A&&"-"!==A&&"~"!==A)return null;const i=e(t,n);return i?{cursor:n=i.cursor,evaluable:new at(A,i.evaluable)}:null}));function gt(e,t){return t+=mt(e,t).length,kt(e,t)}function ft(e){var t;const n=function(e){const t=gt(e,0);return t?t.cursor+mt(e,t.cursor).length!==e.length?null:t.evaluable:null}(e);return null!==(t=null==n?void 0:n.evaluate())&&void 0!==t?t:null}function Ht(e){if("number"==typeof e)return e;if("string"==typeof e){const t=ft(e);if(!r(t))return t}return 0}function Ft(e){return String(e)}function Ct(e){return t=>t.toFixed(Math.max(Math.min(e,20),0))}const Dt=Ct(0);function Jt(e){return Dt(e)+"%"}function vt(e){return String(e)}function jt(e){return e}function Kt(e,t){for(;e.length<t;)e.push(void 0)}function yt(e){const t=[];return Kt(t,e),D(t)}function bt(e){const t=e.indexOf(void 0);return t<0?e:e.slice(0,t)}function qt({primary:e,secondary:t,forward:n,backward:o}){let A=!1;function i(e){A||(A=!0,e(),A=!1)}e.emitter.on("change",(o=>{i((()=>{t.setRawValue(n(e,t),o.options)}))})),t.emitter.on("change",(A=>{i((()=>{e.setRawValue(o(e,t),A.options)})),i((()=>{t.setRawValue(n(e,t),A.options)}))})),i((()=>{t.setRawValue(n(e,t),{forceEmit:!1,last:!0})}))}function xt(e,t){const n=e*(t.altKey?.1:1)*(t.shiftKey?10:1);return t.upKey?+n:t.downKey?-n:0}function Bt(e){return{altKey:e.altKey,downKey:"ArrowDown"===e.key,shiftKey:e.shiftKey,upKey:"ArrowUp"===e.key}}function wt(e){return{altKey:e.altKey,downKey:"ArrowLeft"===e.key,shiftKey:e.shiftKey,upKey:"ArrowRight"===e.key}}function Mt(e){return function(e){return"ArrowUp"===e||"ArrowDown"===e}(e)||"ArrowLeft"===e||"ArrowRight"===e}function Lt(e,t){const n=t.ownerDocument.defaultView,o=t.getBoundingClientRect();return{x:e.pageX-((n&&n.scrollX||0)+o.left),y:e.pageY-((n&&n.scrollY||0)+o.top)}}class St{constructor(e){this.lastTouch_=null,this.onDocumentMouseMove_=this.onDocumentMouseMove_.bind(this),this.onDocumentMouseUp_=this.onDocumentMouseUp_.bind(this),this.onMouseDown_=this.onMouseDown_.bind(this),this.onTouchEnd_=this.onTouchEnd_.bind(this),this.onTouchMove_=this.onTouchMove_.bind(this),this.onTouchStart_=this.onTouchStart_.bind(this),this.elem_=e,this.emitter=new h,e.addEventListener("touchstart",this.onTouchStart_,{passive:!1}),e.addEventListener("touchmove",this.onTouchMove_,{passive:!0}),e.addEventListener("touchend",this.onTouchEnd_),e.addEventListener("mousedown",this.onMouseDown_)}computePosition_(e){const t=this.elem_.getBoundingClientRect();return{bounds:{width:t.width,height:t.height},point:e?{x:e.x,y:e.y}:null}}onMouseDown_(e){var t;e.preventDefault(),null===(t=e.currentTarget)||void 0===t||t.focus();const n=this.elem_.ownerDocument;n.addEventListener("mousemove",this.onDocumentMouseMove_),n.addEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("down",{altKey:e.altKey,data:this.computePosition_(Lt(e,this.elem_)),sender:this,shiftKey:e.shiftKey})}onDocumentMouseMove_(e){this.emitter.emit("move",{altKey:e.altKey,data:this.computePosition_(Lt(e,this.elem_)),sender:this,shiftKey:e.shiftKey})}onDocumentMouseUp_(e){const t=this.elem_.ownerDocument;t.removeEventListener("mousemove",this.onDocumentMouseMove_),t.removeEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("up",{altKey:e.altKey,data:this.computePosition_(Lt(e,this.elem_)),sender:this,shiftKey:e.shiftKey})}onTouchStart_(e){e.preventDefault();const t=e.targetTouches.item(0),n=this.elem_.getBoundingClientRect();this.emitter.emit("down",{altKey:e.altKey,data:this.computePosition_(t?{x:t.clientX-n.left,y:t.clientY-n.top}:void 0),sender:this,shiftKey:e.shiftKey}),this.lastTouch_=t}onTouchMove_(e){const t=e.targetTouches.item(0),n=this.elem_.getBoundingClientRect();this.emitter.emit("move",{altKey:e.altKey,data:this.computePosition_(t?{x:t.clientX-n.left,y:t.clientY-n.top}:void 0),sender:this,shiftKey:e.shiftKey}),this.lastTouch_=t}onTouchEnd_(e){var t;const n=null!==(t=e.targetTouches.item(0))&&void 0!==t?t:this.lastTouch_,o=this.elem_.getBoundingClientRect();this.emitter.emit("up",{altKey:e.altKey,data:this.computePosition_(n?{x:n.clientX-o.left,y:n.clientY-o.top}:void 0),sender:this,shiftKey:e.shiftKey})}}function Tt(e,t,n,o,A){return o+(e-t)/(n-t)*(A-o)}function Nt(e){return String(e.toFixed(10)).split(".")[1].replace(/0+$/,"").length}function Rt(e,t,n){return Math.min(Math.max(e,t),n)}function Ot(e,t){return(e%t+t)%t}const Pt=c("txt");class Ut{constructor(e,t){this.onChange_=this.onChange_.bind(this),this.props_=t.props,this.props_.emitter.on("change",this.onChange_),this.element=e.createElement("div"),this.element.classList.add(Pt(),Pt(void 0,"num")),t.arrayPosition&&this.element.classList.add(Pt(void 0,t.arrayPosition)),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("input");n.classList.add(Pt("i")),n.type="text",t.viewProps.bindDisabled(n),this.element.appendChild(n),this.inputElement=n,this.onDraggingChange_=this.onDraggingChange_.bind(this),this.dragging_=t.dragging,this.dragging_.emitter.on("change",this.onDraggingChange_),this.element.classList.add(Pt()),this.inputElement.classList.add(Pt("i"));const o=e.createElement("div");o.classList.add(Pt("k")),this.element.appendChild(o),this.knobElement=o;const A=e.createElementNS(B,"svg");A.classList.add(Pt("g")),this.knobElement.appendChild(A);const i=e.createElementNS(B,"path");i.classList.add(Pt("gb")),A.appendChild(i),this.guideBodyElem_=i;const r=e.createElementNS(B,"path");r.classList.add(Pt("gh")),A.appendChild(r),this.guideHeadElem_=r;const s=e.createElement("div");s.classList.add(c("tt")()),this.knobElement.appendChild(s),this.tooltipElem_=s,t.value.emitter.on("change",this.onChange_),this.value=t.value,this.refresh()}onDraggingChange_(e){if(null===e.rawValue)return void this.element.classList.remove(Pt(void 0,"drg"));this.element.classList.add(Pt(void 0,"drg"));const t=e.rawValue/this.props_.get("draggingScale"),n=t+(t>0?-1:t<0?1:0),o=Rt(-n,-4,4);this.guideHeadElem_.setAttributeNS(null,"d",[`M ${n+o},0 L${n},4 L${n+o},8`,`M ${t},-1 L${t},9`].join(" ")),this.guideBodyElem_.setAttributeNS(null,"d",`M 0,4 L${t},4`);const A=this.props_.get("formatter");this.tooltipElem_.textContent=A(this.value.rawValue),this.tooltipElem_.style.left=`${t}px`}refresh(){const e=this.props_.get("formatter");this.inputElement.value=e(this.value.rawValue)}onChange_(){this.refresh()}}class Vt{constructor(e,t){this.originRawValue_=0,this.onInputChange_=this.onInputChange_.bind(this),this.onInputKeyDown_=this.onInputKeyDown_.bind(this),this.onInputKeyUp_=this.onInputKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=t.baseStep,this.parser_=t.parser,this.props=t.props,this.value=t.value,this.viewProps=t.viewProps,this.dragging_=D(null),this.view=new Ut(e,{arrayPosition:t.arrayPosition,dragging:this.dragging_,props:this.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_),this.view.inputElement.addEventListener("keydown",this.onInputKeyDown_),this.view.inputElement.addEventListener("keyup",this.onInputKeyUp_);const n=new St(this.view.knobElement);n.emitter.on("down",this.onPointerDown_),n.emitter.on("move",this.onPointerMove_),n.emitter.on("up",this.onPointerUp_)}onInputChange_(e){const t=e.currentTarget.value,n=this.parser_(t);r(n)||(this.value.rawValue=n),this.view.refresh()}onInputKeyDown_(e){const t=xt(this.baseStep_,Bt(e));0!==t&&this.value.setRawValue(this.value.rawValue+t,{forceEmit:!1,last:!1})}onInputKeyUp_(e){0!==xt(this.baseStep_,Bt(e))&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}onPointerDown_(){this.originRawValue_=this.value.rawValue,this.dragging_.rawValue=0}computeDraggingValue_(e){if(!e.point)return null;const t=e.point.x-e.bounds.width/2;return this.originRawValue_+t*this.props.get("draggingScale")}onPointerMove_(e){const t=this.computeDraggingValue_(e.data);null!==t&&(this.value.setRawValue(t,{forceEmit:!1,last:!1}),this.dragging_.rawValue=this.value.rawValue-this.originRawValue_)}onPointerUp_(e){const t=this.computeDraggingValue_(e.data);null!==t&&(this.value.setRawValue(t,{forceEmit:!0,last:!0}),this.dragging_.rawValue=null)}}const Wt=c("sld");class _t{constructor(e,t){this.onChange_=this.onChange_.bind(this),this.props_=t.props,this.props_.emitter.on("change",this.onChange_),this.element=e.createElement("div"),this.element.classList.add(Wt()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("div");n.classList.add(Wt("t")),t.viewProps.bindTabIndex(n),this.element.appendChild(n),this.trackElement=n;const o=e.createElement("div");o.classList.add(Wt("k")),this.trackElement.appendChild(o),this.knobElement=o,t.value.emitter.on("change",this.onChange_),this.value=t.value,this.update_()}update_(){const e=Rt(Tt(this.value.rawValue,this.props_.get("minValue"),this.props_.get("maxValue"),0,100),0,100);this.knobElement.style.width=`${e}%`}onChange_(){this.update_()}}class zt{constructor(e,t){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDownOrMove_=this.onPointerDownOrMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=t.baseStep,this.value=t.value,this.viewProps=t.viewProps,this.props=t.props,this.view=new _t(e,{props:this.props,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new St(this.view.trackElement),this.ptHandler_.emitter.on("down",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("move",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.trackElement.addEventListener("keydown",this.onKeyDown_),this.view.trackElement.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(e,t){e.point&&this.value.setRawValue(Tt(Rt(e.point.x,0,e.bounds.width),0,e.bounds.width,this.props.get("minValue"),this.props.get("maxValue")),t)}onPointerDownOrMove_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerUp_(e){this.handlePointerEvent_(e.data,{forceEmit:!0,last:!0})}onKeyDown_(e){const t=xt(this.baseStep_,wt(e));0!==t&&this.value.setRawValue(this.value.rawValue+t,{forceEmit:!1,last:!1})}onKeyUp_(e){0!==xt(this.baseStep_,wt(e))&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Xt=c("sldtxt");class Qt{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(Xt());const n=e.createElement("div");n.classList.add(Xt("s")),this.sliderView_=t.sliderView,n.appendChild(this.sliderView_.element),this.element.appendChild(n);const o=e.createElement("div");o.classList.add(Xt("t")),this.textView_=t.textView,o.appendChild(this.textView_.element),this.element.appendChild(o)}}class Zt{constructor(e,t){this.value=t.value,this.viewProps=t.viewProps,this.sliderC_=new zt(e,{baseStep:t.baseStep,props:t.sliderProps,value:t.value,viewProps:this.viewProps}),this.textC_=new Vt(e,{baseStep:t.baseStep,parser:t.parser,props:t.textProps,value:t.value,viewProps:t.viewProps}),this.view=new Qt(e,{sliderView:this.sliderC_.view,textView:this.textC_.view})}get sliderController(){return this.sliderC_}get textController(){return this.textC_}}function Yt(e,t){e.write(t)}function $t(e){const t=K;return Array.isArray(e)?t.required.array(t.required.object({text:t.required.string,value:t.required.raw}))(e).value:"object"==typeof e?t.required.raw(e).value:void 0}function en(e){if("inline"===e||"popup"===e)return e}function tn(e){const t=K;return t.required.object({max:t.optional.number,min:t.optional.number,step:t.optional.number})(e).value}function nn(e){if(Array.isArray(e))return e;const t=[];return Object.keys(e).forEach((n=>{t.push({text:n,value:e[n]})})),t}function on(e){return r(e)?null:new Ue(nn(e))}function An(e){const t=e?Pe(e,Ue):null;return t?t.options:null}function rn(e,t){const n=e&&Pe(e,We);return n?Nt(n.step):Math.max(Nt(t),2)}function sn(e){const t=function(e){const t=e?Pe(e,We):null;return t?t.step:null}(e);return null!=t?t:1}function an(e,t){var n;const o=e&&Pe(e,We),A=Math.abs(null!==(n=null==o?void 0:o.step)&&void 0!==n?n:t);return 0===A?.1:Math.pow(10,Math.floor(Math.log10(A))-1)}const ln=c("ckb");class mn{constructor(e,t){this.onValueChange_=this.onValueChange_.bind(this),this.element=e.createElement("div"),this.element.classList.add(ln()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("label");n.classList.add(ln("l")),this.element.appendChild(n);const o=e.createElement("input");o.classList.add(ln("i")),o.type="checkbox",n.appendChild(o),this.inputElement=o,t.viewProps.bindDisabled(this.inputElement);const A=e.createElement("div");A.classList.add(ln("w")),n.appendChild(A);const i=N(e,"check");A.appendChild(i),t.value.emitter.on("change",this.onValueChange_),this.value=t.value,this.update_()}update_(){this.inputElement.checked=this.value.rawValue}onValueChange_(){this.update_()}}class pn{constructor(e,t){this.onInputChange_=this.onInputChange_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.view=new mn(e,{value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(e){const t=e.currentTarget;this.value.rawValue=t.checked}}const hn={id:"input-bool",type:"input",accept:(e,t)=>{if("boolean"!=typeof e)return null;const n=y(t,{options:K.optional.custom($t)});return n?{initialValue:e,params:n}:null},binding:{reader:e=>nt,constraint:e=>function(e){const t=[],n=on(e.options);return n&&t.push(n),new Oe(t)}(e.params),writer:e=>Yt},controller:e=>{var t;const n=e.document,o=e.value,A=e.constraint;return A&&Pe(A,Ue)?new Xe(n,{props:J.fromObject({options:null!==(t=An(A))&&void 0!==t?t:[]}),value:o,viewProps:e.viewProps}):new pn(n,{value:o,viewProps:e.viewProps})}},un=c("col");class cn{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(un()),t.foldable.bindExpandedClass(this.element,un(void 0,"expanded")),G(t.foldable,"completed",E(this.element,un(void 0,"cpl")));const n=e.createElement("div");n.classList.add(un("h")),this.element.appendChild(n);const o=e.createElement("div");o.classList.add(un("s")),n.appendChild(o),this.swatchElement=o;const A=e.createElement("div");if(A.classList.add(un("t")),n.appendChild(A),this.textElement=A,"inline"===t.pickerLayout){const t=e.createElement("div");t.classList.add(un("p")),this.element.appendChild(t),this.pickerElement=t}else this.pickerElement=null}}function dn(e,t,n){const o=Ot(e,360),A=Rt(t/100,0,1),i=Rt(n/100,0,1),r=i*A,s=r*(1-Math.abs(o/60%2-1)),a=i-r;let l,m,p;return[l,m,p]=o>=0&&o<60?[r,s,0]:o>=60&&o<120?[s,r,0]:o>=120&&o<180?[0,r,s]:o>=180&&o<240?[0,s,r]:o>=240&&o<300?[s,0,r]:[r,0,s],[255*(l+a),255*(m+a),255*(p+a)]}function In(e){return[e[0],e[1],e[2]]}function Gn(e,t){return[e[0],e[1],e[2],t]}const En={hsl:{hsl:(e,t,n)=>[e,t,n],hsv:function(e,t,n){const o=n+t*(100-Math.abs(2*n-100))/200;return[e,0!==o?t*(100-Math.abs(2*n-100))/o:0,n+t*(100-Math.abs(2*n-100))/200]},rgb:function(e,t,n){const o=(e%360+360)%360,A=Rt(t/100,0,1),i=Rt(n/100,0,1),r=(1-Math.abs(2*i-1))*A,s=r*(1-Math.abs(o/60%2-1)),a=i-r/2;let l,m,p;return[l,m,p]=o>=0&&o<60?[r,s,0]:o>=60&&o<120?[s,r,0]:o>=120&&o<180?[0,r,s]:o>=180&&o<240?[0,s,r]:o>=240&&o<300?[s,0,r]:[r,0,s],[255*(l+a),255*(m+a),255*(p+a)]}},hsv:{hsl:function(e,t,n){const o=100-Math.abs(n*(200-t)/100-100);return[e,0!==o?t*n/o:0,n*(200-t)/200]},hsv:(e,t,n)=>[e,t,n],rgb:dn},rgb:{hsl:function(e,t,n){const o=Rt(e/255,0,1),A=Rt(t/255,0,1),i=Rt(n/255,0,1),r=Math.max(o,A,i),s=Math.min(o,A,i),a=r-s;let l=0,m=0;const p=(s+r)/2;return 0!==a&&(m=a/(1-Math.abs(r+s-1)),l=o===r?(A-i)/a:A===r?2+(i-o)/a:4+(o-A)/a,l=l/6+(l<0?1:0)),[360*l,100*m,100*p]},hsv:function(e,t,n){const o=Rt(e/255,0,1),A=Rt(t/255,0,1),i=Rt(n/255,0,1),r=Math.max(o,A,i),s=r-Math.min(o,A,i);let a;return a=0===s?0:r===o?((A-i)/s%6+6)%6*60:r===A?60*((i-o)/s+2):60*((o-A)/s+4),[a,100*(0===r?0:s/r),100*r]},rgb:(e,t,n)=>[e,t,n]}};const kn={hsl:e=>{var t;return[Ot(e[0],360),Rt(e[1],0,100),Rt(e[2],0,100),Rt(null!==(t=e[3])&&void 0!==t?t:1,0,1)]},hsv:e=>{var t;return[Ot(e[0],360),Rt(e[1],0,100),Rt(e[2],0,100),Rt(null!==(t=e[3])&&void 0!==t?t:1,0,1)]},rgb:e=>{var t;return[Rt(e[0],0,255),Rt(e[1],0,255),Rt(e[2],0,255),Rt(null!==(t=e[3])&&void 0!==t?t:1,0,1)]}};function gn(e,t){return"object"==typeof e&&!r(e)&&t in e&&"number"==typeof e[t]}class fn{constructor(e,t){this.mode_=t,this.comps_=kn[t](e)}static black(){return new fn([0,0,0],"rgb")}static fromObject(e){const t="a"in e?[e.r,e.g,e.b,e.a]:[e.r,e.g,e.b];return new fn(t,"rgb")}static toRgbaObject(e){return e.toRgbaObject()}static isRgbColorObject(e){return gn(e,"r")&&gn(e,"g")&&gn(e,"b")}static isRgbaColorObject(e){return this.isRgbColorObject(e)&&gn(e,"a")}static isColorObject(e){return this.isRgbColorObject(e)}static equals(e,t){if(e.mode_!==t.mode_)return!1;const n=e.comps_,o=t.comps_;for(let e=0;e<n.length;e++)if(n[e]!==o[e])return!1;return!0}get mode(){return this.mode_}getComponents(e){return Gn((t=In(this.comps_),n=this.mode_,o=e||this.mode_,En[n][o](...t)),this.comps_[3]);var t,n,o}toRgbaObject(){const e=this.getComponents("rgb");return{r:e[0],g:e[1],b:e[2],a:e[3]}}}const Hn=c("colp");class Fn{constructor(e,t){this.alphaViews_=null,this.element=e.createElement("div"),this.element.classList.add(Hn());const n=e.createElement("div");n.classList.add(Hn("hsv"));const o=e.createElement("div");o.classList.add(Hn("sv")),this.svPaletteView_=t.svPaletteView,o.appendChild(this.svPaletteView_.element),n.appendChild(o);const A=e.createElement("div");A.classList.add(Hn("h")),this.hPaletteView_=t.hPaletteView,A.appendChild(this.hPaletteView_.element),n.appendChild(A),this.element.appendChild(n);const i=e.createElement("div");if(i.classList.add(Hn("rgb")),this.textView_=t.textView,i.appendChild(this.textView_.element),this.element.appendChild(i),t.alphaViews){this.alphaViews_={palette:t.alphaViews.palette,text:t.alphaViews.text};const n=e.createElement("div");n.classList.add(Hn("a"));const o=e.createElement("div");o.classList.add(Hn("ap")),o.appendChild(this.alphaViews_.palette.element),n.appendChild(o);const A=e.createElement("div");A.classList.add(Hn("at")),A.appendChild(this.alphaViews_.text.element),n.appendChild(A),this.element.appendChild(n)}}get allFocusableElements(){const e=[this.svPaletteView_.element,this.hPaletteView_.element,this.textView_.modeSelectElement,...this.textView_.textViews.map((e=>e.inputElement))];return this.alphaViews_&&e.push(this.alphaViews_.palette.element,this.alphaViews_.text.inputElement),e}}function Cn(e){const t=K;return y(e,{alpha:t.optional.boolean,expanded:t.optional.boolean,picker:t.optional.custom(en)})}function Dn(e){return e?.1:1}function Jn(e,t){const n=e.match(/^(.+)%$/);return n?Math.min(.01*parseFloat(n[1])*t,t):Math.min(parseFloat(e),t)}const vn={deg:e=>e,grad:e=>360*e/400,rad:e=>360*e/(2*Math.PI),turn:e=>360*e};function jn(e){const t=e.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);if(!t)return parseFloat(e);const n=parseFloat(t[1]),o=t[2];return vn[o](n)}const Kn={"func.rgb":e=>{const t=e.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!t)return null;const n=[Jn(t[1],255),Jn(t[2],255),Jn(t[3],255)];return isNaN(n[0])||isNaN(n[1])||isNaN(n[2])?null:new fn(n,"rgb")},"func.rgba":e=>{const t=e.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!t)return null;const n=[Jn(t[1],255),Jn(t[2],255),Jn(t[3],255),Jn(t[4],1)];return isNaN(n[0])||isNaN(n[1])||isNaN(n[2])||isNaN(n[3])?null:new fn(n,"rgb")},"func.hsl":e=>{const t=e.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!t)return null;const n=[jn(t[1]),Jn(t[2],100),Jn(t[3],100)];return isNaN(n[0])||isNaN(n[1])||isNaN(n[2])?null:new fn(n,"hsl")},"func.hsla":e=>{const t=e.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!t)return null;const n=[jn(t[1]),Jn(t[2],100),Jn(t[3],100),Jn(t[4],1)];return isNaN(n[0])||isNaN(n[1])||isNaN(n[2])||isNaN(n[3])?null:new fn(n,"hsl")},"hex.rgb":e=>{const t=e.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(t)return new fn([parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)],"rgb");const n=e.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return n?new fn([parseInt(n[1],16),parseInt(n[2],16),parseInt(n[3],16)],"rgb"):null},"hex.rgba":e=>{const t=e.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(t)return new fn([parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16),Tt(parseInt(t[4]+t[4],16),0,255,0,1)],"rgb");const n=e.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return n?new fn([parseInt(n[1],16),parseInt(n[2],16),parseInt(n[3],16),Tt(parseInt(n[4],16),0,255,0,1)],"rgb"):null}};function yn(e){return Object.keys(Kn).reduce(((t,n)=>t||((0,Kn[n])(e)?n:null)),null)}const bn=e=>{const t=yn(e);return t?Kn[t](e):null};function qn(e){return"func.hsla"===e||"func.rgba"===e||"hex.rgba"===e}function xn(e){if("string"==typeof e){const t=bn(e);if(t)return t}return fn.black()}function Bn(e){const t=Rt(Math.floor(e),0,255).toString(16);return 1===t.length?`0${t}`:t}function wn(e,t="#"){return`${t}${In(e.getComponents("rgb")).map(Bn).join("")}`}function Mn(e,t="#"){const n=e.getComponents("rgb");return`${t}${[n[0],n[1],n[2],255*n[3]].map(Bn).join("")}`}function Ln(e){const t=Ct(0);return`rgb(${In(e.getComponents("rgb")).map((e=>t(e))).join(", ")})`}function Sn(e){const t=Ct(2),n=Ct(0);return`rgba(${e.getComponents("rgb").map(((e,o)=>(3===o?t:n)(e))).join(", ")})`}const Tn={"func.hsl":function(e){const t=[Ct(0),Jt,Jt];return`hsl(${In(e.getComponents("hsl")).map(((e,n)=>t[n](e))).join(", ")})`},"func.hsla":function(e){const t=[Ct(0),Jt,Jt,Ct(2)];return`hsla(${e.getComponents("hsl").map(((e,n)=>t[n](e))).join(", ")})`},"func.rgb":Ln,"func.rgba":Sn,"hex.rgb":wn,"hex.rgba":Mn};function Nn(e){return Tn[e]}const Rn=c("apl");class On{constructor(e,t){this.onValueChange_=this.onValueChange_.bind(this),this.value=t.value,this.value.emitter.on("change",this.onValueChange_),this.element=e.createElement("div"),this.element.classList.add(Rn()),t.viewProps.bindTabIndex(this.element);const n=e.createElement("div");n.classList.add(Rn("b")),this.element.appendChild(n);const o=e.createElement("div");o.classList.add(Rn("c")),n.appendChild(o),this.colorElem_=o;const A=e.createElement("div");A.classList.add(Rn("m")),this.element.appendChild(A),this.markerElem_=A;const i=e.createElement("div");i.classList.add(Rn("p")),this.markerElem_.appendChild(i),this.previewElem_=i,this.update_()}update_(){const e=this.value.rawValue,t=e.getComponents("rgb"),n=new fn([t[0],t[1],t[2],0],"rgb"),o=new fn([t[0],t[1],t[2],255],"rgb"),A=["to right",Sn(n),Sn(o)];this.colorElem_.style.background=`linear-gradient(${A.join(",")})`,this.previewElem_.style.backgroundColor=Sn(e);const i=Tt(t[3],0,1,0,100);this.markerElem_.style.left=`${i}%`}onValueChange_(){this.update_()}}class Pn{constructor(e,t){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.view=new On(e,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new St(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(e,t){if(!e.point)return;const n=e.point.x/e.bounds.width,o=this.value.rawValue,[A,i,r]=o.getComponents("hsv");this.value.setRawValue(new fn([A,i,r,n],"hsv"),t)}onPointerDown_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerMove_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerUp_(e){this.handlePointerEvent_(e.data,{forceEmit:!0,last:!0})}onKeyDown_(e){const t=xt(Dn(!0),wt(e));if(0===t)return;const n=this.value.rawValue,[o,A,i,r]=n.getComponents("hsv");this.value.setRawValue(new fn([o,A,i,r+t],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(e){0!==xt(Dn(!0),wt(e))&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Un=c("coltxt");class Vn{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(Un());const n=e.createElement("div");n.classList.add(Un("m")),this.modeElem_=function(e){const t=e.createElement("select");return t.appendChild([{text:"RGB",value:"rgb"},{text:"HSL",value:"hsl"},{text:"HSV",value:"hsv"}].reduce(((t,n)=>{const o=e.createElement("option");return o.textContent=n.text,o.value=n.value,t.appendChild(o),t}),e.createDocumentFragment())),t}(e),this.modeElem_.classList.add(Un("ms")),n.appendChild(this.modeSelectElement);const o=e.createElement("div");o.classList.add(Un("mm")),o.appendChild(N(e,"dropdown")),n.appendChild(o),this.element.appendChild(n);const A=e.createElement("div");A.classList.add(Un("w")),this.element.appendChild(A),this.textsElem_=A,this.textViews_=t.textViews,this.applyTextViews_(),I(t.colorMode,(e=>{this.modeElem_.value=e}))}get modeSelectElement(){return this.modeElem_}get textViews(){return this.textViews_}set textViews(e){this.textViews_=e,this.applyTextViews_()}applyTextViews_(){P(this.textsElem_);const e=this.element.ownerDocument;this.textViews_.forEach((t=>{const n=e.createElement("div");n.classList.add(Un("c")),n.appendChild(t.element),this.textsElem_.appendChild(n)}))}}const Wn=Ct(0),_n={rgb:()=>new Ve({min:0,max:255}),hsl:e=>new Ve(0===e?{min:0,max:360}:{min:0,max:100}),hsv:e=>new Ve(0===e?{min:0,max:360}:{min:0,max:100})};function zn(e,t,n){return new Vt(e,{arrayPosition:0===n?"fst":2===n?"lst":"mid",baseStep:Dn(!1),parser:t.parser,props:J.fromObject({draggingScale:1,formatter:Wn}),value:D(0,{constraint:_n[t.colorMode](n)}),viewProps:t.viewProps})}class Xn{constructor(e,t){this.onModeSelectChange_=this.onModeSelectChange_.bind(this),this.parser_=t.parser,this.value=t.value,this.viewProps=t.viewProps,this.colorMode=D(this.value.rawValue.mode),this.ccs_=this.createComponentControllers_(e),this.view=new Vn(e,{colorMode:this.colorMode,textViews:[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}),this.view.modeSelectElement.addEventListener("change",this.onModeSelectChange_)}createComponentControllers_(e){const t={colorMode:this.colorMode.rawValue,parser:this.parser_,viewProps:this.viewProps},n=[zn(e,t,0),zn(e,t,1),zn(e,t,2)];return n.forEach(((e,t)=>{qt({primary:this.value,secondary:e.value,forward:e=>e.rawValue.getComponents(this.colorMode.rawValue)[t],backward:(e,n)=>{const o=this.colorMode.rawValue,A=e.rawValue.getComponents(o);return A[t]=n.rawValue,new fn(Gn(In(A),A[3]),o)}})})),n}onModeSelectChange_(e){const t=e.currentTarget;this.colorMode.rawValue=t.value,this.ccs_=this.createComponentControllers_(this.view.element.ownerDocument),this.view.textViews=[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}}const Qn=c("hpl");class Zn{constructor(e,t){this.onValueChange_=this.onValueChange_.bind(this),this.value=t.value,this.value.emitter.on("change",this.onValueChange_),this.element=e.createElement("div"),this.element.classList.add(Qn()),t.viewProps.bindTabIndex(this.element);const n=e.createElement("div");n.classList.add(Qn("c")),this.element.appendChild(n);const o=e.createElement("div");o.classList.add(Qn("m")),this.element.appendChild(o),this.markerElem_=o,this.update_()}update_(){const e=this.value.rawValue,[t]=e.getComponents("hsv");this.markerElem_.style.backgroundColor=Ln(new fn([t,100,100],"hsv"));const n=Tt(t,0,360,0,100);this.markerElem_.style.left=`${n}%`}onValueChange_(){this.update_()}}class Yn{constructor(e,t){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.view=new Zn(e,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new St(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(e,t){if(!e.point)return;const n=Tt(e.point.x,0,e.bounds.width,0,360),o=this.value.rawValue,[,A,i,r]=o.getComponents("hsv");this.value.setRawValue(new fn([n,A,i,r],"hsv"),t)}onPointerDown_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerMove_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerUp_(e){this.handlePointerEvent_(e.data,{forceEmit:!0,last:!0})}onKeyDown_(e){const t=xt(Dn(!1),wt(e));if(0===t)return;const n=this.value.rawValue,[o,A,i,r]=n.getComponents("hsv");this.value.setRawValue(new fn([o+t,A,i,r],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(e){0!==xt(Dn(!1),wt(e))&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const $n=c("svp");class eo{constructor(e,t){this.onValueChange_=this.onValueChange_.bind(this),this.value=t.value,this.value.emitter.on("change",this.onValueChange_),this.element=e.createElement("div"),this.element.classList.add($n()),t.viewProps.bindTabIndex(this.element);const n=e.createElement("canvas");n.height=64,n.width=64,n.classList.add($n("c")),this.element.appendChild(n),this.canvasElement=n;const o=e.createElement("div");o.classList.add($n("m")),this.element.appendChild(o),this.markerElem_=o,this.update_()}update_(){const e=S(this.canvasElement);if(!e)return;const t=this.value.rawValue.getComponents("hsv"),n=this.canvasElement.width,o=this.canvasElement.height,A=e.getImageData(0,0,n,o),i=A.data;for(let e=0;e<o;e++)for(let A=0;A<n;A++){const r=Tt(A,0,n,0,100),s=Tt(e,0,o,100,0),a=dn(t[0],r,s),l=4*(e*n+A);i[l]=a[0],i[l+1]=a[1],i[l+2]=a[2],i[l+3]=255}e.putImageData(A,0,0);const r=Tt(t[1],0,100,0,100);this.markerElem_.style.left=`${r}%`;const s=Tt(t[2],0,100,100,0);this.markerElem_.style.top=`${s}%`}onValueChange_(){this.update_()}}class to{constructor(e,t){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.view=new eo(e,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new St(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(e,t){if(!e.point)return;const n=Tt(e.point.x,0,e.bounds.width,0,100),o=Tt(e.point.y,0,e.bounds.height,100,0),[A,,,i]=this.value.rawValue.getComponents("hsv");this.value.setRawValue(new fn([A,n,o,i],"hsv"),t)}onPointerDown_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerMove_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerUp_(e){this.handlePointerEvent_(e.data,{forceEmit:!0,last:!0})}onKeyDown_(e){Mt(e.key)&&e.preventDefault();const[t,n,o,A]=this.value.rawValue.getComponents("hsv"),i=Dn(!1),r=xt(i,wt(e)),s=xt(i,Bt(e));0===r&&0===s||this.value.setRawValue(new fn([t,n+r,o+s,A],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(e){const t=Dn(!1),n=xt(t,wt(e)),o=xt(t,Bt(e));0===n&&0===o||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class no{constructor(e,t){this.value=t.value,this.viewProps=t.viewProps,this.hPaletteC_=new Yn(e,{value:this.value,viewProps:this.viewProps}),this.svPaletteC_=new to(e,{value:this.value,viewProps:this.viewProps}),this.alphaIcs_=t.supportsAlpha?{palette:new Pn(e,{value:this.value,viewProps:this.viewProps}),text:new Vt(e,{parser:ft,baseStep:.1,props:J.fromObject({draggingScale:.01,formatter:Ct(2)}),value:D(0,{constraint:new Ve({min:0,max:1})}),viewProps:this.viewProps})}:null,this.alphaIcs_&&qt({primary:this.value,secondary:this.alphaIcs_.text.value,forward:e=>e.rawValue.getComponents()[3],backward:(e,t)=>{const n=e.rawValue.getComponents();return n[3]=t.rawValue,new fn(n,e.rawValue.mode)}}),this.textC_=new Xn(e,{parser:ft,value:this.value,viewProps:this.viewProps}),this.view=new Fn(e,{alphaViews:this.alphaIcs_?{palette:this.alphaIcs_.palette.view,text:this.alphaIcs_.text.view}:null,hPaletteView:this.hPaletteC_.view,supportsAlpha:t.supportsAlpha,svPaletteView:this.svPaletteC_.view,textView:this.textC_.view})}get textController(){return this.textC_}}const oo=c("colsw");class Ao{constructor(e,t){this.onValueChange_=this.onValueChange_.bind(this),t.value.emitter.on("change",this.onValueChange_),this.value=t.value,this.element=e.createElement("div"),this.element.classList.add(oo()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("div");n.classList.add(oo("sw")),this.element.appendChild(n),this.swatchElem_=n;const o=e.createElement("button");o.classList.add(oo("b")),t.viewProps.bindDisabled(o),this.element.appendChild(o),this.buttonElement=o,this.update_()}update_(){const e=this.value.rawValue;this.swatchElem_.style.backgroundColor=Mn(e)}onValueChange_(){this.update_()}}class io{constructor(e,t){this.value=t.value,this.viewProps=t.viewProps,this.view=new Ao(e,{value:this.value,viewProps:this.viewProps})}}class ro{constructor(e,t){this.onButtonBlur_=this.onButtonBlur_.bind(this),this.onButtonClick_=this.onButtonClick_.bind(this),this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.foldable_=Z.create(t.expanded),this.swatchC_=new io(e,{value:this.value,viewProps:this.viewProps});const n=this.swatchC_.view.buttonElement;n.addEventListener("blur",this.onButtonBlur_),n.addEventListener("click",this.onButtonClick_),this.textC_=new tt(e,{parser:t.parser,props:J.fromObject({formatter:t.formatter}),value:this.value,viewProps:this.viewProps}),this.view=new cn(e,{foldable:this.foldable_,pickerLayout:t.pickerLayout}),this.view.swatchElement.appendChild(this.swatchC_.view.element),this.view.textElement.appendChild(this.textC_.view.element),this.popC_="popup"===t.pickerLayout?new Ye(e,{viewProps:this.viewProps}):null;const o=new no(e,{supportsAlpha:t.supportsAlpha,value:this.value,viewProps:this.viewProps});o.view.allFocusableElements.forEach((e=>{e.addEventListener("blur",this.onPopupChildBlur_),e.addEventListener("keydown",this.onPopupChildKeydown_)})),this.pickerC_=o,this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(o.view.element),qt({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:e=>e.rawValue,backward:(e,t)=>t.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),$(this.foldable_,this.view.pickerElement))}get textController(){return this.textC_}onButtonBlur_(e){if(!this.popC_)return;const t=this.view.element,n=e.relatedTarget;n&&t.contains(n)||(this.popC_.shows.rawValue=!1)}onButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(e){if(!this.popC_)return;const t=this.popC_.view.element,n=U(e);n&&t.contains(n)||n&&n===this.swatchC_.view.buttonElement&&!M(t.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(e){this.popC_?"Escape"===e.key&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&"Escape"===e.key&&this.swatchC_.view.buttonElement.focus()}}function so(e){return fn.isColorObject(e)?fn.fromObject(e):fn.black()}function ao(e){return In(e.getComponents("rgb")).reduce(((e,t)=>e<<8|255&Math.floor(t)),0)}function lo(e){return e.getComponents("rgb").reduce(((e,t,n)=>e<<8|255&Math.floor(3===n?255*t:t)),0)>>>0}function mo(e){return"number"!=typeof e?fn.black():new fn([(t=e)>>16&255,t>>8&255,255&t],"rgb");var t}function po(e){return"number"!=typeof e?fn.black():new fn([(t=e)>>24&255,t>>16&255,t>>8&255,Tt(255&t,0,255,0,1)],"rgb");var t}function ho(e,t){const n=t.toRgbaObject();e.writeProperty("r",n.r),e.writeProperty("g",n.g),e.writeProperty("b",n.b),e.writeProperty("a",n.a)}function uo(e,t){const n=t.toRgbaObject();e.writeProperty("r",n.r),e.writeProperty("g",n.g),e.writeProperty("b",n.b)}function co(e){return"alpha"in e&&!0===e.alpha}function Io(e){return e?e=>Mn(e,"0x"):e=>wn(e,"0x")}const Go={id:"input-color-number",type:"input",accept:(e,t)=>{if("number"!=typeof e)return null;if(!("view"in t))return null;if("color"!==t.view)return null;const n=Cn(t);return n?{initialValue:e,params:n}:null},binding:{reader:e=>co(e.params)?po:mo,equals:fn.equals,writer:e=>function(e){const t=e?lo:ao;return(e,n)=>{Yt(e,t(n))}}(co(e.params))},controller:e=>{const t=co(e.params),n="expanded"in e.params?e.params.expanded:void 0,o="picker"in e.params?e.params.picker:void 0;return new ro(e.document,{expanded:null!=n&&n,formatter:Io(t),parser:bn,pickerLayout:null!=o?o:"popup",supportsAlpha:t,value:e.value,viewProps:e.viewProps})}};const Eo={id:"input-color-object",type:"input",accept:(e,t)=>{if(!fn.isColorObject(e))return null;const n=Cn(t);return n?{initialValue:e,params:n}:null},binding:{reader:e=>so,equals:fn.equals,writer:e=>{return t=e.initialValue,fn.isRgbaColorObject(t)?ho:uo;var t}},controller:e=>{const t=fn.isRgbaColorObject(e.initialValue),n="expanded"in e.params?e.params.expanded:void 0,o="picker"in e.params?e.params.picker:void 0,A=t?Mn:wn;return new ro(e.document,{expanded:null!=n&&n,formatter:A,parser:bn,pickerLayout:null!=o?o:"popup",supportsAlpha:t,value:e.value,viewProps:e.viewProps})}},ko={id:"input-color-string",type:"input",accept:(e,t)=>{if("string"!=typeof e)return null;if("view"in t&&"text"===t.view)return null;if(!yn(e))return null;const n=Cn(t);return n?{initialValue:e,params:n}:null},binding:{reader:e=>xn,equals:fn.equals,writer:e=>{const t=yn(e.initialValue);if(!t)throw l.shouldNeverHappen();return function(e){const t=Nn(e);return(e,n)=>{Yt(e,t(n))}}(t)}},controller:e=>{const t=yn(e.initialValue);if(!t)throw l.shouldNeverHappen();const n=Nn(t),o="expanded"in e.params?e.params.expanded:void 0,A="picker"in e.params?e.params.picker:void 0;return new ro(e.document,{expanded:null!=o&&o,formatter:n,parser:bn,pickerLayout:null!=A?A:"popup",supportsAlpha:qn(t),value:e.value,viewProps:e.viewProps})}};class go{constructor(e){this.components=e.components,this.asm_=e.assembly}constrain(e){const t=this.asm_.toComponents(e).map(((e,t)=>{var n,o;return null!==(o=null===(n=this.components[t])||void 0===n?void 0:n.constrain(e))&&void 0!==o?o:e}));return this.asm_.fromComponents(t)}}const fo=c("pndtxt");class Ho{constructor(e,t){this.textViews=t.textViews,this.element=e.createElement("div"),this.element.classList.add(fo()),this.textViews.forEach((t=>{const n=e.createElement("div");n.classList.add(fo("a")),n.appendChild(t.element),this.element.appendChild(n)}))}}class Fo{constructor(e,t){this.value=t.value,this.viewProps=t.viewProps,this.acs_=t.axes.map(((n,o)=>function(e,t,n){return new Vt(e,{arrayPosition:0===n?"fst":n===t.axes.length-1?"lst":"mid",baseStep:t.axes[n].baseStep,parser:t.parser,props:t.axes[n].textProps,value:D(0,{constraint:t.axes[n].constraint}),viewProps:t.viewProps})}(e,t,o))),this.acs_.forEach(((e,n)=>{qt({primary:this.value,secondary:e.value,forward:e=>t.assembly.toComponents(e.rawValue)[n],backward:(e,o)=>{const A=t.assembly.toComponents(e.rawValue);return A[n]=o.rawValue,t.assembly.fromComponents(A)}})})),this.view=new Ho(e,{textViews:this.acs_.map((e=>e.view))})}}function Co(e){const t=[],n=function(e){return"step"in e&&!r(e.step)?new We(e.step):null}(e);n&&t.push(n);const o=function(e){return"max"in e&&!r(e.max)||"min"in e&&!r(e.min)?new Ve({max:e.max,min:e.min}):null}(e);o&&t.push(o);const A=on(e.options);return A&&t.push(A),new Oe(t)}function Do(e){const[t,n]=function(e){const t=e?Pe(e,Ve):null;return t?[t.minValue,t.maxValue]:[void 0,void 0]}(e);return[null!=t?t:0,null!=n?n:100]}const Jo={id:"input-number",type:"input",accept:(e,t)=>{if("number"!=typeof e)return null;const n=K,o=y(t,{format:n.optional.function,max:n.optional.number,min:n.optional.number,options:n.optional.custom($t),step:n.optional.number});return o?{initialValue:e,params:o}:null},binding:{reader:e=>Ht,constraint:e=>Co(e.params),writer:e=>Yt},controller:e=>{var t,n;const o=e.value,A=e.constraint;if(A&&Pe(A,Ue))return new Xe(e.document,{props:J.fromObject({options:null!==(t=An(A))&&void 0!==t?t:[]}),value:o,viewProps:e.viewProps});const i=null!==(n="format"in e.params?e.params.format:void 0)&&void 0!==n?n:Ct(rn(A,o.rawValue));if(A&&Pe(A,Ve)){const[t,n]=Do(A);return new Zt(e.document,{baseStep:sn(A),parser:ft,sliderProps:J.fromObject({maxValue:n,minValue:t}),textProps:J.fromObject({draggingScale:an(A,o.rawValue),formatter:i}),value:o,viewProps:e.viewProps})}return new Vt(e.document,{baseStep:sn(A),parser:ft,props:J.fromObject({draggingScale:an(A,o.rawValue),formatter:i}),value:o,viewProps:e.viewProps})}};class vo{constructor(e=0,t=0){this.x=e,this.y=t}getComponents(){return[this.x,this.y]}static isObject(e){if(r(e))return!1;const t=e.x,n=e.y;return"number"==typeof t&&"number"==typeof n}static equals(e,t){return e.x===t.x&&e.y===t.y}toObject(){return{x:this.x,y:this.y}}}const jo={toComponents:e=>e.getComponents(),fromComponents:e=>new vo(...e)},Ko=c("p2d");class yo{constructor(e,t){this.element=e.createElement("div"),this.element.classList.add(Ko()),t.viewProps.bindClassModifiers(this.element),I(t.expanded,E(this.element,Ko(void 0,"expanded")));const n=e.createElement("div");n.classList.add(Ko("h")),this.element.appendChild(n);const o=e.createElement("button");o.classList.add(Ko("b")),o.appendChild(N(e,"p2dpad")),t.viewProps.bindDisabled(o),n.appendChild(o),this.buttonElement=o;const A=e.createElement("div");if(A.classList.add(Ko("t")),n.appendChild(A),this.textElement=A,"inline"===t.pickerLayout){const t=e.createElement("div");t.classList.add(Ko("p")),this.element.appendChild(t),this.pickerElement=t}else this.pickerElement=null}}const bo=c("p2dp");class qo{constructor(e,t){this.onFoldableChange_=this.onFoldableChange_.bind(this),this.onValueChange_=this.onValueChange_.bind(this),this.invertsY_=t.invertsY,this.maxValue_=t.maxValue,this.element=e.createElement("div"),this.element.classList.add(bo()),"popup"===t.layout&&this.element.classList.add(bo(void 0,"p"));const n=e.createElement("div");n.classList.add(bo("p")),t.viewProps.bindTabIndex(n),this.element.appendChild(n),this.padElement=n;const o=e.createElementNS(B,"svg");o.classList.add(bo("g")),this.padElement.appendChild(o),this.svgElem_=o;const A=e.createElementNS(B,"line");A.classList.add(bo("ax")),A.setAttributeNS(null,"x1","0"),A.setAttributeNS(null,"y1","50%"),A.setAttributeNS(null,"x2","100%"),A.setAttributeNS(null,"y2","50%"),this.svgElem_.appendChild(A);const i=e.createElementNS(B,"line");i.classList.add(bo("ax")),i.setAttributeNS(null,"x1","50%"),i.setAttributeNS(null,"y1","0"),i.setAttributeNS(null,"x2","50%"),i.setAttributeNS(null,"y2","100%"),this.svgElem_.appendChild(i);const r=e.createElementNS(B,"line");r.classList.add(bo("l")),r.setAttributeNS(null,"x1","50%"),r.setAttributeNS(null,"y1","50%"),this.svgElem_.appendChild(r),this.lineElem_=r;const s=e.createElement("div");s.classList.add(bo("m")),this.padElement.appendChild(s),this.markerElem_=s,t.value.emitter.on("change",this.onValueChange_),this.value=t.value,this.update_()}get allFocusableElements(){return[this.padElement]}update_(){const[e,t]=this.value.rawValue.getComponents(),n=this.maxValue_,o=Tt(e,-n,+n,0,100),A=Tt(t,-n,+n,0,100),i=this.invertsY_?100-A:A;this.lineElem_.setAttributeNS(null,"x2",`${o}%`),this.lineElem_.setAttributeNS(null,"y2",`${i}%`),this.markerElem_.style.left=`${o}%`,this.markerElem_.style.top=`${i}%`}onValueChange_(){this.update_()}onFoldableChange_(){this.update_()}}function xo(e,t,n){return[xt(t[0],wt(e)),xt(t[1],Bt(e))*(n?1:-1)]}class Bo{constructor(e,t){this.onPadKeyDown_=this.onPadKeyDown_.bind(this),this.onPadKeyUp_=this.onPadKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.baseSteps_=t.baseSteps,this.maxValue_=t.maxValue,this.invertsY_=t.invertsY,this.view=new qo(e,{invertsY:this.invertsY_,layout:t.layout,maxValue:this.maxValue_,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new St(this.view.padElement),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.padElement.addEventListener("keydown",this.onPadKeyDown_),this.view.padElement.addEventListener("keyup",this.onPadKeyUp_)}handlePointerEvent_(e,t){if(!e.point)return;const n=this.maxValue_,o=Tt(e.point.x,0,e.bounds.width,-n,+n),A=Tt(this.invertsY_?e.bounds.height-e.point.y:e.point.y,0,e.bounds.height,-n,+n);this.value.setRawValue(new vo(o,A),t)}onPointerDown_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerMove_(e){this.handlePointerEvent_(e.data,{forceEmit:!1,last:!1})}onPointerUp_(e){this.handlePointerEvent_(e.data,{forceEmit:!0,last:!0})}onPadKeyDown_(e){Mt(e.key)&&e.preventDefault();const[t,n]=xo(e,this.baseSteps_,this.invertsY_);0===t&&0===n||this.value.setRawValue(new vo(this.value.rawValue.x+t,this.value.rawValue.y+n),{forceEmit:!1,last:!1})}onPadKeyUp_(e){const[t,n]=xo(e,this.baseSteps_,this.invertsY_);0===t&&0===n||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class wo{constructor(e,t){var n,o;this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.onPadButtonBlur_=this.onPadButtonBlur_.bind(this),this.onPadButtonClick_=this.onPadButtonClick_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.foldable_=Z.create(t.expanded),this.popC_="popup"===t.pickerLayout?new Ye(e,{viewProps:this.viewProps}):null;const A=new Bo(e,{baseSteps:[t.axes[0].baseStep,t.axes[1].baseStep],invertsY:t.invertsY,layout:t.pickerLayout,maxValue:t.maxValue,value:this.value,viewProps:this.viewProps});A.view.allFocusableElements.forEach((e=>{e.addEventListener("blur",this.onPopupChildBlur_),e.addEventListener("keydown",this.onPopupChildKeydown_)})),this.pickerC_=A,this.textC_=new Fo(e,{assembly:jo,axes:t.axes,parser:t.parser,value:this.value,viewProps:this.viewProps}),this.view=new yo(e,{expanded:this.foldable_.value("expanded"),pickerLayout:t.pickerLayout,viewProps:this.viewProps}),this.view.textElement.appendChild(this.textC_.view.element),null===(n=this.view.buttonElement)||void 0===n||n.addEventListener("blur",this.onPadButtonBlur_),null===(o=this.view.buttonElement)||void 0===o||o.addEventListener("click",this.onPadButtonClick_),this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(this.pickerC_.view.element),qt({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:e=>e.rawValue,backward:(e,t)=>t.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),$(this.foldable_,this.view.pickerElement))}onPadButtonBlur_(e){if(!this.popC_)return;const t=this.view.element,n=e.relatedTarget;n&&t.contains(n)||(this.popC_.shows.rawValue=!1)}onPadButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(e){if(!this.popC_)return;const t=this.popC_.view.element,n=U(e);n&&t.contains(n)||n&&n===this.view.buttonElement&&!M(t.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(e){this.popC_?"Escape"===e.key&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&"Escape"===e.key&&this.view.buttonElement.focus()}}function Mo(e){return vo.isObject(e)?new vo(e.x,e.y):new vo}function Lo(e,t){e.writeProperty("x",t.x),e.writeProperty("y",t.y)}function So(e){if(!e)return;const t=[];return r(e.step)||t.push(new We(e.step)),r(e.max)&&r(e.min)||t.push(new Ve({max:e.max,min:e.min})),new Oe(t)}function To(e,t){const n=e&&Pe(e,Ve);if(n)return Math.max(Math.abs(n.minValue||0),Math.abs(n.maxValue||0));const o=sn(e);return Math.max(10*Math.abs(o),10*Math.abs(t))}function No(e,t){const n=t instanceof go?t.components[0]:void 0,o=t instanceof go?t.components[1]:void 0,A=To(n,e.x),i=To(o,e.y);return Math.max(A,i)}function Ro(e,t){return{baseStep:sn(t),constraint:t,textProps:J.fromObject({draggingScale:an(t,e),formatter:Ct(rn(t,e))})}}function Oo(e){if(!("y"in e))return!1;const t=e.y;return!!t&&"inverted"in t&&!!t.inverted}const Po={id:"input-point2d",type:"input",accept:(e,t)=>{if(!vo.isObject(e))return null;const n=K,o=y(t,{expanded:n.optional.boolean,picker:n.optional.custom(en),x:n.optional.custom(tn),y:n.optional.object({inverted:n.optional.boolean,max:n.optional.number,min:n.optional.number,step:n.optional.number})});return o?{initialValue:e,params:o}:null},binding:{reader:e=>Mo,constraint:e=>{return t=e.params,new go({assembly:jo,components:[So("x"in t?t.x:void 0),So("y"in t?t.y:void 0)]});var t},equals:vo.equals,writer:e=>Lo},controller:e=>{const t=e.document,n=e.value,o=e.constraint;if(!(o instanceof go))throw l.shouldNeverHappen();const A="expanded"in e.params?e.params.expanded:void 0,i="picker"in e.params?e.params.picker:void 0;return new wo(t,{axes:[Ro(n.rawValue.x,o.components[0]),Ro(n.rawValue.y,o.components[1])],expanded:null!=A&&A,invertsY:Oo(e.params),maxValue:No(n.rawValue,o),parser:ft,pickerLayout:null!=i?i:"popup",value:n,viewProps:e.viewProps})}};class Uo{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}getComponents(){return[this.x,this.y,this.z]}static isObject(e){if(r(e))return!1;const t=e.x,n=e.y,o=e.z;return"number"==typeof t&&"number"==typeof n&&"number"==typeof o}static equals(e,t){return e.x===t.x&&e.y===t.y&&e.z===t.z}toObject(){return{x:this.x,y:this.y,z:this.z}}}const Vo={toComponents:e=>e.getComponents(),fromComponents:e=>new Uo(...e)};function Wo(e){return Uo.isObject(e)?new Uo(e.x,e.y,e.z):new Uo}function _o(e,t){e.writeProperty("x",t.x),e.writeProperty("y",t.y),e.writeProperty("z",t.z)}function zo(e){if(!e)return;const t=[];return r(e.step)||t.push(new We(e.step)),r(e.max)&&r(e.min)||t.push(new Ve({max:e.max,min:e.min})),new Oe(t)}function Xo(e,t){return{baseStep:sn(t),constraint:t,textProps:J.fromObject({draggingScale:an(t,e),formatter:Ct(rn(t,e))})}}const Qo={id:"input-point3d",type:"input",accept:(e,t)=>{if(!Uo.isObject(e))return null;const n=K,o=y(t,{x:n.optional.custom(tn),y:n.optional.custom(tn),z:n.optional.custom(tn)});return o?{initialValue:e,params:o}:null},binding:{reader:e=>Wo,constraint:e=>{return t=e.params,new go({assembly:Vo,components:[zo("x"in t?t.x:void 0),zo("y"in t?t.y:void 0),zo("z"in t?t.z:void 0)]});var t},equals:Uo.equals,writer:e=>_o},controller:e=>{const t=e.value,n=e.constraint;if(!(n instanceof go))throw l.shouldNeverHappen();return new Fo(e.document,{assembly:Vo,axes:[Xo(t.rawValue.x,n.components[0]),Xo(t.rawValue.y,n.components[1]),Xo(t.rawValue.z,n.components[2])],parser:ft,value:t,viewProps:e.viewProps})}};class Zo{constructor(e=0,t=0,n=0,o=0){this.x=e,this.y=t,this.z=n,this.w=o}getComponents(){return[this.x,this.y,this.z,this.w]}static isObject(e){if(r(e))return!1;const t=e.x,n=e.y,o=e.z,A=e.w;return"number"==typeof t&&"number"==typeof n&&"number"==typeof o&&"number"==typeof A}static equals(e,t){return e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w}toObject(){return{x:this.x,y:this.y,z:this.z,w:this.w}}}const Yo={toComponents:e=>e.getComponents(),fromComponents:e=>new Zo(...e)};function $o(e){return Zo.isObject(e)?new Zo(e.x,e.y,e.z,e.w):new Zo}function eA(e,t){e.writeProperty("x",t.x),e.writeProperty("y",t.y),e.writeProperty("z",t.z),e.writeProperty("w",t.w)}function tA(e){if(!e)return;const t=[];return r(e.step)||t.push(new We(e.step)),r(e.max)&&r(e.min)||t.push(new Ve({max:e.max,min:e.min})),new Oe(t)}const nA={id:"input-point4d",type:"input",accept:(e,t)=>{if(!Zo.isObject(e))return null;const n=K,o=y(t,{x:n.optional.custom(tn),y:n.optional.custom(tn),z:n.optional.custom(tn),w:n.optional.custom(tn)});return o?{initialValue:e,params:o}:null},binding:{reader:e=>$o,constraint:e=>{return t=e.params,new go({assembly:Yo,components:[tA("x"in t?t.x:void 0),tA("y"in t?t.y:void 0),tA("z"in t?t.z:void 0),tA("w"in t?t.w:void 0)]});var t},equals:Zo.equals,writer:e=>eA},controller:e=>{const t=e.value,n=e.constraint;if(!(n instanceof go))throw l.shouldNeverHappen();return new Fo(e.document,{assembly:Yo,axes:t.rawValue.getComponents().map(((e,t)=>{return o=e,{baseStep:sn(A=n.components[t]),constraint:A,textProps:J.fromObject({draggingScale:an(A,o),formatter:Ct(rn(A,o))})};var o,A})),parser:ft,value:t,viewProps:e.viewProps})}};const oA={id:"input-string",type:"input",accept:(e,t)=>{if("string"!=typeof e)return null;const n=y(t,{options:K.optional.custom($t)});return n?{initialValue:e,params:n}:null},binding:{reader:e=>vt,constraint:e=>function(e){const t=[],n=on(e.options);return n&&t.push(n),new Oe(t)}(e.params),writer:e=>Yt},controller:e=>{var t;const n=e.document,o=e.value,A=e.constraint;return A&&Pe(A,Ue)?new Xe(n,{props:J.fromObject({options:null!==(t=An(A))&&void 0!==t?t:[]}),value:o,viewProps:e.viewProps}):new tt(n,{parser:e=>e,props:J.fromObject({formatter:jt}),value:o,viewProps:e.viewProps})}},AA={defaultInterval:200,defaultLineCount:3},iA=c("mll");class rA{constructor(e,t){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=t.formatter,this.element=e.createElement("div"),this.element.classList.add(iA()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("textarea");n.classList.add(iA("i")),n.style.height=`calc(var(--bld-us) * ${t.lineCount})`,n.readOnly=!0,t.viewProps.bindDisabled(n),this.element.appendChild(n),this.textareaElem_=n,t.value.emitter.on("change",this.onValueUpdate_),this.value=t.value,this.update_()}update_(){const e=this.textareaElem_,t=e.scrollTop===e.scrollHeight-e.clientHeight,n=[];this.value.rawValue.forEach((e=>{void 0!==e&&n.push(this.formatter_(e))})),e.textContent=n.join("\n"),t&&(e.scrollTop=e.scrollHeight)}onValueUpdate_(){this.update_()}}class sA{constructor(e,t){this.value=t.value,this.viewProps=t.viewProps,this.view=new rA(e,{formatter:t.formatter,lineCount:t.lineCount,value:this.value,viewProps:this.viewProps})}}const aA=c("sgl");class lA{constructor(e,t){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=t.formatter,this.element=e.createElement("div"),this.element.classList.add(aA()),t.viewProps.bindClassModifiers(this.element);const n=e.createElement("input");n.classList.add(aA("i")),n.readOnly=!0,n.type="text",t.viewProps.bindDisabled(n),this.element.appendChild(n),this.inputElement=n,t.value.emitter.on("change",this.onValueUpdate_),this.value=t.value,this.update_()}update_(){const e=this.value.rawValue,t=e[e.length-1];this.inputElement.value=void 0!==t?this.formatter_(t):""}onValueUpdate_(){this.update_()}}class mA{constructor(e,t){this.value=t.value,this.viewProps=t.viewProps,this.view=new lA(e,{formatter:t.formatter,value:this.value,viewProps:this.viewProps})}}const pA={id:"monitor-bool",type:"monitor",accept:(e,t)=>{if("boolean"!=typeof e)return null;const n=y(t,{lineCount:K.optional.number});return n?{initialValue:e,params:n}:null},binding:{reader:e=>nt},controller:e=>{var t;return 1===e.value.rawValue.length?new mA(e.document,{formatter:ot,value:e.value,viewProps:e.viewProps}):new sA(e.document,{formatter:ot,lineCount:null!==(t=e.params.lineCount)&&void 0!==t?t:AA.defaultLineCount,value:e.value,viewProps:e.viewProps})}};class hA{constructor(){this.emitter=new h,this.index_=-1}get index(){return this.index_}set index(e){this.index_!==e&&(this.index_=e,this.emitter.emit("change",{index:e,sender:this}))}}const uA=c("grl");class cA{constructor(e,t){this.onCursorChange_=this.onCursorChange_.bind(this),this.onValueUpdate_=this.onValueUpdate_.bind(this),this.element=e.createElement("div"),this.element.classList.add(uA()),t.viewProps.bindClassModifiers(this.element),this.formatter_=t.formatter,this.minValue_=t.minValue,this.maxValue_=t.maxValue,this.cursor_=t.cursor,this.cursor_.emitter.on("change",this.onCursorChange_);const n=e.createElementNS(B,"svg");n.classList.add(uA("g")),n.style.height=`calc(var(--bld-us) * ${t.lineCount})`,this.element.appendChild(n),this.svgElem_=n;const o=e.createElementNS(B,"polyline");this.svgElem_.appendChild(o),this.lineElem_=o;const A=e.createElement("div");A.classList.add(uA("t"),c("tt")()),this.element.appendChild(A),this.tooltipElem_=A,t.value.emitter.on("change",this.onValueUpdate_),this.value=t.value,this.update_()}get graphElement(){return this.svgElem_}update_(){const e=this.svgElem_.getBoundingClientRect(),t=this.value.rawValue.length-1,n=this.minValue_,o=this.maxValue_,A=[];this.value.rawValue.forEach(((i,r)=>{if(void 0===i)return;const s=Tt(r,0,t,0,e.width),a=Tt(i,n,o,e.height,0);A.push([s,a].join(","))})),this.lineElem_.setAttributeNS(null,"points",A.join(" "));const i=this.tooltipElem_,r=this.value.rawValue[this.cursor_.index];if(void 0===r)return void i.classList.remove(uA("t","a"));const s=Tt(this.cursor_.index,0,t,0,e.width),a=Tt(r,n,o,e.height,0);i.style.left=`${s}px`,i.style.top=`${a}px`,i.textContent=`${this.formatter_(r)}`,i.classList.contains(uA("t","a"))||(i.classList.add(uA("t","a"),uA("t","in")),w(i),i.classList.remove(uA("t","in")))}onValueUpdate_(){this.update_()}onCursorChange_(){this.update_()}}class dA{constructor(e,t){if(this.onGraphMouseMove_=this.onGraphMouseMove_.bind(this),this.onGraphMouseLeave_=this.onGraphMouseLeave_.bind(this),this.onGraphPointerDown_=this.onGraphPointerDown_.bind(this),this.onGraphPointerMove_=this.onGraphPointerMove_.bind(this),this.onGraphPointerUp_=this.onGraphPointerUp_.bind(this),this.value=t.value,this.viewProps=t.viewProps,this.cursor_=new hA,this.view=new cA(e,{cursor:this.cursor_,formatter:t.formatter,lineCount:t.lineCount,maxValue:t.maxValue,minValue:t.minValue,value:this.value,viewProps:this.viewProps}),M(e)){const e=new St(this.view.element);e.emitter.on("down",this.onGraphPointerDown_),e.emitter.on("move",this.onGraphPointerMove_),e.emitter.on("up",this.onGraphPointerUp_)}else this.view.element.addEventListener("mousemove",this.onGraphMouseMove_),this.view.element.addEventListener("mouseleave",this.onGraphMouseLeave_)}onGraphMouseLeave_(){this.cursor_.index=-1}onGraphMouseMove_(e){const t=this.view.element.getBoundingClientRect();this.cursor_.index=Math.floor(Tt(e.offsetX,0,t.width,0,this.value.rawValue.length))}onGraphPointerDown_(e){this.onGraphPointerMove_(e)}onGraphPointerMove_(e){e.data.point?this.cursor_.index=Math.floor(Tt(e.data.point.x,0,e.data.bounds.width,0,this.value.rawValue.length)):this.cursor_.index=-1}onGraphPointerUp_(){this.cursor_.index=-1}}function IA(e){return"format"in e&&!r(e.format)?e.format:Ct(2)}function GA(e){return"view"in e&&"graph"===e.view}const EA={id:"monitor-number",type:"monitor",accept:(e,t)=>{if("number"!=typeof e)return null;const n=K,o=y(t,{format:n.optional.function,lineCount:n.optional.number,max:n.optional.number,min:n.optional.number,view:n.optional.string});return o?{initialValue:e,params:o}:null},binding:{defaultBufferSize:e=>GA(e)?64:1,reader:e=>Ht},controller:e=>GA(e.params)?function(e){var t,n,o;return new dA(e.document,{formatter:IA(e.params),lineCount:null!==(t=e.params.lineCount)&&void 0!==t?t:AA.defaultLineCount,maxValue:null!==(n="max"in e.params?e.params.max:null)&&void 0!==n?n:100,minValue:null!==(o="min"in e.params?e.params.min:null)&&void 0!==o?o:0,value:e.value,viewProps:e.viewProps})}(e):function(e){var t;return 1===e.value.rawValue.length?new mA(e.document,{formatter:IA(e.params),value:e.value,viewProps:e.viewProps}):new sA(e.document,{formatter:IA(e.params),lineCount:null!==(t=e.params.lineCount)&&void 0!==t?t:AA.defaultLineCount,value:e.value,viewProps:e.viewProps})}(e)},kA={id:"monitor-string",type:"monitor",accept:(e,t)=>{if("string"!=typeof e)return null;const n=K,o=y(t,{lineCount:n.optional.number,multiline:n.optional.boolean});return o?{initialValue:e,params:o}:null},binding:{reader:e=>vt},controller:e=>{var t;const n=e.value;return n.rawValue.length>1||"multiline"in e.params&&e.params.multiline?new sA(e.document,{formatter:jt,lineCount:null!==(t=e.params.lineCount)&&void 0!==t?t:AA.defaultLineCount,value:n,viewProps:e.viewProps}):new mA(e.document,{formatter:jt,value:n,viewProps:e.viewProps})}};class gA{constructor(e){this.onValueChange_=this.onValueChange_.bind(this),this.reader=e.reader,this.writer=e.writer,this.emitter=new h,this.value=e.value,this.value.emitter.on("change",this.onValueChange_),this.target=e.target,this.read()}read(){const e=this.target.read();void 0!==e&&(this.value.rawValue=this.reader(e))}write_(e){this.writer(this.target,e)}onValueChange_(e){this.write_(e.rawValue),this.emitter.emit("change",{options:e.options,rawValue:e.rawValue,sender:this})}}class fA{constructor(e){this.onTick_=this.onTick_.bind(this),this.reader_=e.reader,this.target=e.target,this.emitter=new h,this.value=e.value,this.ticker=e.ticker,this.ticker.emitter.on("tick",this.onTick_),this.read()}dispose(){this.ticker.dispose()}read(){const e=this.target.read();if(void 0===e)return;const t=this.value.rawValue,n=this.reader_(e);this.value.rawValue=function(e,t){const n=[...bt(e),t];return n.length>e.length?n.splice(0,n.length-e.length):Kt(n,e.length),n}(t,n),this.emitter.emit("update",{rawValue:n,sender:this})}onTick_(e){this.read()}}function HA(e,t){return 0===t?new Ne:new Re(e,null!=t?t:AA.defaultInterval)}class FA{constructor(){this.pluginsMap_={blades:[],inputs:[],monitors:[]}}getAll(){return[...this.pluginsMap_.blades,...this.pluginsMap_.inputs,...this.pluginsMap_.monitors]}register(e){"blade"===e.type?this.pluginsMap_.blades.unshift(e):"input"===e.type?this.pluginsMap_.inputs.unshift(e):"monitor"===e.type&&this.pluginsMap_.monitors.unshift(e)}createInput(e,t,n){if(r(t.read()))throw new l({context:{key:t.key},type:"nomatchingcontroller"});const o=this.pluginsMap_.inputs.reduce(((o,A)=>o||function(e,t){const n=e.accept(t.target.read(),t.params);if(r(n))return null;const o=K,A={target:t.target,initialValue:n.initialValue,params:n.params},i=e.binding.reader(A),s=e.binding.constraint?e.binding.constraint(A):void 0,a=D(i(n.initialValue),{constraint:s,equals:e.binding.equals}),l=new gA({reader:i,target:t.target,value:a,writer:e.binding.writer(A)}),m=o.optional.boolean(t.params.disabled).value,p=o.optional.boolean(t.params.hidden).value,h=e.controller({constraint:s,document:t.document,initialValue:n.initialValue,params:n.params,value:l.value,viewProps:Ke.create({disabled:m,hidden:p})}),u=o.optional.string(t.params.label).value;return new oe(t.document,{binding:l,blade:Q(),props:J.fromObject({label:u||t.target.key}),valueController:h})}(A,{document:e,target:t,params:n})),null);if(o)return o;throw new l({context:{key:t.key},type:"nomatchingcontroller"})}createMonitor(e,t,n){const o=this.pluginsMap_.monitors.reduce(((o,A)=>o||function(e,t){var n,o,A;const i=K,s=e.accept(t.target.read(),t.params);if(r(s))return null;const a={target:t.target,initialValue:s.initialValue,params:s.params},l=e.binding.reader(a),m=null!==(o=null!==(n=i.optional.number(t.params.bufferSize).value)&&void 0!==n?n:e.binding.defaultBufferSize&&e.binding.defaultBufferSize(s.params))&&void 0!==o?o:1,p=i.optional.number(t.params.interval).value,h=new fA({reader:l,target:t.target,ticker:HA(t.document,p),value:yt(m)}),u=i.optional.boolean(t.params.disabled).value,c=i.optional.boolean(t.params.hidden).value,d=e.controller({document:t.document,params:s.params,value:h.value,viewProps:Ke.create({disabled:u,hidden:c})}),I=null!==(A=i.optional.string(t.params.label).value)&&void 0!==A?A:t.target.key;return new ie(t.document,{binding:h,blade:Q(),props:J.fromObject({label:I}),valueController:d})}(A,{document:e,params:n,target:t})),null);if(o)return o;throw new l({context:{key:t.key},type:"nomatchingcontroller"})}createBlade(e,t){const n=this.pluginsMap_.blades.reduce(((n,o)=>n||function(e,t){const n=e.accept(t.params);if(!n)return null;const o=K.optional.boolean(t.params.disabled).value,A=K.optional.boolean(t.params.hidden).value;return e.controller({blade:Q(),document:t.document,params:Object.assign(Object.assign({},n.params),{disabled:o,hidden:A}),viewProps:Ke.create({disabled:o,hidden:A})})}(o,{document:e,params:t})),null);if(!n)throw new l({type:"nomatchingview",context:{params:t}});return n}createBladeApi(e){if(e instanceof oe)return new ne(e);if(e instanceof ie)return new Ae(e);if(e instanceof Ie)return new le(e,this);const t=this.pluginsMap_.blades.reduce(((t,n)=>t||n.api({controller:e,pool:this})),null);if(!t)throw l.shouldNeverHappen();return t}}class CA extends t{constructor(e){super(e),this.emitter_=new h,this.controller_.valueController.value.emitter.on("change",(e=>{this.emitter_.emit("change",{event:new o(this,e.rawValue)})}))}get label(){return this.controller_.props.get("label")}set label(e){this.controller_.props.set("label",e)}get options(){return this.controller_.valueController.props.get("options")}set options(e){this.controller_.valueController.props.set("options",e)}get value(){return this.controller_.valueController.value.rawValue}set value(e){this.controller_.valueController.value.rawValue=e}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}}class DA extends t{constructor(e){super(e),this.emitter_=new h,this.controller_.valueController.value.emitter.on("change",(e=>{this.emitter_.emit("change",{event:new o(this,e.rawValue)})}))}get label(){return this.controller_.props.get("label")}set label(e){this.controller_.props.set("label",e)}get maxValue(){return this.controller_.valueController.sliderController.props.get("maxValue")}set maxValue(e){this.controller_.valueController.sliderController.props.set("maxValue",e)}get minValue(){return this.controller_.valueController.sliderController.props.get("minValue")}set minValue(e){this.controller_.valueController.sliderController.props.set("minValue",e)}get value(){return this.controller_.valueController.value.rawValue}set value(e){this.controller_.valueController.value.rawValue=e}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}}class JA extends t{constructor(e){super(e),this.emitter_=new h,this.controller_.valueController.value.emitter.on("change",(e=>{this.emitter_.emit("change",{event:new o(this,e.rawValue)})}))}get label(){return this.controller_.props.get("label")}set label(e){this.controller_.props.set("label",e)}get formatter(){return this.controller_.valueController.props.get("formatter")}set formatter(e){this.controller_.valueController.props.set("formatter",e)}get value(){return this.controller_.valueController.value.rawValue}set value(e){this.controller_.valueController.value.rawValue=e}on(e,t){const n=t.bind(this);return this.emitter_.on(e,(e=>{n(e.event)})),this}}const vA={id:"list",type:"blade",accept(e){const t=K,n=y(e,{options:t.required.custom($t),value:t.required.raw,view:t.required.constant("list"),label:t.optional.string});return n?{params:n}:null},controller(e){const t=new Xe(e.document,{props:J.fromObject({options:nn(e.params.options)}),value:D(e.params.value),viewProps:e.viewProps});return new fe(e.document,{blade:e.blade,props:J.fromObject({label:e.params.label}),valueController:t})},api:e=>e.controller instanceof fe&&e.controller.valueController instanceof Xe?new CA(e.controller):null};class jA extends me{constructor(e,t){super(e,t)}get element(){return this.controller_.view.element}importPreset(e){(function(e,t){e.forEach((e=>{const n=t[e.presetKey];void 0!==n&&e.write(n)}))})(this.controller_.rackController.rack.find(oe).map((e=>e.binding.target)),e),this.refresh()}exportPreset(){return this.controller_.rackController.rack.find(oe).map((e=>e.binding.target)).reduce(((e,t)=>Object.assign(e,{[t.presetKey]:t.read()})),{})}refresh(){this.controller_.rackController.rack.find(oe).forEach((e=>{e.binding.read()})),this.controller_.rackController.rack.find(ie).forEach((e=>{e.binding.read()}))}}class KA extends ke{constructor(e,t){super(e,{expanded:t.expanded,blade:t.blade,props:t.props,root:!0,viewProps:t.viewProps})}}const yA={id:"slider",type:"blade",accept(e){const t=K,n=y(e,{max:t.required.number,min:t.required.number,view:t.required.constant("slider"),format:t.optional.function,label:t.optional.string,value:t.optional.number});return n?{params:n}:null},controller(e){var t,n;const o=null!==(t=e.params.value)&&void 0!==t?t:0,A=new Zt(e.document,{baseStep:1,parser:ft,sliderProps:J.fromObject({maxValue:e.params.max,minValue:e.params.min}),textProps:J.fromObject({draggingScale:an(void 0,o),formatter:null!==(n=e.params.format)&&void 0!==n?n:Ft}),value:D(o),viewProps:e.viewProps});return new fe(e.document,{blade:e.blade,props:J.fromObject({label:e.params.label}),valueController:A})},api:e=>e.controller instanceof fe&&e.controller.valueController instanceof Zt?new DA(e.controller):null},bA={id:"text",type:"blade",accept(e){const t=K,n=y(e,{parse:t.required.function,value:t.required.raw,view:t.required.constant("text"),format:t.optional.function,label:t.optional.string});return n?{params:n}:null},controller(e){var t;const n=new tt(e.document,{parser:e.params.parse,props:J.fromObject({formatter:null!==(t=e.params.format)&&void 0!==t?t:e=>String(e)}),value:D(e.params.value),viewProps:e.viewProps});return new fe(e.document,{blade:e.blade,props:J.fromObject({label:e.params.label}),valueController:n})},api:e=>e.controller instanceof fe&&e.controller.valueController instanceof tt?new JA(e.controller):null};function qA(e,t,n){if(e.querySelector(`style[data-tp-style=${t}]`))return;const o=e.createElement("style");o.dataset.tpStyle=t,o.textContent=n,e.head.appendChild(o)}const xA=new class{constructor(e){const[t,n]=e.split("-"),o=t.split(".");this.major=parseInt(o[0],10),this.minor=parseInt(o[1],10),this.patch=parseInt(o[2],10),this.prerelease=null!=n?n:null}toString(){const e=[this.major,this.minor,this.patch].join(".");return null!==this.prerelease?[e,this.prerelease].join("-"):e}}("3.0.6");e.BladeApi=t,e.ButtonApi=p,e.FolderApi=me,e.InputBindingApi=ne,e.ListApi=CA,e.MonitorBindingApi=Ae,e.Pane=class extends jA{constructor(e){var t;const n=e||{},o=null!==(t=n.document)&&void 0!==t?t:L().document,A=function(){const e=new FA;return[Po,Qo,nA,oA,Jo,ko,Eo,Go,hn,pA,kA,EA,z,ge,Je,Te].forEach((t=>{e.register(t)})),e}();super(new KA(o,{expanded:n.expanded,blade:Q(),props:J.fromObject({title:n.title}),viewProps:Ke.create()}),A),this.pool_=A,this.containerElem_=n.container||function(e){const t=e.createElement("div");return t.classList.add(c("dfw")()),e.body&&e.body.appendChild(t),t}(o),this.containerElem_.appendChild(this.element),this.doc_=o,this.usesDefaultWrapper_=!n.container,this.setUpDefaultPlugins_()}get document(){if(!this.doc_)throw l.alreadyDisposed();return this.doc_}dispose(){const e=this.containerElem_;if(!e)throw l.alreadyDisposed();if(this.usesDefaultWrapper_){const t=e.parentElement;t&&t.removeChild(e)}this.containerElem_=null,this.doc_=null,super.dispose()}registerPlugin(e){("plugin"in e?[e.plugin]:"plugins"in e?e.plugins:[]).forEach((e=>{this.pool_.register(e),this.embedPluginStyle_(e)}))}embedPluginStyle_(e){e.css&&qA(this.document,`plugin-${e.id}`,e.css)}setUpDefaultPlugins_(){qA(this.document,"default",".tp-lstv_s,.tp-btnv_b,.tp-p2dv_b,.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i,.tp-grlv_g,.tp-sglv_i,.tp-mllv_i,.tp-fldv_b,.tp-rotv_b,.tp-ckbv_i,.tp-coltxtv_ms,.tp-tbiv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-lstv_s,.tp-btnv_b,.tp-p2dv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-lstv_s:hover,.tp-btnv_b:hover,.tp-p2dv_b:hover{background-color:var(--btn-bg-h)}.tp-lstv_s:focus,.tp-btnv_b:focus,.tp-p2dv_b:focus{background-color:var(--btn-bg-f)}.tp-lstv_s:active,.tp-btnv_b:active,.tp-p2dv_b:active{background-color:var(--btn-bg-a)}.tp-lstv_s:disabled,.tp-btnv_b:disabled,.tp-p2dv_b:disabled{opacity:0.5}.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-colswv_sw:hover,.tp-p2dpv_p:hover,.tp-txtv_i:hover{background-color:var(--in-bg-h)}.tp-colswv_sw:focus,.tp-p2dpv_p:focus,.tp-txtv_i:focus{background-color:var(--in-bg-f)}.tp-colswv_sw:active,.tp-p2dpv_p:active,.tp-txtv_i:active{background-color:var(--in-bg-a)}.tp-colswv_sw:disabled,.tp-p2dpv_p:disabled,.tp-txtv_i:disabled{opacity:0.5}.tp-grlv_g,.tp-sglv_i,.tp-mllv_i{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);width:100%}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono,Source Code Pro,Menlo,Courier,monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #2f3137);--bs-sh: var(--tp-base-shadow-color, rgba(0,0,0,0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #2f3137);--cnt-bg: var(--tp-container-background-color, rgba(187,188,196,0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187,188,196,0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187,188,196,0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187,188,196,0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(0,0,0,0.2));--in-bg-a: var(--tp-input-background-color-active, rgba(0,0,0,0.35));--in-bg-f: var(--tp-input-background-color-focus, rgba(0,0,0,0.3));--in-bg-h: var(--tp-input-background-color-hover, rgba(0,0,0,0.25));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187,188,196,0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0,0,0,0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187,188,196,0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(0,0,0,0.2))}.tp-fldv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-rotv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-v-p))}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-rotv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-fldv_c>.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv{margin-left:4px}.tp-fldv_c>.tp-fldv>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c .tp-fldv>.tp-fldv_c,.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-tabv>.tp-tabv_i,.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-fldv_c .tp-tabv>.tp-tabv_c,.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_b,.tp-rotv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:calc(var(--cnt-h-p) + 8px);padding-right:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-fldv_b:hover,.tp-rotv_b:hover{background-color:var(--cnt-bg-h)}.tp-fldv_b:focus,.tp-rotv_b:focus{background-color:var(--cnt-bg-f)}.tp-fldv_b:active,.tp-rotv_b:active{background-color:var(--cnt-bg-a)}.tp-fldv_b:disabled,.tp-rotv_b:disabled{opacity:0.5}.tp-fldv_m,.tp-rotv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:'';display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px) / 2 - 2px);margin:auto;opacity:0.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m,.tp-rotv.tp-rotv-expanded .tp-rotv_m{transform:none}.tp-fldv_c,.tp-rotv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c,.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c{display:none}.tp-fldv.tp-fldv-expanded>.tp-fldv_c,.tp-rotv.tp-rotv-expanded .tp-rotv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-coltxtv_m,.tp-lstv{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-coltxtv_mm,.tp-lstv_m{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-coltxtv_mm svg,.tp-lstv_m svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-coltxtv_mm svg path,.tp-lstv_m svg path{fill:currentColor}.tp-coltxtv_w,.tp-pndtxtv{display:flex}.tp-coltxtv_c,.tp-pndtxtv_a{width:100%}.tp-coltxtv_c+.tp-coltxtv_c,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-pndtxtv_a{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:0.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:'';height:2px;left:calc(-1 * var(--cnt-h-p));position:absolute;right:calc(-1 * var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us) * 4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0,0,0,0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,0.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,0.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br)}.tp-colswv.tp-v-disabled{opacity:0.5}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,0.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:'';display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left 0.05s, top 0.05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:0.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:0.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:0.5}.tp-mllv_i{display:block;height:calc(var(--bld-us) * 3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:0.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:0.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:0.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:0.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:'';display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:0.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:0.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:0.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:0.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:0.1;position:absolute;top:0;transition:border-radius 0.1s, height 0.1s, transform 0.1s, width 0.1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:'';font-size:0.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}"),this.pool_.getAll().forEach((e=>{this.embedPluginStyle_(e)})),this.registerPlugin({plugins:[yA,vA,Te,bA]})}},e.SeparatorApi=He,e.SliderApi=DA,e.TabApi=we,e.TabPageApi=Be,e.TextApi=JA,e.TpChangeEvent=o,e.VERSION=xA,Object.defineProperty(e,"__esModule",{value:!0})}(t)},5410:()=>{},8628:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{},6824:e=>{"use strict";e.exports=JSON.parse('{"layers":[{"preprocessing":"inputMix0","size":64,"nBlurPass":1,"varianceMin":0.1,"blurKernelSizePx":5,"type":"input","index":0,"mask":null,"tilt":0,"customInputShader":false},{"size":128,"sparsity":8,"activation":"arctan","connectivity":{"fromLayerSize":64,"toLayerSize":128,"toSparsity":8,"weights":{"isPot":true,"width":64,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":16384,\\"data\\":\\"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\\"}"},"kernelsCount":8,"layerIndex":1},"bias":{"isPot":true,"width":8,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":256,\\"data\\":\\"wFvereufOLs7vIvaNqPzQotRnZQyQhs6qMQysJtkuar1wAKXP/wvwfRkQVwPt/w4N2PDsIutQRPZO3vAmVw1QcQyP7qkQguvLewxwbwtKVQusLwcQ2w/vCQhp8wvsswetAQjQ3wWPJqKpEQeMTRNvBREPfRgQ0RLtyyvwvrmobxFw5plo6xpwenHPpwzQIuQAAqVoSwSIXQprmQXQMxEQXQ1LYxRw6Q1JpRIwzwyMbqzwuwxN3RJQxsuFCxIsRQ4ogQpqlsNCTqXt+r9Qqw+wyQ4pwuEsruKGjxAn4wxObrswsw4Q+RKQxORq4Q9Q0sWopwmwYtRwBQkrHwWQNtFsDQ8qYxGtOw1oqQ2uewwovQ/QuwzhXxEQuQ1QDsfQxtNQLwnwYwgnEwswbrHoKxPxIodQHwkOmv1NaRBQxvxw0tnrFsiQwRJtkQ1laQFQxQxoiQpwev2K/sBwcr9oeQUQ0szO4xHueQ4lKtZrKwtoTRHvHQ1rDxLKBQ1JZxGw4Q1\\"}"},"index":1,"classesCount":0,"connectivityUp":"conv","normalize":false,"kernelsCount":8,"maxPooling":{"size":2},"remap":{"isEnabled":false},"isReorganize":true,"dynPelu":false},{"size":32,"sparsity":32,"activation":"elu01","connectivity":{"fromLayerSize":64,"toLayerSize":32,"toSparsity":32,"weights":{"isPot":true,"width":128,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":65536,\\"data\\":\\"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\\"}"},"kernelsCount":4,"layerIndex":2},"bias":{"isPot":true,"width":4,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":64,\\"data\\":\\"kAnfHDAAIakRqUotJrGPFAgLqKI1GIiaEoItlhrxqckUAAjYIHsgoqJ0lPniqtI2kfpFqto2qEHyJ2mxAAreCyCpkbGCHTqRIBFMFKHMI0JmFWJpgUmgnzpVI1pTpRkt\\"}"},"index":2,"classesCount":0,"connectivityUp":"conv","normalize":false,"kernelsCount":4,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":true,"dynPelu":false},{"size":16,"sparsity":14,"activation":"elu01","connectivity":{"fromLayerSize":32,"toLayerSize":16,"toSparsity":14,"weightsFromTo":false,"fromBindings":false,"toBindings":false,"squareFast":true,"weights":{"isPot":false,"width":224,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":200704,\\"data\\":\\"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\\"}"},"stride":1},"bias":{"isPot":true,"width":16,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":1024,\\"data\\":\\"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\\"}"},"index":3,"classesCount":0,"connectivityUp":"squareFast","normalize":false,"kernelsCount":0,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":false,"dynPelu":false},{"size":16,"sparsity":5,"activation":"elu01","connectivity":{"fromLayerSize":16,"toLayerSize":16,"toSparsity":5,"weightsFromTo":false,"fromBindings":false,"toBindings":false,"squareFast":true,"weights":{"isPot":false,"width":80,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":25600,\\"data\\":\\"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\\"}"},"stride":3},"bias":{"isPot":true,"width":16,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":1024,\\"data\\":\\"HgNLqqNSJZJNKdD/MCIxrdIXIVKhuEEgI/KBIDCkICKXsbMyKELttJq7uxIKL0LQMIOiGZGkqdNgNCkKn7LdKCpjJlHeO2JnOWodKGLLKALOruI5MaMrIaKQMGMyFtLVMMMHH2NOnRIVoOMdo1KZp3KuOqGls/pMLPOeG4sqJlMYp4MMu6OSIwMwA+MIMLpxBrHtrZJboloJkZscpSkrkmtVLnJ8rSNsFWJiOKMKqMoZKfOWJbKdLnNjq0MfIZKJLLMNMRNrstpjsZJ7vFh8NTMjttJ9MFMYNwMQtNqepjpcqXLUreuxjzE7qJLmJ9GLkJMzk+JrPdI1OHr0slpvsCsVM2GJG2pxOOKBqRueOAOGLUJXL9OOp3qFNQMxMQp5LjqOKLMIOLsPJnKLjfNnI9ExpyNKpuMXGiKvJOLPqvp2tRlWmSLUoUCFmBOftsoUnIntsJsSsmqSuDrOrct3mTFCkBAjrkoCM+sVsLq/EGqrMfMHKRpDLBNyPII/LKN4LrM+JFOSsFiNlKl8sdmykxIBmBmTL2stpgpQo7qyqVHcAAueLTscuPsJsiuWJiuBK4NAMXKwMXj6oLrSM6saKXgzstqiPJoBsKq9MdMRrsrDqlOkNUlPISMtLEAytfMhMvspnHLbJiIpLwsPNUIysaqVrvKmNTLCIdHGqSmXreJmqErIKesPs8kAmEp9JJuaKCslsipHgIH8mCKpt7pIr+mUo2OtMjqaK1uiLltLK8nBrWk2OhL1smHoqCk8LuLiIcJwLIMzHrLoOEtwqYoPLVEsocM6Ksr3sroiNvsksAlsM1qrMwOOKTObOBsWhikOsFEIscmqOROHjBuHMMNwMQqwrPLgLPMwAAnvLOvXslI4qjJwmfqDq1LLlRnRrenILxN1KTMXK1OGrqOdpmpTLfNgGeNmtGrVHjMovrMgKQKfmRMuoKMcsmqpoXkOobuRKENPsCOHNbKKnLqCqLuXr+IXpdtDsbORNwqDN9tyNvHprJq9IOKfLUqEOjOANXGjJUqeMxMdKaOWpLHlMZOZKwM2r8u/JfrfOyOsN1NVJNGELhqlGrJiNKOZIlOOsJmGILrDMaAAu/GhNrLouHDjNcOUsSgOq1MOtFETn3ruGxKYuTONsGjiMgsQrZMiPgrhNMKarSrQIBKJMdo4AANAKnoZsCpBqqqAitKlskuRPPLxtBsjJVMSOcqQM2ttNoNinjowO0LcLPsZKwHBNDs4HUshOLtbuDK5KEqztjnELaKsofqmopMKrPKYAAGcnrLho2JeMDNgI9lmAAM2O7KCKXKNN5Bcrasvs8pUN9CBPLthrKF6OLqCJVNdtrJiu3KxK4r4uvLtKHjwKsqBvVIareLxuZI6uauQt5sKMKk6pzGlKPOPmSrQKZscOFAAMjJwI/NIM8OuMXNLNWM9iYIMH5AAqFr7tBuEK8OcGPL5ryuEr9HiMhOFkDF+LvNOpnGSqUNqOPrQq9I5mgtgGjoqrsOQh4opLBMhsNEgMVMAKHJXHohpEUpHNWI2MztHN6i6LdNFLhOjLeK/IGLqOKpFsfpsmVOSLbL2OEKgl9OwPTtZoxG8rKLDqXLAtNmAG/rGp1OQOQMfnkMlHlo6pLOfuDMVMbqjsOrAqpqnKqI9MGuBJLPKqOKbH7sYJIrqAnMALzLmMrJ7NhLiqYLlQAKIKZMGMRsIJqKJN5rVMPtOOarcOnMMHrMsENqsMSljsKLTEGLqC0prMIA2sNLRiit2KvHOpJsXr+NZuKL9DQmCLVnjQNOAj5quOeNgIkMor6KiGwnNMYN4IwKqIjMyN7o3qlMcM/I1NtOaM7E/ozOMruPMNXNaOMsFE4DpJoGNK9oFKiJfI7Dsrdu5MGMdPTIUJTH5J6LqqCocMoi1GpGhuJoerJMtHcK7iELgMLsONpPhMHFDMwNYLvJcIHJoKGKQO6qgMKHXNyLQtzMkDCmMOEKaM0M0NSLXOHMvL2NwqkolNXM+MJLereIaL2H2l6EAk2mKHjmWB4icNTKVkaqhskvBNTIGq6KnNRNVMNKJKBKS\\"}"},"index":4,"classesCount":0,"connectivityUp":"squareFast","normalize":false,"kernelsCount":0,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":false,"dynPelu":false},{"size":16,"sparsity":5,"activation":"elu01","connectivity":{"fromLayerSize":16,"toLayerSize":16,"toSparsity":5,"weightsFromTo":false,"fromBindings":false,"toBindings":false,"squareFast":true,"weights":{"isPot":false,"width":80,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":25600,\\"data\\":\\"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\\"}"},"stride":1},"bias":{"isPot":true,"width":16,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":1024,\\"data\\":\\"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\\"}"},"index":5,"classesCount":0,"connectivityUp":"squareFast","normalize":false,"kernelsCount":0,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":false,"dynPelu":false},{"size":16,"sparsity":5,"activation":"elu01","connectivity":{"fromLayerSize":16,"toLayerSize":16,"toSparsity":5,"weightsFromTo":false,"fromBindings":false,"toBindings":false,"squareFast":true,"weights":{"isPot":false,"width":80,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":25600,\\"data\\":\\"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\\"}"},"stride":3},"bias":{"isPot":true,"width":16,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":1024,\\"data\\":\\"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\\"}"},"index":6,"classesCount":0,"connectivityUp":"squareFast","normalize":false,"kernelsCount":0,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":false,"dynPelu":false},{"size":16,"sparsity":5,"activation":"elu01","connectivity":{"fromLayerSize":16,"toLayerSize":16,"toSparsity":5,"weightsFromTo":false,"fromBindings":false,"toBindings":false,"squareFast":true,"weights":{"isPot":false,"width":80,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":25600,\\"data\\":\\"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\\"}"},"stride":1},"bias":{"isPot":true,"width":16,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":1024,\\"data\\":\\"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\\"}"},"index":7,"classesCount":0,"connectivityUp":"squareFast","normalize":false,"kernelsCount":0,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":false,"dynPelu":false},{"size":4,"sparsity":16,"activation":"copy","connectivity":{"fromLayerSize":16,"toLayerSize":4,"toSparsity":16,"weightsFromTo":false,"fromBindings":false,"toBindings":false,"square":false,"weights":{"isPot":true,"width":64,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":16384,\\"data\\":\\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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\\"}"}},"bias":{"isPot":true,"width":4,"isFloat":true,"data":"{\\"ne\\":4,\\"nf\\":7,\\"n\\":64,\\"data\\":\\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANBMxM7M9MTMCLhLPAAAAAAAAAAAAAAAABcAQHNh4AAk+AAlFOFOAODODuFuAuDuDHElKmelylzE/A2oSGoGWAAmbHOCcminC\\"}"},"index":8,"classesCount":0,"connectivityUp":"full","normalize":false,"kernelsCount":0,"maxPooling":false,"remap":{"isEnabled":false},"isReorganize":false,"dynPelu":false}],"exportData":{"fgScaleXFactor":0.4,"fgDisplaceXFactor":0.7,"rotationEulerAnglesFactors":[0.8726646259971648,1.1344640137963142,0.13962634015954636],"translationScalingFactors":[0.2,0.2,0.3],"nExpressions":1}}')}},t={};function n(o){var A=t[o];if(void 0!==A)return A.exports;var i=t[o]={id:o,loaded:!1,exports:{}};return e[o].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var o in t)n.o(t,o)&&!n.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;n.g.importScripts&&(e=n.g.location+"");var t=n.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var o=t.getElementsByTagName("script");o.length&&(e=o[o.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=e})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{addImpl:()=>Fm,bincountImpl:()=>dp,bincountReduceImpl:()=>Ip,ceilImpl:()=>kp,concatImpl:()=>Dp,equalImpl:()=>sh,expImpl:()=>Eh,expm1Impl:()=>Fh,floorImpl:()=>Nh,gatherNdImpl:()=>zh,gatherV2Impl:()=>Qh,greaterEqualImpl:()=>tu,greaterImpl:()=>Yh,lessEqualImpl:()=>cu,lessImpl:()=>pu,linSpaceImpl:()=>Gu,logImpl:()=>ku,maxImpl:()=>Bu,maximumImpl:()=>Lu,minimumImpl:()=>_u,multiplyImpl:()=>$p,negImpl:()=>oc,notEqualImpl:()=>pc,prodImpl:()=>Cc,rangeImpl:()=>Jc,rsqrtImpl:()=>Sc,sigmoidImpl:()=>mm,simpleAbsImpl:()=>qm,sliceImpl:()=>pp,sparseFillEmptyRowsImpl:()=>Ad,sparseReshapeImpl:()=>rd,sparseSegmentReductionImpl:()=>ad,sqrtImpl:()=>ud,squaredDifferenceImpl:()=>Gd,stridedSliceImpl:()=>Hd,stringNGramsImpl:()=>Dd,stringSplitImpl:()=>jd,stringToHashBucketFastImpl:()=>yd,subImpl:()=>Kh,tileImpl:()=>Md,topKImpl:()=>Nd,transposeImpl:()=>Tm,uniqueImpl:()=>_d});var t=n(3379),o=n.n(t),A=n(7192);o()(A.Z,{insert:"head",singleton:!1}),A.Z.locals;var i=n(2212),r=n(6498),s=n(1140),a=n(9121),l=n(2271),m=n(4841),p=n(1901);const h={kernelName:a.SY,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,(0,p.N)((0,l.p)(n,"float32"),-1))}}};var u=n(1274),c=n(7370),d=n(9494),I=n(3261),G=n(248),E=n(827);const k={kernelName:a.VG,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,G.h)((0,l.p)(n,"float32")),o=(0,I._)((0,E.l)((0,d.i)(1),t));return(0,c.W)((0,u.h)(e,o))}}}},g={kernelName:a.Sp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,I._)((0,E.l)((0,G.h)((0,l.p)(n,"float32")),1));return(0,u.h)(e,t)}}}};var f=n(2200),H=n(4968),F=n(5475);const C={kernelName:a.mm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=f.$N(n.shape,o.shape);return{a:()=>{let t=e;const o=f.RR(n.shape,A);return o.length>0&&(t=(0,F.S)(t,o)),(0,H.X)(t,n.shape)},b:()=>{let t=e;const n=f.RR(o.shape,A);return n.length>0&&(t=(0,F.S)(t,n)),(0,H.X)(t,o.shape)}}}},D={kernelName:a.Xz,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,o)=>{n[o]=()=>e.clone()})),n}};var J=n(6577);const v={kernelName:a.sJ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,J.P)(n)}}},j={kernelName:a.aJ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,J.P)(n)}}},K={kernelName:a.M2,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,I._)((0,E.l)((0,d.i)(1),(0,G.h)((0,l.p)(n,"float32")))))}}};var y=n(6407);const b={kernelName:a.qw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,I._)((0,y.I)((0,d.i)(1),(0,G.h)((0,l.p)(n,"float32"))));return(0,u.h)(e,t)}}}},q={kernelName:a.QC,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=(0,f.$N)(n.shape,o.shape);return{a:()=>{const t=(0,y.I)((0,G.h)(n),(0,G.h)(o));let i=(0,m.d)(e,(0,u.h)(o,t));const r=(0,f.RR)(n.shape,A);return r.length>0&&(i=(0,F.S)(i,r)),(0,H.X)(i,n.shape)},b:()=>{const t=(0,y.I)((0,G.h)(n),(0,G.h)(o));let i=(0,c.W)((0,m.d)(e,(0,u.h)(n,t)));const r=(0,f.RR)(o.shape,A);return r.length>0&&(i=(0,F.S)(i,r)),(0,H.X)(i,o.shape)}}}},x={kernelName:a.jM,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,y.I)((0,G.h)((0,l.p)(n,"float32")),1))}}},B={kernelName:a.Oy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,E.l)((0,d.i)(1),(0,G.h)((0,l.p)(n,"float32"))))}}};var w=n(7097),M=n(3740),L=n(569),S=n(2668);const T=(0,S.op)({avgPool3dGrad_:function(e,t,n,o,A,i){const r=(0,M._1)(e,"dy","avgPool3dGrad"),s=(0,M._1)(t,"input","avgPool3dGrad");let l=r,m=s,p=!1;4===s.rank&&(p=!0,l=(0,H.X)(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]),m=(0,H.X)(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),L.hu(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),L.hu(5===m.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${m.rank}.`)),null!=i&&L.hu(L.GN(A),(()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${A}.`));const h={dy:l,input:m},u={filterSize:n,strides:o,pad:A,dimRoundingMode:i},c=w.BV.runKernel(a.IM,h,u);return p?(0,H.X)(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),N={kernelName:a._k,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{filterSize:A,strides:i,pad:r,dimRoundingMode:s}=n;return{x:()=>T(e,o,A,i,r,s)}}},R=(0,S.op)({avgPoolGrad_:function(e,t,n,o,A){const i=(0,M._1)(e,"dy","avgPoolGrad"),r=(0,M._1)(t,"input","avgPoolGrad");L.hu(r.rank===i.rank,(()=>`Rank of input (${r.rank}) does not match rank of dy (${i.rank})`));let s=r,l=i,m=!1;3===r.rank&&(m=!0,s=(0,H.X)(r,[1,r.shape[0],r.shape[1],r.shape[2]]),l=(0,H.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L.hu(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),L.hu(4===s.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${s.rank}.`));const p={dy:l,input:s},h={filterSize:n,strides:o,pad:A},u=w.BV.runKernel(a.RO,p,h);return m?(0,H.X)(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),O={kernelName:a.Jh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{filterSize:A,strides:i,pad:r}=n;return{x:()=>R(e,o,A,i,r)}}};var P=n(8687);const U={kernelName:a.XL,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[o,A]=t,{transposeA:i,transposeB:r}=n;return i||r?!i&&r?{a:()=>(0,P.O)(e,A,!1,!1),b:()=>(0,P.O)(e,o,!0,!1)}:i&&!r?{a:()=>(0,P.O)(A,e,!1,!0),b:()=>(0,P.O)(o,e,!1,!1)}:{a:()=>(0,P.O)(A,e,!0,!0),b:()=>(0,P.O)(e,o,!0,!0)}:{a:()=>(0,P.O)(e,A,!1,!0),b:()=>(0,P.O)(o,e,!0,!1)}}};var V=n(7918);const W={kernelName:a.zw,gradFunc:(e,t,n)=>{const{blockShape:o,crops:A}=n;return{x:()=>(0,V.f)(e,o,A)}}},_={kernelName:a.Ly,gradFunc:(e,t,n)=>{const o=n,A=o.inputShape,i=o.shape,r=Array.from(i);for(let e=A.length-1;e>=0;e--)if(A[e]===i[e])r[e]=1;else if(1!==A[e])throw new Error(`broadcastTo(): [${A}] cannot be broadcast to [${i}].`);const s=[];for(let e=0;e<r.length;e++)r[e]>1&&s.push(e);return{x:()=>(0,F.S)(e,s,!0)}}},z={kernelName:a.RF,gradFunc:e=>({x:()=>e.clone()})},X={kernelName:a.gJ,gradFunc:e=>({x:()=>(0,J.P)(e)})};var Q=n(7630),Z=n(624),Y=n(2856),$=n(5912);const ee={kernelName:a.xn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{clipValueMin:A,clipValueMax:i}=n;return{x:()=>(0,$.a)((0,Y.H)((0,Q.b)(o,A),(0,Z.z)(o,i)),e,(0,J.P)(e))}}},te={kernelName:a.yj,inputsToSave:["x"],gradFunc:h.gradFunc};var ne=n(8644);const oe={kernelName:a.Eh,saveAllInputs:!0,gradFunc:(e,t,n)=>{const o=t.map((e=>e.shape)),{axis:A}=n,i=(0,L.EC)(A,t[0].shape)[0],r=o.map((e=>e[i]));return(0,ne.V)(e,r,i).map((e=>()=>e))}};var Ae=n(6013),ie=n(9832),re=n(2582);const se={kernelName:a.mh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[o,A]=t,{dilations:i,strides:r,pad:s,dataFormat:a}=n;return L.hu(re.I0(i),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`)),{x:()=>(0,ie._)(o.shape,e,A,r,s,a),filter:()=>(0,Ae.p)(o,e,A.shape,r,s,a)}}};var ae=n(4794);const le={kernelName:a.wm,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[o,A]=t,{strides:i,pad:r,dataFormat:s,dimRoundingMode:a}=n;return{dy:()=>(0,ae.T)(e,A,i,r,s,1,a),filter:()=>(0,Ae.p)(e,o,A.shape,i,r,s,a)}}},me=(0,S.op)({conv3DBackpropFilter_:function(e,t,n,o,A){let i=e;4===e.rank&&(i=(0,H.X)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let r=t;4===r.rank&&(r=(0,H.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),L.hu(5===i.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`)),L.hu(5===r.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${r.shape}.`)),L.hu(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),L.hu(i.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`)),L.hu(r.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${r.shape[4]}) must match output depth for filter (${n[4]}).`));const s={x:i,dy:r},l={strides:o,pad:A,filterShape:n};return w.BV.runKernel(a.o2,s,l)}});var pe=n(7594);const he={kernelName:a.x1,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:o,strides:A,pad:i}=n;L.hu((0,re.I0)(o),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`));const[r,s]=t;return{x:()=>(0,pe._)(r.shape,e,s,A,i),filter:()=>me(r,e,s.shape,A,i)}}};var ue=n(9331);const ce={kernelName:a.mc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)((0,c.W)((0,ue.O)((0,l.p)(n,"float32"))),e)}}};var de=n(3254);const Ie={kernelName:a.TR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)((0,de.R)((0,l.p)(n,"float32")),e)}}};var Ge=n(3591),Ee=n(7405),ke=n(9065);const ge={kernelName:a.iH,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{axis:A,exclusive:i,reverse:r}=n;return{x:()=>{const t=(0,Ge.Q3)([A],o.rank);let n=(0,Ee.z)(e,A,i,!r);return null!=t&&(n=(0,ke.p)(n,t)),n}}}};var fe=n(8098),He=n(4375);const Fe={kernelName:a.ci,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:o,strides:A,pad:i,dimRoundingMode:r}=n,s=null==o?[1,1]:o;L.hu(re.I0(s),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[a,l]=t;return L.hu(4===a.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${a.rank}.`)),L.hu(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),L.hu(a.shape[3]===l.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${a.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),L.hu(re.jT(A,s),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${A} and dilations '${s}'.`)),null!=r&&L.hu(L.GN(i),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`)),{x:()=>(0,He.v)(a.shape,e,l,A,i,s,r),filter:()=>(0,fe.z)(a,e,l.shape,A,i,s,r)}}},Ce={kernelName:a.p4,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[o,A]=t,i={x:o,filter:A,dy:e},r={x:o,filter:A,dy:e};return{x:()=>w.BV.runKernel(a.ek,i,n),filter:()=>w.BV.runKernel(a.Vn,r,n)}}},De={kernelName:a.SX,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,o={dy:e,y:n};return{x:()=>w.BV.runKernel(a.HE,o)}}};var Je=n(4842);const ve={kernelName:a.Om,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,o=(0,m.d)((0,Je.Q)((0,c.W)((0,G.h)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,m.d)(e,o)}}},je={kernelName:a.NE,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,n)}}},Ke={kernelName:a.YF,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>(0,H.X)(e,n.shape)}}},ye={kernelName:a.Y0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,(0,Je.Q)(n))}}},be={kernelName:a.OR,gradFunc:e=>({x:()=>(0,J.P)(e)})},qe={kernelName:a.je,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=(0,f.$N)(n.shape,o.shape);return{a:()=>{const t=(0,u.h)(e,(0,l.p)(o,"float32")),i=(0,f.RR)(n.shape,A);return i.length>0?(0,H.X)((0,F.S)(t,i),n.shape):t},b:()=>{let t=(0,m.d)(e,(0,l.p)(n,"float32"));const i=(0,f.RR)(o.shape,A);i.length>0&&(t=(0,H.X)((0,F.S)(t,i),o.shape));const r=(0,G.h)(o);return(0,c.W)((0,u.h)(t,(0,l.p)(r,"float32")))}}}};var xe=n(2634),Be=n(7501);const we={kernelName:a.sH,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:o}=n,[A,i,r,s]=t,a=null==s?(0,d.i)(1):s,l=(0,f.RR)(i.shape,A.shape),p=[];if(1===i.rank){for(let e=0;e<A.shape.length-1;++e)p.push(A.shape[e]);p.push(1)}const h=(0,E.l)(A,i),u=(0,m.d)(e,a),c=(0,xe.b)((0,y.I)(r,(0,d.i)(o))),I=(0,m.d)((0,m.d)((0,m.d)(c,c),c),(0,d.i)(-.5));return{x:()=>1===i.rank?(0,H.X)((0,m.d)((0,m.d)(e,(0,Be.G)((0,H.X)(c,[1,1,1,i.shape[0]]),p)),a),A.shape):(0,H.X)((0,m.d)((0,m.d)(e,c),a),A.shape),mean:()=>{let e=(0,m.d)((0,m.d)(c,(0,d.i)(-1)),u);return 1===i.rank&&(e=(0,F.S)(e,l)),(0,H.X)(e,i.shape)},variance:()=>{let e=(0,m.d)((0,m.d)(I,h),u);return 1===i.rank&&(e=(0,F.S)(e,l)),(0,H.X)(e,i.shape)},scale:()=>{const t=(0,m.d)(h,c);let n=(0,m.d)(e,t);return 1===i.rank&&(n=(0,F.S)(n,l)),(0,H.X)(n,i.shape)},offset:()=>{let t=e;return 1===i.rank&&(t=(0,F.S)(t,l)),(0,H.X)(t,i.shape)}}}},Me=(0,S.op)({unsortedSegmentSum_:function(e,t,n){const o=(0,M._1)(e,"x","unsortedSegmentSum"),A=(0,M._1)(t,"segmentIds","unsortedSegmentSum","int32");(0,L.hu)((0,L.GN)(n),(()=>"numSegments must be of dtype int"));const i={x:o,segmentIds:A},r={numSegments:n};return w.BV.runKernel(a.Qv,i,r)}}),Le={kernelName:a.qi,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[o,A]=t,{axis:i}=n,r=(0,L.EC)(i,o.shape)[0];return{x:()=>{const t=o.shape,n=A.size,s=t.slice(0,r),a=s.length,l=t.slice(i,t.length).slice(1),m=l.length,p=Se(0,a),h=Se(a+1,a+1+m),u=Te([s,[n],l]),c=(0,H.X)(e,u),d=(0,H.X)(A,[n]),I=Te([[a],p,h]),G=(0,ke.p)(c,I);let E=Me(G,d,o.shape[r]);const k=(0,Ge.LJ)(I);return E=(0,ke.p)(E,k),E},indices:()=>A}}};function Se(e,t){const n=[];for(let o=e;o<t;++o)n.push(o);return n}function Te(e){const t=[];for(let n=0;n<e.length;++n)for(let o=0;o<e[n].length;++o)t.push(e[n][o]);return t}const Ne={kernelName:a.Ac,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t;return{a:()=>(0,J.P)(n),b:()=>(0,J.P)(o)}}},Re={kernelName:a.iJ,gradFunc:e=>({x:()=>(0,l.p)(e,"float32")})},Oe={kernelName:a.av,gradFunc:e=>({x:()=>(0,J.P)(e)})},Pe={kernelName:a.iW,gradFunc:e=>({x:()=>(0,J.P)(e)})},Ue={kernelName:a.r7,gradFunc:e=>({x:()=>(0,J.P)(e)})};var Ve=n(636);const We={kernelName:a.J$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{alpha:A}=n,i=(0,Ve.p)(o,0);return{x:()=>(0,$.a)(i,e,(0,m.d)(e,A))}}},_e={kernelName:a.kU,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,y.I)(n,1))}}},ze={kernelName:a.Zb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,l.p)(n,"float32"))}}},Xe={kernelName:a.qC,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[o]=t,{axis:A}=n;return{logits:()=>{const t=(0,Je.Q)(o);return(0,E.l)(e,(0,m.d)((0,F.S)(e,A,!0),t))}}}},Qe=(0,S.op)({localResponseNormalizationBackprop_:function(e,t,n,o=5,A=1,i=1,r=.5){const s={x:e,y:t,dy:n},l={depthRadius:o,bias:A,alpha:i,beta:r};return w.BV.runKernel(a.Hh,s,l)}}),Ze={kernelName:a.eZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[o,A]=t,{depthRadius:i,bias:r,alpha:s,beta:a}=n;return{x:()=>Qe(o,A,e,i,r,s,a)}}};var Ye=n(6477);function $e(e,t,n,o){return t.rank<n.rank&&(t=(0,H.X)(t,Ge.rv(t.shape,o))),e.rank<n.rank&&(e=(0,H.X)(e,Ge.rv(e.shape,o))),{x:()=>(0,m.d)(e,(0,l.p)((0,Ye.D)(n,t),e.dtype))}}const et={kernelName:a.Yo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const o=n,{reductionIndices:A}=o,i=t[0],r=$e(e,t[1],i,L.EC(A,i.shape));return{x:()=>r.x()}}};var tt=n(6573);const nt={kernelName:a.BM,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t;return{a:()=>(0,m.d)(e,(0,l.p)((0,Q.b)(n,o),"float32")),b:()=>(0,m.d)(e,(0,l.p)((0,tt.d)(n,o),"float32"))}}},ot=(0,S.op)({maxPool3dGrad_:function(e,t,n,o,A,i,r){const s=(0,M._1)(e,"dy","maxPool3dGrad"),l=(0,M._1)(t,"input","maxPool3dGrad"),m=(0,M._1)(n,"output","maxPool3dGrad");let p=s,h=l,u=m,c=!1;4===l.rank&&(c=!0,p=(0,H.X)(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),h=(0,H.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),u=(0,H.X)(m,[1,m.shape[0],m.shape[1],m.shape[2],m.shape[3]])),L.hu(5===p.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`)),L.hu(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),L.hu(5===u.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${u.rank}.`)),null!=r&&L.hu(L.GN(i),(()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`));const d={dy:p,input:h,output:u},I={filterSize:o,strides:A,pad:i,dimRoundingMode:r},G=w.BV.runKernel(a.OU,d,I);return c?(0,H.X)(G,[G.shape[1],G.shape[2],G.shape[3],G.shape[4]]):G}}),At={kernelName:a.OA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[o,A]=t,{filterSize:i,strides:r,pad:s,dimRoundingMode:a}=n;return{x:()=>ot(e,o,A,i,r,s,a)}}},it=(0,S.op)({maxPoolGrad_:function(e,t,n,o,A,i,r){const s=(0,M._1)(e,"dy","maxPoolGrad"),l=(0,M._1)(t,"input","maxPoolGrad"),m=(0,M._1)(n,"output","maxPoolGrad");L.hu(l.rank===s.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${s.rank})`)),L.hu(4===s.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${s.rank}.`)),L.hu(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),null!=r&&L.hu(L.GN(i),(()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`));const p={dy:s,input:l,output:m},h={filterSize:o,strides:A,pad:i,dimRoundingMode:r};return w.BV.runKernel(a.OV,p,h)}}),rt={kernelName:a.mT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[o,A]=t,{filterSize:i,strides:r,pad:s}=n;return{x:()=>it(e,o,A,i,r,s)}}};var st=n(4917);const at={kernelName:a.q2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{axis:A}=n,i=L.EC(A,o.shape),r=(0,Ge.kz)(o.shape,i)[1],s=L.NA(r);return{x:()=>{const t=o.shape.slice();i.forEach((e=>{t[e]=1}));const n=(0,H.X)(e,t);return(0,u.h)((0,m.d)(n,(0,st.i)(o.shape,"float32")),s)}}}},lt={kernelName:a.c1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const o=n,{axis:A}=o,[i,r]=t,s=$e(e,r,i,L.EC(A,i.shape));return{x:()=>s.x()}}},mt={kernelName:a.q8,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t;return{a:()=>(0,m.d)(e,(0,l.p)((0,Z.z)(n,o),"float32")),b:()=>(0,m.d)(e,(0,l.p)((0,Ve.p)(n,o),"float32"))}}};var pt=n(2676);const ht={kernelName:a.jQ,inputsToSave:["x"],gradFunc:(e,t,n)=>{const o=t[0],{paddings:A}=n,i=A.map((e=>e[0]));return{x:()=>(0,pt.t)(e,i,o.shape)}}};var ut=n(6943);const ct={kernelName:a.Vb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=(0,f.$N)(n.shape,o.shape);return{a:()=>{const t=(0,f.RR)(n.shape,A);return t.length>0?(0,H.X)((0,F.S)(e,t),n.shape):e},b:()=>{const t=(0,m.d)(e,(0,c.W)((0,ut.G)((0,u.h)(n,o)))),i=(0,f.RR)(o.shape,A);return i.length>0?(0,H.X)((0,F.S)(t,i),o.shape):t}}}},dt={kernelName:a.wY,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=(0,f.$N)(n.shape,o.shape);return{a:()=>{const t=(0,m.d)(e,(0,l.p)(o,"float32")),i=(0,f.RR)(n.shape,A);return i.length>0?(0,H.X)((0,F.S)(t,i),n.shape):t},b:()=>{const t=(0,m.d)(e,(0,l.p)(n,"float32")),i=(0,f.RR)(o.shape,A);return i.length>0?(0,H.X)((0,F.S)(t,i),o.shape):t}}}},It={kernelName:a.ku,gradFunc:e=>({x:()=>(0,c.W)(e)})};var Gt=n(9640);const Et={kernelName:a.we,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>(0,Gt.l)(n.shape,"float32")}}},kt={kernelName:a.qW,gradFunc:e=>({x:()=>(0,J.P)(e)})};var gt=n(4136);const ft={kernelName:a.Qi,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:o}=n;return(0,gt.H)(e,o).map((e=>()=>e))}},Ht={kernelName:a.ly,inputsToSave:["x"],gradFunc:(e,t,n)=>{const o=t[0],{paddings:A}=n,i=A.map((e=>e[0]));return{x:()=>(0,pt.t)(e,i,o.shape)}}};var Ft=n(2597),Ct=n(3453);const Dt={kernelName:a.pe,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,o,A]=t,i=n,r=o,s=f.$N(i.shape,r.shape);return{a:()=>{const t=(0,l.p)(r,"float32");let n=(0,m.d)(e,(0,m.d)(t,(0,Ct.s)(i,(0,E.l)(t,(0,d.i)(1)))));const o=f.RR(i.shape,s);return o.length>0&&(n=(0,F.S)(n,o)),(0,H.X)(n,i.shape)},b:()=>{const t=(0,Ve.p)(i,0),n=(0,$.a)(t,(0,Ft.c)(i),(0,J.P)(i));let o=(0,m.d)(e,(0,m.d)(A,n));const a=f.RR(r.shape,s);return a.length>0&&(o=(0,F.S)(o,a)),(0,H.X)(o,r.shape)}}}},Jt={kernelName:a.o0,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,o]=t,A=(0,Ve.p)(n,0);return{x:()=>(0,$.a)(A,e,(0,m.d)(e,o)),alpha:()=>{let t=(0,$.a)(A,(0,J.P)(e),(0,m.d)(e,n));const i=(0,f.RR)(o.shape,e.shape);return i.length>0&&(t=(0,F.S)(t,i)),(0,H.X)(t,o.shape)}}}},vt={kernelName:a.oH,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=f.$N(n.shape,o.shape);return{a:()=>{const t=(0,u.h)(e,(0,l.p)(o,"float32")),i=f.RR(n.shape,A);return i.length>0?(0,H.X)((0,F.S)(t,i),n.shape):t},b:()=>{let t=(0,m.d)(e,(0,l.p)(n,"float32"));const i=f.RR(o.shape,A);i.length>0&&(t=(0,H.X)((0,F.S)(t,i),o.shape));const r=(0,G.h)(o);return(0,c.W)((0,u.h)(t,(0,l.p)(r,"float32")))}}}},jt={kernelName:a.$H,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,c.W)((0,G.h)(n)))}}},Kt={kernelName:a.Sb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,o=(0,m.d)((0,Z.z)(n,6),(0,p.N)(n));return{x:()=>(0,m.d)(e,(0,l.p)(o,"float32"))}}},yt={kernelName:a.qk,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,(0,l.p)((0,p.N)(n),"float32"))}}},bt={kernelName:a.HZ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,H.X)(e,n.shape)}}},qt={kernelName:a._Y,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[o]=t,A={dy:e,images:o};return{images:()=>w.BV.runKernel(a.zb,A,n)}}},xt={kernelName:a.dp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[o]=t,A={dy:e,images:o};return{images:()=>w.BV.runKernel(a.Hm,A,n)}}};var Bt=n(7486);const wt={kernelName:a.mK,gradFunc:(e,t,n)=>{const{dims:o}=n,A=(0,L.EC)(o,e.shape);return{x:()=>(0,Bt.G)(e,A)}}},Mt={kernelName:a.e0,gradFunc:e=>({x:()=>(0,J.P)(e)})},Lt={kernelName:a.bV,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,c.W)((0,u.h)(e,(0,m.d)((0,Ct.s)(n,1.5),2)))}}};var St=n(8651);const Tt={kernelName:a.Ph,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>(0,l.p)((0,J.P)(n),"float32"),t:()=>(0,m.d)(e,(0,l.p)(n,e.dtype)),e:()=>(0,m.d)(e,(0,l.p)((0,St.h)(n),e.dtype))}}};var Nt=n(3179);const Rt={kernelName:a.oF,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,Ve.p)(n,(0,d.i)(0)),o=(0,d.i)(Nt.y),A=(0,d.i)(Nt.$),i=(0,m.d)(e,A),r=(0,m.d)((0,m.d)(e,o),(0,Je.Q)((0,l.p)(n,"float32")));return(0,$.a)(t,i,r)}}}},Ot={kernelName:a.a5,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,(0,m.d)(n,(0,E.l)((0,d.i)(1),n)))}}},Pt={kernelName:a.i5,gradFunc:e=>({x:()=>(0,J.P)(e)})};var Ut=n(173);const Vt={kernelName:a.RQ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)((0,Ut.m)((0,l.p)(n,"float32")),e)}}};var Wt=n(2699);const _t={kernelName:a.w3,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)((0,Wt.f)((0,l.p)(n,"float32")),e)}}};var zt=n(9682),Xt=n(7650);const Qt={kernelName:a.p2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{begin:A,size:i}=n,r=o.shape,[s,a]=(0,Xt.parseSliceParams)(o,A,i),l=[];for(let t=0;t<e.rank;t++)l.push([s[t],r[t]-s[t]-a[t]]);return{x:()=>(0,zt.v)(e,l)}}},Zt={kernelName:a.Gc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[o]=t,{dim:A}=n,i=(0,m.d)(e,o);return{logits:()=>(0,E.l)(i,(0,m.d)((0,F.S)(i,[A],!0),o))}}};var Yt=n(625);const $t={kernelName:a.MR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,(0,Yt.X)(n))}}};var en=n(8441);const tn={kernelName:a.TQ,gradFunc:(e,t,n)=>{const{blockShape:o,paddings:A}=n;return{x:()=>(0,en.E)(e,o,A)}}};var nn=n(6884);const on={kernelName:a.L8,gradFunc:(e,t,n)=>{const{axis:o}=n;return{x:()=>(0,nn.z)(e,o)}}},An={kernelName:a.FK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,m.d)((0,I._)((0,l.p)(n,"float32")),2))}}},rn={kernelName:a.bK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)(e,(0,m.d)((0,l.p)(n,"float32"),2))}}},sn={kernelName:a._t,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=(0,d.i)(2);return{a:()=>(0,m.d)(e,(0,m.d)(A,(0,E.l)(n,o))),b:()=>(0,m.d)(e,(0,m.d)(A,(0,E.l)(o,n)))}}},an={kernelName:a.h8,gradFunc:e=>({x:()=>(0,J.P)(e)})},ln={kernelName:a.Tr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,o]=t,A=f.$N(n.shape,o.shape);return{a:()=>{let t=e;const o=f.RR(n.shape,A);return o.length>0&&(t=(0,F.S)(t,o)),(0,H.X)(t,n.shape)},b:()=>{let t=e;const n=f.RR(o.shape,A);return n.length>0&&(t=(0,F.S)(t,n)),(0,H.X)((0,c.W)(t),o.shape)}}}},mn={kernelName:a.GB,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,A=o.shape.slice(),{axis:i}=n;(0,L.EC)(i,o.shape).forEach((e=>{A[e]=1}));const r=(0,H.X)(e,A),s=(0,m.d)(r,(0,st.i)(o.shape,"float32"));return{x:()=>s}}},pn={kernelName:a.sE,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,u.h)(e,(0,G.h)((0,Ut.m)(n)))}}},hn={kernelName:a.MI,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,m.d)((0,E.l)((0,d.i)(1),(0,G.h)(n)),e)}}},un={kernelName:a.n9,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{reps:A}=n;return{x:()=>{let t=(0,J.P)(o);if(1===o.rank)for(let n=0;n<A[0];++n)t=(0,y.I)(t,(0,pt.t)(e,[n*o.shape[0]],[o.shape[0]]));else if(2===o.rank)for(let n=0;n<A[0];++n)for(let i=0;i<A[1];++i)t=(0,y.I)(t,(0,pt.t)(e,[n*o.shape[0],i*o.shape[1]],[o.shape[0],o.shape[1]]));else if(3===o.rank)for(let n=0;n<A[0];++n)for(let i=0;i<A[1];++i)for(let r=0;r<A[2];++r)t=(0,y.I)(t,(0,pt.t)(e,[n*o.shape[0],i*o.shape[1],r*o.shape[2]],[o.shape[0],o.shape[1],o.shape[2]]));else{if(4!==o.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${o.rank} tensors yet.`);for(let n=0;n<A[0];++n)for(let i=0;i<A[1];++i)for(let r=0;r<A[2];++r)for(let s=0;s<A[3];++s)t=(0,y.I)(t,(0,pt.t)(e,[n*o.shape[0],i*o.shape[1],r*o.shape[2],s*o.shape[3]],[o.shape[0],o.shape[1],o.shape[2],o.shape[3]]))}return t}}}},cn={kernelName:a.G3,gradFunc:(e,t,n)=>{const o=n,{perm:A}=o,i=Ge.LJ(A);return{x:()=>(0,ke.p)(e,i)}}};var dn=n(2991);const In={kernelName:a.To,gradFunc:(e,t,n)=>{const o=n,{axis:A}=o;return{value:()=>(0,dn.k)(e,A)}}};var Gn=n(1300),En=n(4926),kn=n(632);const gn={kernelName:a.Qv,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=(0,kn.g)(t,(0,J.P)(t)),o=(0,En.I)(e,n);let A=(0,Q.b)(t,(0,d.i)(0,"int32"));const i=o.rank-A.rank;for(let e=0;e<i;++e)A=(0,Gn.d)(A,e+1);A=(0,Y.H)(A,(0,st.i)(o.shape,"bool"));const r=(0,J.P)(o);return(0,$.a)(A,o,r)}(e,n)}}},fn={kernelName:a.Ru,gradFunc:e=>({x:()=>(0,J.P)(e)})};var Hn=n(6151);const Fn=[h,k,g,C,D,v,j,K,b,q,x,B,N,O,U,W,_,z,X,ee,te,oe,le,se,he,ce,Ie,ge,Fe,Ce,vt,De,ve,je,Ke,ye,qe,be,we,Le,Ne,Re,Oe,Pe,Ue,We,_e,ze,Xe,Ze,et,et,nt,At,rt,at,lt,mt,ht,ct,dt,It,Et,kt,ft,Ht,Ht,Dt,Jt,jt,Kt,yt,bt,qt,xt,wt,Mt,Lt,Tt,Rt,Ot,Pt,Vt,_t,Qt,Zt,$t,tn,tn,on,on,An,sn,rn,an,ln,mn,pn,hn,un,cn,In,gn,fn];for(const e of Fn)(0,Hn.Li)(e);var Cn=n(6235),Dn=n(4077);(0,Dn.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,Cn.W)(this)};var Jn=n(7839);(0,Dn.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,Jn.K)(this)};var vn=n(1470);(0,Dn.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,vn._)(this)},(0,Dn.t3)().prototype.add=function(e){return this.throwIfDisposed(),(0,y.I)(this,e)};var jn=n(781);(0,Dn.t3)().prototype.all=function(e,t){return this.throwIfDisposed(),(0,jn.$)(this,e,t)};var Kn=n(2998);(0,Dn.t3)().prototype.any=function(e,t){return this.throwIfDisposed(),(0,Kn.Y)(this,e,t)};var yn=n(47);(0,Dn.t3)().prototype.argMax=function(e){return this.throwIfDisposed(),(0,yn.N)(this,e)};var bn=n(7394);(0,Dn.t3)().prototype.argMin=function(e){return this.throwIfDisposed(),(0,bn.v)(this,e)},(0,Dn.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,L.hu)(1===this.size,(()=>"The array must have only 1 element.")),(0,H.X)(this,[])},(0,Dn.t3)().prototype.asType=function(e){return this.throwIfDisposed(),(0,l.p)(this,e)},(0,Dn.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,H.X)(this,[this.size])},(0,Dn.t3)().prototype.as2D=function(e,t){return this.throwIfDisposed(),(0,H.X)(this,[e,t])},(0,Dn.t3)().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),(0,H.X)(this,[e,t,n])},(0,Dn.t3)().prototype.as4D=function(e,t,n,o){return this.throwIfDisposed(),(0,H.X)(this,[e,t,n,o])},(0,Dn.t3)().prototype.as5D=function(e,t,n,o,A){return this.throwIfDisposed(),(0,H.X)(this,[e,t,n,o,A])};var qn=n(2421);(0,Dn.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,qn.Z)(this)};var xn=n(1891);(0,Dn.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,xn.V)(this)};var Bn=n(7037);(0,Dn.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,Bn.z)(this)};var wn=n(9812);(0,Dn.t3)().prototype.atan2=function(e){return this.throwIfDisposed(),(0,wn.f)(this,e)};var Mn=n(369);(0,Dn.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,Mn.C)(this)};var Ln=n(5176);(0,Dn.t3)().prototype.avgPool=function(e,t,n,o){return this.throwIfDisposed(),(0,Ln.w)(this,e,t,n,o)},(0,Dn.t3)().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),(0,en.E)(this,e,t)};var Sn=n(7505);(0,Dn.t3)().prototype.batchNorm=function(e,t,n,o,A){return this.throwIfDisposed(),(0,Sn.t)(this,e,t,n,o,A)};var Tn=n(8247);(0,Dn.t3)().prototype.broadcastTo=function(e){return this.throwIfDisposed(),(0,Tn.U)(this,e)},(0,Dn.t3)().prototype.cast=function(e){return this.throwIfDisposed(),(0,l.p)(this,e)};var Nn=n(6825);(0,Dn.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,Nn.m)(this)};var Rn=n(2279);(0,Dn.t3)().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),(0,Rn.i)(this,e,t)},(0,Dn.t3)().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Dn.es&&(e=[e]),(0,nn.z)([this,...e],t)};var On=n(1355);(0,Dn.t3)().prototype.conv1d=function(e,t,n,o,A,i){return this.throwIfDisposed(),(0,On.P)(this,e,t,n,o,A,i)};var Pn=n(1405);(0,Dn.t3)().prototype.conv2dTranspose=function(e,t,n,o,A){return this.throwIfDisposed(),(0,Pn.b)(this,e,t,n,o,A)},(0,Dn.t3)().prototype.conv2d=function(e,t,n,o,A,i){return this.throwIfDisposed(),(0,ae.T)(this,e,t,n,o,A,i)},(0,Dn.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,Ut.m)(this)},(0,Dn.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,Wt.f)(this)},(0,Dn.t3)().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),(0,Ee.z)(this,e,t,n)};var Un=n(9112);(0,Dn.t3)().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),(0,Un.n)(this,e,t)};var Vn=n(4718);(0,Dn.t3)().prototype.depthwiseConv2d=function(e,t,n,o,A,i){return this.throwIfDisposed(),(0,Vn.B)(this,e,t,n,o,A,i)};var Wn=n(557);(0,Dn.t3)().prototype.dilation2d=function(e,t,n,o,A){return this.throwIfDisposed(),(0,Wn.W)(this,e,t,n,o,A)};var _n=n(9322);(0,Dn.t3)().prototype.divNoNan=function(e){return this.throwIfDisposed(),(0,_n.N)(this,e)},(0,Dn.t3)().prototype.div=function(e){return this.throwIfDisposed(),(0,u.h)(this,e)};const zn=(0,S.op)({dot_:function(e,t){const n=(0,M._1)(e,"t1","dot"),o=(0,M._1)(t,"t2","dot");L.hu(!(1!==n.rank&&2!==n.rank||1!==o.rank&&2!==o.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${o.rank}.`));const A=1===n.rank?n.size:n.shape[1],i=1===o.rank?o.size:o.shape[0];if(L.hu(A===i,(()=>`Error in dot: inner dimensions of inputs must match, but got ${A} and ${i}.`)),1===n.rank&&1===o.rank){const e=(0,H.X)(n,[1,-1]),t=(0,H.X)(o,[-1,1]),A=(0,P.O)(e,t);return(0,H.X)(A,[])}if(1===n.rank&&2===o.rank){const e=(0,H.X)(n,[1,-1]),t=(0,H.X)(o,[o.shape[0],o.shape[1]]),A=(0,P.O)(e,t);return(0,H.X)(A,[A.size])}if(2===n.rank&&1===o.rank){const e=(0,H.X)(o,[-1,1]),t=(0,P.O)(n,e);return(0,H.X)(t,[t.size])}{const e=(0,H.X)(o,[o.shape[0],o.shape[1]]);return(0,P.O)(n,e)}}});(0,Dn.t3)().prototype.dot=function(e){return this.throwIfDisposed(),zn(this,e)};var Xn=n(3233);(0,Dn.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,Xn.p)(this)},(0,Dn.t3)().prototype.equal=function(e){return this.throwIfDisposed(),(0,Ye.D)(this,e)};var Qn=n(4650);(0,Dn.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,Qn.q)(this)},(0,Dn.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,Je.Q)(this)},(0,Dn.t3)().prototype.expandDims=function(e){return this.throwIfDisposed(),(0,Gn.d)(this,e)};var Zn=n(3426);(0,Dn.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,Zn.t)(this)};var Yn=n(7020);(0,Dn.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,Yn.k)(this)},(0,Dn.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,H.X)(this,[this.size])},(0,Dn.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,ut.G)(this)};var $n=n(9165);(0,Dn.t3)().prototype.floorDiv=function(e){return this.throwIfDisposed(),(0,$n.q)(this,e)},(0,Dn.t3)().prototype.gather=function(e,t){return this.throwIfDisposed(),(0,En.I)(this,e,t)},(0,Dn.t3)().prototype.greaterEqual=function(e){return this.throwIfDisposed(),(0,Q.b)(this,e)},(0,Dn.t3)().prototype.greater=function(e){return this.throwIfDisposed(),(0,Ve.p)(this,e)};var eo=n(8447);(0,Dn.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,eo.S)(this)};var to=n(4415);(0,Dn.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,to.w)(this)};const no=(0,S.op)({isFinite_:function(e){const t={x:(0,M._1)(e,"x","isFinite")};return w.BV.runKernel(a.av,t)}});(0,Dn.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),no(this)};const oo=(0,S.op)({isInf_:function(e){const t={x:(0,M._1)(e,"x","isInf")};return w.BV.runKernel(a.iW,t)}});(0,Dn.t3)().prototype.isInf=function(){return this.throwIfDisposed(),oo(this)};var Ao=n(6230);(0,Dn.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,Ao.i)(this)};var io=n(9133);(0,Dn.t3)().prototype.leakyRelu=function(e){return this.throwIfDisposed(),(0,io.h)(this,e)},(0,Dn.t3)().prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,Z.z)(this,e)},(0,Dn.t3)().prototype.less=function(e){return this.throwIfDisposed(),(0,tt.d)(this,e)};var ro=n(9648);(0,Dn.t3)().prototype.localResponseNormalization=function(e,t,n,o){return this.throwIfDisposed(),(0,ro.G)(this,e,t,n,o)};var so=n(633),ao=n(3694);const lo=(0,S.op)({logSigmoid_:function(e){const t=(0,M._1)(e,"x","logSigmoid"),n=(0,so.cb)((e=>({value:(0,c.W)((0,ao.W)((0,c.W)(e))),gradFunc:t=>(0,m.d)(t,(0,Yt.X)((0,c.W)(e)))})));return n(t)}});(0,Dn.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),lo(this)};var mo=n(1510);(0,Dn.t3)().prototype.logSoftmax=function(e){return this.throwIfDisposed(),(0,mo.C)(this,e)};var po=n(1391);(0,Dn.t3)().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),(0,po.l)(this,e,t)},(0,Dn.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,Ft.c)(this)};var ho=n(7474);(0,Dn.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,ho.K)(this)},(0,Dn.t3)().prototype.logicalAnd=function(e){return this.throwIfDisposed(),(0,Y.H)(this,e)},(0,Dn.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,St.h)(this)};var uo=n(5750);(0,Dn.t3)().prototype.logicalOr=function(e){return this.throwIfDisposed(),(0,uo.K)(this,e)};const co=(0,S.op)({logicalXor_:function(e,t){const n=(0,M._1)(e,"a","logicalXor","bool"),o=(0,M._1)(t,"b","logicalXor","bool");return(0,f.$N)(n.shape,o.shape),(0,Y.H)((0,uo.K)(e,t),(0,St.h)((0,Y.H)(e,t)))}});(0,Dn.t3)().prototype.logicalXor=function(e){return this.throwIfDisposed(),co(this,e)},(0,Dn.t3)().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),(0,P.O)(this,e,t,n)};var Io=n(1174);(0,Dn.t3)().prototype.maxPool=function(e,t,n,o){return this.throwIfDisposed(),(0,Io._)(this,e,t,n,o)};var Go=n(3307);(0,Dn.t3)().prototype.max=function(e,t){return this.throwIfDisposed(),(0,Go.F)(this,e,t)},(0,Dn.t3)().prototype.maximum=function(e){return this.throwIfDisposed(),(0,kn.g)(this,e)};var Eo=n(5130);(0,Dn.t3)().prototype.mean=function(e,t){return this.throwIfDisposed(),(0,Eo.J)(this,e,t)};var ko=n(5735);(0,Dn.t3)().prototype.min=function(e,t){return this.throwIfDisposed(),(0,ko.V)(this,e,t)};var go=n(4513);(0,Dn.t3)().prototype.minimum=function(e){return this.throwIfDisposed(),(0,go.L)(this,e)};var fo=n(1483);(0,Dn.t3)().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),(0,fo.V)(this,e,t)};var Ho=n(5228);(0,Dn.t3)().prototype.mod=function(e){return this.throwIfDisposed(),(0,Ho.w)(this,e)},(0,Dn.t3)().prototype.mul=function(e){return this.throwIfDisposed(),(0,m.d)(this,e)},(0,Dn.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,c.W)(this)};var Fo=n(3561);(0,Dn.t3)().prototype.norm=function(e,t,n){return this.throwIfDisposed(),(0,Fo.K)(this,e,t,n)};var Co=n(6500);(0,Dn.t3)().prototype.notEqual=function(e){return this.throwIfDisposed(),(0,Co.Q)(this,e)};var Do=n(6708);(0,Dn.t3)().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),(0,Do.l)(this,e,t,n)};var Jo=n(7846);(0,Dn.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,Jo.J)(this)},(0,Dn.t3)().prototype.pad=function(e,t){return this.throwIfDisposed(),(0,zt.v)(this,e,t)};const vo=(0,S.op)({pool_:function(e,t,n,o,A,i){null==A&&(A=[1,1]),null==i&&(i=1),0===o&&(o="valid");const r=(0,M._1)(e,"x","maxPool");let s=r,a=!1;3===r.rank&&(a=!0,s=(0,H.X)(r,[1,r.shape[0],r.shape[1],r.shape[2]])),L.hu(re.jT(i,A),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${A}'`));const l=re.Xw(s.shape,t,i,A,o),m=[l.dilationHeight,l.dilationWidth];let p;p="same"===o?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),o=n.map((e=>Math.floor(e/2))),A=n.map(((e,t)=>e-o[t]));return n.map(((e,t)=>[o[t],A[t]]))}([l.filterHeight,l.filterWidth],m):[[0,0],[0,0]];const h=1===m[0]&&1===m[1],[u,c]=function(e,t,n){const o=n.map((e=>e[0])),A=n.map((e=>e[1])),i=e.concat(o,A),r=t.map(((e,t)=>(e-i[t]%e)%e)),s=A.map(((e,t)=>e+r[t]));return[t.map(((e,t)=>[o[t],s[t]])),t.map(((e,t)=>[0,r[t]]))]}([l.inHeight,l.inWidth],m,p),d=h?o:"valid",I=h?s:(0,V.f)(s,m,u),G=("avg"===n?()=>(0,Ln.w)(I,t,i,d):()=>(0,Io._)(I,t,i,d))(),E=h?G:(0,en.E)(G,m,c);return a?(0,H.X)(E,[E.shape[1],E.shape[2],E.shape[3]]):E}});(0,Dn.t3)().prototype.pool=function(e,t,n,o,A){return this.throwIfDisposed(),vo(this,e,t,n,o,A)},(0,Dn.t3)().prototype.pow=function(e){return this.throwIfDisposed(),(0,Ct.s)(this,e)};var jo=n(8151);(0,Dn.t3)().prototype.prelu=function(e){return this.throwIfDisposed(),(0,jo.A)(this,e)};var Ko=n(9451);(0,Dn.t3)().prototype.prod=function(e,t){return this.throwIfDisposed(),(0,Ko.W)(this,e,t)};var yo=n(9036);(0,Dn.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,yo.M)(this)};var bo=n(7409);(0,Dn.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,bo.U)(this)};var qo=n(3582);(0,Dn.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,qo.b)(this)},(0,Dn.t3)().prototype.reshapeAs=function(e){return this.throwIfDisposed(),(0,H.X)(this,e.shape)},(0,Dn.t3)().prototype.reshape=function(e){return this.throwIfDisposed(),(0,H.X)(this,e)};var xo=n(3305);(0,Dn.t3)().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),(0,xo.I)(this,e,t,n)};var Bo=n(5098);(0,Dn.t3)().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),(0,Bo.j)(this,e,t,n)},(0,Dn.t3)().prototype.reverse=function(e){return this.throwIfDisposed(),(0,Bt.G)(this,e)};var wo=n(3710);(0,Dn.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,wo.Q)(this)};var Mo=n(7809);(0,Dn.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,Mo.N)(this)},(0,Dn.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,xe.b)(this)};var Lo=n(5503);(0,Dn.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,Lo.U)(this)};var So=n(8678);(0,Dn.t3)().prototype.separableConv2d=function(e,t,n,o,A,i){return this.throwIfDisposed(),(0,So.U)(this,e,t,n,o,A,i)},(0,Dn.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,Yt.X)(this)};var To=n(4434);(0,Dn.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,To.X)(this)},(0,Dn.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,ue.O)(this)},(0,Dn.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,de.R)(this)},(0,Dn.t3)().prototype.slice=function(e,t){return this.throwIfDisposed(),(0,pt.t)(this,e,t)};var No=n(682);(0,Dn.t3)().prototype.softmax=function(e){return this.throwIfDisposed(),(0,No.X)(this,e)},(0,Dn.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,ao.W)(this)},(0,Dn.t3)().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),(0,V.f)(this,e,t)},(0,Dn.t3)().prototype.split=function(e,t){return this.throwIfDisposed(),(0,ne.V)(this,e,t)},(0,Dn.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,I._)(this)},(0,Dn.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,G.h)(this)};var Ro=n(5265);(0,Dn.t3)().prototype.squaredDifference=function(e){return this.throwIfDisposed(),(0,Ro.$)(this,e)};var Oo=n(9590);(0,Dn.t3)().prototype.squeeze=function(e){return this.throwIfDisposed(),(0,Oo.L)(this,e)},(0,Dn.t3)().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Dn.es?[this,e]:[this,...e];return(0,dn.k)(n,t)},(0,Dn.t3)().prototype.step=function(e){return this.throwIfDisposed(),(0,p.N)(this,e)};var Po=n(5158);(0,Dn.t3)().prototype.stridedSlice=function(e,t,n,o,A,i,r,s){return this.throwIfDisposed(),(0,Po.N)(this,e,t,n,o,A,i,r,s)},(0,Dn.t3)().prototype.sub=function(e){return this.throwIfDisposed(),(0,E.l)(this,e)},(0,Dn.t3)().prototype.sum=function(e,t){return this.throwIfDisposed(),(0,F.S)(this,e,t)};var Uo=n(1173);(0,Dn.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,Uo.O)(this)};var Vo=n(1869);(0,Dn.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Vo.A)(this)},(0,Dn.t3)().prototype.tile=function(e){return this.throwIfDisposed(),(0,Be.G)(this,e)},(0,Dn.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,l.p)(this,"bool")},(0,Dn.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,l.p)(this,"float32")},(0,Dn.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,l.p)(this,"int32")};var Wo=n(3243);(0,Dn.t3)().prototype.topk=function(e,t){return this.throwIfDisposed(),(0,Wo.h)(this,e,t)},(0,Dn.t3)().prototype.transpose=function(e){return this.throwIfDisposed(),(0,ke.p)(this,e)};var _o=n(9608);let zo;function Xo(){return null==zo&&(zo=(0,s.y3$)().epsilon()),zo}(0,Dn.t3)().prototype.unique=function(e){return this.throwIfDisposed(),(0,_o.T)(this,e)},(0,Dn.t3)().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Me(this,e,t)},(0,Dn.t3)().prototype.unstack=function(e){return this.throwIfDisposed(),(0,gt.H)(this,e)},(0,Dn.t3)().prototype.where=function(e,t){return this.throwIfDisposed(),(0,$.a)(e,this,t)},(0,Dn.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,J.P)(this)};class Qo extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Qo.prototype)}}class Zo extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Zo.prototype)}}class Yo extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Yo.prototype)}}class $o extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$o.prototype)}}class eA extends Error{constructor(e){super(e),Object.setPrototypeOf(this,eA.prototype)}}function tA(e,t){if(Array.isArray(e)){let n=[];for(let o=0;o<t;o++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function nA(e,t){if(!e)throw new eA(t)}function oA(e,t){let n=0;for(const o of e)o===t&&n++;return n}function AA(e){return 1===e.length?e[0]:e}function iA(e){return Array.isArray(e)?e:[e]}function rA(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function sA(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}Error;let aA={};function lA(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function mA(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>mA(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?mA(t):e[n]=t.value)}}}function pA(e,t={},n={},o="object",A=!1){if("string"==typeof e){const A=e;let i;if(A in n)i=n[A];else if(A in aA)i=aA[A];else if(i=t[A],null==i)throw new Yo(`Unknown ${o}: ${e}. This may be due to one of the following reasons:\n1. The ${o} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${o} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=e;if(null==i.className||null==i.config)throw new Yo(`${o}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const r=i.className;let s,a;if(r in n?[s,a]=n[r]:r in aA?[s,a]=aA.className:r in t&&([s,a]=t[r]),null==s)throw new Yo(`Unknown ${o}: ${r}. This may be due to one of the following reasons:\n1. The ${o} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${o} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=a){const e={};for(const t of Object.keys(aA))e[t]=aA[t];for(const t of Object.keys(n))e[t]=n[t];i.config.customObjects=e;const t=Object.assign({},aA);for(const e of Object.keys(n))aA[e]=n[e];mA(i.config);const o=a(s,i.config,n,A);return aA=Object.assign({},t),o}{const e=Object.assign({},aA);for(const e of Object.keys(n))aA[e]=n[e];const t=new s(i.config);return aA=Object.assign({},e),t}}}function hA(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function uA(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function cA(e){if(null==e)throw new Yo(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function dA(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Yo(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function IA(e,t,n=0,o=1/0){return nA(n>=0),nA(o>=n),Array.isArray(e)&&e.length>=n&&e.length<=o&&e.every((e=>typeof e===t))}function GA(e,t){Array.isArray(e)?(s.D5U.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>GA(e,`element ${n+1} of ${t}`)))):s.D5U.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${EA(e)}.`))}function EA(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>EA(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function kA(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function gA(e,t){return(0,s.lub)((()=>s._b3(s.Smz(s.dC7(e,e),t,!0))))}class fA extends s.m7h.Serializable{getConfig(){return{}}}class HA extends fA{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,s.lub)((()=>{const t=gA(e,this.axis),n=s.iUl(t,0,this.maxValue);return s.dC7(e,s.hiC(n,s.IHx(Xo(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}HA.className="MaxNorm",s.m7h.registerClass(HA);class FA extends fA{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,s.lub)((()=>s.hiC(e,s.IHx(Xo(),gA(e,this.axis)))))}getConfig(){return{axis:this.axis}}}FA.className="UnitNorm",s.m7h.registerClass(FA);class CA extends fA{apply(e){return s.UYe(e)}}CA.className="NonNeg",s.m7h.registerClass(CA);class DA extends fA{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,s.lub)((()=>{const t=gA(e,this.axis),n=s.IHx(s.dC7(this.rate,s.iUl(t,this.minValue,this.maxValue)),s.dC7(1-this.rate,t));return s.dC7(e,s.hiC(n,s.IHx(Xo(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}DA.className="MinMaxNorm",s.m7h.registerClass(DA);const JA={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function vA(e){return lA(e)}function jA(e,t={}){return pA(e,s.m7h.SerializationMap.getMap().classNameMap,t,"constraint")}function KA(e){return null==e?null:"string"==typeof e?jA({className:e in JA?JA[e]:e,config:{}}):e instanceof fA?e:jA(e)}const yA=["channelsFirst","channelsLast"],bA=["nearest","bilinear"],qA=["valid","same","causal"],xA=["max","avg"],BA=["sum","mul","concat","ave"],wA=new Map;function MA(e){dA(yA,"DataFormat",e)}function LA(e){dA(qA,"PaddingMode",e)}function SA(e){dA(xA,"PoolMode",e)}const TA=[];function NA(e,t){TA.push(e);try{const e=t();return TA.pop(),e}catch(e){throw TA.pop(),e}}function RA(e){if(!UA(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===TA.length?"":TA.join("/")+"/")+e}function OA(e){if(!UA(e))throw new Error("Not a valid tensor name: '"+e+"'");wA.has(e)||wA.set(e,0);const t=wA.get(e);if(wA.set(e,wA.get(e)+1),t>0){const n=`${e}_${t}`;return wA.set(n,1),n}return e}const PA=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function UA(e){return!!e.match(PA)}function VA(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let o=1;for(let A=t;A<n;++A)o*=e[A];return o}function WA(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const o=e[n];o<t&&(t=o)}return t}function _A(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const o=e[n];o>t&&(t=o)}return t}function zA(e,t){if(t<e)throw new Yo(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let o=e;o<t;++o)n.push(o);return n}function XA(e,t){return s.pju(e,t)}function QA(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),s.XLQ(e,n)}function ZA(e,t,n){return(0,s.lub)((()=>{switch(e.rank){case 1:return s.jZU(e,t,n);case 2:return s.SmN(e,[t,0],[n,e.shape[1]]);case 3:return s.CnO(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return s.p0P(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return s.tPi(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return s.tPi(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Yo(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function YA(e,t,n){return(0,s.lub)((()=>{switch(e.rank){case 1:return s.jZU(e,t,n);case 2:return s.SmN(e,[0,t],[e.shape[0],n]);case 3:return s.CnO(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return s.p0P(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Yo(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function $A(e,t,n,o){return(0,s.lub)((()=>{switch(e.rank){case 1:return s.jZU(e,t,n);case 2:switch(o){case 1:return ZA(e,t,n);case 2:return YA(e,t,n);default:throw new Yo(`The axis is not within the rank of the tensor ${o}`)}case 3:switch(o){case 1:return ZA(e,t,n);case 2:return s.CnO(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return YA(e,t,n);default:throw new Yo(`The axis is not within the rank of the tensor ${o}`)}case 4:switch(o){case 1:return ZA(e,t,n);case 2:return s.p0P(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return s.p0P(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return YA(e,t,n);default:throw new Yo(`The axis is not within the rank of the tensor ${o}`)}default:throw new Yo(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function ei(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),s.zoF(e,t)}function ti(e,t){switch(e.rank){case 1:return s.gME([e,t]);case 2:return s.Izb([e,t],0);case 3:return s.MNy([e,t],0);case 4:return s.ZaL([e,t],0);default:throw new Yo(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function ni(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Yo(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return s.Gg6(e,t)}function oi(e,t=0,n=1,o,A){return s.nGf(e,t,n,o,A)}function Ai(e,t,n,o){if(e.rank<2||t.rank<2)throw new $o(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new $o(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank){const A=!1,i=!1;return s.imm.matMul({a:e,b:t,transposeA:A,transposeB:i,bias:o?si(e.rank,o,"channelsLast"):null,activation:n})}{const A=e.shape.slice(),i=A.pop();e=s.XLQ(e,[-1,i]);const r=t.shape.slice(),a=r.pop(),l=r.pop(),m=[...r,a],p=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=s.XLQ(s.p4s(t,p),[l,-1]);const h=[...A,...m],u=!1,c=!1;return s.XLQ(s.imm.matMul({a:e,b:t,transposeA:u,transposeB:c,bias:o?si(e.rank,o,"channelsLast"):null,activation:n}),h)}}function ii(e,t,n){return(0,s.lub)((()=>(t=Array.isArray(t)?(0,s.RRF)(t,"int32"):s.pju(t,"int32"),s.Iqj(e,t,n))))}function ri(e){return s.dC7(e,e)}function si(e,t,n){const o=t.shape;if(1!==t.rank&&t.rank!==e)throw new Yo(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===o.length?s.XLQ(t,[1,o[0],1,1,1]):s.XLQ(t,[1,o[3],o[0],o[1],o[2]]);if("channelsLast"===n)return 1===o.length?s.XLQ(t,[1,1,1,1,o[0]]):s.XLQ(t,[1].concat(o))}else if(4===e){if("channelsFirst"===n)return 1===o.length?s.XLQ(t,[1,o[0],1,1]):s.XLQ(t,[1,o[2],o[0],o[1]]);if("channelsLast"===n)return 1===o.length?s.XLQ(t,[1,1,1,o[0]]):s.XLQ(t,[1].concat(o))}else if(3===e){if("channelsFirst"===n)return 1===o.length?s.XLQ(t,[1,o[0],1]):s.XLQ(t,[1,o[1],o[0]]);if("channelsLast"===n)return 1===o.length?s.XLQ(t,[1,1,o[0]]):s.XLQ(t,[1].concat(o))}else if(e<3)return t;throw new Yo(`Unsupported input rank by biasAdd: ${t.rank}`)}function ai(e,t,n){return(0,s.lub)((()=>(null==n&&(n="channelsLast"),MA(n),s.IHx(e,si(e.rank,t,n)))))}function li(e,t,n,o){return(0,s.lub)((()=>s.rvX(e,t,n,o)))}function mi(e,t,n=!1){return n?e():t()}const pi=["fanIn","fanOut","fanAvg"],hi=["normal","uniform","truncatedNormal"];class ui extends s.m7h.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class ci extends ui{apply(e,t){return(0,s.lls)(e,t)}}ci.className="Zeros",s.m7h.registerClass(ci);class di extends ui{apply(e,t){return(0,s.iUs)(e,t)}}di.className="Ones",s.m7h.registerClass(di);class Ii extends ui{constructor(e){if(super(),"object"!=typeof e)throw new Yo(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Yo(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return(0,s.lub)((()=>(0,s.dC7)((0,s.iD$)(this.value),(0,s.iUs)(e,t))))}getConfig(){return{value:this.value}}}Ii.className="Constant",s.m7h.registerClass(Ii);class Gi extends ui{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return(0,s.LGj)(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Gi.className="RandomUniform",s.m7h.registerClass(Gi);class Ei extends ui{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new $o(`randomNormal does not support dType ${t}.`);return oi(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Ei.className="RandomNormal",s.m7h.registerClass(Ei);class ki extends ui{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new $o(`truncatedNormal does not support dType ${t}.`);return(0,s.Xu6)(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ki.className="TruncatedNormal",s.m7h.registerClass(ki);class gi extends ui{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return(0,s.lub)((()=>{if(2!==e.length||e[0]!==e[1])throw new Yo("Identity matrix initializer can only be used for 2D square matrices.");return(0,s.dC7)(this.gain,(0,s.iyy)(e[0]))}))}getConfig(){return{gain:this.gain}}}gi.className="Identity",s.m7h.registerClass(gi);class fi extends ui{constructor(e){if(super(),e.scale<0)throw new Yo(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,dA(pi,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){dA(hi,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,o;if(MA(t),2===e.length)n=e[0],o=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=VA(e,2);n=e[1]*t,o=e[0]*t}else if("channelsLast"===t){const t=VA(e,0,e.length-2);n=e[e.length-2]*t,o=e[e.length-1]*t}}else{const t=VA(e);n=Math.sqrt(t),o=Math.sqrt(t)}return[n,o]}(e),o=n[0],A=n[1];let i=this.scale;if("fanIn"===this.mode?i/=Math.max(1,o):"fanOut"===this.mode?i/=Math.max(1,A):i/=Math.max(1,(o+A)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new $o(`${this.getClassName()} does not support dType ${t}.`);return(0,s.Xu6)(e,0,n,t,this.seed)}{const n=Math.sqrt(3*i);return(0,s.LGj)(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}fi.className="VarianceScaling",s.m7h.registerClass(fi);class Hi extends fi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fi.className}}Hi.className="GlorotUniform",s.m7h.registerClass(Hi);class Fi extends fi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fi.className}}Fi.className="GlorotNormal",s.m7h.registerClass(Fi);class Ci extends fi{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fi.className}}Ci.className="HeNormal",s.m7h.registerClass(Ci);class Di extends fi{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fi.className}}Di.className="HeUniform",s.m7h.registerClass(Di);class Ji extends fi{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fi.className}}Ji.className="LeCunNormal",s.m7h.registerClass(Ji);class vi extends fi{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fi.className}}vi.className="LeCunNormal",s.m7h.registerClass(vi);class ji extends ui{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new $o("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return(0,s.lub)((()=>{if(e.length<2)throw new $o("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=oi(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=s.$r2.gramSchmidt(t);return e[0]>e[1]&&(n=(0,s.p4s)(n)),(0,s.dC7)(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}ji.className="Orthogonal",s.m7h.registerClass(ji);const Ki={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function yi(e,t={}){return pA(e,s.m7h.SerializationMap.getMap().classNameMap,t,"initializer")}function bi(e){return lA(e)}function qi(e){if("string"==typeof e){const t=e in Ki?Ki[e]:e;if("GlorotNormal"===t)return new Fi;if("GlorotUniform"===t)return new Hi;if("HeNormal"===t)return new Ci;if("HeUniform"===t)return new Di;if("LeCunNormal"===t)return new Ji;if("LeCunUniform"===t)return new vi;{const e={};return e.className=t,e.config={},yi(e)}}return e instanceof ui?e:yi(e)}let xi=0;function Bi(){return xi++}const wi={};function Mi(e=""){return e in wi||(wi[e]=0),wi[e]+=1,e+wi[e].toString()}function Li(e){return Array.isArray(e)&&Array.isArray(e[0])}function Si(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Ti(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Yo(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Ni(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new Yo(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Ri(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}class Oi{constructor(e,t="float32",n="Variable",o=!0,A=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Bi(),n=null==n?"Variable":n,this.originalName=RA(n),this.name=OA(this.originalName),this.trainable_=o,this.constraint=A,this.val=s.VD$(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Pi(e){return e.map((e=>e.read()))}function Ui(e){e.forEach((e=>{e[0].write(e[1])}))}class Vi{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Wi{constructor(e,t,n,o,A,i,r){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=o,this.callArgs=A,this.outputTensorIndex=r,this.id=Bi(),null!=i&&(this.originalName=RA(i),this.name=OA(this.originalName)),this.rank=t.length}}let _i=0;class zi{constructor(e,t){this.callArgs=t,this.id=_i++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Xi=0;class Qi extends s.m7h.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Xi++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=rA(e)+"_"+Mi(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Zo(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Yo(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return AA(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return AA(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Qo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Qo(`Layer ${this.name} is not connected, no input to return.`);return AA(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Qo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Qo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return AA(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=iA(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=iA(this.inputSpec);if(e.length!==t.length)throw new Yo(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const o=e[n],A=t[n];if(null==A)continue;const i=o.rank;if(null!=A.ndim&&i!==A.ndim)throw new Yo(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${A.ndim}, found ndim=${i}`);if(null!=A.maxNDim&&i>A.maxNDim)throw new Yo(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${A.maxNDim}, found ndim=${i}`);if(null!=A.minNDim&&i<A.minNDim)throw new Yo(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${A.minNDim}, found ndim=${i}.`);if(null!=A.dtype&&o.dtype!==A.dtype)throw new Yo(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${A.dtype}, found dtype=${o.dtype}.`);if(A.axes){const e=o.shape;for(const t in A.axes){const o=Number(t),i=A.axes[t],r=o>=0?e[o]:e[e.length+o];if(null!=i&&-1===[i,null].indexOf(r))throw new Yo(`Input ${n} is incompatible with layer ${this.name}: expected axis ${o} of input shape to have value ${i} but got shape ${e}.`)}}if(null!=A.shape)for(let e=0;e<A.shape.length;++e){const t=A.shape[e],i=o.shape[e];if(null!=t&&null!=i&&t!==i)throw new Yo(`Input ${n} is incompatible with layer ${this.name}: expected shape=${A.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=iA(e);let o=!0;for(const e of n)if(!(e instanceof Wi)){o=!1;break}let A=!0;for(const e of n)if(e instanceof Wi){A=!1;break}if(o===A)throw new Yo("Arguments to apply() must be all SymbolicTensors or all Tensors");return NA(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of iA(e))t.push(n.shape);this.build(AA(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&A&&(this._refCount=1)}if(this.assertInputCompatibility(e),A){let o=this.call(e,t);const A=iA(o),i=[];for(let e of A)-1!==n.indexOf(e)&&(e=e.clone()),i.push(e);if(o=AA(i),null!=this.activityRegularizer)throw new $o("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const n=function(e){e=iA(e);const t=[];for(const n of e)t.push(n.shape);return AA(t)}(e),o=this.computeOutputShape(n);let A;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),A=null!=o&&o.length>0&&Array.isArray(o[0])?o.map(((n,o)=>new Wi(i,n,this,iA(e),t,this.name,o))):new Wi(i,o,this,iA(e),t,this.name),this.addInboundNode(e,A,null,null,n,o,t),this._refCount++,null!=this.activityRegularizer)throw new $o("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return A}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,o)=>{null!=n&&null!=e[o]&&e[o]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Qo(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Qo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Zo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Ri(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Pi(e?this.trainableWeights:this.weights)}setWeights(e){(0,s.lub)((()=>{const t=this.weights;if(t.length!==e.length)throw new Yo(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],o=Pi(t);for(let A=0;A<o.length;++A){const i=o[A],r=t[A],a=e[A];if(!s.D5U.arraysEqual(i.shape,a.shape))throw new Yo(`Layer weight shape ${i.shape} not compatible with provided weight shape ${a.shape}`);n.push([r,a])}Ui(n)}))}addWeight(e,t,n,o,A,i,r,s){if(-1!==this._addedWeightNames.indexOf(e))throw new Yo(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(o=null!=s?s():qi("zeros"));const a=o.apply(t,n),l=new Oi(a,n,e,i,r);return a.dispose(),null!=A&&this.addLoss((()=>A.apply(l.read()))),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=iA(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,o,A,i,r=null){const s=iA(e);t=iA(t),n=iA(n),o=iA(o),A=Si(A),i=Si(i);const a=[],l=[],m=[];for(const e of s)a.push(e.sourceLayer),l.push(e.nodeIndex),m.push(e.tensorIndex);new zi({outboundLayer:this,inboundLayers:a,nodeIndices:l,tensorIndices:m,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:o,inputShapes:A,outputShapes:i},r);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Zi(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const o=Zi(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of o)-1===t.indexOf(e)&&t.push(e)}return t}}}class Yi extends Qi{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Mi("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Yo("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Yo("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Yo("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const o=new Wi(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new zi({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Yo(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function $i(e){if(null==e)return;const t=[],n=[],o=[];for(const A in e){const i=e[A];if("number"!=typeof i){const e=i;t.push(e.data()),n.push(A),o.push(e)}}if(t.length>0){const A=await Promise.all(t);for(let t=0;t<A.length;++t)e[n[t]]=A[t][0];(0,s.B90)(o)}}function er(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var tr;Yi.className="InputLayer",s.m7h.registerClass(Yi),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(tr||(tr={}));class nr{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class or{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Ar extends nr{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const o=t[e];if("number"==typeof o)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+o*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const A=(0,s.lub)((()=>(0,s.IHx)(this.totals[e],(0,s.dC7)(o,n))));this.totals[e]=A,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:(0,s.lub)((()=>{const n=(0,s.dC7)((0,s.hiC)(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),(0,s.CnY)(t[e])})))}}class ir extends nr{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const o in this.history){const A=this.history[o];for(let i=0;i<A.length;++i)if("number"!=typeof A[i]){const r=A[i];e.push(r.data()),t.push(o),n.push(i)}}const o=await Promise.all(e);for(let e=0;e<o.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=o[e][0]}}class rr extends nr{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||s.glt,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");s.D5U.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let o,A=null!=n?n():s.D5U.now();return(...i)=>{const r=null!=n?n():s.D5U.now();return r-A<t||(A=r,o=e(...i)),o}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const o=[];null!=this.yield&&(await $i(n),o.push(this.yield(e,t,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await $i(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await $i(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await $i(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await $i(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):s.D5U.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await $i(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await $i(e),await this.trainEnd(e))}}function sr(e,t){return null==e&&(e={}),e instanceof nr?[e]:Array.isArray(e)&&e[0]instanceof nr?e:iA(e).map((e=>new rr(e,t)))}class ar{constructor(){}static registerCallbackConstructor(e,t){s.D5U.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),ar.checkForDuplicate(t),null==ar.constructors[e]&&(ar.constructors[e]=[]),ar.constructors[e].push(t)}static checkForDuplicate(e){for(const t in ar.constructors)ar.constructors[+t].forEach((t=>{if(t===e)throw new Yo("Duplicate callback constructor.")}))}static clear(){ar.constructors={}}static createCallbacks(e){const t=[];for(const n in ar.constructors){const o=+n;e>=o&&t.push(...ar.constructors[o])}return t.map((e=>new e))}}function lr(e,t,n,o,A,i,r,s,a){const l=new ir,m=[new Ar,...ar.createCallbacks(t)];null!=e&&m.push(...e),m.push(l);const p=new or(m);return p.setParams({epochs:n,initialEpoch:o,samples:A,steps:i,batchSize:r,verbose:t,doValidation:s,metrics:a}),{callbackList:p,history:l}}function mr(e,t={},n=!1){return pA(e,s.m7h.SerializationMap.getMap().classNameMap,t,"layer",n)}function pr(e,t){return(0,s.lub)((()=>{"float32"!==e.dtype&&(e=s.pju(e,"float32"));const n=s.Smz(ri(e),t,!0),o=s.hlL(n.shape,Xo()),A=s._b3(s.gWQ(n,o));return s.hiC(e,A)}))}function hr(e,t){return(0,s.lub)((()=>s.J69(ri(s.luU(t,e)),-1)))}function ur(e,t){return(0,s.lub)((()=>s.J69(s.WnP(s.luU(t,e)),-1)))}function cr(e,t){return(0,s.lub)((()=>{const n=s.luU(e,t),o=s.iUl(s.WnP(e),Xo(),Number.MAX_VALUE),A=s.WnP(s.hiC(n,o));return s.dC7(100,s.J69(A,-1))}))}function dr(e,t,n=!1){return(0,s.lub)((()=>{if(n)t=s.XAC(t);else{const e=s.Smz(t,t.shape.length-1,!0);t=s.hiC(t,e)}return t=s.iUl(t,Xo(),1-Xo()),s.W76(s.Smz(s.dC7(s.pju(e,"float32"),s.cM7(t)),t.shape.length-1))}))}function Ir(e,t,n=!1){return(0,s.lub)((()=>{const o=s.pju(s.GWj(function(e){const t=[VA(e.shape)];return s.XLQ(e,t)}(e)),"int32"),A=(t=s.iUl(t,Xo(),1-Xo())).shape;return dr(s.XLQ(s.lfX(o,A[A.length-1]),A),t,n)}))}function Gr(e,t){return(0,s.lub)((()=>{let n;return n=s.iUl(t,Xo(),1-Xo()),n=s.cM7(s.hiC(n,s.luU(1,n))),s.J69(function(e,t){if(!s.D5U.arraysEqual(e.shape,t.shape))throw new Yo(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return(0,s.lub)((()=>{const n=s.UYe(t),o=s.W76(s.WnP(t));return s.IHx(s.luU(n,s.dC7(t,e)),s.Krr(s.Qqt(o)))}))}(e,n),-1)}))}function Er(e,t){return(0,s.lub)((()=>{const n=pr(e,-1),o=pr(t,-1),A=s.dC7(n,o);return s.W76(s.Smz(A,-1))}))}ar.constructors={};const kr={meanSquaredError:hr,meanAbsoluteError:ur,meanAbsolutePercentageError:cr,meanSquaredLogarithmicError:function(e,t){return(0,s.lub)((()=>{const n=s.iUl(t,Xo(),Number.MAX_VALUE),o=s.cM7(s.IHx(1,n)),A=s.iUl(e,Xo(),Number.MAX_VALUE),i=s.cM7(s.IHx(1,A));return s.J69(ri(s.luU(o,i)),-1)}))},squaredHinge:function(e,t){return(0,s.lub)((()=>{const n=s.gWQ(0,s.luU(1,s.dC7(e,t)));return s.J69(ri(n),-1)}))},hinge:function(e,t){return(0,s.lub)((()=>{const n=s.gWQ(0,s.luU(1,s.dC7(e,t)));return s.J69(n,-1)}))},categoricalHinge:function(e,t){return(0,s.lub)((()=>{const n=s.Smz(s.dC7(e,t),-1),o=s.Fp7(s.dC7(s.luU(1,e),t),-1);return s.gWQ(0,s.IHx(1,s.luU(o,n)))}))},logcosh:function(e,t){return(0,s.lub)((()=>{const n=Math.log(2),o=s.luU(t,e),A=s.luU(s.IHx(o,s.Wvh(s.dC7(-2,o))),n);return s.J69(A,-1)}))},categoricalCrossentropy:dr,sparseCategoricalCrossentropy:Ir,binaryCrossentropy:Gr,kullbackLeiblerDivergence:function(e,t){return(0,s.lub)((()=>{const n=s.iUl(e,Xo(),1),o=s.iUl(t,Xo(),1);return s.Smz(s.dC7(e,s.cM7(s.hiC(n,o))),-1)}))},poisson:function(e,t){return(0,s.lub)((()=>{const n=s.cM7(s.IHx(Xo(),t));return s.J69(s.luU(t,s.dC7(e,n)),-1)}))},cosineProximity:Er};function gr(e){if("string"==typeof e){if(e in kr)return kr[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Yo(t)}return e}function fr(e,t){return(0,s.lub)((()=>{const n=s.dC7(.5,s.JpU(t)),o=XA(s.pjt(t,n),e.dtype);return s.J69(s.DgJ(e,o),-1)}))}function Hr(e,t){return(0,s.lub)((()=>XA(s.DgJ(s.NqF(e,-1),s.NqF(t,-1)),"float32")))}function Fr(e,t){return Gr(e,t)}function Cr(e,t){return e.rank===t.rank&&(e=s.L9e(e,[e.rank-1])),(t=s.NqF(t,-1)).dtype!==e.dtype&&(t=s.pju(t,e.dtype)),s.pju(s.DgJ(e,t),"float32")}const Dr=dr,Jr=Ir,vr={binaryAccuracy:fr,categoricalAccuracy:Hr,precision:function(e,t){return(0,s.lub)((()=>{const n=function(e,t){return(0,s.lub)((()=>s.pju(s.Smz(s.HvI(s.DgJ(e,1),s.DgJ(t,1))),"float32")))}(e,t),o=function(e,t){return(0,s.lub)((()=>s.pju(s.Smz(s.HvI(s.DgJ(e,0),s.DgJ(t,1))),"float32")))}(e,t),A=s.IHx(n,o);return s.pju(s.arb(s.pjt(A,0),s.hiC(n,A),0),"float32")}))},categoricalCrossentropy:Dr,sparseCategoricalCrossentropy:Jr,mse:hr,MSE:hr,mae:ur,MAE:ur,mape:cr,MAPE:cr,cosine:Er};function jr(e){if("string"==typeof e&&e in vr)return vr[e];if("string"!=typeof e&&null!=e)return e;throw new Yo(`Unknown metric ${e}`)}function Kr(e){if(nA(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(kr))if(kr[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(vr))if(vr[n]===e){t=n;break}return void 0!==t?t:e.name}}function yr(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!br(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function br(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!br(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!br(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function qr(e,t,n=console.log){let o="";for(let n=0;n<e.length;++n)n>0&&(o=o.slice(0,o.length-1)+" "),o+=e[n],o=o.slice(0,t[n]),o+=" ".repeat(t[n]-o.length);n(o)}function xr(e,t,n){let o;try{o=JSON.stringify(e.outputShape)}catch(e){o="multiple"}qr([`${e.name} (${e.getClassName()})`,o,e.countParams().toString()],t,n)}function Br(e,t,n,o){let A;try{A=JSON.stringify(e.outputShape)}catch(e){A="multiple"}const i=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,o=t.nodeIndices[e],A=t.tensorIndices[e];i.push(`${n}[${o}][${A}]`)}const r=e.name,s=e.getClassName(),a=0===i.length?"":i[0];qr([`${r} (${s})`,A,e.countParams().toString(),a],t,o);for(let e=1;e<i.length;++e)qr(["","","",i[e]],t,o)}function wr(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Mr(e,t){if(null===e)return null;if("string"==typeof e)return sA(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],o=e.length;for(let A=0;A<o;++A){const o=e[A];wr(t,A,o)?n.push(o):n.push(Mr(o,t))}return n}{const t={};for(const n of Object.keys(e)){const o=e[n];if("name"===n&&"string"==typeof o)t[n]=o;else{const e=sA(n);t[e]=Mr(o,e)}}return t}}function Lr(e,t){if(null==e)return null;if("string"==typeof e)return rA(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],o=e.length;for(let A=0;A<o;++A){const o=e[A];wr(t,A,o)?n.push(o):n.push(Lr(o,t))}return n}{const t={};for(const n of Object.keys(e)){const o=e[n];t[rA(n)]="name"!==n&&"className"!==n||"string"!=typeof o?Lr(o,n):o}return t}}class Sr{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Sr)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Yo(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return(0,s.pju)(t,e.dtype)}catch(n){throw new Yo(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Wi){if(null==this.id2Value[e.id])throw new Yo(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Yo(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Wi){if(null==this.id2Value[e.id])throw new Yo(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Yo(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&(0,s.B90)(this.id2Mask)}}const Tr={},Nr={};function Rr(e,t,n,o){const A=null!=n&&n.training,i=Array.isArray(e),r=i?e:[e],a=r.map((e=>e.name)),l=[],m=t.names();for(const e of a)-1!==m.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=o&&(o.maxNumTensors=-1/0,o.minNumTensors=1/0);const p=a.join(",")+"|"+t.names().join(",");let h,u;if(null==Tr[p]){const e=function(e,t){s.D5U.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],o={};if(1===e.length){const A=Pr(e[0],t);n=A.sorted,o=A.recipientMap}else{const A=new Set;for(const i of e){const{sorted:e,recipientMap:r}=Pr(i,t);for(const t of e)A.has(t.name)||(n.push(t),A.add(t.name));for(const e in r)null==o[e]&&(o[e]=new Set),r[e].forEach((t=>o[e].add(t)))}}return{sorted:n,recipientCounts:Or(o)}}(r,t);h=e.sorted,u=e.recipientCounts,Tr[p]=h,Nr[p]=u}h=Tr[p],u={},A||Object.assign(u,Nr[p]);const c=new Sr(t);for(let e=0;e<h.length;++e){if(null!=o){const e=(0,s.sq6)().numTensors;e>o.maxNumTensors&&(o.maxNumTensors=e),e<o.minNumTensors&&(o.minNumTensors=e)}const i=h[e],r=i.sourceLayer;if(r instanceof Yi)continue;const m=[],p=[],d=[];let I=!1;for(const e of i.inputs){const n=c.getValue(e),o=c.getMask(e);m.push(n),p.push(o),null!=o&&(I=!0),A||(u[e.name]--,0!==u[e.name]||t.hasKey(e)||-1!==a.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||d.push(n))}I&&((n=n||{}).mask=p[0]);const G=iA(r.apply(m,n));let E=null;r.supportsMasking&&(E=r.computeMask(m,p));const k=Ur(i),g=Array.isArray(k)?k:[k];for(let e=0;e<g.length;++e){c.hasKey(g[e])||c.add(g[e],G[e],Array.isArray(E)?E[0]:E);const t=a.indexOf(g[e].name);-1!==t&&(l[t]=G[e])}A||(0,s.B90)(d)}return c.disposeMasks(),i?l:l[0]}function Or(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Pr(e,t){const n=new Set,o=[],A={};for(const e of t.names())n.add(e);const i=[],r=[];for(i.push(e);i.length>0;){const e=i[i.length-1];if(n.has(e.name)){i.pop();continue}const t=r[r.length-1]===i.length-1;if(0===e.inputs.length||t)i.pop(),o.push(e),n.add(e.name),t&&r.pop();else{r.push(i.length-1);for(const t of e.inputs)null==A[t.name]&&(A[t.name]=new Set),A[t.name].add(e.name),n.has(t.name)||i.push(t)}}return{sorted:o,recipientMap:A}}function Ur(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const o of e.sourceLayer.inboundNodes[t].outputTensors)if(o.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}class Vr extends Qi{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Mi(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],uA(this.inputs).length!==this.inputs.length)throw new Yo(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);uA(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,o=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(o)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,o=e.tensorIndex;nA(0===n,"input layer has >1 nodes"),nA(0===o,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(o)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof Yi))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},o={},A={},i={},r=[],s=(e,t,n,o,A,a)=>{null!=o&&null!=A&&null!=a||(o=e.sourceLayer,A=e.nodeIndex,a=e.tensorIndex);const l=o.inboundNodes[A];if(-1!==n.indexOf(l))throw new Zo(`The tensor ${e.name} at layer "${o.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(Vr.nodeKey(o,A)),o.id in i||(i[o.id]=Object.keys(i).length),-1===n.indexOf(l)&&n.push(l);const m=l.inboundLayers.length;for(let e=0;e<m;e++){const o=l.inputTensors[e],A=l.inboundLayers[e],i=l.nodeIndices[e],r=l.tensorIndices[e];s(o,t,n,A,i,r)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);r.push(l)},a=[],l=[];for(const e of this.outputs)s(e,a,l);const m=r.slice().reverse();for(const e of m){n[e.id]=e,e.id in t||(t[e.id]=0);let i=t[e.id];const r=null==o[e.outboundLayer.id]?0:o[e.outboundLayer.id];i=Math.max(i,r),o[e.outboundLayer.id]=i,A[e.outboundLayer.id]=e.outboundLayer,t[e.id]=i;for(let o=0;o<e.inboundLayers.length;o++){const A=e.inboundLayers[o],r=e.nodeIndices[o],s=A.inboundNodes[r],a=null==t[s.id]?0:t[s.id];t[s.id]=Math.max(i+1,a),n[s.id]=s}}const p={};for(const e in t){const o=t[e];o in p||(p[o]=[]),p[o].push(n[e])}const h={};for(const e in o){const t=o[e];t in h||(h[t]=[]),h[t].push(A[e])}let u=Object.keys(h).map((e=>parseInt(e,10))).sort(hA);this.layers=[];for(const e of u){const t=h[e];t.sort(((e,t)=>{const n=i[e.id],o=i[t.id];return n<o?-1:n>o?1:0}));for(const e of t)e instanceof Vr&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=h,u=Object.keys(p).map((e=>parseInt(e,10))).sort(hA);const c=this.inputs.slice(),d=[];for(const e of u)for(const t of p[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===c.indexOf(n))throw new Zo(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${d}`);for(const e of t.outputTensors)c.push(e);d.push(e.name)}}this.nodesByDepth=p;const I=this.layers.map((e=>e.name));for(const e of I){const t=I.filter((t=>t===e)).length;if(1!==t)throw new Zo(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(I))}this.outboundNodes=[],this.inboundNodes=[],new zi({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Yo("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let o=0;for(const e of this.layers)for(const t of e.weights){if(null!=n[t.originalName])throw new Yo(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,o++}const A=[];for(const o in e){let i=o;if(null==n[o]){const e=o.split("/");i=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[i])A.push([n[i],e[o]]);else if(t)throw new Yo(`Provided weight data has no target variable: ${o}`);delete n[i]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Yo(`${e.length} of ${o} weights are not set: ${e}`)}Ui(A)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers 3.11.0",t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=Lr(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return(0,s.lub)((()=>{e=iA(e);const n=new Sr;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Rr(this.outputs,n,t)}))}computeMask(e,t){return(0,s.lub)((()=>{let n;return e=iA(e),n=null==t?tA(null,e.length):iA(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Si(e);if(t.length!==this.inputLayers.length)throw new Yo(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const o=this.inputLayers[e],A=t[e];n[o.name+"_0_0"]=A}const o=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(hA);if(o.length>1)for(const e of o){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const o=[];for(let t=0;t<e.inboundLayers.length;t++){const A=e.inboundLayers[t],i=e.nodeIndices[t],r=e.tensorIndices[t],s=n[`${A.name}_${i}_${r}`];o.push(s)}const A=Si(t.computeOutputShape(AA(o))),i=t.inboundNodes.indexOf(e);for(let e=0;e<A.length;e++)n[`${t.name}_${i}_${e}`]=A[e]}}const A=[],i=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],o=this.outputLayersTensorIndices[e],A=`${t.name}_${n}_${o}`;i.push(A)}for(let e=0;e<i.length;e++){const t=i[e];nA(t in n),A.push(n[t])}return AA(A)}runInternalGraph(e,t){null==t&&(t=tA(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const A=this.inputs[o],i=e[o],r=t[o];n[A.id]=[i,r]}const o=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(hA);for(const e of o){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,o=e.inputTensors,A=e.outputTensors,i=new Array;for(const e of o)e.id in n&&i.push(n[e.id]);if(i.length===o.length){let o,r,s,a,l={};if(null!=e.callArgs&&(l=e.callArgs),1===i.length){const[e,n]=i[0];null==l.mask&&(l.mask=n),s=iA(t.call(e,l)),a=iA(t.computeMask(e,n)),o=[e],r=[n]}else o=i.map((e=>e[0])),r=i.map((e=>e[1])),null==l.mask&&(l.mask=r),s=iA(t.call(o,l)),a=iA(t.computeMask(o,r));if(t.activityRegularizer)throw new $o("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<A.length;++e){const t=A[e],o=s[e],i=a[e];n[t.id]=[o,i]}}}}const A=[],i=[],r=[];for(const e of this.outputs){nA(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,o]=n[e.id];r.push(t.shape),A.push(t),i.push(o)}return[A,i,r]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof Vr?1:0;for(let o=0;o<e.inboundNodes.length;o++){const A=Vr.nodeKey(e,o);this.containerNodes.has(A)&&(t[A]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new Yo(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new Yo("Provide either a layer name or layer index");for(const t of this.layers)if(t.name===e)return t;throw new Yo(`No such layer: ${e}`)}calculateLosses(){return(0,s.lub)((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const o=Vr.nodeKey(t,n);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const o=e.getClassName(),A=e.getConfig(),i=[];for(let n=0;n<e.inboundNodes.length;n++){const o=e.inboundNodes[n],A=Vr.nodeKey(e,n);let r={};if(this.containerNodes.has(A)){if(o.callArgs)try{JSON.stringify(o.callArgs),r=o.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${o.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),r={}}if(o.inboundLayers.length>0){const e=[];for(let n=0;n<o.inboundLayers.length;n++){const A=o.inboundLayers[n],i=o.nodeIndices[n],s=o.tensorIndices[n];let a=t[Vr.nodeKey(A,i)];null==a&&(a=0),e.push([A.name,a,s,r])}i.push(e)}}}const r={};r.name=e.name,r.className=o,r.config=A,r.inboundNodes=i,n.push(r)}e.layers=n;const o=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],A=this.inputLayersNodeIndices[e],i=Vr.nodeKey(n,A);if(!this.containerNodes.has(i))continue;let r=t[i];null==r&&(r=0);const s=this.inputLayersTensorIndices[e];o.push([n.name,r,s])}e.inputLayers=o;const A=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],o=this.outputLayersNodeIndices[e],i=Vr.nodeKey(n,o);if(!this.containerNodes.has(i))continue;let r=t[i];null==r&&(r=0);const s=this.outputLayersTensorIndices[e];A.push([n.name,r,s])}return e.outputLayers=A,e}static fromConfig(e,t,n={},o=!1){const A={},i={};function r(e,t){e.name in i?i[e.name].push(t):i[e.name]=[t]}function s(e,t){const n=[];let o;for(const i of t){const s=i[0],a=i[1],l=i[2];if(o=null==i[3]?{}:i[3],!(s in A))return void r(e,t);const m=A[s];if(m.inboundNodes.length<=a)return void r(e,t);const p=m.inboundNodes[a];n.push(p.outputTensors[l])}n.length>0&&e.apply(AA(n),o)}function a(e){const n=e.name,i=mr(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(o),A[n]=i,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Yo(`Corrupted configuration, expected array for nodeData: ${e}`);r(i,e)}))}const l=t.name,m=t.layers;for(const e of m)a(e);for(;!cA(i);)for(const e of m){const t=A[e.name];if(t.name in i){const e=i[t.name];delete i[t.name];for(const n of e)s(t,n)}}const p=[],h=[],u=t.inputLayers;for(const e of u){const t=e[0],n=e[1],o=e[2];nA(t in A);const i=A[t].inboundNodes[n].outputTensors;p.push(i[o])}const c=t.outputLayers;for(const e of c){const t=e[0],n=e[1],o=e[2];nA(t in A);const i=A[t].inboundNodes[n].outputTensors;h.push(i[o])}return new e({inputs:p,outputs:h,name:l})}get stateful(){if(this._stateful)throw new Yo("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){(0,s.lub)((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Wr(e,t){return function(e,t,n){const o=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===o)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==o)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${o} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${o}) outputs, so ${n} must be either an array with ${o} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function _r(e,t,n,o){if(null!=t||null!=o)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=(0,s.lub)((()=>{if(1===e.shape.length)return(0,s.d9v)(e);if(2===e.shape.length){if(e.shape[1]>1){const t=1;return(0,s.NqF)(e,t)}if(1===e.shape[1])return(0,s.XLQ)(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),o=Array.from(await t.data());(0,s.B90)(t);const A=[];return o.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);A.push(n[e])})),(0,s.RRF)(A,"float32")}return null}function zr(e,t){return(0,s.dC7)(e,t)}function Xr(e,t){let n,o;const A=t;n=A.xs,o=A.ys,s.D5U.assert(null!=n&&null!=o,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const i=Qr("input",e.inputNames,n),r=Qr("output",e.outputNames,o),a=i[0].shape[0];s.D5U.assert(i.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),s.D5U.assert(r.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${r.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<i.length;t++)s.D5U.assert(i[t].shape[0]===a,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${i[t].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`));for(let t=0;t<r.length;t++)s.D5U.assert(r[t].shape[0]===a,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${r[t].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`));return{xs:i,ys:r}}function Qr(e,t,n){if(n instanceof s.esB)return[n];if(Array.isArray(n))return s.D5U.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const o=[];for(const A of t){if(null==n[A])throw new Yo(`The feature data generated by the dataset lacks the required ${e} key '${A}'.`);o.push(n[A])}return o}}function Zr(e){return"function"==typeof e.iterator}function Yr(e){s.D5U.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function $r(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>ZA(e,t,n-t))):ZA(e,t,n-t)}function es(e,t){return s.lub((()=>null==e?null:Array.isArray(e)?e.map((e=>es(e,t))):ii(e,"int32"===t.dtype?t:s.pju(t,"int32"))))}function ts(e,t){const n=[];let o=0,A=null;for(;o<e;)A=o+t,A>=e&&(A=e),n.push([o,A]),o=A;return n}function ns(e){const t=[];e instanceof s.esB&&(e=[e]);for(let n=0;n<e.length;++n){const o=e[n];if(1===o.rank)t.push(QA(o,1));else{if(0===o.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(o)}}return t}function os(e,t){if(null==e)return;const n=[];if(t instanceof s.esB)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const o=t[e];n.push(o.id)}const o=[];if(e instanceof s.esB)-1===n.indexOf(e.id)&&o.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&o.push(e)}));else if(null!=e)for(const t in e){const A=e[t];-1===n.indexOf(A.id)&&o.push(A)}o.forEach((e=>{e.isDisposed||e.dispose()}))}function As(e){return Array.isArray(e)}function is(e){return!function(e){return e instanceof s.esB}(e)&&!As(e)}function rs(e,t,n,o=!0,A=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(As(e)&&e.length>0)t=!0;else if(is(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Yo(`Error when checking model ${A} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let i;if(is(e)){e=e,i=[];for(const n of t){if(null==e[n])throw new Yo(`No data provided for "${n}". Need data for each key in: ${t}`);i.push(e[n])}}else if(As(e)){if((e=e).length!==t.length)throw new Yo(`Error when checking model ${A}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);i=e}else{if(e=e,t.length>1)throw new Yo(`The model ${A} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);i=[e]}if(i=ns(i),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const r=i[e];if(r.shape.length!==n[e].length)throw new Yo(`Error when checking ${A}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${r.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!o)continue;const i=r.shape[t],s=n[e][t];if(null!=s&&s>=0&&i!==s)throw new Yo(`${A} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${A} received an input with ${r.shape[0]} examples, each with shape [${r.shape.slice(1,r.shape.length)}] (tensor shape [${r.shape}])`)}}return i}function ss(e,t,n,o=!0,A=""){let i;if(Array.isArray(e)){if(e.length!==t.length)throw new Yo(`Error when checking model ${A}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);i=e}else{if(t.length>1)throw new Yo(`The model expects ${t.length} ${A} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);i=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const r=i[e];if(r.shape.length!==n[e].length)throw new Yo(`Error when checking ${A}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(r.shape)}`);for(let i=0;i<n[e].length;++i){if(0===i&&!o)continue;const s=r.shape[i],a=n[e][i];if(null!=a&&a!==s)throw new Yo(`Error when checking ${A}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(r.shape)}.`)}}}class as extends Vr{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Yo("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,o=console.log){const A=function(e){let t=!0;const n=[],o=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}o.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const A of n.inboundNodes)if(-1!==o.indexOf(A)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Output shape","Param #"];let r;if(A?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!A){i.push("Receives inputs"),r=[];for(const t in e.nodesByDepth)r.push(...e.nodesByDepth[t])}o("_".repeat(t)),qr(i,n,o),o("=".repeat(t));const s=e.layers;for(let e=0;e<s.length;++e)A?xr(s[e],n,o):Br(s[e],n,r,o),o((e===s.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const a=function(e){let t;return t=null!=e.collectedTrainableWeights?Ri(e.collectedTrainableWeights):Ri(e.trainableWeights),t}(e),l=Ri(e.nonTrainableWeights);o(`Total params: ${a+l}`),o(`Trainable params: ${a}`),o(`Non-trainable params: ${l}`),o("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>s.p_j.adagrad(.01),Adadelta:()=>s.p_j.adadelta(1,.95,Xo()),Adam:()=>s.p_j.adam(.001,.9,.999,Xo()),Adamax:()=>s.p_j.adamax(.002,.9,.999,Xo(),0),RMSProp:()=>s.p_j.rmsprop(.001,.9,0,Xo()),SGD:()=>s.p_j.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Yo(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof s.gaJ))throw new Yo("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Yo(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>gr(e)))}else{const n=gr(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Yo(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(gr(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],NA("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const o=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const o of t){let t=n.hasOwnProperty(o)?n[o]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),A=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};NA("metric",(()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,o,i;for(const r of t){if("string"==typeof r&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(r)){const t=this.internalOutputShapes[e];let A;1===t[t.length-1]||this.lossFunctions[e]===Gr?-1!==["accuracy","acc"].indexOf(r)?o=fr:-1!==["crossentropy","ce"].indexOf(r)&&(o=Fr):this.lossFunctions[e]===Ir?-1!==["accuracy","acc"].indexOf(r)?o=Cr:-1!==["crossentropy","ce"].indexOf(r)&&(o=Jr):-1!==["accuracy","acc"].indexOf(r)?o=Hr:-1!==["crossentropy","ce"].indexOf(r)&&(o=Dr),-1!==["accuracy","acc"].indexOf(r)?A="acc":-1!==["crossentropy","ce"].indexOf(r)&&(A="ce"),i=o,n=""+A}else{const e=jr(r);i=e,n=""+Kr(r)}let t;NA(n,(()=>{t=i})),A(e,n,t)}})(o[e])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const o=null==n.batchSize?32:n.batchSize;Yr(o);const A=this.standardizeUserDataXY(e,t,!0,o);try{const i=A[0].concat(A[1]);this.makeTestFunction();const r=this.testFunction;return AA(this.testLoop(r,i,o,n.verbose,n.steps))}finally{os(A[0],e),os(A[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const o=null!=(n=n||{}).batches,A=e.testFunction;let i=[];if(n.verbose>0)throw new $o("Verbose mode is not implemented yet.");s.D5U.assert(!o||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const r="function"==typeof t.next?t:await t.iterator();let a=0,l=0;for(;!o||l<n.batches;){const t=await r.next();if(i=s.lub((()=>{if(t.value){const{xs:n,ys:o}=Xr(e,t.value),r=n.concat(o),m=s.lub((()=>A(r)));if(s.B90(r),0===l)for(let e=0;e<m.length;++e)i.push((0,s.iD$)(0));const p=r[0].shape[0];for(let e=0;e<m.length;++e){const t=m[e],n=i[e];i[e]=s.lub((()=>s.IHx(i[e],s.dC7(p,t)))),l>0&&s.B90(n)}s.B90(m),a+=p,++l}return i})),t.done){o&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<i.length;++e){const t=i[e];i[e]=s.hiC(i[e],a),s.B90(t)}return AA(i)}(this,e,t)}checkNumSamples(e,t,n,o="steps"){let A;if(null!=n){if(A=null,null!=t)throw new Yo(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Yo(`Either the input data should have a defined shape, or ${o} shoud be specified.`);A=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return A}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Yo("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),o=n?t:[t],A=this.retrieveSymbolicTensors(o),i=new Sr;if(e instanceof s.esB&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Yo(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)i.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new Yo(`No value is provided for the model's input ${t.name}`);i.add(t,n)}const r=Rr(A,i);return n?r:r[0]}retrieveSymbolicTensors(e){const t=tA(null,e.length);let n=e.length;for(const o of this.layers){const A=Array.isArray(o.output)?o.output:[o.output],i=A.map((e=>e.name));for(let o=0;o<e.length;++o){const r=i.indexOf(e[o]);if(-1!==r&&(t[o]=A[r],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,o)=>{null==t&&n.push(e[o])})),new Yo(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return s.lub((()=>{const o=this.checkNumSamples(e);if(n)throw new $o("Verbose predictLoop() is not implemented yet.");const A=ts(o,t),i=this.outputs.map((e=>[]));for(let t=0;t<A.length;++t)s.lub((()=>{const n=A[t][0],o=A[t][1],i=$r(e,n,o),r=[];if(Array.isArray(i))for(let e=0;e<i.length;++e)r.push({key:this.inputs[e],value:i[e]});else r.push({key:this.inputs[0],value:i});const s=new Sr(r);return Rr(this.outputs,s)})).forEach(((e,t)=>i[t].push(e)));return AA(i.map((e=>s.zoF(e,0))))}))}predict(e,t={}){const n=ns(e);ss(n,this.inputNames,this.feedInputShapes,!1);try{const o=null==t.batchSize?32:t.batchSize;return Yr(o),this.predictLoop(n,o)}finally{os(n,e)}}predictOnBatch(e){ss(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,o){if(null==this.optimizer_)throw new Zo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const A=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===Ir?A.push(t.slice(0,t.length-1).concat([1])):A.push(t)}if(function(e,t,n){const o=uA(e.map((e=>e.shape[0])));o.sort();const A=uA(t.map((e=>e.shape[0])));if(A.sort(),o.length>1)throw new Yo(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(A.length>1)throw new Yo(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(o.length>0&&A.length>0&&!s.D5U.arraysEqual(o,A))throw new Yo(`Input Tensors should have the same number of samples as target Tensors. Found ${o[0]} input sample(s) and ${A[0]} target sample(s).`)}(e=rs(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=rs(t,this.feedOutputNames,A,!1,"target")),function(e,t,n){const o=[hr,Gr,dr];for(let A=0;A<e.length;++A){const i=e[A],r=t[A],s=n[A];if(null!=r){if(r===dr&&1===i.shape[i.shape.length-1])throw new Yo(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==o.indexOf(r)){const e=i.shape.slice(1),t=s.slice(1);for(let n=0;n<e.length;++n){const o=e[n],A=t[n];if(null!=A&&o!==A)throw new Yo(`A target Tensor with shape ${i.shape} was passed for an output of shape ${s}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new Yo(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,o,A=!0,i){const[r,s]=this.standardizeUserDataXY(e,t,A,i);if(null!=n)throw new Error("sample weight is not supported yet.");let a=null;if(null!=o){const e=Wr(o,this.outputNames);a=[];for(let t=0;t<e.length;++t)a.push(await _r(s[t],null,e[t]))}return[r,s,a]}testLoop(e,t,n,o=0,A){return s.lub((()=>{const i=this.checkNumSamples(t,n,A,"steps"),r=[];if(o>0)throw new $o("Verbose mode is not implemented yet.");if(null!=A)throw new $o("steps mode in testLoop() is not implemented yet");{const o=ts(i,n),A=(0,s.RRF)(zA(0,i));for(let n=0;n<o.length;++n){const i=o[n][0],a=o[n][1],l=ZA(A,i,a-i),m=es(t,l),p=e(m);if(0===n)for(let e=0;e<p.length;++e)r.push((0,s.iD$)(0));for(let e=0;e<p.length;++e){const t=p[e];r[e]=s.IHx(r[e],s.dC7(a-i,t))}}for(let e=0;e<r.length;++e)r[e]=s.hiC(r[e],i)}return r}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const o=e[n];let A=o;oA(e,o)>1&&(A+=`_${oA(e.slice(0,n),o)}`),t.push(A)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),A=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],r=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const r=new Sr(e),a=Rr(this.outputs,r,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(o[e],a[e]);null!=A[e]&&(n=zr(n,A[e]));const i=s.J69(n);t.push(i),l=0===e?n:s.IHx(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],A=this.metricsTensors[e][1];n=s.J69(t(o[A],a[A]))}s.CnY(n),i.push(n)}return l=s.J69(l),this.calculateLosses().forEach((e=>{l=s.IHx(l,e)})),l}),!0,r)].concat(i)}}makeTestFunction(){this.testFunction=e=>s.lub((()=>{const t=[];let n;const o=e.slice(0,this.inputs.length),A=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:o[e]});const r=new Sr(i),a=Rr(this.outputs,r);for(let e=0;e<this.lossFunctions.length;++e){const o=this.lossFunctions[e],i=s.J69(o(A[e],a[e]));n=0===e?i:s.IHx(n,i),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],o=this.metricsTensors[e][1],i=s.J69(n(A[o],a[o]));t.push(i)}return t}))}async fit(e,t,n={}){return async function(e,t,n,o={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let A,i,r,a,l,m,p;e.isTraining=!0;try{const h=null==o.batchSize?32:o.batchSize;Yr(h);const u=!1,c=await e.standardizeUserData(t,n,o.sampleWeight,o.classWeight,u,h);A=c[0],i=c[1],p=c[2];let d,I=!1;if(null!=o.validationData&&o.validationData.length>0){if(I=!0,2!==o.validationData.length)throw 3===o.validationData.length?new $o("validationData including sample weights is not supported yet."):new Yo(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);r=o.validationData[0],a=o.validationData[1];const t=!0,n=await e.standardizeUserData(r,a,null,null,t,h);l=n[0],m=n[1],d=l.concat(m)}else if(null!=o.validationSplit&&o.validationSplit>0&&o.validationSplit<1){I=!0;const e=Math.floor(A[0].shape[0]*(1-o.validationSplit)),t=A[0].shape[0];l=$r(A,e,t),A=$r(A,0,e),m=$r(i,e,t),i=$r(i,0,e),d=l.concat(m)}else null!=o.validationSteps&&(I=!0);const G=A.concat(i).concat(p);e.checkTrainableWeightsConsistency();const E=e.makeTrainFunction(),k=e.getDedupedMetricsNames();let g,f;I?(e.makeTestFunction(),g=e.testFunction,f=k.slice().concat(k.map((e=>"val_"+e)))):(g=null,d=[],f=k.slice());const H=sr(o.callbacks,o.yieldEvery),F=await async function(e,t,n,o,A,i,r,a,l,m,p,h,u,c,d){null==A&&(A=32),null==i&&(i=1),null==p&&(p=!0),null==u&&(u=0);let I=!1;null!=l&&null!=m&&(I=!0);const G=e.checkNumSamples(n,A,c,"steps_per_epoch");let E;null!=G&&(E=zA(0,G)),null==r&&(r=1);const{callbackList:k,history:g}=lr(a,r,i,u,G,c,A,I,h);k.setModel(e),e.history=g,await k.onTrainBegin(),e.stopTraining_=!1;for(let r=u;r<i;++r){await k.onEpochBegin(r);const i={};{if("batch"===p)throw new $o("batch shuffling is not implemneted yet");p&&s.D5U.shuffle(E);const r=(0,s.RRF)(E),a=ts(G,A);for(let p=0;p<a.length;++p){const h={};if(await k.onBatchBegin(p,h),s.lub((()=>{const u=a[p][0],c=a[p][1],d=ZA(r,u,c-u);h.batch=p,h.size=c-u;const G=es(n,d),E=t(G);for(let e=0;e<o.length;++e){const t=o[e],n=E[e];h[t]=n,s.CnY(n)}if(p===a.length-1&&I){const t=e.testLoop(l,m,A);for(let e=0;e<o.length;++e){const n=o[e],A=t[e];s.CnY(A),i["val_"+n]=A}}})),await k.onBatchEnd(p,h),er(h),e.stopTraining_)break}r.dispose()}if(await k.onEpochEnd(r,i),e.stopTraining_)break}return await k.onTrainEnd(),await e.history.syncData(),e.history}(e,E,G,k,h,o.epochs,o.verbose,H,g,d,o.shuffle,f,o.initialEpoch,null);return F}finally{e.isTraining=!1,os(A,t),os(i,n),os(l,r),os(m,a),null!=p&&s.B90(p)}}(this,e,t,n)}async fitDataset(e,t){return async function(e,t,n){const o=null!=n.batchesPerEpoch;if(s.D5U.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),s.D5U.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),s.D5U.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),s.D5U.assert(!o||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),s.D5U.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const A=null!=n.validationData;let i,r;if(A)if(Zr(n.validationData))s.D5U.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new $o("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);i=e.xs,r=e.ys}const a=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let m;m=A?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const p=sr(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:u,history:c}=lr(p,h,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,A,m);u.setModel(e),e.history=c,await u.onTrainBegin(),e.stopTraining_=!1;let d=null==n.initialEpoch?0:n.initialEpoch,I=await t.iterator();for(;d<n.epochs;){const m={};await u.onEpochBegin(d);let p=0,h=0;for(o||(I=await t.iterator());!o||p<n.batchesPerEpoch;){const t=await I.next();if(o&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${p} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:o,ys:A}=Xr(e,t.value),i={};i.batch=h,i.size=o[0].shape[0],await u.onBatchBegin(h,i);const r=[];if(null!=n.classWeight){const t=Wr(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)r.push(await _r(A[e],null,t[e]))}const m=o.concat(A).concat(r),c=a(m);s.B90(m);for(let e=0;e<l.length;++e){const t=l[e],n=c[e];i[t]=n,s.CnY(n)}await u.onBatchEnd(h,i),er(i),h++,p++}if(o?p>=n.batchesPerEpoch:t.done){if(A){let t;t=Zr(n.validationData)?iA(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):iA(e.evaluate(i,r,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)m[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await u.onEpochEnd(d,m),d++,e.stopTraining_)break}return await u.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),o=n[0],A=n[1],i=this.makeTrainFunction()(o.concat(A)),r=[];for(const e of i){const t=await e.data();r.push(t[0])}return s.B90(i),AA(r)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,o=n?this.trainableWeights:this.weights,A=this.getWeights(n);for(let e=0;e<o.length;++e)n&&!o[e].trainable||t.push({name:o[e].originalName,tensor:A[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=s.sq6().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-s.sq6().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=rA(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>rA(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const o of t){if("string"!=typeof n[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=rA(n[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[rA(Kr(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>rA(Kr(e))));{const e={};for(const t in this.metrics)e[t]=rA(Kr(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=mr(Mr(e.optimizer_config));let n,o;if("string"==typeof e.loss)n=sA(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>sA(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=sA(e.loss[t])}if(Array.isArray(e.metrics))o=e.metrics.map((e=>sA(e)));else if(null!=e.metrics){o={};for(const t in e.metrics)o[t]=sA(e.metrics[t])}this.compile({loss:n,metrics:o,optimizer:t})}async save(e,t){if("string"==typeof e){const t=s.io.getSaveHandlers(e);if(0===t.length)throw new Yo(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Yo(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Yo("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await s.io.encodeWeights(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.11.0",convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){o.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:A}=await s.io.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...A),n.data=s.io.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;yr(this.userDefinedMetadata,this.name,e),o.userDefinedMetadata=this.userDefinedMetadata}return o.weightData=n.data,o.weightSpecs=n.specs,e.save(o)}setUserDefinedMetadata(e){yr(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}as.className="Model",s.m7h.registerClass(as);class ls extends as{}ls.className="Functional",s.m7h.registerClass(ls);class ms extends as{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Mi("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Yo(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof ms||e instanceof as;let n;if(t){if(n=e,1!==n.outputs.length)throw new Yo("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Yo("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Yo("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Yo("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new Yi({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Yo(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Yo("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Zi(this.outputs[0])}this.inboundNodes=[],new zi({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:tA(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Ni(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new as({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Zo("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Zo("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Zo("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Zo("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},o=!1){let A,i={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Yo("Legacy serialization format not supported yet.");A=t}else s.D5U.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),A=t.layers,delete t.layers,i=t;const r=new e(i);if(!(r instanceof ms))throw new $o(`Sequential.fromConfig called on non-Sequential input: ${r}`);for(const e of A){const t=mr(e,void 0,o);o&&t.setFastWeightInitDuringBuild(!0),r.add(t)}return r}set stopTraining(e){if(null==this.model)throw new Yo("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Yo("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}ms.className="Sequential",s.m7h.registerClass(ms);class ps extends s.m7h.Serializable{getConfig(){return{}}}class hs extends ps{apply(e,t=1){return function(e,t=1){if(1!==t)throw new $o(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return s.pyx(e)}(e,t)}}hs.className="elu",s.m7h.registerClass(hs);class us extends ps{apply(e){return s.U8D(e)}}us.className="selu",s.m7h.registerClass(us);class cs extends ps{apply(e){return s.UYe(e)}}cs.className="relu",s.m7h.registerClass(cs);class ds extends ps{apply(e){return(0,s.lub)((()=>s.LTh(6,s.UYe(e))))}}ds.className="relu6",s.m7h.registerClass(ds);class Is extends ps{apply(e){return e}}Is.className="linear",s.m7h.registerClass(Is);class Gs extends ps{apply(e){return s.XD2(e)}}Gs.className="sigmoid",s.m7h.registerClass(Gs);class Es extends ps{apply(e){return function(e){return(0,s.lub)((()=>{const t=s.IHx(.5,s.dC7(.2,e));return s.iUl(t,0,1)}))}(e)}}Es.className="hardSigmoid",s.m7h.registerClass(Es);class ks extends ps{apply(e){return s.Wvh(e)}}ks.className="softplus",s.m7h.registerClass(ks);class gs extends ps{apply(e){return function(e){return(0,s.lub)((()=>s.hiC(e,s.IHx(s.WnP(e),1))))}(e)}}gs.className="softsign",s.m7h.registerClass(gs);class fs extends ps{apply(e){return s.AEp(e)}}fs.className="tanh",s.m7h.registerClass(fs);class Hs extends ps{apply(e,t=-1){return s.XAC(e,t)}}Hs.className="softmax",s.m7h.registerClass(Hs);class Fs extends ps{apply(e,t=-1){return s.CmS(e,t)}}Fs.className="logSoftmax",s.m7h.registerClass(Fs);class Cs extends ps{apply(e,t=1){return(0,s.lub)((()=>s.dC7(s.XD2(s.dC7(e,t)),e)))}}Cs.className="swish",s.m7h.registerClass(Cs);class Ds extends ps{apply(e){return(0,s.lub)((()=>s.dC7(e,s.AEp(s.Wvh(e)))))}}function Js(e){return e.getClassName()}function vs(e,t={}){return pA(e,s.m7h.SerializationMap.getMap().classNameMap,t,"activation")}function js(e){if(null==e){return vs({className:"linear",config:{}})}if("string"==typeof e){const t={};return t.className=e,t.config={},vs(t)}return e instanceof ps?e:vs(e)}Ds.className="mish",s.m7h.registerClass(Ds);class Ks extends s.m7h.Serializable{}class ys extends Ks{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,s.lub)((()=>{let t=(0,s.lls)([1]);return this.hasL1&&(t=(0,s.IHx)(t,(0,s.Smz)(s.dC7(this.l1,(0,s.WnP)(e))))),this.hasL2&&(t=(0,s.IHx)(t,(0,s.Smz)(s.dC7(this.l2,ri(e))))),s.XLQ(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}ys.className="L1L2",s.m7h.registerClass(ys);const bs={l1l2:"L1L2"};function qs(e){return lA(e)}function xs(e,t={}){return pA(e,s.m7h.SerializationMap.getMap().classNameMap,t,"regularizer")}function Bs(e){return null==e?null:"string"==typeof e?xs({className:e in bs?bs[e]:e,config:{}}):e instanceof Ks?e:xs(e)}class ws extends Qi{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Ti(e);let n=(0,s.UYe)(e);return null!=this.maxValue&&(n=(0,s.iUl)(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}ws.className="ReLU",s.m7h.registerClass(ws);class Ms extends Qi{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Ti(e);return(0,s.hi7)(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Ms.className="LeakyReLU",s.m7h.registerClass(Ms);class Ls extends Qi{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=qi(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Bs(e.alphaRegularizer),this.alphaConstraint=KA(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new Yo(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=Ni(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new Vi({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ti(e),(0,s.AL3)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:bi(this.alphaInitializer),alphaRegularizer:qs(this.alphaRegularizer),alphaConstraint:vA(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Ls.className="PReLU",s.m7h.registerClass(Ls);class Ss extends Qi{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new $o(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Ti(e);return(0,s.pyx)(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Ss.className="ELU",s.m7h.registerClass(Ss);class Ts extends Qi{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Ti(e);return(0,s.dC7)(n,(0,s.pju)((0,s.pjt)(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Ts.className="ThresholdedReLU",s.m7h.registerClass(Ts);class Ns extends Qi{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Hs).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=Ti(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Rs(e,t,n){if("number"==typeof e)return tA(e,t);if(e.length!==t)throw new Yo(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let A=0;A<t;++A){const i=e[A];if((o=i)!==parseInt(o.toString(),10))throw new Yo(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${i}`)}return e;var o}function Os(e,t,n,o,A=1){if(null==e)return e;let i;return i="same"===n?e:e-(t+(t-1)*(A-1))+1,Math.floor((i+o-1)/o)}function Ps(e,t,n,o){if(null==e)return null;if("valid"===o)e=e*t+_A([n-t,0]);else{if("same"!==o)throw new Yo(`Unsupport padding mode: ${o}.`);e*=t}return e}function Us(e,t){return(0,s.lub)((()=>(MA(t),"channelsFirst"===t?s.p4s(e,[0,2,3,1]):e)))}function Vs(e,t){return(0,s.lub)((()=>(MA(t),"channelsFirst"===t?s.p4s(e,[0,2,3,4,1]):e)))}function Ws(e,t,n,o=[1,1],A="valid",i,r,a=null){return(0,s.lub)((()=>{if(null==i&&(i="channelsLast"),MA(i),3!==e.rank&&4!==e.rank)throw new Yo(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Yo(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=Us(e,i);if("causal"===A)throw new $o("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=s.imm.conv2d({x:l,filter:t,strides:o,pad:"same"===A?"same":"valid",dilations:r,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===i&&(l=s.p4s(l,[0,3,1,2])),l}))}Ns.className="Softmax",s.m7h.registerClass(Ns);class _s extends Qi{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",_s.verifyArgs(t),this.rank=e,GA(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new $o(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Rs(t.kernelSize,e,"kernelSize"),this.strides=Rs(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,LA(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,MA(this.dataFormat),this.activation=js(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=qi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=KA(t.biasConstraint),this.biasRegularizer=Bs(t.biasRegularizer),this.activityRegularizer=Bs(t.activityRegularizer),this.dilationRate=Rs(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Yo(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Yo(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Yo(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(nA("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!IA(e.kernelSize,"number",1,3))throw new Yo(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Js(this.activation),useBias:this.useBias,biasInitializer:bi(this.biasInitializer),biasRegularizer:qs(this.biasRegularizer),activityRegularizer:qs(this.activityRegularizer),biasConstraint:vA(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class zs extends _s{constructor(e,t){super(e,t),this.kernel=null,zs.verifyArgs(t),this.filters=t.filters,GA(this.filters,"filters"),this.kernelInitializer=qi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=KA(t.kernelConstraint),this.kernelRegularizer=Bs(t.kernelRegularizer)}build(e){e=Ni(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Yo(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return(0,s.lub)((()=>{let t;e=Ti(e);const n=null==this.bias?null:this.bias.read(),o=kA(this.activation.getClassName());if(null!=o&&2===this.rank)t=Ws(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)t=function(e,t,n,o=1,A="valid",i,r=1){return(0,s.lub)((()=>{if(null==i&&(i="channelsLast"),MA(i),3!==e.shape.length)throw new Yo(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Yo(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Yo(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(e=s.p4s(e,[0,2,1])),"causal"===A)throw new $o("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=s.PAt(e,t,o,"same"===A?"same":"valid","NWC",r);return null!=n&&(a=ai(a,n)),a}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Ws(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new $o("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,o=[1,1,1],A="valid",i,r){return(0,s.lub)((()=>{if(null==i&&(i="channelsLast"),MA(i),4!==e.rank&&5!==e.rank)throw new Yo(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Yo(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let a=Vs(e,i);if("causal"===A)throw new $o("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=s.pdZ(a,t,o,"same"===A?"same":"valid","NDHWC",r),null!=n&&(a=ai(a,n)),"channelsFirst"===i&&(a=s.p4s(a,[0,4,1,2,3])),a}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Ni(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const o=Os(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(o)}let o=[e[0]];return"channelsLast"===this.dataFormat?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){const e={filters:this.filters,kernelInitializer:bi(this.kernelInitializer),kernelRegularizer:qs(this.kernelRegularizer),kernelConstraint:vA(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new Yo(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Xs extends zs{constructor(e){super(2,e),Xs.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!IA(e.kernelSize,"number",1,2))throw new Yo(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Xs.className="Conv2D",s.m7h.registerClass(Xs);class Qs extends zs{constructor(e){super(3,e),Qs.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Yo(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Qs.className="Conv3D",s.m7h.registerClass(Qs);class Zs extends Xs{constructor(e){if(super(e),this.inputSpec=[new Vi({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Yo(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Ni(e)).length)throw new Yo("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Yo("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Vi({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return s.lub((()=>{let t=Ti(e);if(4!==t.shape.length)throw new Yo(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,o=n[0];let A,i;"channelsFirst"===this.dataFormat?(A=2,i=3):(A=1,i=2);const r=n[A],a=n[i],l=this.kernelSize[0],m=this.kernelSize[1],p=this.strides[0],h=this.strides[1],u=[o,Ps(r,p,l,this.padding),Ps(a,h,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=s.p4s(t,[0,2,3,1]));let c=s.bc(t,this.kernel.read(),u,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(c=s.p4s(c,[0,3,1,2])),null!=this.bias&&(c=ai(c,this.bias.read(),this.dataFormat)),null!=this.activation&&(c=this.activation.apply(c)),c}))}computeOutputShape(e){const t=(e=Ni(e)).slice();let n,o,A;"channelsFirst"===this.dataFormat?(n=1,o=2,A=3):(n=3,o=1,A=2);const i=this.kernelSize[0],r=this.kernelSize[1],s=this.strides[0],a=this.strides[1];return t[n]=this.filters,t[o]=Ps(t[o],s,i,this.padding),t[A]=Ps(t[A],a,r,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Zs.className="Conv2DTranspose",s.m7h.registerClass(Zs);class Ys extends Qs{constructor(e){if(super(e),this.inputSpec=[new Vi({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Yo(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Ni(e)).length)throw new Yo("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Yo("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Vi({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return s.lub((()=>{let t=Ti(e);if(5!==t.shape.length)throw new Yo(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,o=n[0];let A,i,r;"channelsFirst"===this.dataFormat?(r=2,A=3,i=4):(r=1,A=2,i=3);const a=n[r],l=n[A],m=n[i],p=this.kernelSize[0],h=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],d=this.strides[1],I=this.strides[2],G=[o,Ps(a,c,p,this.padding),Ps(l,d,h,this.padding),Ps(m,I,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=s.p4s(t,[0,2,3,4,1]));let E=s.$QV(t,this.kernel.read(),G,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(E=s.p4s(E,[0,4,1,2,3])),null!==this.bias&&(E=ai(E,this.bias.read(),this.dataFormat)),null!==this.activation&&(E=this.activation.apply(E)),E}))}computeOutputShape(e){const t=(e=Ni(e)).slice();let n,o,A,i;"channelsFirst"===this.dataFormat?(n=1,o=2,A=3,i=4):(n=4,o=1,A=2,i=3);const r=this.kernelSize[0],s=this.kernelSize[1],a=this.kernelSize[2],l=this.strides[0],m=this.strides[1],p=this.strides[2];return t[n]=this.filters,t[o]=Ps(t[o],l,r,this.padding),t[A]=Ps(t[A],m,s,this.padding),t[i]=Ps(t[i],p,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ys.className="Conv3DTranspose",s.m7h.registerClass(Ys);class $s extends zs{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Yo("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Yo("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Yo(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=qi(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Bs(t.depthwiseRegularizer),this.depthwiseConstraint=KA(t.depthwiseConstraint),this.pointwiseInitializer=qi(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Bs(t.pointwiseRegularizer),this.pointwiseConstraint=KA(t.pointwiseConstraint)}build(e){if((e=Ni(e)).length<this.rank+2)throw new Yo(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Yo(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],o=this.kernelSize.concat([n,this.depthMultiplier]),A=[];for(let e=0;e<this.rank;++e)A.push(1);A.push(n*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",A,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Vi({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return(0,s.lub)((()=>{let t;if(e=Ti(e),1===this.rank)throw new $o("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=s.p4s(e,[0,2,3,1])),t=s.U_I(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=ai(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=s.p4s(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=bi(this.depthwiseInitializer),e.pointwiseInitializer=bi(this.pointwiseInitializer),e.depthwiseRegularizer=qs(this.depthwiseRegularizer),e.pointwiseRegularizer=qs(this.pointwiseRegularizer),e.depthwiseConstraint=vA(this.depthwiseConstraint),e.pointwiseConstraint=vA(this.pointwiseConstraint),e}}$s.className="SeparableConv";class ea extends $s{constructor(e){super(2,e)}}ea.className="SeparableConv2D",s.m7h.registerClass(ea);class ta extends zs{constructor(e){super(1,e),ta.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!IA(e.kernelSize,"number",1,1))throw new Yo(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}ta.className="Conv1D",s.m7h.registerClass(ta);class na extends Qi{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return(0,s.lub)((()=>{if(e=Ti(e),"channelsLast"===this.dataFormat){const t=$A(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return $A(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=$A(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return $A(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}na.className="Cropping2D",s.m7h.registerClass(na);class oa extends Qi{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,MA(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,dA(bA,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return s.lub((()=>{let t=Ti(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=s.p4s(t,[0,2,3,1]);const e=this.size[0]*n[2],o=this.size[1]*n[3],A="nearest"===this.interpolation?s.BHj.resizeNearestNeighbor(t,[e,o]):s.BHj.resizeBilinear(t,[e,o]);return s.p4s(A,[0,3,1,2])}{const e=this.size[0]*n[1],o=this.size[1]*n[2];return"nearest"===this.interpolation?s.BHj.resizeNearestNeighbor(t,[e,o]):s.BHj.resizeBilinear(t,[e,o])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}oa.className="UpSampling2D",s.m7h.registerClass(oa);class Aa extends _s{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=qi(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=KA(e.depthwiseConstraint),this.depthwiseRegularizer=Bs(e.depthwiseRegularizer)}build(e){if((e=Ni(e)).length<4)throw new Yo(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Yo(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,s.lub)((()=>{let t=function(e,t,n=[1,1],o="valid",A,i){return(0,s.lub)((()=>{null==A&&(A="channelsLast"),MA(A);let r=Us(e,A);if(4!==e.rank)throw new Yo(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Yo(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return r=s.B10(r,t,n,"same"===o?"same":"valid","NHWC",i),"channelsFirst"===A&&(r=s.p4s(r,[0,3,1,2])),r}))}(e=Ti(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=ai(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Ni(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,A=Os(t,this.kernelSize[0],this.padding,this.strides[0]),i=Os(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,A,i]:[e[0],A,i,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=bi(this.depthwiseInitializer),e.depthwiseRegularizer=qs(this.depthwiseRegularizer),e.depthwiseConstraint=vA(this.depthwiseRegularizer),e}}function ia(e,t,n,o){if(Array.isArray(e)){if(null!=t||null!=n)throw new Yo("When inputs is an array, neither initialState or constants should be provided");null!=o&&(n=e.slice(e.length-o,e.length),e=e.slice(0,e.length-o)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function A(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=A(t),constants:n=A(n)}}function ra(e,t,n,o=!1,A,i,r=!1,a=!1){return s.lub((()=>{const l=t.shape.length;if(l<3)throw new Yo(`Input should be at least 3D, but is ${l}D.`);const m=[1,0].concat(zA(2,l));if(t=s.p4s(t,m),null!=i)throw new $o("The rnn() functoin of the deeplearn.js backend does not support constants yet.");r&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=A&&((A=s.pju(s.pju(A,"bool"),"float32")).rank===l-1&&(A=s.dt4(A,-1)),A=s.p4s(A,m)),o&&(t=s.GYS(t,0),null!=A&&(A=s.GYS(A,0)));const p=[];let h,u=n;const c=t.shape[0],d=s.HHK(t);let I,G;null!=A&&(I=s.HHK(A));for(let t=0;t<c;++t){const n=d[t],o=s.lub((()=>e(n,u)));if(null==A)h=o[0],u=o[1];else{const e=s.lub((()=>{const e=I[t],n=s.luU(s.JpU(e),e);return{output:s.IHx(s.dC7(o[0],e),s.dC7(u[0],n)),newStates:u.map(((t,A)=>s.IHx(s.dC7(o[1][A],e),s.dC7(t,n))))}}));h=e.output,u=e.newStates}a&&p.push(h)}if(a){const e=1;G=s.knu(p,e)}return[h,G,u]}))}Aa.className="DepthwiseConv2D",s.m7h.registerClass(Aa);class sa extends Qi{constructor(e){let t;if(super(e),null==e.cell)throw new Yo("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new da({cells:e.cell}):e.cell,null==t.stateSize)throw new Yo("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Vi({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?zA(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null)):this.states_}setStates(e){this.states_=e}computeOutputShape(e){Li(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let o;if(o=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const o of t)n.push([e[0],o]);return[o].concat(n)}return o}computeMask(e,t){return s.lub((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new $o("Constants support is not implemented in RNN yet.");Li(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Vi({shape:[t,null,...n]});const o=[e[0]].concat(e.slice(2));let A;if(this.cell.build(o),A=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!s.D5U.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),A))throw new Yo(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=A.map((e=>new Vi({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){(0,s.lub)((()=>{if(!this.stateful)throw new Qo("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Yo("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>s.lls([n,e]))):this.states_=[s.lls([n,this.cell.stateSize])];else if(null==e)s.B90(this.states_),null!=this.keptStates&&(s.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>s.lls([n,e]))):this.states_[0]=s.lls([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Yo(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):s.B90(this.states_);for(let t=0;t<this.states_.length;++t){const o=e[t],A=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,i=[n,A];if(!s.D5U.arraysEqual(o.shape,i))throw new Yo(`State ${t} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${o.shape}`);this.states_[t]=o}}this.states_=this.states_.map((e=>s.CnY(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,o=null==t?null:t.constants;null==t&&(t={});const A=ia(e,n,o,this.numConstants);e=A.inputs,n=A.initialState,o=A.constants;let i=[],r=[];if(null!=n){t.initialState=n,i=i.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Vi({shape:e.shape}));r=r.concat(this.stateSpec)}if(null!=o&&(t.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof Wi){const n=[e].concat(i),o=this.inputSpec.concat(r),A=this.inputSpec;this.inputSpec=o;const s=super.apply(n,t);return this.inputSpec=A,s}return super.apply(e,t)}call(e,t){return(0,s.lub)((()=>{const n=null==t?null:t.mask,o=null==t?null:t.training;let A=null==t?null:t.initialState;e=Ti(e),null==A&&(A=this.stateful?this.states_:this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(A.length!==i)throw new Yo(`RNN Layer has ${i} state(s) but was passed ${A.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const r={training:o},s=ra(((e,t)=>{const n=this.cell.call([e].concat(t),r);return[n[0],n.slice(1)]}),e,A,this.goBackwards,n,null,this.unroll,this.returnSequences),a=s[0],l=s[1],m=s[2];this.stateful&&this.resetStates(m,o);const p=this.returnSequences?l:a;return this.returnState?[p].concat(m):p}))}getInitialState(e){return(0,s.lub)((()=>{let t=s.lls(e.shape);return t=s.Smz(t,[1,2]),t=QA(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?ni(t,[1,e]):t)):this.cell.stateSize>1?[ni(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===sa.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const o=mr(t.cell,n);return new e(Object.assign(t,{cell:o}))}}sa.className="RNN",s.m7h.registerClass(sa);class aa extends Qi{}class la extends aa{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,GA(this.units,"units"),this.activation=js(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=qi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Bs(e.kernelRegularizer),this.recurrentRegularizer=Bs(e.recurrentRegularizer),this.biasRegularizer=Bs(e.biasRegularizer),this.kernelConstraint=KA(e.kernelConstraint),this.recurrentConstraint=KA(e.recurrentConstraint),this.biasConstraint=KA(e.biasConstraint),this.dropout=WA([1,_A([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=WA([1,_A([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ni(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,s.lub)((()=>{if(2!==(e=e).length)throw new Yo(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const o=null!=t.training&&t.training;let A;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ia({ones:()=>s.JpU(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ia({ones:()=>s.JpU(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,r=this.recurrentDropoutMask;A=Ai(null!=i?s.dC7(e,i):e,this.kernel.read()),null!=this.bias&&(A=ai(A,this.bias.read())),null!=r&&(n=s.dC7(n,r));let a=s.IHx(A,Ai(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Js(this.activation),useBias:this.useBias,kernelInitializer:bi(this.kernelInitializer),recurrentInitializer:bi(this.recurrentInitializer),biasInitializer:bi(this.biasInitializer),kernelRegularizer:qs(this.kernelRegularizer),recurrentRegularizer:qs(this.recurrentRegularizer),biasRegularizer:qs(this.biasRegularizer),activityRegularizer:qs(this.activityRegularizer),kernelConstraint:vA(this.kernelConstraint),recurrentConstraint:vA(this.recurrentConstraint),biasConstraint:vA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}la.className="SimpleRNNCell",s.m7h.registerClass(la);class ma extends sa{constructor(e){e.cell=new la(e),super(e)}call(e,t){return(0,s.lub)((()=>{null!=this.cell.dropoutMask&&(s.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,o=null==t?null:t.training,A=null==t?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:A})}))}static fromConfig(e,t){return new e(t)}}ma.className="SimpleRNN",s.m7h.registerClass(ma);class pa extends aa{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Yo("GRUCell does not support reset_after parameter set to true.");this.units=e.units,GA(this.units,"units"),this.activation=js(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=js(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=qi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Bs(e.kernelRegularizer),this.recurrentRegularizer=Bs(e.recurrentRegularizer),this.biasRegularizer=Bs(e.biasRegularizer),this.kernelConstraint=KA(e.kernelConstraint),this.recurrentConstraint=KA(e.recurrentConstraint),this.biasConstraint=KA(e.biasConstraint),this.dropout=WA([1,_A([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=WA([1,_A([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=Ni(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,s.lub)((()=>{if(2!==(e=e).length)throw new Yo(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ia({ones:()=>s.JpU(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ia({ones:()=>s.JpU(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const A=this.dropoutMask,i=this.recurrentDropoutMask;let r,a,l;0<this.dropout&&this.dropout<1&&(e=s.dC7(e,A[0]));let m=Ai(e,this.kernel.read());this.useBias&&(m=ai(m,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=s.dC7(o,i[0]));const p=this.recurrentKernel.read(),[h,u]=s.Vl2(p,[2*this.units,this.units],p.rank-1),c=Ai(o,h),[d,I,G]=s.Vl2(m,3,m.rank-1),[E,k]=s.Vl2(c,2,c.rank-1);r=this.recurrentActivation.apply(s.IHx(d,E)),a=this.recurrentActivation.apply(s.IHx(I,k));const g=Ai(s.dC7(a,o),u);l=this.activation.apply(s.IHx(G,g));const f=s.IHx(s.dC7(r,o),s.dC7(s.IHx(1,s.W76(r)),l));return[f,f]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Js(this.activation),recurrentActivation:Js(this.recurrentActivation),useBias:this.useBias,kernelInitializer:bi(this.kernelInitializer),recurrentInitializer:bi(this.recurrentInitializer),biasInitializer:bi(this.biasInitializer),kernelRegularizer:qs(this.kernelRegularizer),recurrentRegularizer:qs(this.recurrentRegularizer),biasRegularizer:qs(this.biasRegularizer),activityRegularizer:qs(this.activityRegularizer),kernelConstraint:vA(this.kernelConstraint),recurrentConstraint:vA(this.recurrentConstraint),biasConstraint:vA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}pa.className="GRUCell",s.m7h.registerClass(pa);class ha extends sa{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new pa(e),super(e)}call(e,t){return(0,s.lub)((()=>{null!=this.cell.dropoutMask&&(s.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,o=null==t?null:t.training,A=null==t?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:A})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}ha.className="GRU",s.m7h.registerClass(ha);class ua extends aa{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,GA(this.units,"units"),this.activation=js(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=js(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=qi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Bs(e.kernelRegularizer),this.recurrentRegularizer=Bs(e.recurrentRegularizer),this.biasRegularizer=Bs(e.biasRegularizer),this.kernelConstraint=KA(e.kernelConstraint),this.recurrentConstraint=KA(e.recurrentConstraint),this.biasConstraint=KA(e.biasConstraint),this.dropout=WA([1,_A([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=WA([1,_A([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=Ni(e))[e.length-1];let o;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;o=new((t=class extends ui{apply(t,o){const A=e.apply([n]),i=(new di).apply([n]),r=e.apply([2*n]);return ti(ti(A,i),r)}}).className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return(0,s.lub)((()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new Yo(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const A=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ia({ones:()=>s.JpU(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ia({ones:()=>s.JpU(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,r=this.recurrentDropoutMask;let a,l,m,p;0<this.dropout&&this.dropout<1&&(e=s.dC7(e,i[0]));let h=Ai(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=s.dC7(o,r[0])),h=s.IHx(h,Ai(o,this.recurrentKernel.read())),this.useBias&&(h=ai(h,this.bias.read()));const[u,c,d,I]=s.Vl2(h,4,h.rank-1);a=this.recurrentActivation.apply(u),l=this.recurrentActivation.apply(c),m=s.IHx(s.dC7(l,A),s.dC7(a,this.activation.apply(d))),p=this.recurrentActivation.apply(I);const G=s.dC7(p,this.activation.apply(m));return[G,G,m]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Js(this.activation),recurrentActivation:Js(this.recurrentActivation),useBias:this.useBias,kernelInitializer:bi(this.kernelInitializer),recurrentInitializer:bi(this.recurrentInitializer),biasInitializer:bi(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:qs(this.kernelRegularizer),recurrentRegularizer:qs(this.recurrentRegularizer),biasRegularizer:qs(this.biasRegularizer),activityRegularizer:qs(this.activityRegularizer),kernelConstraint:vA(this.kernelConstraint),recurrentConstraint:vA(this.recurrentConstraint),biasConstraint:vA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}ua.className="LSTMCell",s.m7h.registerClass(ua);class ca extends sa{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ua(e),super(e)}call(e,t){return(0,s.lub)((()=>{null!=this.cell.dropoutMask&&(s.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,o=null==t?null:t.training,A=null==t?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:A})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}ca.className="LSTM",s.m7h.registerClass(ca);class da extends aa{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return(0,s.lub)((()=>{let n=(e=e).slice(1);const o=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?o.push(n.splice(0,e.stateSize.length)):o.push(n.splice(0,1));o.reverse();const A=[];let i;for(let r=0;r<this.cells.length;++r){const s=this.cells[r];n=o[r],i=0===r?[e[0]].concat(n):[i[0]].concat(n),i=s.call(i,t),A.push(i.slice(1))}n=[];for(const e of A.slice().reverse())n.push(...e);return[i[0]].concat(n)}))}build(e){let t;Li(e)&&(e=e[0]),e=e,this.cells.forEach(((n,o)=>{NA(`RNNCell_${o}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign({},e,t)}static fromConfig(e,t,n={}){const o=[];for(const e of t.cells)o.push(mr(e,n));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Pi(e)}setWeights(e){const t=[];for(const n of this.cells){const o=n.weights.length,A=e.splice(o);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],A[e]])}Ui(t)}}function Ia(e){const{ones:t,rate:n,training:o=!1,count:A=1,dropoutFunc:i}=e,r=()=>null!=i?i(t(),n):li(t(),n),a=()=>mi(r,t,o);return!A||A<=1?s.CnY(a().clone()):Array(A).fill(void 0).map(a).map((e=>s.CnY(e.clone())))}da.className="StackedRNNCells",s.m7h.registerClass(da);class Ga extends sa{constructor(e){if(e.unroll)throw new $o("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new $o("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Vi({ndim:5})]}call(e,t){return s.lub((()=>{if(null!=this.cell.dropoutMask&&(s.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Yo("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,o=null==t?null:t.training,A=null==t?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:A})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return s.lub((()=>{const{stateSize:t}=this.cell,n=e.shape,o=this.computeSingleOutputShape(n),A=[o[0],...o.slice(2)],i=s.lls(A);return Array.isArray(t)?Array(t.length).fill(i):[i]}))}resetStates(e,t=!1){s.lub((()=>{if(!this.stateful)throw new Qo("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),A=[o[0],...o.slice(2)];if(null==n[0])throw new Yo("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>s.lls(A))):this.states_=[s.lls(A)];else if(null==e)s.B90(this.states_),null!=this.keptStates&&(s.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>s.lls(A))):this.states_[0]=s.lls(A);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Yo(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):s.B90(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],o=A;if(!s.D5U.arraysEqual(n.shape,o))throw new Yo(`State ${t} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>s.CnY(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:o,padding:A,strides:i,dilationRate:r}=this.cell,s="channelsFirst"===t,a=e[s?3:2],l=e[s?4:3],m=Os(a,o[0],A,i[0],r[0]),p=Os(l,o[1],A,i[1],r[1]);return[...e.slice(0,2),...s?[n,m,p]:[m,p,n]]}}Ga.className="ConvRNN2D";class Ea extends ua{constructor(e){const{filters:t,kernelSize:n,strides:o,padding:A,dataFormat:i,dilationRate:r}=e;super(Object.assign({},e,{units:t})),this.filters=t,GA(this.filters,"filters"),this.kernelSize=Rs(n,2,"kernelSize"),this.kernelSize.forEach((e=>GA(e,"kernelSize"))),this.strides=Rs(o||1,2,"strides"),this.strides.forEach((e=>GA(e,"strides"))),this.padding=A||"valid",LA(this.padding),this.dataFormat=i||"channelsLast",MA(this.dataFormat),this.dilationRate=Rs(r||1,2,"dilationRate"),this.dilationRate.forEach((e=>GA(e,"dilationRate")))}build(e){var t;e=Ni(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Yo(`The channel dimension of the input should be defined. Found ${e[n]}`);const o=e[n],A=this.kernelSize.concat([o,4*this.filters]);this.kernel=this.addWeight("kernel",A,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,o=this.filters;e=new((t=class extends ui{apply(e,t){return ei([n.apply([o]),s.iUs([o]),n.apply([2*o])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return s.lub((()=>{if(3!==e.length)throw new Yo(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,o=e[0],A=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ia({ones:()=>s.JpU(o),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=(e,t,n)=>t&&t[n]?s.dC7(t[n],e):e;let l=a(o,r,0),m=a(o,r,1),p=a(o,r,2),h=a(o,r,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ia({ones:()=>s.JpU(A),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const u=this.recurrentDropoutMask;let c=a(A,u,0),d=a(A,u,1),I=a(A,u,2),G=a(A,u,3);const[E,k,g,f]=s.Vl2(this.kernel.read(),4,3),[H,F,C,D]=this.useBias?s.Vl2(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,E,H,this.padding),m=this.inputConv(m,k,F,this.padding),p=this.inputConv(p,g,C,this.padding),h=this.inputConv(h,f,D,this.padding);const[J,v,j,K]=s.Vl2(this.recurrentKernel.read(),4,3);c=this.recurrentConv(c,J),d=this.recurrentConv(d,v),I=this.recurrentConv(I,j),G=this.recurrentConv(G,K);const y=this.recurrentActivation.apply(s.IHx(l,c)),b=this.recurrentActivation.apply(s.IHx(m,d)),q=s.IHx(s.dC7(b,i),s.dC7(y,this.activation.apply(s.IHx(p,I)))),x=s.dC7(this.recurrentActivation.apply(s.IHx(h,G)),this.activation.apply(q));return[x,x,q]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var A=0;for(o=Object.getOwnPropertySymbols(e);A<o.length;A++)t.indexOf(o[A])<0&&Object.prototype.propertyIsEnumerable.call(e,o[A])&&(n[o[A]]=e[o[A]])}return n}(e,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,o)}inputConv(e,t,n,o){const A=s.Tek(e,t,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?ai(A,n,this.dataFormat):A}recurrentConv(e,t){return s.Tek(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Ea.className="ConvLSTM2DCell",s.m7h.registerClass(Ea);class ka extends Ga{constructor(e){const t=new Ea(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}ka.className="ConvLSTM2D",s.m7h.registerClass(ka);class ga extends Qi{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,o=this.getNoiseShape(n);return mi((()=>li(n,this.rate,o,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}ga.className="Dropout",s.m7h.registerClass(ga);class fa extends ga{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}fa.className="SpatialDropout1D",s.m7h.registerClass(fa);class Ha extends Qi{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,GA(this.units,"units"),this.activation=js(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=qi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=qi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=KA(e.kernelConstraint),this.biasConstraint=KA(e.biasConstraint),this.kernelRegularizer=Bs(e.kernelRegularizer),this.biasRegularizer=Bs(e.biasRegularizer),this.activityRegularizer=Bs(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=Ni(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=Ni(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e),o=kA(this.activation.getClassName());let A;return null!=o?A=Ai(n,this.kernel.read(),o,this.bias?this.bias.read():null):(A=Ai(n,this.kernel.read()),null!=this.bias&&(A=ai(A,this.bias.read())),null!=this.activation&&(A=this.activation.apply(A))),A}))}getConfig(){const e={units:this.units,activation:Js(this.activation),useBias:this.useBias,kernelInitializer:bi(this.kernelInitializer),biasInitializer:bi(this.biasInitializer),kernelRegularizer:qs(this.kernelRegularizer),biasRegularizer:qs(this.biasRegularizer),activityRegularizer:qs(this.activityRegularizer),kernelConstraint:vA(this.kernelConstraint),biasConstraint:vA(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Ha.className="Dense",s.m7h.registerClass(Ha);class Fa extends Qi{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ni(e);for(const t of e.slice(1))if(null==t)throw new Yo(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],VA(e,1)]}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);let n=Ti(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=(0,s.p4s)(n,e)}return function(e){if(e.rank<=1)throw new Yo(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],VA(e.shape,1)];return s.XLQ(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Fa.className="Flatten",s.m7h.registerClass(Fa);class Ca extends Qi{constructor(e){super(e),this.supportsMasking=!0,this.activation=js(e.activation)}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e);return this.activation.apply(n)}))}getConfig(){const e={activation:Js(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Ca.className="Activation",s.m7h.registerClass(Ca);class Da extends Qi{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return(0,s.lub)((()=>{return e=Ti(e),t=e,n=this.n,(0,s.lub)((()=>{if(2!==t.shape.length)throw new Yo(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return ni(QA(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Da.className="RepeatVector",s.m7h.registerClass(Da);class Ja extends Qi{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",o=t.slice();let A=1,i=null;for(let e=0;e<o.length;++e){const t=o[e];if(this.isUnknown(t)){if(null!==i)throw new Yo("Can only specifiy one unknown dimension.");i=e}else A*=t}const r=VA(e);if(null!==i){if(0===A||r%A!=0)throw new Yo(n);o[i]=r/A}else if(r!==A)throw new Yo(n);return o}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e),o=n.shape,A=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return(0,s.XLQ)(n,A)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Ja.className="Reshape",s.m7h.registerClass(Ja);class va extends Qi{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=zA(1,e.dims.length+1);if(!s.D5U.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Vi({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=Ni(e)).slice();return this.dims.forEach(((n,o)=>{t[o+1]=e[n]})),t}call(e,t){return(0,s.p4s)(Ti(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}va.className="Permute",s.m7h.registerClass(va);class ja extends Qi{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Ti(e);return(0,s.YjB)((0,s.Quu)(n,this.maskValue),-1)}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e),o=(0,s.YjB)((0,s.Quu)(n,this.maskValue),-1,!0);return(0,s.dC7)(n,(0,s.pju)(o,n.dtype))}))}}ja.className="Masking",s.m7h.registerClass(ja);class Ka extends Qi{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(iA(e.inputLength))}this.inputDim=e.inputDim,GA(this.inputDim,"inputDim"),this.outputDim=e.outputDim,GA(this.outputDim,"outputDim"),this.embeddingsInitializer=qi(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Bs(e.embeddingsRegularizer),this.activityRegularizer=Bs(e.activityRegularizer),this.embeddingsConstraint=KA(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return(0,s.lub)((()=>this.maskZero?(e=Ti(e),(0,s.Quu)(e,(0,s.P84)(e))):null))}computeOutputShape(e){if(e=Ni(e),null==this.inputLength)return[...e,this.outputDim];const t=iA(this.inputLength);if(t.length!==e.length-1)throw new Yo(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let o=0;o<t.length;++o){const A=t[o],i=e[o+1];if(null!=A&&null!=i&&A!==i)throw new Yo(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==A&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);let n=Ti(e);"int32"!==n.dtype&&(n=XA(n,"int32"));const o=ii(this.embeddings.read(),(0,s.XLQ)(n,[n.size]));return(0,s.XLQ)(o,Ni(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:bi(this.embeddingsInitializer),embeddingsRegularizer:qs(this.embeddingsRegularizer),activityRegularizer:qs(this.activityRegularizer),embeddingsConstraint:vA(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Ka.className="Embedding",s.m7h.registerClass(Ka);class ya extends Qi{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new $o}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){const A=e[e.length-t.length+o],i=t[o];if(null==A||null==i||A<0||i<0)n.push(null);else if(1===A)n.push(i);else if(1===i)n.push(A);else{if(A!==i)throw new Yo("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(A)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ni(e)]),(e=e).length<2)throw new Yo(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=uA(t),t.length>1)throw new Yo(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const o=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}const o=e.map((e=>e.length));-1===e.indexOf(null)&&1===uA(o).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return(0,s.lub)((()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const o=_A(n);for(let n of e){const e=n.rank;for(let t=0;t<o-e;++t)n=QA(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const o of e){const e=o.rank;if(null==e){const e=o.shape,A=e[0],i=e.slice(1).concat([A]);let r=s.XLQ(o,[A].concat(VA(e.slice(1))));r=s.p4s(r,[1,0]),r=s.XLQ(r,i),t.push(r),n=!0}else if(e>1){const A=zA(1,e).concat([0]);t.push(s.p4s(o,A)),n=!0}else t.push(o)}let o=this.mergeFunction(t);const A=o.rank;if(n)if(null==A){const e=o.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));o=s.XLQ(s.p4s(s.XLQ(o,[-1,t]),[1,0]),n)}else if(A>1){const e=[A-1].concat(zA(0,A-1));o=s.p4s(o,e)}return o}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const o=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,o)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=uA(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return s.lub((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Yo("`mask` should be an Array");if(!Array.isArray(e))throw new Yo("`inputs` should be an Array");if(t.length!==e.length)throw new Yo(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:s.dt4(e,0))))[0];for(let e=1;e<t.length-1;++e)n=s.HvI(n,t[e]);return n}))}}class ba extends ya{constructor(e){super(e)}mergeFunction(e){return(0,s.lub)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.IHx(t,e[n]);return t}))}}ba.className="Add",s.m7h.registerClass(ba);class qa extends ya{constructor(e){super(e)}mergeFunction(e){return(0,s.lub)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.dC7(t,e[n]);return t}))}}qa.className="Multiply",s.m7h.registerClass(qa);class xa extends ya{constructor(e){super(e)}mergeFunction(e){return(0,s.lub)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.IHx(t,e[n]);return s.dC7(1/e.length,t)}))}}xa.className="Average",s.m7h.registerClass(xa);class Ba extends ya{constructor(e){super(e)}mergeFunction(e){return(0,s.lub)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=s.gWQ(t,e[n]);return t}))}}Ba.className="Maximum",s.m7h.registerClass(Ba);class wa extends ya{constructor(e){super(e)}mergeFunction(e){return(0,s.lub)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=s.LTh(t,e[n]);return t}))}}wa.className="Minimum",s.m7h.registerClass(wa);class Ma extends ya{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Yo("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const o=e[t].slice();o.splice(this.axis,1);let A=!1;for(const e of n)if(s.D5U.arraysEqual(e,o)){A=!0;break}A||n.push(o)}if(n.length>1)throw new Yo("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,s.lub)((()=>ei(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Yo("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[o]||null==e[o]){n[o]=null;break}n[o]+=e[o]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Yo("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Yo("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Yo(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return s.lub((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const o=[];for(let n=0;n<e.length;++n)null==t[n]?o.push(s.pju(s.JpU(e[n]),"bool")):t[n].rank<e[n].rank?o.push(s.dt4(t[n],-1)):o.push(t[n]);const A=s.zoF(o,this.axis);return s.$6P(A,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function La(e,t){for(;e<0;)e+=t;return e}Ma.className="Concatenate",s.m7h.registerClass(Ma);class Sa extends ya{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){s.D5U.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new $o("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(t,n);if(t[o[0]]!==n[o[1]])throw new Yo(`Dimension incompatibility: ${t[o[0]]} !== ${n[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Yo(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],o=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>La(t,e[n].shape.length))):[La(this.axes,n.shape.length),La(this.axes,o.shape.length)],this.normalize&&(n=pr(n,t[0]),o=pr(o,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new $o("batchDot is not implemented for tensors of 4D or higher rank yet");if(s.D5U.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),s.D5U.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new $o("batchDot is not implemented for complex64-type Tensors yet.");const o=e.shape.length,A=t.shape.length;null==n&&(n=[o-1,A-2]);const i=n;return s.lub((()=>{let n,r;if(o>A){n=o-A;const e=[];for(let t=0;t<n;++t)e.push(1);t=s.XLQ(t,t.shape.concat(e))}else if(A>o){n=A-o;const t=[];for(let e=0;e<n;++e)t.push(1);e=s.XLQ(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)r=i[0]===i[1]?s.Smz(s.dC7(e,t),i[0]):s.Smz(s.dC7(s.p4s(e,[1,0]),t),i[1]);else{const n=i[0]!==e.shape.length-1,o=i[1]===t.shape.length-1;r=s.OI3(e,t,n,o)}if(n>0){let e;e=o>A?o+A-3:o-1;const t=[];for(let o=e;o<e+n;++o)t.push(o);r=s.L9e(r,t)}return 1===r.shape.length&&(r=s.dt4(r,1)),r}))}(n,o,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[La(this.axes,e.length),La(this.axes,t.length)],n}computeOutputShape(e){s.D5U.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new $o("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(t,n);t.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);const A=t.concat(n);return 1===A.length&&A.push(1),A}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Sa.className="Dot",s.m7h.registerClass(Sa);class Ta extends Qi{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e);return mi((()=>(0,s.IHx)(oi(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}Ta.className="GaussianNoise",s.m7h.registerClass(Ta);class Na extends Qi{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t);const n=Ti(e);return this.rate>0&&this.rate<1?mi((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return(0,s.dC7)(n,oi(n.shape,1,e))}),(()=>n),t.training||!1):n}))}}Na.className="GaussianDropout",s.m7h.registerClass(Na);class Ra extends Qi{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ti(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,s.lub)((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return mi((()=>{const t=Ti(e),o=-1.7580993408473766;let A=(0,s.brS)((0,s.LGj)(n),this.rate);A=XA(A,"float32");const i=((1-this.rate)*(1+this.rate*o**2))**-.5,r=-i*o*this.rate,a=(0,s.IHx)((0,s.dC7)(t,A),(0,s.dC7)((0,s.IHx)(A,-1),o));return(0,s.IHx)((0,s.dC7)(a,i),r)}),(()=>Ti(e)),t.training||!1)}return e}))}}function Oa(e,t,n,o,A,i=.001){let r;if(2===e.rank)r=s.Dxk(e,t,n,o,A,i);else if(3===e.rank)r=s.JY5(e,t,n,o,A,i);else{if(4!==e.rank)throw new $o(`batchNormalization is not implemented for array of rank ${e.rank} yet`);r=s.p3b(e,t,n,o,A,i)}return r}Ra.className="AlphaDropout",s.m7h.registerClass(Ra);class Pa extends Qi{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=qi(e.betaInitializer||"zeros"),this.gammaInitializer=qi(e.gammaInitializer||"ones"),this.movingMeanInitializer=qi(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=qi(e.movingVarianceInitializer||"ones"),this.betaConstraint=KA(e.betaConstraint),this.gammaConstraint=KA(e.gammaConstraint),this.betaRegularizer=Bs(e.betaRegularizer),this.gammaRegularizer=Bs(e.gammaRegularizer)}build(e){e=Ni(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Yo(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Vi({ndim:e.length,axes:{[t]:n}})];const o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return(0,s.lub)((()=>{const n=null!=t.training&&t.training,o=Ti(e),A=o.shape,i=A.length,r=zA(0,i),a=this.axis>=0?this.axis:this.axis+i;r.splice(a,1);const l=tA(1,i);l[a]=A[a];const m=r.slice();m.sort();const p=!s.D5U.arraysEqual(m,zA(0,i).slice(0,i-1));if(!n)return(()=>{if(p){const e=(0,s.XLQ)(this.movingMean.read(),l),t=(0,s.XLQ)(this.movingVariance.read(),l),n=this.center?(0,s.XLQ)(this.beta.read(),l):null,A=this.scale?(0,s.XLQ)(this.gamma.read(),l):null;return Oa(o,e,t,n,A,this.epsilon)}return Oa(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,u,c]=function(e,t,n,o,A=.001){return s.D5U.arraysEqual(o.slice().sort(),zA(0,e.rank-1))?function(e,t,n,o,A=.001){return(0,s.lub)((()=>{const i=s.Gi7(e,o),r=i.mean,a=i.variance;return[Oa(e,r,a,n,t,A),r,a]}))}(e,t,n,o,A):function(e,t,n,o,A=.001){return(0,s.lub)((()=>{const i=s.Gi7(e,o),r=i.mean,a=i.variance,l=[];for(const t of zA(0,e.rank))-1!==o.indexOf(t)?l.push(1):l.push(e.shape[t]);const m=(0,s.XLQ)(r,l),p=(0,s.XLQ)(a,l),h=null==t?null:(0,s.XLQ)(t,l),u=null==n?null:(0,s.XLQ)(n,l);return[Oa(e,m,p,u,h,A),r,a]}))}(e,t,n,o,A)}(o,this.gamma.read(),this.beta.read(),r,this.epsilon),d=(e,t,n)=>{s.lub((()=>{const o=1-n,A=e.read(),i=s.dC7(s.luU(A,t),o);e.write(s.luU(A,i))}))};return(()=>{d(this.movingMean,u,this.momentum),d(this.movingVariance,c,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:bi(this.betaInitializer),gammaInitializer:bi(this.gammaInitializer),movingMeanInitializer:bi(this.movingMeanInitializer),movingVarianceInitializer:bi(this.movingVarianceInitializer),betaRegularizer:qs(this.betaRegularizer),gammaRegularizer:qs(this.gammaRegularizer),betaConstraint:vA(this.betaConstraint),gammaConstraint:vA(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Pa.className="BatchNormalization",s.m7h.registerClass(Pa);class Ua extends Qi{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=qi(e.betaInitializer||"zeros"),this.gammaInitializer=qi(e.gammaInitializer||"ones"),this.betaRegularizer=Bs(e.betaRegularizer),this.gammaRegularizer=Bs(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=Ni(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==uA(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){const n=Ti(e),o=n.shape,A=o.length;return(0,s.lub)((()=>{let{mean:e,variance:t}=(0,s.Gi7)(n,this.axis,!0);const i=tA(1,A);for(const e of this.axis)i[e]=o[e];const r=e=>null!=e&&e.shape.length!==A?s.XLQ(e,i):e;let a=r(this.gamma.read()),l=r(this.beta.read());const m=[],p=[];for(let e=0;e<A;++e)-1!==this.axis.indexOf(e)?(m.push(o[e]),p.push(1)):(m.push(1),p.push(o[e]));return e=s.Gg6(e,m),t=s.Gg6(t,m),a=s.Gg6(a,p),l=s.Gg6(l,p),Oa(n,e,t,l,a,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:bi(this.betaInitializer),gammaInitializer:bi(this.gammaInitializer),betaRegularizer:qs(this.betaRegularizer),gammaRegularizer:qs(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Ua.className="LayerNormalization",s.m7h.registerClass(Ua);class Va extends Qi{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Yo(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Yo(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Yo(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Vi({ndim:4})]}computeOutputShape(e){let t,n;return e=Ni(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return(0,s.lub)((()=>{return t=Ti(e),n=this.padding,o=this.dataFormat,(0,s.lub)((()=>{if(4!==t.rank)throw new Yo(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Yo("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==o&&(o="channelsLast"),"channelsLast"!==o&&"channelsFirst"!==o)throw new Yo(`Unknown data format: ${o}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===o?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],s.vku(t,e)}));var t,n,o}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Wa(e,t,n,o,A,i){return(0,s.lub)((()=>{let r;MA(A),SA(i),LA(o),null==n&&(n=[1,1]),null==o&&(o="valid"),null==A&&(A="channelsLast"),null==i&&(i="max"),e=Us(e,A);const a="same"===o?"same":"valid";return r="max"===i?s._sB(e,t,n,a):s.wS1(e,t,n,a),"channelsFirst"===A&&(r=s.p4s(r,[0,3,1,2])),r}))}function _a(e,t,n,o,A,i){return(0,s.lub)((()=>{let r;MA(A),SA(i),LA(o),null==n&&(n=[1,1,1]),null==o&&(o="valid"),null==A&&(A="channelsLast"),null==i&&(i="max"),e=Vs(e,A);const a="same"===o?"same":"valid";return r="max"===i?s.YQQ(e,t,n,a):s.uR5(e,t,n,a),"channelsFirst"===A&&(r=s.p4s(r,[0,4,1,2,3])),r}))}Va.className="ZeroPadding2D",s.m7h.registerClass(Va);class za extends Qi{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new Yo(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(GA(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new Yo(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}GA(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,LA(this.padding),this.inputSpec=[new Vi({ndim:3})]}computeOutputShape(e){const t=Os((e=Ni(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return(0,s.lub)((()=>{this.invokeCallHook(e,t),e=QA(Ti(e),2);const n=this.poolingFunction(Ti(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return s.L9e(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Xa extends za{constructor(e){super(e)}poolingFunction(e,t,n,o,A){return MA(A),LA(o),Wa(e,t,n,o,A,"max")}}Xa.className="MaxPooling1D",s.m7h.registerClass(Xa);class Qa extends za{constructor(e){super(e)}poolingFunction(e,t,n,o,A){return MA(A),LA(o),Wa(e,t,n,o,A,"avg")}}Qa.className="AveragePooling1D",s.m7h.registerClass(Qa);class Za extends Qi{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Yo(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];GA(this.poolSize,"poolSize"),GA(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,MA(this.dataFormat),LA(this.padding),this.inputSpec=[new Vi({ndim:4})]}computeOutputShape(e){e=Ni(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Os(t,this.poolSize[0],this.padding,this.strides[0]),n=Os(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return(0,s.lub)((()=>(this.invokeCallHook(e,t),this.poolingFunction(Ti(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Ya extends Za{constructor(e){super(e)}poolingFunction(e,t,n,o,A){return MA(A),LA(o),Wa(e,t,n,o,A,"max")}}Ya.className="MaxPooling2D",s.m7h.registerClass(Ya);class $a extends Za{constructor(e){super(e)}poolingFunction(e,t,n,o,A){return MA(A),LA(o),Wa(e,t,n,o,A,"avg")}}$a.className="AveragePooling2D",s.m7h.registerClass($a);class el extends Qi{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Yo(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];GA(this.poolSize,"poolSize"),GA(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,MA(this.dataFormat),LA(this.padding),this.inputSpec=[new Vi({ndim:5})]}computeOutputShape(e){e=Ni(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Os(t,this.poolSize[0],this.padding,this.strides[0]),n=Os(n,this.poolSize[1],this.padding,this.strides[1]),o=Os(o,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,o]:[e[0],t,n,o,e[4]]}call(e,t){return(0,s.lub)((()=>(this.invokeCallHook(e,t),this.poolingFunction(Ti(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class tl extends el{constructor(e){super(e)}poolingFunction(e,t,n,o,A){return MA(A),LA(o),_a(e,t,n,o,A,"max")}}tl.className="MaxPooling3D",s.m7h.registerClass(tl);class nl extends el{constructor(e){super(e)}poolingFunction(e,t,n,o,A){return MA(A),LA(o),_a(e,t,n,o,A,"avg")}}nl.className="AveragePooling3D",s.m7h.registerClass(nl);class ol extends Qi{constructor(e){super(e),this.inputSpec=[new Vi({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new $o}}class Al extends ol{constructor(e){super(e||{})}call(e,t){return(0,s.lub)((()=>{const t=Ti(e);return s.J69(t,1)}))}}Al.className="GlobalAveragePooling1D",s.m7h.registerClass(Al);class il extends ol{constructor(e){super(e||{})}call(e,t){return(0,s.lub)((()=>{const t=Ti(e);return s.Fp7(t,1)}))}}il.className="GlobalMaxPooling1D",s.m7h.registerClass(il);class rl extends Qi{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,MA(this.dataFormat),this.inputSpec=[new Vi({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new $o}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class sl extends rl{call(e,t){return(0,s.lub)((()=>{const t=Ti(e);return"channelsLast"===this.dataFormat?s.J69(t,[1,2]):s.J69(t,[2,3])}))}}sl.className="GlobalAveragePooling2D",s.m7h.registerClass(sl);class al extends rl{call(e,t){return(0,s.lub)((()=>{const t=Ti(e);return"channelsLast"===this.dataFormat?s.Fp7(t,[1,2]):s.Fp7(t,[2,3])}))}}al.className="GlobalMaxPooling2D",s.m7h.registerClass(al);class ll extends Qi{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const o=mr(t.layer,n);delete t.layer;const A={layer:o};return Object.assign(A,t),new e(A)}}class ml extends ll{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Ni(e)).length<3)throw new Yo(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=Ni(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),o=e[1];return[n[0],o].concat(n.slice(1))}call(e,t){return(0,s.lub)((()=>ra(((e,n)=>[Ti(this.layer.call(e,t)),[]]),e=Ti(e),[],!1,null,null,!1,!0)[1]))}}ml.className="TimeDistributed",s.m7h.registerClass(ml);class pl extends ll{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=mr(n),t.goBackwards=!0!==t.goBackwards;const o={};var A;if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=mr(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,A=this.mergeMode,dA(BA,"BidirectionalMergeMode",A),e.weights)throw new $o("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,o,A=this.forwardLayer.computeOutputShape(e);return Array.isArray(A)&&Array.isArray(A[0])||(A=[A]),A=A,this.returnState?(o=A.slice(1),t=A[0]):t=A[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(o).concat(o.slice()):[t].concat(o).concat(o.slice()):AA(n)}apply(e,t){let n=null==t?null:t.initialState,o=null==t?null:t.constants;null==t&&(t={});const A=ia(e,n,o,this.numConstants);if(e=A.inputs,n=A.initialState,o=A.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==o)return super.apply(e,t);const i=[],r=[];if(null!=n){const e=n.length;if(e%2>0)throw new Yo("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);const o=n.map((e=>new Vi({shape:e.shape})));this.forwardLayer.stateSpec=o.slice(0,e/2),this.backwardLayer.stateSpec=o.slice(e/2),r.push(...o)}if(null!=o)throw new $o("Support for constants in Bidirectional layers is not implemented yet.");const s=i[0]instanceof Wi;for(const e of i)if(e instanceof Wi!==s)throw new Yo("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(s){const n=[e].concat(i),o=this.inputSpec.concat(r),A=this.inputSpec;this.inputSpec=o;const s=super.apply(n,t);return this.inputSpec=A,s}return super.apply(e,t)}call(e,t){return(0,s.lub)((()=>{const n=t.initialState;let o,A,i,r;if(null==n)o=this.forwardLayer.call(e,t),A=this.backwardLayer.call(e,t);else{const i=n.slice(0,n.length/2),r=n.slice(n.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:i})),A=this.backwardLayer.call(e,Object.assign(t,{initialState:r}))}return this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(A.slice(1))),o=o[0],A=A[0]),this.returnSequences&&(A=s.GYS(A,1)),"concat"===this.mergeMode?r=ei([o,A]):"sum"===this.mergeMode?r=s.IHx(o,A):"ave"===this.mergeMode?r=s.dC7(.5,s.IHx(o,A)):"mul"===this.mergeMode?r=s.dC7(o,A):null==this.mergeMode&&(r=[o,A]),this.returnState?null==this.mergeMode?r.concat(i):[r].concat(i):r}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){NA(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),NA(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=mr(t.layer);if(delete t.layer,null!=t.numConstants)throw new $o("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=t;return o.layer=n,new e(o)}}pl.className="Bidirectional",s.m7h.registerClass(pl);var hl,ul,cl=n(2766),dl=n(6377);function Il(e,t,n=new Map,o=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(o.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const A=t(e);if(A.recurse&&null!==A.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(A.recurse){if(gl(e)){const A=Array.isArray(e)?[]:{};o.add(e);for(const i in e){const r=Il(e[i],t,n,o);A[i]=r}return o.delete(e),e.__proto__&&(A.__proto__=e.__proto__),A}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,A.value),A.value}function Gl(e,t=kl){return El(e,t)}function El(e,t,n=new Set){const o=e[0];if(n.has(o))throw new Error("Circular references are not supported.");const A=t(e);if(A.recurse&&null!==A.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(A.recurse){if(gl(o)){const A=Array.isArray(o)?[]:{};n.add(o);for(const i in o){const o=El(e.map((e=>e[i])),t,n);A[i]=o}return n.delete(o),A}throw new Error(`Can't recurse into non-iterable type: ${o}`)}return A.value}function kl(e){return null===e?null:gl(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function gl(e){let t=!1;if(s.OBj().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:o}=n(4977);t=e instanceof o}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof s.esB)&&!(e instanceof Promise)&&!t)}function fl(e){return Il(e,Hl)}function Hl(e){return e instanceof s.esB?{value:e.clone(),recurse:!1}:gl(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class Fl{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class Cl extends Fl{constructor(){super(Cl.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}Cl.INITIAL_CAPACITY=32;class Dl{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Bl(this,e)}filter(e){return new ql(this,e)}map(e){return new xl(this,e)}mapAsync(e){return new wl(this,e)}serialMapAsync(e){return new wl(this,e).serial()}flatmap(e){return new Ll(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new bl(this,e,t)}columnMajorBatch(e,t=!0,n=kl){return this.rowMajorBatch(e,t).map((e=>Gl(e,n)))}concatenate(e,t){return new Sl(new Jl([this,e]),t)}take(e){return e<0||null==e?this:new yl(this,e)}skip(e){return e<0||null==e?this:new Kl(this,e)}prefetch(e){return new Tl(this,e)}shuffle(e,t){return new Nl(this,e,t)}serial(){return new jl(this)}}class Jl extends Dl{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:fl(e),done:!1}}}class vl extends Dl{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class jl extends Dl{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class Kl extends Dl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;s.B90(e.value)}return this.upstream.next()}}class yl extends Dl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class bl extends Dl{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class ql extends Dl{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;s.B90(e.value)}}}class xl extends Dl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=s.piX.getTensorsInContainer(e.value),n=this.transform(e.value),o=s.piX.getTensorsInContainer(n);for(const e of t)s.piX.isTensorInList(e,o)||e.dispose();return{value:n,done:!1}}}class Bl extends Dl{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class wl extends Dl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=s.piX.getTensorsInContainer(e.value),n=await this.transform(e.value),o=s.piX.getTensorsInContainer(n);for(const e of t)s.piX.isTensorInList(e,o)||e.dispose();return{value:n,done:!1}}}class Ml extends Dl{constructor(){super(),this.outputQueue=new Cl,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Ll extends Ml{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=s.piX.getTensorsInContainer(e.value),n=this.transform(e.value),o=s.piX.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const e of t)s.piX.isTensorInList(e,o)||e.dispose();return!0}}class Sl extends Dl{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}(ul=hl||(hl={}))[ul.FAIL=0]="FAIL",ul[ul.SHORTEST=1]="SHORTEST",ul[ul.LONGEST=2]="LONGEST";class Tl extends Dl{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Fl(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Nl extends Tl{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=dl.alea(n||s.D5U.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class Rl{constructor(){this.size=null}batch(e,t=!0){const n=this;let o;return s.D5U.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),o=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),Ol((async()=>(await n.iterator()).columnMajorBatch(e,t,Pl)),o)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,Ol((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,Ol((async()=>(await t.iterator()).filter((t=>s.lub((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Ol((async()=>(await t.iterator()).map((t=>s.lub((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return Ol((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Ol((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,Ol((async()=>{return n=(A=async()=>({value:await t.iterator(),done:!1}),new vl(A)).take(e),new Sl(n,o);var n,o,A}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,Ol((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const o=this,A=dl.alea(t||s.D5U.now().toString());return Ol((async()=>{let t=A.int32();return n&&(t+=A.int32()),(await o.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,Ol((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function Ol(e,t=null){return new class extends Rl{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Pl(e){if(null===e)return null;return null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof s.esB||s.D5U.isTypedArray(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof s.esB?s.knu(e):s.XeE(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}function Ul(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&s.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}Rl.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const Vl=s.GDt.ZA;class Wl extends s.Zuw{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new s.JLz(this,(0,s.SRH)())}nextDataId(){return Wl.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,(0,s.OBj)().get("IS_NODE")&&s.Wap.warn("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if("string"===t&&null!=n&&n.length>0&&s.D5U.isString(n[0])){const A=n.map((e=>s.D5U.encodeString(e)));o=this.write(A,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,o,A){this.data.set(e,{values:t,dtype:o,refCount:A})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return s.Wap.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>s.D5U.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,s.f3b)(e.shape,e.dtype,n)}makeOutput(e,t,n){const o=this.write(e,t,n);return(0,s.SRH)().makeTensorFromDataId(o,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=s.D5U.now();return e(),{kernelMs:s.D5U.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ul([e],"where");const t=this.readSync(e.dataId);return Vl(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function _l(e,t,n){return({inputs:o,attrs:A,backend:i})=>{const{x:r}=o;if(Ul(r,e),"string"===r.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(r.dataId).values,m=s.D5U.sizeFromShape(r.shape),p=n||r.dtype,h=s.D5U.getArrayFromDType(p,m);for(let e=0;e<m;++e)h[e]=t(l[e],A);return a.makeTensorInfo(r.shape,p,h)}}function zl(e,t,n){return({inputs:o,attrs:A,backend:i})=>{const{x:r}=o;if(Ul(r,e),"string"===r.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const s=i,a=s.data.get(r.dataId).values,l=n||r.dtype,m=t(a,l,A);return s.makeTensorInfo(r.shape,l,m)}}Wl.nextDataId=0,(0,s.jqO)("cpu",(()=>new Wl),1);const Xl=_l(s.SX0,(e=>e>=0?e:Math.exp(e)-1)),Ql={kernelName:s.SX0,backendName:"cpu",kernelFunc:Xl};function Zl(e){const{inputs:t,backend:n}=e,{x:o}=t;return n.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}const Yl={kernelName:s.iJz,backendName:"cpu",kernelFunc:Zl};function $l(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{alpha:i}=o;Ul([A],"leakyRelu");const r=s.D5U.sizeFromShape(A.shape),a=n.data.get(A.dataId).values,l=s.D5U.getTypedArrayFromDType("float32",r);for(let e=0;e<a.length;e++)l[e]=a[e]<0?i*a[e]:a[e];return n.makeTensorInfo(A.shape,"float32",l)}const em={kernelName:s.J$2,backendName:"cpu",kernelFunc:$l};function tm(e){return(t,n,o,A,i)=>{const r=s.Wap.assertAndGetBroadcastShape(t,n),a=r.length,l=s.D5U.computeStrides(r),m=s.D5U.sizeFromShape(r),p=s.D5U.getTypedArrayFromDType(i,m),h=t.length,u=n.length,c=s.D5U.computeStrides(t),d=s.D5U.computeStrides(n),I=s.Wap.getBroadcastDims(t,r),G=s.Wap.getBroadcastDims(n,r);if(I.length+G.length===0)for(let t=0;t<p.length;++t)p[t]=e(o[t%o.length],A[t%A.length]);else for(let t=0;t<p.length;++t){const n=s.D5U.indexToLoc(t,a,l),i=n.slice(-h);I.forEach((e=>i[e]=0));const r=s.D5U.locToIndex(i,h,c),m=n.slice(-u);G.forEach((e=>m[e]=0));const E=s.D5U.locToIndex(m,u,d);p[t]=e(o[r],A[E])}return[p,r]}}const nm=tm(((e,t)=>e<0?t*e:e));function om(e){const{inputs:t,backend:n}=e,{x:o,alpha:A}=t;Ul([o,A],"prelu");const i=n.data.get(o.dataId).values,r=n.data.get(A.dataId).values,[s,a]=nm(o.shape,A.shape,i,r,"float32");return n.makeTensorInfo(a,"float32",s)}const Am={kernelName:s.o0g,backendName:"cpu",kernelFunc:om},im=_l(s.qkr,(e=>Math.max(0,e))),rm={kernelName:s.qkr,backendName:"cpu",kernelFunc:im},sm=_l(s.SbG,(e=>Math.min(Math.max(0,e),6))),am={kernelName:s.SbG,backendName:"cpu",kernelFunc:sm};function lm(e){return(t,n,o)=>{const A=s.D5U.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)A[n]=e(t[n],o);return A}}const mm=lm((e=>1/(1+Math.exp(-e)))),pm=_l(s.a5O,(e=>1/(1+Math.exp(-e)))),hm={kernelName:s.a5O,backendName:"cpu",kernelFunc:pm};function um(e,t,n,o,A){if("linear"===n)return Zl({inputs:{x:t},backend:e});if("relu"===n)return im({inputs:{x:t},backend:e});if("elu"===n)return Xl({inputs:{x:t},backend:e});if("relu6"===n)return sm({inputs:{x:t},backend:e});if("prelu"===n)return om({inputs:{x:t,alpha:o},backend:e});if("leakyrelu"===n)return $l({inputs:{x:t},backend:e,attrs:{alpha:A}});if("sigmoid"===n)return pm({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function cm(e){const{inputs:t,backend:n}=e,{real:o,imag:A}=t,i=n.data.get(o.dataId).values,r=n.data.get(A.dataId).values,s=n.makeTensorInfo(o.shape,"complex64");return n.data.get(s.dataId).complexTensorInfos={real:n.makeTensorInfo(o.shape,"float32",i),imag:n.makeTensorInfo(A.shape,"float32",r)},s}const dm={kernelName:s.Zz9,backendName:"cpu",kernelFunc:cm};function Im(e,t,n="float32"){if("complex64"===n)return cm({inputs:{real:Im(e,t,"float32"),imag:Im(e,t,"float32")},backend:e});const o=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(t),n);return e.makeTensorInfo(t,n,o)}function Gm(e){const{inputs:t,backend:n}=e,{input:o}=t,A=n.data.get(o.dataId).complexTensorInfos.real,i=n.data.get(A.dataId).values;return n.makeTensorInfo(A.shape,A.dtype,i)}const Em={kernelName:s.xJR,backendName:"cpu",kernelFunc:Gm};function km(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{dtype:i}=o;if("complex64"===i){if("complex64"===A.dtype)return Zl({inputs:{x:A},backend:n});const e=Im(n,A.shape,A.dtype),t=km({inputs:{x:A},backend:n,attrs:{dtype:"float32"}}),o=cm({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),o}if("complex64"===A.dtype){const e=Gm({inputs:{input:A},backend:n}),t=km({inputs:{x:e},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(e),t}if(!s.D5U.hasEncodingLoss(A.dtype,i)){const e=Zl({inputs:{x:A},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i){const e=n.data.get(A.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(A.shape,"int32",t)}if("bool"===i){const e=n.data.get(A.dataId).values,t=s.D5U.toTypedArray([0],A.dtype),[o,i]=tm(((e,t)=>e!==t?1:0))(A.shape,[],e,t,"bool");return n.makeTensorInfo(i,"bool",o)}throw new Error(`Error in Cast: failed to cast ${A.dtype} to ${i}`)}const gm={kernelName:s.RFZ,backendName:"cpu",kernelFunc:km};function fm(e,t,n,o){return null==n?({inputs:n,backend:A})=>{const{a:i,b:r}=n,a=A;Ul([i,r],e);const l=a.data.get(i.dataId).values,m=a.data.get(r.dataId).values,p="string"===i.dtype?s.Wap.fromUint8ToStringArray(l):l,h="string"===i.dtype?s.Wap.fromUint8ToStringArray(m):m,u=o||i.dtype,[c,d]=t(i.shape,r.shape,p,h,u);return a.makeTensorInfo(d,u,c)}:({inputs:e,backend:A})=>{const{a:i,b:r}=e,s=A;if("complex64"===i.dtype||"complex64"===r.dtype){const e=km({inputs:{x:i},backend:s,attrs:{dtype:"complex64"}}),t=s.data.get(e.dataId),o=t.complexTensorInfos.real,A=t.complexTensorInfos.imag,a=s.data.get(o.dataId).values,l=s.data.get(A.dataId).values,m=km({inputs:{x:r},backend:s,attrs:{dtype:"complex64"}}),p=s.data.get(m.dataId),h=p.complexTensorInfos.real,u=p.complexTensorInfos.imag,c=s.data.get(h.dataId).values,d=s.data.get(u.dataId).values,[I,G,E]=n(i.shape,r.shape,a,l,c,d),k=s.makeTensorInfo(E,"float32",I),g=s.makeTensorInfo(E,"float32",G),f=cm({inputs:{real:k,imag:g},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(g),f}{const e=s.data.get(i.dataId).values,n=s.data.get(r.dataId).values,A=o||i.dtype,[a,l]=t(i.shape,r.shape,e,n,A);return s.makeTensorInfo(l,A,a)}}}function Hm(e){return(t,n,o,A,i,r)=>{const a=s.Wap.assertAndGetBroadcastShape(t,n),l=s.D5U.sizeFromShape(a),m=a.length,p=s.D5U.computeStrides(a),h=s.D5U.getTypedArrayFromDType("float32",l),u=s.D5U.getTypedArrayFromDType("float32",l),c=s.Wap.getBroadcastDims(t,a),d=s.Wap.getBroadcastDims(n,a),I=s.Wap.mergeRealAndImagArrays(o,A),G=s.Wap.mergeRealAndImagArrays(i,r),E=t.length,k=s.D5U.computeStrides(t),g=n.length,f=s.D5U.computeStrides(n);if(c.length+d.length===0)for(let t=0;t<h.length;t++){const n=t%I.length,o=t%G.length,A=e(I[2*n],I[2*n+1],G[2*o],G[2*o+1]);h[t]=A.real,u[t]=A.imag}else for(let t=0;t<h.length;t++){const n=s.D5U.indexToLoc(t,m,p),o=n.slice(-E);c.forEach((e=>o[e]=0));const A=s.D5U.locToIndex(o,E,k),i=n.slice(-g);d.forEach((e=>i[e]=0));const r=s.D5U.locToIndex(i,g,f),a=e(I[2*A],I[2*A+1],G[2*r],G[2*r+1]);h[t]=a.real,u[t]=a.imag}return[h,u,a]}}const Fm=tm(((e,t)=>e+t)),Cm=Hm(((e,t,n,o)=>({real:e+n,imag:t+o}))),Dm=fm(s.mm_,Fm,Cm),Jm={kernelName:s.mm_,backendName:"cpu",kernelFunc:Dm};function vm(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{shape:i}=o,r=s.D5U.sizeFromShape(A.shape),a=s.D5U.inferFromImplicitShape(i,r),l=s.D5U.sizeFromShape(a);s.D5U.assert(r===l,(()=>`The new shape (${a}) has ${l} elements and the old shape (${A.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(A.dataId);const m=n.data.get(A.dataId);if(null!=m.complexTensorInfos){const e=m.complexTensorInfos.real,t=m.complexTensorInfos.imag;e.shape=a,t.shape=a}return{dataId:A.dataId,shape:a,dtype:A.dtype}}const jm={kernelName:s.HZH,backendName:"cpu",kernelFunc:vm};function Km(e){const{inputs:t,backend:n,attrs:o}=e,{a:A,b:i}=t,{transposeA:r,transposeB:a}=o;Ul([A,i],"matMul");const l=A.shape.length,m=i.shape.length,p=r?A.shape[l-2]:A.shape[l-1],h=a?i.shape[m-1]:i.shape[m-2],u=r?A.shape[l-1]:A.shape[l-2],c=a?i.shape[m-2]:i.shape[m-1],d=A.shape.slice(0,-2),I=i.shape.slice(0,-2),G=s.D5U.sizeFromShape(d),E=s.D5U.sizeFromShape(I),k=G===E||1===G||1===E;s.D5U.assert(l>=2&&m>=2&&k,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${I}).`));const g=(G>E?A.shape.slice(0,-2):i.shape.slice(0,-2)).concat([u,c]);s.D5U.assert(p===h,(()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${A.shape} and ${i.shape} and transposeA=${r} and transposeB=${a} must match.`));const f=a?[E,c,h]:[E,h,c],H=vm({inputs:{x:A},backend:n,attrs:{shape:r?[G,p,u]:[G,u,p]}}),F=vm({inputs:{x:i},backend:n,attrs:{shape:f}}),C=r?H.shape[1]:H.shape[2],D=r?H.shape[2]:H.shape[1],J=a?F.shape[1]:F.shape[2],v=Math.max(G,E),j=n.data.get(H.dataId).values,K=n.data.get(F.dataId).values,y=s.D5U.computeStrides(H.shape),b=s.D5U.computeStrides(F.shape),[q,x,B]=r?[y[0],1,y[1]]:[y[0],y[1],1],[w,M,L]=a?[1,b[1],b[0]]:[b[1],1,b[0]],S=D*J,T=(0,s.f3b)([v,D,J],H.dtype),N=T.values,R=n.blockSize;for(let e=0;e<v;e++)for(let t=0;t<D;t+=R)for(let n=0;n<J;n+=R)for(let o=0;o<C;o+=R){const A=Math.min(t+R,D),i=Math.min(n+R,J),r=Math.min(o+R,C);for(let s=t;s<A;s++)for(let t=n;t<i;t++){let n=0;for(let A=o;A<r;A++){const o=Math.min(e,G-1)*q,i=Math.min(e,E-1)*L;n+=j[o+s*x+A*B]*K[A*w+t*M+i]}N[e*S+(s*J+t)]+=n}}return n.disposeIntermediateTensorInfo(H),n.disposeIntermediateTensorInfo(F),n.makeTensorInfo(g,T.dtype,T.values)}const ym={kernelName:s.XLW,backendName:"cpu",kernelFunc:Km},bm={kernelName:s.usg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{a:A,b:i,bias:r,preluActivationWeights:s}=t,{transposeA:a,transposeB:l,activation:m,leakyreluAlpha:p}=o;let h,u,c;const d=[];h=Km({inputs:{a:A,b:i},attrs:{transposeA:a,transposeB:l},backend:n}),r&&(u=Dm({inputs:{a:h,b:r},backend:n}),d.push(h),h=u),m&&(c=um(n,h,m,s,p),d.push(h),h=c);for(const e of d)n.disposeIntermediateTensorInfo(e);return h}};function qm(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const xm={kernelName:s.SYM,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;Ul(t,"abs");let o=new Float32Array(s.D5U.sizeFromShape(t.shape));return o=qm(n.data.get(t.dataId).values),n.makeOutput(o,t.shape,t.dtype)}},Bm=_l(s.VGw,(e=>Math.acos(e))),wm={kernelName:s.VGw,backendName:"cpu",kernelFunc:Bm},Mm=_l(s.SpW,(e=>Math.acosh(e))),Lm={kernelName:s.SpW,backendName:"cpu",kernelFunc:Mm},Sm={kernelName:s.Xze,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,o=t;Ul(t,"addN");const A=o.map((e=>n.data.get(e.dataId).values)),i=(0,s.f3b)(o[0].shape,o[0].dtype),r=i.values;for(let e=0;e<o.length;e++){const t=A[e];for(let e=0;e<r.length;e++)r[e]+=t[e]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function Tm(e,t,n,o,A){const i=t.length,r=s.D5U.sizeFromShape(t),a=s.D5U.computeStrides(t),l=s.D5U.computeStrides(A),m=s.D5U.getTypedArrayFromDType(n,s.D5U.sizeFromShape(A));for(let t=0;t<r;++t){const n=s.D5U.indexToLoc(t,i,a),A=new Array(n.length);for(let e=0;e<A.length;e++)A[e]=n[o[e]];m[s.D5U.locToIndex(A,i,l)]=e[t]}return m}function Nm(e){const{inputs:t,attrs:n,backend:o}=e,{x:A}=t,{perm:i}=n;Ul(A,"transpose");const r=A.shape.length,s=new Array(r);for(let e=0;e<s.length;e++)s[e]=A.shape[i[e]];const a=Tm(o.data.get(A.dataId).values,A.shape,A.dtype,i,s);return{dataId:o.write(a,s,A.dtype),shape:s,dtype:A.dtype}}const Rm={kernelName:s.G3Y,backendName:"cpu",kernelFunc:Nm},Om={kernelName:s.oT6,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o;Ul(A,"all");const a=s.D5U.parseAxisParam(i,A.shape);let l=a;const m=s.Wap.getAxesPermutation(l,A.shape.length);let p=A;null!=m&&(p=Nm({inputs:{x:A},backend:n,attrs:{perm:m}}),l=s.Wap.getInnerMostAxes(l.length,A.shape.length)),s.Wap.assertAxesAreInnerMostDims("all",l,p.shape.length);const[h,u]=s.Wap.computeOutAndReduceShapes(p.shape,l),c=s.D5U.sizeFromShape(u),d=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(h),p.dtype),I=n.data.get(p.dataId).values;for(let e=0;e<d.length;++e){const t=e*c;let n=I[t];for(let e=0;e<c;++e){const o=I[t+e];n=n&&o}d[e]=n}null!=m&&n.disposeIntermediateTensorInfo(p);const G=n.makeTensorInfo(h,p.dtype,d);if(r){const e=vm({inputs:{x:G},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(h,a)}});return n.disposeIntermediateTensorInfo(G),e}return G}},Pm={kernelName:s.IKK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o;Ul(A,"any");const a=s.D5U.parseAxisParam(i,A.shape);let l=a;const m=s.Wap.getAxesPermutation(l,A.shape.length);let p=A;null!=m&&(p=Nm({inputs:{x:A},backend:n,attrs:{perm:m}}),l=s.Wap.getInnerMostAxes(l.length,A.shape.length)),s.Wap.assertAxesAreInnerMostDims("any",l,p.shape.length);const[h,u]=s.Wap.computeOutAndReduceShapes(p.shape,l),c=s.D5U.sizeFromShape(u),d=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(h),p.dtype),I=n.data.get(p.dataId).values;for(let e=0;e<d.length;++e){const t=e*c;let n=I[t];for(let e=0;e<c;++e){const o=I[t+e];n=n||o}d[e]=n}null!=m&&n.disposeIntermediateTensorInfo(p);const G=n.makeTensorInfo(h,p.dtype,d);if(r){const e=vm({inputs:{x:G},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(h,a)}});return n.disposeIntermediateTensorInfo(G),e}return G}},Um={kernelName:s.sJF,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i}=o;Ul(A,"argMax");let r=s.D5U.parseAxisParam(i,A.shape);const a=s.Wap.getAxesPermutation(r,A.shape.length);let l=A;const m=[];null!=a&&(l=Nm({inputs:{x:A},backend:n,attrs:{perm:a}}),m.push(l),r=s.Wap.getInnerMostAxes(r.length,l.shape.length)),r=[r[0]],s.Wap.assertAxesAreInnerMostDims("argMax",r,l.shape.length);const[p,h]=s.Wap.computeOutAndReduceShapes(l.shape,r),u=s.D5U.sizeFromShape(p),c=s.D5U.makeZerosTypedArray(u,"int32"),d=s.D5U.sizeFromShape(h),I=n.data.get(l.dataId).values;for(let e=0;e<c.length;++e){const t=e*d;let n=I[t],o=0;for(let e=0;e<d;++e){const A=I[t+e];A>n&&(n=A,o=e)}c[e]=o}return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",c)}},Vm={kernelName:s.aJk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i}=o;Ul(A,"argMin");let r=s.D5U.parseAxisParam(i,A.shape);const a=s.Wap.getAxesPermutation(r,A.shape.length);let l=A;const m=[];null!=a&&(l=Nm({inputs:{x:A},backend:n,attrs:{perm:a}}),m.push(l),r=s.Wap.getInnerMostAxes(r.length,l.shape.length)),r=[r[0]],s.Wap.assertAxesAreInnerMostDims("argMin",r,l.shape.length);const[p,h]=s.Wap.computeOutAndReduceShapes(l.shape,r),u=s.D5U.sizeFromShape(p),c=s.D5U.makeZerosTypedArray(u,"int32"),d=s.D5U.sizeFromShape(h),I=n.data.get(l.dataId).values;for(let e=0;e<c.length;++e){const t=e*d;let n=I[t],o=0;for(let e=0;e<d;++e){const A=I[t+e];A<n&&(n=A,o=e)}c[e]=o}return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",c)}},Wm=_l(s.M2y,(e=>Math.asin(e))),_m={kernelName:s.M2y,backendName:"cpu",kernelFunc:Wm},zm=_l(s.qw7,(e=>Math.asinh(e))),Xm={kernelName:s.qw7,backendName:"cpu",kernelFunc:zm},Qm=_l(s.jMg,(e=>Math.atan(e))),Zm={kernelName:s.jMg,backendName:"cpu",kernelFunc:Qm},Ym=tm(((e,t)=>Math.atan2(e,t))),$m=fm(s.QCc,Ym),ep={kernelName:s.QCc,backendName:"cpu",kernelFunc:$m},tp=_l(s.Oyi,(e=>Math.atanh(e))),np={kernelName:s.Oyi,backendName:"cpu",kernelFunc:tp};function op(e,t,n,o,A,i){const r=A.strideHeight,a=A.strideWidth,l=A.dilationHeight,m=A.dilationWidth,p=A.effectiveFilterHeight,h=A.effectiveFilterWidth,u=A.padInfo.top,c=A.padInfo.left,d="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=(0,s.f3b)(A.outShape,n),G=I.values,E=A.outShape[1]*A.outShape[2]*A.outShape[3],k=A.outShape[2]*A.outShape[3],g=A.outShape[3];for(let t=0;t<A.batchSize;++t){const n=t*E,s=t*o[0];for(let t=0;t<A.inChannels;++t)for(let I=0;I<A.outHeight;++I){const E=I*r-u,f=Math.max(0,E),H=Math.min(A.inHeight,p+E),F=n+I*k;for(let n=0;n<A.outWidth;++n){const r=n*a-c,p=Math.max(0,r),u=Math.min(A.inWidth,h+r);let I=d,E=0,k=0;for(let n=f;n<H;n+=l){const A=s+n*o[1];for(let n=p;n<u;n+=m){const r=e[A+n*o[2]+t];"max"===i&&r>I?I=r:"avg"===i&&(E+=r,k++)}if(isNaN(I))break}G[F+n*g+t]="avg"===i?E/k:I}}}return I}function Ap(e,t,n,o,A=!1,i=!1){const r=(0,s.f3b)(o.outShape,"int32"),a=o.strideHeight,l=o.strideWidth,m=o.dilationHeight,p=o.dilationWidth,h=o.effectiveFilterHeight,u=o.effectiveFilterWidth,c=o.padInfo.top,d=o.padInfo.left,I=(0,s.f3b)(t,n,e);for(let e=0;e<o.batchSize;++e)for(let t=0;t<o.inChannels;++t)for(let n=0;n<o.outHeight;++n){const s=n*a-c;let G=s;for(;G<0;)G+=m;const E=Math.min(o.inHeight,h+s);for(let a=0;a<o.outWidth;++a){const h=a*l-d;let c=h;for(;c<0;)c+=p;const k=Math.min(o.inWidth,u+h);let g=Number.NEGATIVE_INFINITY,f=-1;for(let n=G;n<E;n+=m){const r=n-s;for(let s=c;s<k;s+=p){const a=s-h,l=I.get(e,n,s,t);l>g&&(g=l,f=A?i?((e*o.inHeight+n)*o.inWidth+s)*o.inChannels+t:(n*o.inWidth+s)*o.inChannels+t:r*u+a)}}r.set(f,e,n,a,t)}}return r}function ip(e,t,n,o,A,i){const r=A.strideDepth,a=A.strideHeight,l=A.strideWidth,m=A.dilationDepth,p=A.dilationHeight,h=A.dilationWidth,u=A.effectiveFilterDepth,c=A.effectiveFilterHeight,d=A.effectiveFilterWidth,I=A.padInfo.front,G=A.padInfo.top,E=A.padInfo.left,k="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=(0,s.f3b)(A.outShape,n),f=g.values,H=A.outShape[1]*A.outShape[2]*A.outShape[3]*A.outShape[4],F=A.outShape[2]*A.outShape[3]*A.outShape[4],C=A.outShape[3]*A.outShape[4],D=A.outShape[4];for(let t=0;t<A.batchSize;++t){const n=t*H,s=t*o[0];for(let t=0;t<A.inChannels;++t)for(let g=0;g<A.outDepth;++g){const H=g*r-I;let J=H;for(;J<0;)J+=m;const v=Math.min(A.inDepth,u+H),j=n+g*F;for(let n=0;n<A.outHeight;++n){const r=n*a-G;let u=r;for(;u<0;)u+=p;const I=Math.min(A.inHeight,c+r),g=j+n*C;for(let n=0;n<A.outWidth;++n){const r=n*l-E;let a=r;for(;a<0;)a+=h;const c=Math.min(A.inWidth,d+r),G=g+n*D;let H=k,F=0,C=0;for(let n=J;n<v;n+=m){const A=s+n*o[1];for(let n=u;n<I;n+=p){const r=A+n*o[2];for(let n=a;n<c;n+=h){const A=e[r+n*o[3]+t];if("max"===i&&A>H?H=A:"avg"===i&&(F+=A,C++),isNaN(H))break}if(isNaN(H))break}if(isNaN(H))break}f[G+t]="avg"===i?F/C:H}}}}return g}const rp={kernelName:s.JhU,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t;Ul(A,"avgPool");const{filterSize:i,strides:r,pad:a,dimRoundingMode:l}=o;s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(r,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`));const m=s.Wap.computePool2DInfo(A.shape,i,r,1,a,l);let p;if(1===m.filterWidth&&1===m.filterHeight&&s.D5U.arraysEqual(m.inShape,m.outShape))p=Zl({inputs:{x:A},backend:n});else{const e=n.data.get(A.dataId).values,t=s.D5U.computeStrides(A.shape),o=op(e,A.shape,A.dtype,t,m,"avg");p=n.makeTensorInfo(m.outShape,A.dtype,o.values)}return p}},sp={kernelName:s._k9,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{filterSize:i,strides:r,pad:a,dimRoundingMode:l,dataFormat:m}=o;Ul(A,"avgPool3d");const p=s.Wap.computePool3DInfo(A.shape,i,r,1,a,l,m),h=ip(n.data.get(A.dataId).values,A.shape,A.dtype,s.D5U.computeStrides(A.shape),p,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},ap={kernelName:s.IMb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i}=t,{filterSize:r,strides:a,pad:l,dimRoundingMode:m}=o;Ul([A,i],"avgPool3DGrad");const p=s.Wap.computePool3DInfo(i.shape,r,a,1,l,m),h=p.strideDepth,u=p.strideHeight,c=p.strideWidth,d=p.filterDepth,I=p.filterHeight,G=p.filterWidth,E=p.dilationDepth,k=p.dilationHeight,g=p.dilationWidth,f=p.effectiveFilterDepth,H=p.effectiveFilterHeight,F=p.effectiveFilterWidth,C=f-1-p.padInfo.front,D=F-1-p.padInfo.left,J=H-1-p.padInfo.top,v=(0,s.f3b)(i.shape,"float32"),j=1/(d*I*G),K=n.bufferSync(A);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inDepth;++n)for(let o=0;o<p.inHeight;++o)for(let A=0;A<p.inWidth;++A){const i=n-C,r=o-J,s=A-D;let a=0;for(let n=0;n<f;n+=E){const o=(i+n)/h;if(!(o<0||o>=p.outDepth||Math.floor(o)!==o))for(let n=0;n<H;n+=k){const A=(r+n)/u;if(!(A<0||A>=p.outHeight||Math.floor(A)!==A))for(let n=0;n<F;n+=g){const i=(s+n)/c;i<0||i>=p.outWidth||Math.floor(i)!==i||(a+=K.get(e,o,A,i,t))}}}v.set(a*j,e,n,o,A,t)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},lp={kernelName:s.ROF,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i}=t,r=i;Ul([A,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:m}=o,p=s.Wap.computePool2DInfo(r.shape,a,l,1,m),h=p.strideHeight,u=p.strideWidth,c=p.filterHeight,d=p.filterWidth,I=p.dilationHeight,G=p.dilationWidth,E=p.effectiveFilterHeight,k=p.effectiveFilterWidth,g=k-1-p.padInfo.left,f=E-1-p.padInfo.top,H=(0,s.f3b)(r.shape,"float32"),F=1/(c*d),C=n.data.get(A.dataId).values,D=(0,s.f3b)(A.shape,"float32",C);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inHeight;++n)for(let o=0;o<p.inWidth;++o){const A=n-f,i=o-g;let r=0;for(let n=0;n<E;n+=I){const o=(A+n)/h;if(!(o<0||o>=p.outHeight||Math.floor(o)!==o))for(let n=0;n<k;n+=G){const A=(i+n)/u;A<0||A>=p.outWidth||Math.floor(A)!==A||(r+=D.get(e,o,A,t))}}H.set(r*F,e,n,o,t)}return n.makeTensorInfo(H.shape,H.dtype,H.values)}},mp={kernelName:s.sHE,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,scale:i,offset:r,mean:a,variance:l}=t;s.D5U.assert(a.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),s.D5U.assert(null==r||a.shape.length===r.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),s.D5U.assert(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),Ul([A,a,l,i,r],"batchNorm");let{varianceEpsilon:m}=o;null==m&&(m=.001);const p=n.data.get(A.dataId).values,h=n.data.get(a.dataId).values,u=n.data.get(l.dataId).values,c=i?n.data.get(i.dataId).values:new Float32Array([1]),d=r?n.data.get(r.dataId).values:new Float32Array([0]),I=new Float32Array(p.length),G=d.length,E=c.length,k=u.length,g=h.length;let f=0,H=0,F=0,C=0;for(let e=0;e<p.length;++e)I[e]=d[f++]+(p[e]-h[H++])*c[F++]/Math.sqrt(u[C++]+m),f>=G&&(f=0),H>=g&&(H=0),F>=E&&(F=0),C>=k&&(C=0);return n.makeTensorInfo(A.shape,A.dtype,I)}};function pp(e,t,n,o,A){const i=s.kuN.isSliceContinous(o,t,n),r=s.D5U.sizeFromShape(n),a=s.D5U.computeStrides(o);if(i){const n=s.kuN.computeFlatOffset(t,a);return"string"===A?e.slice(n,n+r):e.subarray(n,n+r)}const l="string"===A?s.Wap.fromUint8ToStringArray(e):e,m=(0,s.f3b)(o,A,l),p=(0,s.f3b)(n,A);for(let e=0;e<p.size;++e){const n=p.indexToLoc(e),o=n.map(((e,n)=>e+t[n]));p.set(m.get(...o),...n)}return"string"===A?s.Wap.fromStringArrayToUint8(p.values):p.values}function hp(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{begin:i,size:r}=o;Ul(A,"slice");const[a,l]=s.kuN.parseSliceParams(A,i,r);s.kuN.assertParamsValid(A,a,l);const m=pp(n.data.get(A.dataId).values,a,l,A.shape,A.dtype);return n.makeTensorInfo(l,A.dtype,m)}const up={kernelName:s.p2w,backendName:"cpu",kernelFunc:hp},cp={kernelName:s.zws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{blockShape:i,crops:r}=o;Ul([A],"batchToSpaceND");const a=i.reduce(((e,t)=>e*t)),l=s.Wap.getReshaped(A.shape,i,a),m=s.Wap.getPermuted(l.length,i.length),p=s.Wap.getReshapedPermuted(A.shape,i,a),h=s.Wap.getSliceBeginCoords(r,i.length),u=s.Wap.getSliceSize(p,r,i.length),c=vm({inputs:{x:A},backend:n,attrs:{shape:l}}),d=Nm({inputs:{x:c},backend:n,attrs:{perm:m}}),I=vm({inputs:{x:d},backend:n,attrs:{shape:p}}),G=hp({inputs:{x:I},backend:n,attrs:{begin:h,size:u}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(I),G}};function dp(e,t,n,o,A){const i=s.D5U.sizeFromShape(o),r=s.D5U.makeZerosTypedArray(A,n);for(let n=0;n<e.length;n++){const o=e[n];if(o<0)throw new Error("Input x must be non-negative!");o>=A||(r[o]+=i>0?t[n]:1)}return r}function Ip(e,t,n,o=!1){const A=e.shape[0],i=e.shape[1],r=(0,s.f3b)([A,n],t.dtype);for(let s=0;s<A;s++)for(let A=0;A<i;A++){const i=e.get(s,A);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(o?r.set(1,s,i):t.size>0?r.set(r.get(s,i)+t.get(s,A),s,i):r.set(r.get(s,i)+1,s,i))}return r}const Gp={kernelName:s.zvY,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,weights:i}=t,{size:r}=o,s=dp(n.data.get(A.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,r);return n.makeTensorInfo([r],i.dtype,s)}},Ep={kernelName:s.eEB,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:o,s1:A}=t,i=n.data.get(o.dataId).values,r=n.data.get(A.dataId).values,a=s.Wap.assertAndGetBroadcastShape(Array.from(i),Array.from(r));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},kp=lm((e=>Math.ceil(e))),gp=zl(s.gJX,kp),fp={kernelName:s.gJX,backendName:"cpu",kernelFunc:gp},Hp=_l(s.xnO,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),Fp={kernelName:s.xnO,backendName:"cpu",kernelFunc:Hp},Cp={kernelName:s.yj2,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,o=new Float32Array(s.D5U.sizeFromShape(t.shape)),A=n.data.get(t.dataId),i=A.complexTensorInfos.real,r=A.complexTensorInfos.imag,a=n.data.get(i.dataId).values,l=n.data.get(r.dataId).values;for(let e=0;e<a.length;e++){const t=a[e],n=l[e];o[e]=Math.hypot(t,n)}return n.makeOutput(o,t.shape,"float32")}};function Dp(e,t,n,o){const A=s.D5U.getArrayFromDType(n,s.D5U.sizeFromShape(t));if(o&&"string"!==n){let t=0;e.forEach((e=>{const n=s.D5U.sizeFromShape(e.shape);A.set(e.vals,t),t+=n}))}else{let o=0;e.forEach((e=>{const i="string"===n?s.Wap.fromUint8ToStringArray(e.vals):e.vals;let r=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+o;for(let t=0;t<e.shape[1];++t)A[s+t]=i[r++]}o+=e.shape[1]}))}return A}function Jp(e){const{inputs:t,backend:n}=e,{input:o}=t,A=n.data.get(o.dataId).complexTensorInfos.imag,i=n.data.get(A.dataId).values;return n.makeTensorInfo(A.shape,A.dtype,i)}const vp={kernelName:s.J_u,backendName:"cpu",kernelFunc:Jp};function jp(e){const{inputs:t,backend:n,attrs:o}=e,{axis:A}=o,i=s.D5U.parseAxisParam(A,t[0].shape)[0];let r=s.Wap.computeOutShape(t.map((e=>e.shape)),i);if(0===s.D5U.sizeFromShape(r))return n.makeTensorInfo(r,t[0].dtype,[]);const a=t.filter((e=>s.D5U.sizeFromShape(e.shape)>0));if(1===a.length)return Zl({inputs:{x:a[0]},backend:n});const l=a.map((e=>e.shape));if(s.Wap.assertParamsConsistent(l,i),"complex64"===a[0].dtype){const e=a.map((e=>Gm({inputs:{input:e},backend:n}))),t=a.map((e=>Jp({inputs:{input:e},backend:n}))),o=jp({inputs:e,backend:n,attrs:{axis:i}}),A=jp({inputs:t,backend:n,attrs:{axis:i}}),r=cm({inputs:{real:o,imag:A},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(A),r}const m=a.map((e=>{const t=s.D5U.sizeFromShape(e.shape.slice(i));return vm({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),p=m.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));r=s.Wap.computeOutShape(m.map((e=>e.shape)),1);const h=1===m[0].shape[0],u=Dp(p,r,t[0].dtype,h),c=s.Wap.computeOutShape(a.map((e=>e.shape)),i),d=n.makeTensorInfo(c,t[0].dtype,u);return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}const Kp={kernelName:s.Eh3,backendName:"cpu",kernelFunc:jp};function yp(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dataFormat:l,dilations:m,dimRoundingMode:p}=o;Ul([A,i],"conv2d");const h=s.Wap.convertConv2DDataFormat(l),u=s.Wap.computeConv2DInfo(A.shape,i.shape,r,m,a,p,!1,h),c=u.filterHeight,d=u.filterWidth,I=u.dilationHeight,G=u.dilationWidth,E=u.padInfo.left,k=u.padInfo.top,g="channelsLast"===u.dataFormat,f=new s.YDk(u.outShape,A.dtype),H=s.D5U.computeStrides(A.shape),F=s.D5U.computeStrides(i.shape),C=H[0],D=g?H[1]:H[2],J=g?H[2]:1,v=g?1:H[1],j=f.strides[0],K=g?f.strides[1]:f.strides[2],y=g?f.strides[2]:1,b=g?1:f.strides[1],q=n.data.get(A.dataId).values,x=n.data.get(i.dataId).values,B=f.values;for(let e=0;e<u.batchSize;++e){const t=e*C,n=e*j;for(let e=0;e<u.outHeight;++e){const o=n+e*K,A=e*u.strideHeight-k;for(let e=0;e<c;++e){const n=A+e*I;if(n<0||n>=u.inHeight)continue;const i=e*F[0],r=t+n*D;for(let e=0;e<u.outWidth;++e){const t=o+e*y,n=e*u.strideWidth-E;for(let e=0;e<d;++e){const o=n+e*G;if(o<0||o>=u.inWidth)continue;const A=r+o*J;let s=i+e*F[1];for(let e=0;e<u.inChannels;++e){const n=q[A+e*v];for(let e=0;e<u.outChannels;++e)B[t+e*b]+=n*x[s+e];s+=u.outChannels}}}}}}return n.makeTensorInfo(f.shape,f.dtype,B)}const bp={kernelName:s.mhS,backendName:"cpu",kernelFunc:yp},qp={kernelName:s.wUP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,dy:i}=t,{strides:r,pad:a,dataFormat:l,dimRoundingMode:m,filterShape:p}=o;Ul([A,i],"conv2dBackpropFilter");const h=s.Wap.convertConv2DDataFormat(l),u=s.Wap.computeConv2DInfo(A.shape,p,r,1,a,m,!1,h),{strideHeight:c,strideWidth:d,filterHeight:I,filterWidth:G}=u,E="channelsLast"===u.dataFormat,k=new s.YDk(u.filterShape,"float32"),g=u.padInfo.left,f=u.padInfo.top,H=n.data.get(A.dataId).values,F=n.data.get(i.dataId).values,C=new s.YDk(A.shape,A.dtype,H),D=new s.YDk(i.shape,i.dtype,F);for(let e=0;e<I;++e){const t=Math.max(0,Math.ceil((f-e)/c)),n=Math.min(u.outHeight,(u.inHeight+f-e)/c);for(let o=0;o<G;++o){const A=Math.max(0,Math.ceil((g-o)/d)),i=Math.min(u.outWidth,(u.inWidth+g-o)/d);for(let r=0;r<u.inChannels;++r)for(let s=0;s<u.outChannels;++s){let a=0;for(let l=0;l<u.batchSize;++l)for(let m=t;m<n;++m){const t=e+m*c-f;for(let e=A;e<i;++e){const n=o+e*d-g;a+=E?C.get(l,t,n,r)*D.get(l,m,e,s):C.get(l,r,t,n)*D.get(l,s,m,e)}}k.set(a,e,o,r,s)}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},xp={kernelName:s.wm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,filter:i}=t,{inputShape:r,strides:a,pad:l,dataFormat:m,dimRoundingMode:p}=o;Ul([A,i],"conv2dBackpropInput");const h=s.D5U.computeStrides(i.shape),u=s.D5U.computeStrides(A.shape);let c=s.Wap.convertConv2DDataFormat(m);const d=s.Wap.computeConv2DInfo(r,i.shape,a,1,l,p,!1,c),I=new s.YDk(d.inShape,"float32"),G=I.values,E=n.data.get(A.dataId).values,k=n.data.get(i.dataId).values,[g,f,H]=h,{batchSize:F,filterHeight:C,filterWidth:D,inChannels:J,inHeight:v,inWidth:j,outChannels:K,outHeight:y,outWidth:b,strideHeight:q,strideWidth:x}=d;c=d.dataFormat;const B=C-1-d.padInfo.top,w=D-1-d.padInfo.left,M="channelsLast"===c,L=I.strides[0],S=M?I.strides[1]:I.strides[2],T=M?I.strides[2]:1,N=M?1:I.strides[1],R=u[0],O=M?u[1]:u[2],P=M?u[2]:1,U=M?1:u[1];for(let e=0;e<F;++e)for(let t=0;t<J;++t)for(let n=0;n<v;++n){const o=n-B,A=Math.max(0,Math.ceil(o/q)),i=Math.min(y,(C+o)/q);for(let r=0;r<j;++r){const s=r-w,a=Math.max(0,Math.ceil(s/x)),l=Math.min(b,(D+s)/x);let m=0;for(let n=A;n<i;++n){const A=n*q-o;for(let o=a;o<l;++o){const i=R*e+O*n+P*o,r=g*(C-1-A)+f*(D-1-(o*x-s))+H*t;for(let e=0;e<K;++e)m+=E[i+U*e]*k[r+e]}}G[L*e+S*n+T*r+N*t]=m}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},Bp={kernelName:s.x12,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dilations:l}=o;Ul([A,i],"conv3d");const m=s.Wap.computeConv3DInfo(A.shape,i.shape,r,l,a),{filterDepth:p,filterHeight:h,filterWidth:u,dilationDepth:c,dilationHeight:d,dilationWidth:I,padInfo:G}=m,E=G.front,k=G.left,g=G.top,f=new s.YDk(m.outShape,A.dtype),H=n.data.get(A.dataId).values,F=n.data.get(i.dataId).values,C=f.values,D=s.D5U.computeStrides(A.shape),J=s.D5U.computeStrides(i.shape);for(let e=0;e<m.batchSize;++e){const t=e*D[0],n=e*f.strides[0];for(let e=0;e<m.outDepth;++e){const o=n+e*f.strides[1],A=e*m.strideDepth-E;for(let e=0;e<p;++e){const n=A+e*c;if(n<0||n>=m.inDepth)continue;const i=e*J[0],r=t+n*D[1];for(let e=0;e<m.outHeight;++e){const t=o+e*f.strides[2],n=e*m.strideHeight-g;for(let e=0;e<h;++e){const o=n+e*d;if(o<0||o>=m.inHeight)continue;const A=i+e*J[1],s=r+o*D[2];for(let e=0;e<m.outWidth;++e){const n=t+e*m.outChannels,o=e*m.strideWidth-k;for(let e=0;e<u;++e){const t=o+e*I;if(t<0||t>=m.inWidth)continue;const i=A+e*J[2],r=s+t*m.inChannels;let a=i;for(let e=0;e<m.inChannels;++e){const t=H[r+e];for(let e=0;e<m.outChannels;++e)C[n+e]+=t*F[a+e];a+=m.outChannels}}}}}}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},wp={kernelName:s.o2y,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,dy:i}=t,{strides:r,pad:a,filterShape:l}=o;Ul([A,i],"conv3dBackpropFilterV2");const m=s.D5U.computeStrides(A.shape),p=s.D5U.computeStrides(i.shape),h=s.Wap.computeConv3DInfo(A.shape,l,r,1,a),u=h.strideDepth,c=h.strideHeight,d=h.strideWidth,I=h.filterDepth,G=h.filterHeight,E=h.filterWidth,k=new s.YDk(h.filterShape,"float32"),g=k.values,[f,H,F,C]=k.strides,D=n.data.get(i.dataId).values,[J,v,j,K]=p,y=n.data.get(A.dataId).values,[b,q,x,B]=m,w=h.padInfo.front,M=h.padInfo.left,L=h.padInfo.top;for(let e=0;e<I;++e){const t=Math.max(0,Math.ceil((w-e)/u)),n=Math.min(h.outDepth,(h.inDepth+w-e)/u),o=e*f;for(let A=0;A<G;++A){const i=Math.max(0,Math.ceil((L-A)/c)),r=Math.min(h.outHeight,(h.inHeight+L-A)/c),s=A*H+o;for(let o=0;o<E;++o){const a=Math.max(0,Math.ceil((M-o)/d)),l=Math.min(h.outWidth,(h.inWidth+M-o)/d),m=o*F+s;for(let s=0;s<h.inChannels;++s){const p=s*C+m;for(let m=0;m<h.outChannels;++m){let I=0;for(let p=0;p<h.batchSize;++p){const h=p*b,G=p*J;for(let p=t;p<n;++p){const t=(e+p*u-w)*q+h,n=p*v+G;for(let e=i;e<r;++e){const i=(A+e*c-L)*x+t,r=e*j+n;for(let e=a;e<l;++e){const t=e*K+r;I+=y[(o+e*d-M)*B+i+s]*D[t+m]}}}}g[p+m]=I}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},Mp={kernelName:s.ik2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,filter:i}=t,{pad:r,strides:a,inputShape:l}=o;Ul([A],"conv3dBackpropInputV2");const m=s.D5U.computeStrides(A.shape),p=s.D5U.computeStrides(i.shape),h=s.Wap.computeConv3DInfo(l,i.shape,a,1,r),u=new s.YDk(h.inShape,"float32"),c=u.values,[d,I,G,E]=u.strides,k=n.data.get(A.dataId).values,[g,f,H,F]=m,C=n.data.get(i.dataId).values,[D,J,v,j]=p,{batchSize:K,filterDepth:y,filterHeight:b,filterWidth:q,inChannels:x,inDepth:B,inHeight:w,inWidth:M,outChannels:L,outDepth:S,outHeight:T,outWidth:N,strideDepth:R,strideHeight:O,strideWidth:P}=h,U=y-1-h.padInfo.front,V=b-1-h.padInfo.top,W=q-1-h.padInfo.left;for(let e=0;e<K;++e)for(let t=0;t<x;++t)for(let n=0;n<B;++n){const o=n-U,A=Math.max(0,Math.ceil(o/R)),i=Math.min(S,(y+o)/R);for(let r=0;r<w;++r){const s=r-V,a=Math.max(0,Math.ceil(s/O)),l=Math.min(T,(b+s)/O);for(let m=0;m<M;++m){const p=m-W,h=Math.max(0,Math.ceil(p/P)),u=Math.min(N,(q+p)/P);let K=0;for(let n=A;n<i;++n){const A=n*R-o;for(let o=a;o<l;++o){const i=o*O-s;for(let r=h;r<u;++r){const s=g*e+f*n+H*o+F*r,a=D*(y-1-A)+J*(b-1-i)+v*(q-1-(r*P-p))+j*t;for(let e=0;e<L;++e)K+=k[s+e]*C[a+e]}}}c[d*e+I*n+G*r+E*m+t]=K}}}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},Lp=_l(s.mc4,(e=>Math.cos(e))),Sp={kernelName:s.mc4,backendName:"cpu",kernelFunc:Lp},Tp=_l(s.TR1,(e=>Math.cosh(e))),Np={kernelName:s.TR1,backendName:"cpu",kernelFunc:Tp},Rp={kernelName:s.VcC,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{image:A,boxes:i,boxInd:r}=t,{cropSize:a,method:l,extrapolationValue:m}=o,[p,h,u,c]=A.shape,d=i.shape[0],[I,G]=a,E=(0,s.f3b)([d,I,G,c],"float32"),k=n.data.get(i.dataId).values,g=n.data.get(r.dataId).values,f=n.data.get(A.dataId).values,H=s.D5U.computeStrides(A.shape),F=s.D5U.computeStrides(E.shape);for(let e=0;e<d;e++){const t=4*e,n=k[t],o=k[t+1],A=k[t+2],i=k[t+3],r=g[e];if(r>=p)continue;const s=I>1?(A-n)*(h-1)/(I-1):0,a=G>1?(i-o)*(u-1)/(G-1):0;for(let t=0;t<I;t++){const p=I>1?n*(h-1)+t*s:.5*(n+A)*(h-1);if(p<0||p>h-1)for(let n=0;n<G;n++)for(let o=0;o<c;o++){const A=o+n*F[2]+t*F[1]+e*F[0];E.values[A]=m}else if("bilinear"===l){const n=Math.floor(p),A=Math.ceil(p),s=p-n;for(let l=0;l<G;l++){const p=G>1?o*(u-1)+l*a:.5*(o+i)*(u-1);if(p<0||p>u-1){for(let n=0;n<c;n++){const o=n+l*F[2]+t*F[1]+e*F[0];E.values[o]=m}continue}const h=Math.floor(p),d=Math.ceil(p),I=p-h;for(let o=0;o<c;o++){let i=o+h*H[2]+n*H[1]+r*H[0];const a=f[i];i=o+d*H[2]+n*H[1]+r*H[0];const m=f[i];i=o+h*H[2]+A*H[1]+r*H[0];const p=f[i];i=o+d*H[2]+A*H[1]+r*H[0];const u=a+(m-a)*I,c=p+(f[i]-p)*I;i=o+l*F[2]+t*F[1]+e*F[0],E.values[i]=u+(c-u)*s}}}else for(let n=0;n<G;++n){const A=G>1?o*(u-1)+n*a:.5*(o+i)*(u-1);if(A<0||A>u-1){for(let o=0;o<c;o++){const A=o+n*F[2]+t*F[1]+e*F[0];E.values[A]=m}continue}const s=Math.round(A),l=Math.round(p);for(let o=0;o<c;o++){const A=o+s*H[2]+l*H[1]+r*H[0],i=o+n*F[2]+t*F[1]+e*F[0];E.values[i]=f[A]}}}}return n.makeTensorInfo(E.shape,E.dtype,E.values)}},Op={kernelName:s.iHb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,exclusive:r,reverse:a}=o;Ul(A,"cumsum");const l=s.Wap.getAxesPermutation([i],A.shape.length);let m=A;null!=l&&(m=Nm({inputs:{x:A},backend:n,attrs:{perm:l}}));const p=s.Wap.getInnerMostAxes(1,A.shape.length)[0];if(p!==m.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${m.shape.length-1} but got axis=${p}`);const h=(0,s.x8V)(m.dtype,"int32"),u=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(m.shape),h),c=n.data.get(m.dataId).values,d=m.shape[m.shape.length-1],I=a?(e,t)=>e+d-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=d)for(let t=0;t<d;t++){const n=I(e,t);if(0===t)u[n]=r?0:c[n];else{const o=I(e,t-1);u[n]=r?c[o]+u[o]:c[n]+u[o]}}const G=n.makeTensorInfo(m.shape,h,u);if(null!=l){const e=Nm({inputs:{x:G},backend:n,attrs:{perm:s.Wap.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(G),n.disposeIntermediateTensorInfo(m),e}return G}},Pp={kernelName:s.QRR,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,weights:i}=t,{size:r,binaryOutput:s}=o;if(1===A.shape.length){const e=dp(n.data.get(A.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,r);return n.makeTensorInfo([r],i.dtype,e)}if(2===A.shape.length){const e=Ip(n.bufferSync(A),n.bufferSync(i),r,s);return n.makeTensorInfo(e.shape,i.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${A.shape.length}.`)}},Up={kernelName:s.T0n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{blockSize:i,dataFormat:r}=o;s.D5U.assert("NHWC"===r,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`));const a=A.shape[0],l=A.shape[1],m=A.shape[2],p=A.shape[3],h=l*i,u=m*i,c=p/(i*i),d=n.data.get(A.dataId).values,I=new Float32Array(a*h*u*c);let G=0;for(let e=0;e<a;++e)for(let t=0;t<h;++t){const n=Math.floor(t/i),o=t%i;for(let t=0;t<u;++t){const A=Math.floor(t/i),r=(o*i+t%i)*c;for(let t=0;t<c;++t){const o=t+r+p*(A+m*(n+l*e));I[G++]=d[o]}}}return n.makeTensorInfo([a,h,u,c],A.dtype,I)}};function Vp(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dilations:l,dimRoundingMode:m}=o;Ul([A,i],"depthwiseConv2DNative");const p=s.D5U.computeStrides(A.shape),h=s.D5U.computeStrides(i.shape);let u=l;null==u&&(u=[1,1]),s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(r,u),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`));const c=s.Wap.computeConv2DInfo(A.shape,i.shape,r,u,a,m,!0),{filterHeight:d,filterWidth:I,dilationHeight:G,dilationWidth:E,padInfo:k}=c,g=k.left,f=k.top,H=c.outChannels/c.inChannels,F=new s.YDk(c.outShape,A.dtype),C=n.data.get(A.dataId).values,D=n.data.get(i.dataId).values,J=F.values;for(let e=0;e<c.batchSize;++e){const t=e*p[0],n=e*F.strides[0];for(let e=0;e<c.outHeight;++e){const o=n+e*F.strides[1],A=e*c.strideHeight-f;for(let e=0;e<d;++e){const n=A+e*G;if(n<0||n>=c.inHeight)continue;const i=e*h[0],r=t+n*p[1];for(let e=0;e<c.outWidth;++e){const t=o+e*F.strides[2],n=e*c.strideWidth-g;for(let e=0;e<I;++e){const o=n+e*E;if(o<0||o>=c.inWidth)continue;const A=i+e*h[1],s=r+o*c.inChannels;let a=t,l=A;for(let e=0;e<c.inChannels;++e){const t=C[s+e];for(let e=0;e<H;++e)J[a+e]+=t*D[l+e];a+=H,l+=H}}}}}}return n.makeTensorInfo(F.shape,F.dtype,F.values)}const Wp={kernelName:s.cie,backendName:"cpu",kernelFunc:Vp},_p={kernelName:s.sL$,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,dy:i}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:m,filterShape:p}=o;Ul([A,i],"depthwiseConv2dNativeBackpropFilter");const h=s.Wap.computeConv2DInfo(A.shape,p,r,a,l,m,!0),{strideHeight:u,strideWidth:c,filterHeight:d,filterWidth:I}=h,G=new s.YDk(h.filterShape,"float32"),E=h.padInfo.left,k=h.padInfo.top,g=h.outChannels/h.inChannels,f=n.data.get(A.dataId).values,H=new s.YDk(A.shape,A.dtype,f),F=n.data.get(i.dataId).values,C=new s.YDk(i.shape,i.dtype,F);for(let e=0;e<d;++e){const t=Math.max(0,Math.ceil((k-e)/u)),n=Math.min(h.outHeight,(h.inHeight+k-e)/u);for(let o=0;o<I;++o){const A=Math.max(0,Math.ceil((E-o)/c)),i=Math.min(h.outWidth,(h.inWidth+E-o)/c);for(let r=0;r<h.outChannels;++r){const s=Math.trunc(r/g),a=r%g;let l=0;for(let a=0;a<h.batchSize;++a)for(let m=t;m<n;++m){const t=e+m*u-k;for(let e=A;e<i;++e){const n=o+e*c-E;l+=H.get(a,t,n,s)*C.get(a,m,e,r)}}G.set(l,e,o,s,a)}}}return n.makeTensorInfo(G.shape,G.dtype,G.values)}},zp={kernelName:s.y7R,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,filter:i}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:m,inputShape:p}=o;Ul([A,i],"depthwiseConv2DNativeBackpropInput");const h=s.D5U.computeStrides(A.shape),u=s.D5U.computeStrides(i.shape),c=s.Wap.computeConv2DInfo(p,i.shape,r,a,l,m,!0),d=new s.YDk(c.inShape,"float32"),I=d.values,[G,E,k]=d.strides,g=n.data.get(A.dataId).values,[f,H,F]=h,C=n.data.get(i.dataId).values,[D,J,v]=u,{batchSize:j,filterHeight:K,filterWidth:y,inChannels:b,inHeight:q,inWidth:x,outChannels:B,outHeight:w,outWidth:M,strideHeight:L,strideWidth:S}=c,T=K-1-c.padInfo.top,N=y-1-c.padInfo.left,R=B/b;for(let e=0;e<j;++e)for(let t=0;t<b;++t)for(let n=0;n<q;++n){const o=n-T,A=Math.max(0,Math.ceil(o/L)),i=Math.min(w,(K+o)/L);for(let r=0;r<x;++r){const s=r-N,a=Math.max(0,Math.ceil(s/S)),l=Math.min(M,(y+s)/S);let m=0;for(let n=A;n<i;++n){const A=n*L-o;for(let o=a;o<l;++o){const i=f*e+H*n+F*o,r=D*(K-1-A)+J*(y-1-(o*S-s))+v*t;for(let e=0;e<R;++e)m+=g[i+(t*R+e)]*C[r+e]}}I[G*e+E*n+k*r+t]=m}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},Xp={kernelName:s.$w,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t,A=s.D5U.sizeFromShape(o.shape),i=n.data.get(o.dataId).values,r=(0,s.f3b)([A,A],o.dtype),a=r.values;for(let e=0;e<i.length;e++)a[e*A+e]=i[e];const l=[...o.shape,...o.shape];return n.makeTensorInfo(l,r.dtype,r.values)}},Qp={kernelName:s.p4S,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,filter:A}=e,{strides:i,pad:r,dilations:a}=n,l=t,m=l.data.get(o.dataId).values,p=o.shape.length,h=l.data.get(A.dataId).values,u=A.shape.length,{batchSize:c,inHeight:d,inWidth:I,inChannels:G,outHeight:E,outWidth:k,padInfo:g,strideHeight:f,strideWidth:H,filterHeight:F,filterWidth:C,dilationHeight:D,dilationWidth:J,outShape:v}=s.Wap.computeDilation2DInfo(o.shape,A.shape,i,r,"NHWC",a),j=s.D5U.sizeFromShape(v),K=v.length,y=s.D5U.getArrayFromDType(o.dtype,j);for(let e=0;e<c;++e)for(let t=0;t<E;++t){const n=t*f-g.top;for(let i=0;i<k;++i){const r=i*H-g.left;for(let a=0;a<G;++a){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<F;++t){const i=n+t*D;if(i>=0&&i<d)for(let n=0;n<C;++n){const c=r+n*J;if(c>=0&&c<I){const r=s.D5U.locToIndex([e,i,c,a],p,s.D5U.computeStrides(o.shape)),d=s.D5U.locToIndex([t,n,a],u,s.D5U.computeStrides(A.shape)),I=m[r]+h[d];I>l&&(l=I)}}}y[s.D5U.locToIndex([e,t,i,a],K,s.D5U.computeStrides(v))]=l}}}return{dataId:l.write(s.D5U.toTypedArray(y,o.dtype),v,o.dtype),shape:v,dtype:o.dtype}}},Zp={kernelName:s.Vn9,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,filter:A,dy:i}=e,{strides:r,pad:a,dilations:l}=n,m=t,p=s.D5U.toNestedArray(o.shape,m.data.get(o.dataId).values),h=s.D5U.toNestedArray(A.shape,m.data.get(A.dataId).values),{batchSize:u,inHeight:c,inWidth:d,inChannels:I,outHeight:G,outWidth:E,padInfo:k,strideHeight:g,strideWidth:f,filterHeight:H,filterWidth:F,dilationHeight:C,dilationWidth:D,outShape:J}=s.Wap.computeDilation2DInfo(o.shape,A.shape,r,a,"NHWC",l);s.D5U.assert(i.rank===J.length,(()=>`Error in ${s.Vn9}, dy must have the same rank as output ${J.length}, but got ${i.rank}`));const v=s.D5U.toNestedArray(J,m.data.get(i.dataId).values),j=s.D5U.makeZerosNestedTypedArray(A.shape,A.dtype);for(let e=0;e<u;++e)for(let t=0;t<G;++t){const n=t*g-k.top;for(let o=0;o<E;++o){const A=o*f-k.left;for(let i=0;i<I;++i){let r=Number.MIN_SAFE_INTEGER,s=0,a=0;for(let t=0;t<H;++t){const o=n+t*C;if(o>=0&&o<c)for(let n=0;n<F;++n){const l=A+n*D;if(l>=0&&l<d){const A=p[e][o][l][i]+h[t][n][i];A>r&&(r=A,s=t,a=n)}}}j[s][a][i]+=v[e][t][o][i]}}}return{dataId:m.write(s.D5U.toTypedArray(j,o.dtype),A.shape,A.dtype),shape:A.shape,dtype:A.dtype}}},Yp={kernelName:s.ekb,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,filter:A,dy:i}=e,{strides:r,pad:a,dilations:l}=n,m=t,p=s.D5U.toNestedArray(o.shape,m.data.get(o.dataId).values),h=s.D5U.toNestedArray(A.shape,m.data.get(A.dataId).values),{batchSize:u,inHeight:c,inWidth:d,inChannels:I,outHeight:G,outWidth:E,padInfo:k,strideHeight:g,strideWidth:f,filterHeight:H,filterWidth:F,dilationHeight:C,dilationWidth:D,outShape:J}=s.Wap.computeDilation2DInfo(o.shape,A.shape,r,a,"NHWC",l);s.D5U.assert(i.rank===J.length,(()=>`Error in ${s.ekb}, dy must have the same rank as output ${J.length}, but got ${i.rank}`));const v=s.D5U.toNestedArray(J,m.data.get(i.dataId).values),j=s.D5U.makeZerosNestedTypedArray(o.shape,o.dtype);for(let e=0;e<u;++e)for(let t=0;t<G;++t){const n=t*g-k.top;for(let o=0;o<E;++o){const A=o*f-k.left;for(let i=0;i<I;++i){let r=Number.MIN_SAFE_INTEGER,s=n<0?0:n,a=A<0?0:A;for(let t=0;t<H;++t){const o=n+t*C;if(o>=0&&o<c)for(let n=0;n<F;++n){const l=A+n*D;if(l>=0&&l<d){const A=p[e][o][l][i]+h[t][n][i];A>r&&(r=A,s=o,a=l)}}}j[e][s][a][i]+=v[e][t][o][i]}}}return{dataId:m.write(s.D5U.toTypedArray(j,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},$p=tm(((e,t)=>e*t)),eh=Hm(((e,t,n,o)=>({real:e*n-t*o,imag:e*o+t*n}))),th=fm(s.wYn,$p,eh),nh={kernelName:s.wYn,backendName:"cpu",kernelFunc:th};function oh(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o;let a;Ul(A,"sum"),a="bool"===A.dtype?km({inputs:{x:A},backend:n,attrs:{dtype:"int32"}}):Zl({inputs:{x:A},backend:n});const l=a.shape.length,m=s.D5U.parseAxisParam(i,a.shape),p=s.Wap.getAxesPermutation(m,l);let h=m,u=a;null!=p&&(u=Nm({inputs:{x:a},backend:n,attrs:{perm:p}}),h=s.Wap.getInnerMostAxes(h.length,l)),s.Wap.assertAxesAreInnerMostDims("sum",h,u.shape.length);const[c,d]=s.Wap.computeOutAndReduceShapes(u.shape,h);let I=Im(n,c,s.Wap.upcastType(u.dtype,"int32"));const G=s.D5U.sizeFromShape(d),E=n.data.get(I.dataId).values,k=n.data.get(u.dataId).values;for(let e=0;e<E.length;++e){const t=e*G;let n=0;for(let e=0;e<G;++e)n+=k[t+e];E[e]=n}if(r){const e=I;I=vm({inputs:{x:I},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(I.shape,m)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(a),null!=p&&n.disposeIntermediateTensorInfo(u),I}const Ah={kernelName:s.GBy,backendName:"cpu",kernelFunc:oh},ih={kernelName:s.$g6,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{equation:A}=o,i=t,{allDims:r,summedDims:a,idDims:l}=s.Wap.decodeEinsumEquation(A,i.length);s.Wap.checkEinsumDimSizes(r.length,l,i);const{path:m,steps:p}=s.Wap.getEinsumComputePath(a,l),h=p.length;let u=null,c=r.length;const d=[];for(let e=0;e<h;++e){for(const t of p[e]){const{permutationIndices:e,expandDims:o}=s.Wap.getEinsumPermutation(c,l[t]);let A;s.Wap.isIdentityPermutation(e)?A=i[t]:(A=Nm({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),d.push(A));const r=A.shape.slice();for(let e=0;e<o.length;++e)r.splice(o[e],0,1);s.D5U.arraysEqual(A.shape,r)||(A=vm({inputs:{x:A},backend:n,attrs:{shape:r}}),d.push(A)),null===u?u=A:(u=th({inputs:{a:A,b:u},backend:n}),d.push(u))}e<h-1&&(m[e]>=0&&(u=oh({inputs:{x:u},backend:n,attrs:{axis:m[e]-(r.length-c),keepDims:!1}}),d.push(u)),c--)}for(const e of d)e!==u&&n.disposeIntermediateTensorInfo(e);return u}},rh={kernelName:s.HEU,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:o,y:A}=t;Ul([o,A],"eluGrad");const i=new Float32Array(s.D5U.sizeFromShape(A.shape)),r=n.data.get(A.dataId).values,a=n.data.get(o.dataId).values;for(let e=0;e<r.length;++e){const t=r[e];i[e]=t>=1?a[e]:a[e]*(t+1)}return n.makeTensorInfo(A.shape,"float32",i)}},sh=tm(((e,t)=>e===t?1:0)),ah=fm(s.hdR,sh,null,"bool"),lh={kernelName:s.hdR,backendName:"cpu",kernelFunc:ah},mh=s.Wap.ERF_P,ph=s.Wap.ERF_A1,hh=s.Wap.ERF_A2,uh=s.Wap.ERF_A3,ch=s.Wap.ERF_A4,dh=s.Wap.ERF_A5,Ih=_l(s.Omj,(e=>{const t=Math.sign(e),n=Math.abs(e),o=1/(1+mh*n);return t*(1-((((dh*o+ch)*o+uh)*o+hh)*o+ph)*o*Math.exp(-n*n))})),Gh={kernelName:s.Omj,backendName:"cpu",kernelFunc:Ih},Eh=lm((e=>Math.exp(e))),kh=zl(s.NEP,Eh,"float32"),gh={kernelName:s.NEP,backendName:"cpu",kernelFunc:kh};function fh(e){const{inputs:t,backend:n,attrs:o}=e,{input:A}=t,{dim:i}=o,r=A.shape.length,a=A.shape.slice();let l=i;return i<0&&(s.D5U.assert(-(r+1)<=i,(()=>`Axis must be in the interval [${-(r+1)}, ${r}]`)),l=r+i+1),a.splice(l,0,1),vm({inputs:{x:A},backend:n,attrs:{shape:a}})}const Hh={kernelName:s.YFo,backendName:"cpu",kernelFunc:fh},Fh=lm((e=>Math.expm1(e))),Ch=zl(s.Y0y,Fh),Dh={kernelName:s.Y0y,backendName:"cpu",kernelFunc:Ch},Jh=tm(((e,t)=>e/t)),vh=fm(s.oHH,Jh),jh={kernelName:s.oHH,backendName:"cpu",kernelFunc:vh},Kh=tm(((e,t)=>e-t)),yh=Hm(((e,t,n,o)=>({real:e-n,imag:t-o}))),bh=fm(s.Tr8,Kh,yh),qh={kernelName:s.Tr8,backendName:"cpu",kernelFunc:bh};function xh(e,t,n){const o=e.shape,A=o[0],i=o[1],r=n.data.get(e.dataId),a=r.complexTensorInfos.real,l=r.complexTensorInfos.imag,m=[A,i],p=s.D5U.sizeFromShape(m),h=s.D5U.getTypedArrayFromDType("float32",p),u=s.D5U.getTypedArrayFromDType("float32",p);for(let e=0;e<A;e++){const o=hp({inputs:{x:a},backend:n,attrs:{begin:[e,0],size:[1,i]}}),A=hp({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,i]}}),r=cm({inputs:{real:o,imag:A},backend:n}),{real:m,imag:p}=Bh(r,t,n),c=s.Wap.mergeRealAndImagArrays(m,p);for(let t=0;t<i;t++){const n=s.Wap.getComplexWithIndex(c,t);h[e*i+t]=n.real,u[e*i+t]=n.imag}n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(r)}const c=n.makeTensorInfo(m,"float32",h),d=n.makeTensorInfo(m,"float32",u),I=cm({inputs:{real:c,imag:d},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),I}function Bh(e,t,n){const o=s.D5U.sizeFromShape(e.shape),A=n.data.get(e.dataId),i=n.data.get(A.complexTensorInfos.real.dataId).values,r=n.data.get(A.complexTensorInfos.imag.dataId).values;if(0==((a=o)&a-1)){const A=wh(i,r,o,t,n),a=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(a,"float32",A.real),t=n.makeTensorInfo(a,"float32",A.imag),i=n.makeTensorInfo([],"float32",s.D5U.createScalarValue(o,"float32")),r=Zl({inputs:{x:i},backend:n}),l=jh.kernelFunc({inputs:{a:e,b:i},backend:n}),m=jh.kernelFunc({inputs:{a:t,b:r},backend:n}),p=n.data.get(l.dataId).values,h=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(m),{real:p,imag:h}}return A}{const e=function(e,t,n){const o=new Float32Array(2*t);for(let A=0;A<t;A++){let i=0,r=0;for(let o=0;o<t;o++){const a=s.Wap.exponent(A*o,t,n),l=s.Wap.getComplexWithIndex(e,o);i+=l.real*a.real-l.imag*a.imag,r+=l.real*a.imag+l.imag*a.real}n&&(i/=t,r/=t),s.Wap.assignToTypedArray(o,i,r,A)}return o}(s.Wap.mergeRealAndImagArrays(i,r),o,t);return s.Wap.splitRealAndImagArrays(e)}var a}function wh(e,t,n,o,A){if(1===n)return{real:e,imag:t};const i=s.Wap.mergeRealAndImagArrays(e,t),r=n/2,a=s.Wap.complexWithEvenIndex(i),l=a.real,m=a.imag,p=[l.length],h=A.makeTensorInfo(p,"float32",l),u=A.makeTensorInfo(p,"float32",m),c=cm({inputs:{real:h,imag:u},backend:A}),d=s.Wap.complexWithOddIndex(i),I=d.real,G=d.imag,E=[I.length],k=A.makeTensorInfo(E,"float32",I),g=A.makeTensorInfo(E,"float32",G),f=cm({inputs:{real:k,imag:g},backend:A}),H=wh(l,m,r,o,A),F=H.real,C=H.imag,D=[F.length],J=A.makeTensorInfo(D,"float32",F),v=A.makeTensorInfo(D,"float32",C),j=cm({inputs:{real:J,imag:v},backend:A}),K=wh(I,G,r,o,A),y=K.real,b=K.imag,q=[y.length],x=A.makeTensorInfo(q,"float32",y),B=A.makeTensorInfo(q,"float32",b),w=cm({inputs:{real:x,imag:B},backend:A}),M=s.Wap.exponents(n,o),L=[M.real.length],S=A.makeTensorInfo(L,"float32",M.real),T=A.makeTensorInfo(L,"float32",M.imag),N=cm({inputs:{real:S,imag:T},backend:A}),R=th({inputs:{a:N,b:w},backend:A}),O=Dm({inputs:{a:j,b:R},backend:A}),P=bh({inputs:{a:j,b:R},backend:A}),U=Gm({inputs:{input:O},backend:A}),V=Gm({inputs:{input:P},backend:A}),W=Jp({inputs:{input:O},backend:A}),_=Jp({inputs:{input:P},backend:A}),z=jp({inputs:[U,V],backend:A,attrs:{axis:0}}),X=jp({inputs:[W,_],backend:A,attrs:{axis:0}}),Q=A.data.get(z.dataId).values,Z=A.data.get(X.dataId).values;return A.disposeIntermediateTensorInfo(h),A.disposeIntermediateTensorInfo(u),A.disposeIntermediateTensorInfo(c),A.disposeIntermediateTensorInfo(k),A.disposeIntermediateTensorInfo(g),A.disposeIntermediateTensorInfo(f),A.disposeIntermediateTensorInfo(J),A.disposeIntermediateTensorInfo(v),A.disposeIntermediateTensorInfo(j),A.disposeIntermediateTensorInfo(x),A.disposeIntermediateTensorInfo(B),A.disposeIntermediateTensorInfo(w),A.disposeIntermediateTensorInfo(S),A.disposeIntermediateTensorInfo(T),A.disposeIntermediateTensorInfo(N),A.disposeIntermediateTensorInfo(R),A.disposeIntermediateTensorInfo(O),A.disposeIntermediateTensorInfo(P),A.disposeIntermediateTensorInfo(U),A.disposeIntermediateTensorInfo(W),A.disposeIntermediateTensorInfo(V),A.disposeIntermediateTensorInfo(_),A.disposeIntermediateTensorInfo(z),A.disposeIntermediateTensorInfo(X),{real:Q,imag:Z}}const Mh={kernelName:s.vwp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:o}=t,A=s.D5U.sizeFromShape(o.shape),i=o.shape[o.shape.length-1],r=vm({inputs:{x:o},backend:n,attrs:{shape:[A/i,i]}}),a=xh(r,!1,n),l=vm({inputs:{x:a},backend:n,attrs:{shape:o.shape}});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),l}};function Lh(e){const{backend:t,attrs:n}=e,{shape:o,value:A,dtype:i}=n,r=i||s.D5U.inferDtype(A),a=s.D5U.getArrayFromDType(r,s.D5U.sizeFromShape(o));return function(e,t,n){e.fill(t)}(a,A),t.makeTensorInfo(o,r,a)}const Sh={kernelName:s.deh,backendName:"cpu",kernelFunc:Lh},Th={kernelName:s.Uyb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:o}=e,A=n,i=s.D5U.getTypedArrayFromDType(o.dtype,s.D5U.sizeFromShape(o.shape)),[r,a,l,m]=o.shape,p=A.data.get(o.dataId).values;for(let e=0;e<r;e++){const t=e*l*a*m;for(let e=0;e<a;e++){const n=e*(l*m);for(let e=0;e<l;e++){const o=e*m;for(let A=0;A<m;A++){const r=Math.round(l-e-1),s=t+n+o+A;let a=p[s];r>=0&&r<l&&(a=p[t+n+r*m+A]),i[s]=a}}}}return{dataId:A.write(i,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},Nh=lm((e=>Math.floor(e))),Rh=zl(s.OR,Nh),Oh={kernelName:s.OR,backendName:"cpu",kernelFunc:Rh},Ph=tm(((e,t)=>Math.floor(e/t))),Uh=fm(s.jeX,Ph,null,"int32"),Vh={kernelName:s.jeX,backendName:"cpu",kernelFunc:Uh},Wh={kernelName:s._V0,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i,bias:r,preluActivationWeights:s}=t,{strides:a,pad:l,dataFormat:m,dilations:p,dimRoundingMode:h,activation:u,leakyreluAlpha:c}=o;let d=yp({inputs:{x:A,filter:i},backend:n,attrs:{strides:a,pad:l,dataFormat:m,dilations:p,dimRoundingMode:h}});if(r){const e=d;d=Dm({inputs:{a:d,b:r},backend:n}),n.disposeIntermediateTensorInfo(e)}if(u){const e=d;d=um(n,d,u,s,c),n.disposeIntermediateTensorInfo(e)}return d}},_h={kernelName:s.luS,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i,bias:r,preluActivationWeights:s}=t,{strides:a,pad:l,dataFormat:m,dilations:p,dimRoundingMode:h,activation:u,leakyreluAlpha:c}=o;let d=Vp({inputs:{x:A,filter:i},backend:n,attrs:{strides:a,pad:l,dataFormat:m,dilations:p,dimRoundingMode:h}});if(r){const e=d;d=Dm({inputs:{a:d,b:r},backend:n}),n.disposeIntermediateTensorInfo(e)}if(u){const e=d;d=um(n,d,u,s,c),n.disposeIntermediateTensorInfo(e)}return d}};function zh(e,t,n,o,A,i,r,a,l){const m=(0,s.f3b)([o,i],n);for(let n=0;n<o;n++){const o=[];let s=0;for(let t=0;t<A;t++){const i=e[n*A+t];s+=i*r[t],o.push(i)}if(s<0||s>=l/i)throw new Error(`Invalid indices: ${o} does not index into ${a}`);for(let e=0;e<i;e++)m.values[n*i+e]=t.get(...t.indexToLoc(s*i+e))}return m}const Xh={kernelName:s.q1x,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:o,indices:A}=t,i=s.D5U.sizeFromShape(o.shape),r=A.shape,a=r[r.length-1],[l,m,p,h]=s.Wap.prepareAndValidate(o,A);if(0===m)return n.makeTensorInfo(l,o.dtype,[]);const u=zh(n.data.get(A.dataId).values,n.bufferSync(o),o.dtype,m,a,p,h,o.shape,i);return n.makeTensorInfo(l,o.dtype,u.values)}};function Qh(e,t,n){const o=(0,s.f3b)(n,e.dtype);for(let n=0;n<o.size;++n){const A=o.indexToLoc(n).slice(),i=A[0],r=A[2],s=t.locToIndex([i,r]);A[2]=t.values[s];const a=e.locToIndex(A);o.values[n]=e.values[a]}return o}const Zh={kernelName:s.qi_,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,indices:i}=t,{axis:r,batchDims:a}=o;Ul([A,i],"gatherV2");const l=s.D5U.parseAxisParam(r,A.shape)[0],m=n.data.get(i.dataId).values,p=A.shape[l];for(let e=0;e<m.length;++e){const t=m[e];s.D5U.assert(t<=p-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${p-1}]`))}let h=a;null==a&&(h=0);const u=s.D5U.sizeFromShape(i.shape),c=s.Wap.segment_util.collectGatherOpShapeInfo(A,i,l,h),d=vm({inputs:{x:A},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),I=vm({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}}),G=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize],E=n.bufferSync(I),k=Qh(n.bufferSync(d),E,G);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(c.outputShape,k.dtype,k.values)}},Yh=tm(((e,t)=>e>t?1:0)),$h=fm(s.iZT,Yh,null,"bool"),eu={kernelName:s.iZT,backendName:"cpu",kernelFunc:$h},tu=tm(((e,t)=>e>=t?1:0)),nu=fm(s.Acj,tu,null,"bool"),ou={kernelName:s.Acj,backendName:"cpu",kernelFunc:nu},Au={kernelName:s.Qg5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:o}=t,A=s.D5U.sizeFromShape(o.shape),i=o.shape[o.shape.length-1],r=vm({inputs:{x:o},backend:n,attrs:{shape:[A/i,i]}}),a=xh(r,!0,n),l=vm({inputs:{x:a},backend:n,attrs:{shape:o.shape}});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),l}},iu=_l(s.avt,(e=>Number.isFinite(e)?1:0),"bool"),ru={kernelName:s.avt,backendName:"cpu",kernelFunc:iu},su=_l(s.iWB,(e=>Math.abs(e)===1/0?1:0),"bool"),au={kernelName:s.iWB,backendName:"cpu",kernelFunc:su},lu=_l(s.r7n,(e=>Number.isNaN(e)?1:0),"bool"),mu={kernelName:s.r7n,backendName:"cpu",kernelFunc:lu},pu=tm(((e,t)=>e<t?1:0)),hu=fm(s.vtC,pu,null,"bool"),uu={kernelName:s.vtC,backendName:"cpu",kernelFunc:hu},cu=tm(((e,t)=>e<=t?1:0)),du=fm(s.CAk,cu,null,"bool"),Iu={kernelName:s.CAk,backendName:"cpu",kernelFunc:du};function Gu(e,t,n){const o=(t-e)/(n-1),A=s.D5U.makeZerosTypedArray(n,"float32");A[0]=e;for(let e=1;e<A.length;e++)A[e]=A[e-1]+o;return A}const Eu={kernelName:s.e7N,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:o,stop:A,num:i}=n,r=Gu(o,A,i);return t.makeTensorInfo([r.length],"float32",r)}},ku=lm((e=>Math.log(e))),gu=zl(s.ZbH,ku),fu={kernelName:s.ZbH,backendName:"cpu",kernelFunc:gu},Hu=_l(s.kU,(e=>Math.log1p(e))),Fu={kernelName:s.kU,backendName:"cpu",kernelFunc:Hu},Cu=tm(((e,t)=>e&&t)),Du=fm(s.PYm,Cu,null,"bool"),Ju={kernelName:s.PYm,backendName:"cpu",kernelFunc:Du},vu=_l(s.VfG,(e=>e?0:1),"bool"),ju={kernelName:s.VfG,backendName:"cpu",kernelFunc:vu},Ku=tm(((e,t)=>e||t)),yu=fm(s.MZg,Ku,null,"bool"),bu={kernelName:s.MZg,backendName:"cpu",kernelFunc:yu},qu={kernelName:s.eZ0,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{depthRadius:i,bias:r,alpha:a,beta:l}=o;Ul(A,"LRN");const m=A.shape[3],p=m-1,h=n.data.get(A.dataId).values,u=s.D5U.sizeFromShape(A.shape),c=new Float32Array(u);function d(e){const t=e%m;let n=e-t+Math.max(0,t-i);const o=e-t+Math.min(t+i,p);let A=0;for(;n<=o;n++){const e=h[n];A+=e*e}return A}for(let e=0;e<u;e++){const t=d(e),n=h[e]*Math.pow(r+a*t,-l);c[e]=n}return n.makeTensorInfo(A.shape,A.dtype,c)}},xu={kernelName:s.Hhh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,y:i,dy:r}=t,{depthRadius:a,bias:l,alpha:m,beta:p}=o;Ul(r,"LRNGrad");const h=s.D5U.sizeFromShape(r.shape),u=r.shape[3],c=n.data.get(r.dataId).values,d=n.data.get(A.dataId).values,I=n.data.get(i.dataId).values,G=new Float32Array(h),E=h;for(let e=0;e<E;e++){const t=e%u,n=e-t+Math.max(0,t-a),o=e-t+Math.min(u,t+a+1);let A=0;for(let e=n;e<o;e++)A+=Math.pow(d[e],2);A=m*A+l;for(let t=n;t<o;t++){let n=-2*m*p*d[t]*I[e]/A;e===t&&(n+=Math.pow(A,-p)),n*=c[e],G[t]+=n}}return n.makeTensorInfo(r.shape,A.dtype,G)}};function Bu(e,t,n,o){const A=s.D5U.getTypedArrayFromDType(o,s.D5U.sizeFromShape(n));for(let n=0;n<A.length;++n){const o=n*t;let i=e[o];for(let n=0;n<t;++n){const t=e[o+n];(Number.isNaN(t)||t>i)&&(i=t)}A[n]=i}return A}function wu(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{reductionIndices:i,keepDims:r}=o,a=n;let l=A.shape;const m=l.length,p=s.D5U.parseAxisParam(i,l);let h=p;const u=s.Wap.getAxesPermutation(h,m);let c=a.data.get(A.dataId).values;if(null!=u){const e=new Array(m);for(let t=0;t<e.length;t++)e[t]=l[u[t]];c=Tm(c,l,A.dtype,u,e),h=s.Wap.getInnerMostAxes(h.length,m),l=e}Ul(A,"max"),s.Wap.assertAxesAreInnerMostDims("max",h,m);const[d,I]=s.Wap.computeOutAndReduceShapes(l,h),G=Bu(c,s.D5U.sizeFromShape(I),d,A.dtype),E=a.write(G,d,A.dtype);let k=d;return r&&(k=s.Wap.expandShapeToKeepDim(d,p)),{dataId:E,shape:k,dtype:A.dtype}}const Mu={kernelName:s.YoZ,backendName:"cpu",kernelFunc:wu},Lu=tm(((e,t)=>Math.max(e,t))),Su=fm(s.BMI,Lu),Tu={kernelName:s.BMI,backendName:"cpu",kernelFunc:Su},Nu={kernelName:s.mTV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t;Ul(A,"maxPool");const{filterSize:i,strides:r,pad:a,dimRoundingMode:l}=o;s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(r,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`));const m=s.Wap.computePool2DInfo(A.shape,i,r,1,a,l);let p;if(1===m.filterWidth&&1===m.filterHeight&&s.D5U.arraysEqual(m.inShape,m.outShape))p=Zl({inputs:{x:A},backend:n});else{const e=n.data.get(A.dataId).values,t=s.D5U.computeStrides(A.shape),o=op(e,A.shape,A.dtype,t,m,"max");p=n.makeTensorInfo(m.outShape,A.dtype,o.values)}return p}},Ru={kernelName:s.OAf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{filterSize:i,strides:r,pad:a,dimRoundingMode:l,dataFormat:m}=o;Ul(A,"maxPool3d");const p=s.Wap.computePool3DInfo(A.shape,i,r,1,a,l,m),h=ip(n.data.get(A.dataId).values,A.shape,A.dtype,s.D5U.computeStrides(A.shape),p,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},Ou={kernelName:s.OU7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i}=t,{filterSize:r,strides:a,pad:l,dimRoundingMode:m}=o;Ul([A,i],"maxPool3DGrad");const p=s.Wap.computePool3DInfo(i.shape,r,a,1,l,m),h=function(e,t){const n=(0,s.f3b)(t.outShape,"int32"),o=t.strideDepth,A=t.strideHeight,i=t.strideWidth,r=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,m=t.effectiveFilterDepth,p=t.effectiveFilterHeight,h=t.effectiveFilterWidth,u=t.padInfo.front,c=t.padInfo.top,d=t.padInfo.left;for(let s=0;s<t.batchSize;++s)for(let I=0;I<t.inChannels;++I)for(let G=0;G<t.outDepth;++G){const E=G*o-u;let k=E;for(;k<0;)k+=r;const g=Math.min(t.inDepth,m+E);for(let o=0;o<t.outHeight;++o){const m=o*A-c;let u=m;for(;u<0;)u+=a;const f=Math.min(t.inHeight,p+m);for(let A=0;A<t.outWidth;++A){const c=A*i-d;let H=c;for(;H<0;)H+=l;const F=Math.min(t.inWidth,h+c);let C=Number.NEGATIVE_INFINITY,D=-1;for(let t=k;t<g;t+=r){const n=t-E;for(let o=u;o<f;o+=a){const A=o-m;for(let i=H;i<F;i+=l){const r=i-c,a=e.get(s,t,o,i,I);a>=C&&(C=a,D=n*p*h+A*p+r)}}}n.set(D,s,G,o,A,I)}}}return n}(n.bufferSync(i),p),u=p.strideDepth,c=p.strideHeight,d=p.strideWidth,I=p.dilationDepth,G=p.dilationHeight,E=p.dilationWidth,k=p.effectiveFilterDepth,g=p.effectiveFilterHeight,f=p.effectiveFilterWidth,H=k-1-p.padInfo.front,F=f-1-p.padInfo.left,C=g-1-p.padInfo.top,D=(0,s.f3b)(i.shape,"float32"),J=n.bufferSync(A);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inDepth;++n)for(let o=0;o<p.inHeight;++o)for(let A=0;A<p.inWidth;++A){const i=n-H,r=o-C,s=A-F;let a=0;for(let n=0;n<k;n+=I){const o=(i+n)/u;if(!(o<0||o>=p.outDepth||Math.floor(o)!==o))for(let A=0;A<g;A+=G){const i=(r+A)/c;if(!(i<0||i>=p.outHeight||Math.floor(i)!==i))for(let r=0;r<f;r+=E){const l=(s+r)/d;if(l<0||l>=p.outWidth||Math.floor(l)!==l)continue;const m=k*g*f-1-h.get(e,o,i,l,t)===n*g*f+A*f+r?1:0;0!==m&&(a+=J.get(e,o,i,l,t)*m)}}}D.set(a,e,n,o,A,t)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}},Pu={kernelName:s.OV7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i,output:r}=t,a=i;Ul([i,r],"maxPoolGrad");const{filterSize:l,strides:m,pad:p,dimRoundingMode:h}=o,u=s.Wap.computePool2DInfo(a.shape,l,m,1,p,h),c=n.data.get(a.dataId).values,d=(0,s.f3b)(u.outShape,a.dtype,Ap(c,a.shape,a.dtype,u).values),I=u.strideHeight,G=u.strideWidth,E=u.dilationHeight,k=u.dilationWidth,g=u.effectiveFilterHeight,f=u.effectiveFilterWidth,H=f-1-u.padInfo.left,F=g-1-u.padInfo.top,C=(0,s.f3b)(a.shape,"float32"),D=n.data.get(A.dataId).values,J=(0,s.f3b)(A.shape,"float32",D);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inHeight;++n)for(let o=0;o<u.inWidth;++o){const A=n-F,i=o-H;let r=0;for(let n=0;n<g;n+=E){const o=(A+n)/I;if(!(o<0||o>=u.outHeight||Math.floor(o)!==o))for(let A=0;A<f;A+=k){const s=(i+A)/G;if(s<0||s>=u.outWidth||Math.floor(s)!==s)continue;const a=g*f-1-d.get(e,o,s,t)===n*f+A?1:0;0!==a&&(r+=J.get(e,o,s,t)*a)}}C.set(r,e,n,o,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},Uu={kernelName:s.vFR,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:o}=e,{filterSize:A,strides:i,pad:r,includeBatchInIndex:a}=t,l=n;Ul(o,"MaxPoolWithArgmax");const m=l.data.get(o.dataId).values,p=s.Wap.computePool2DInfo(o.shape,A,i,[1,1],r),[h,u]=function(e,t,n,o,A){const i=op(e,0,n,s.D5U.computeStrides(t),A,"max"),r=Ap(e,t,n,A,!0,o);return[i.values,r.values]}(m,o.shape,o.dtype,a,p),c=l.write(h,p.outShape,o.dtype),d=l.write(u,p.outShape,o.dtype);return[{dataId:c,shape:p.outShape,dtype:o.dtype},{dataId:d,shape:p.outShape,dtype:"int32"}]}},Vu={kernelName:s.q2K,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o,a=s.D5U.parseAxisParam(i,A.shape),l=s.Wap.computeOutAndReduceShapes(A.shape,a)[1],m=s.D5U.sizeFromShape(l),p=[],h=n.makeTensorInfo([],"float32",new Float32Array([m]));p.push(h);const u=km({inputs:{x:A},backend:n,attrs:{dtype:"float32"}});p.push(u);const c=vh({inputs:{a:u,b:h},backend:n});p.push(c);const d=oh({inputs:{x:c},backend:n,attrs:{axis:i,keepDims:r}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},Wu={kernelName:s.c17,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o;Ul(A,"min");const a=s.D5U.parseAxisParam(i,A.shape);let l=a;const m=s.Wap.getAxesPermutation(l,A.shape.length);let p=A;null!=m&&(p=Nm({inputs:{x:A},backend:n,attrs:{perm:m}}),l=s.Wap.getInnerMostAxes(l.length,A.shape.length)),s.Wap.assertAxesAreInnerMostDims("min",l,p.shape.length);const[h,u]=s.Wap.computeOutAndReduceShapes(p.shape,l),c=s.D5U.sizeFromShape(u),d=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(h),p.dtype),I=n.data.get(p.dataId).values;for(let e=0;e<d.length;++e){const t=e*c;let n=I[t];for(let e=0;e<c;++e){const o=I[t+e];(Number.isNaN(o)||o<n)&&(n=o)}d[e]=n}null!=m&&n.disposeIntermediateTensorInfo(p);const G=n.makeTensorInfo(h,p.dtype,d);if(r){const e=vm({inputs:{x:G},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(h,a)}});return n.disposeIntermediateTensorInfo(G),e}return G}},_u=tm(((e,t)=>Math.min(e,t))),zu=fm(s.q8u,_u),Xu={kernelName:s.q8u,backendName:"cpu",kernelFunc:zu},Qu={kernelName:s.jQs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{paddings:i,mode:r}=o;Ul(A,"mirrorPad");const a=i.map(((e,t)=>e[0]+A.shape[t]+e[1])),l=i.map((e=>e[0])),m=i.map(((e,t)=>e[0]+A.shape[t])),p="reflect"===r?0:1,h=n.data.get(A.dataId).values,u=A.shape.length,c=s.D5U.computeStrides(A.shape),d=s.D5U.sizeFromShape(a),I=a.length,G=s.D5U.computeStrides(a),E=s.D5U.getTypedArrayFromDType(A.dtype,d);for(let e=0;e<d;e++){let t=s.D5U.indexToLoc(e,I,G);for(let e=0;e<I;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-p:t[e]>=m[e]&&(t[e]=2*(m[e]-1)-t[e]+p);t=t.map(((e,t)=>e-l[t]));const n=s.D5U.locToIndex(t,u,c);E[e]=h[n]}return{dataId:n.write(E,a,A.dtype),shape:a,dtype:A.dtype}}},Zu=tm(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),Yu=fm(s.Vbg,Zu),$u={kernelName:s.Vbg,backendName:"cpu",kernelFunc:Yu};function ec(e){const{inputs:t,backend:n,attrs:o}=e,{logits:A}=t,{dim:i}=o,r=A.shape.length;let a=i;if(-1===a&&(a=r-1),a!==r-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r} and dim was ${a}`);const l=s.D5U.parseAxisParam([a],A.shape),m=wu({inputs:{x:A},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=s.Wap.expandShapeToKeepDim(m.shape,l),h=vm({inputs:{x:m},backend:n,attrs:{shape:p}}),u=bh({inputs:{a:A,b:h},backend:n}),c=kh({inputs:{x:u},backend:n}),d=oh({inputs:{x:c},backend:n,attrs:{axis:l,keepDims:!1}}),I=vm({inputs:{x:d},backend:n,attrs:{shape:p}}),G=vh({inputs:{a:c,b:I},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(I),G}const tc={kernelName:s.Gcp,backendName:"cpu",kernelFunc:ec},nc={kernelName:s.NZg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{logits:A}=t,{numSamples:i,seed:r,normalized:a}=o;Ul(A,"multinomial");const l=a?A:ec({inputs:{logits:A},backend:n,attrs:{dim:-1}}),m=l.shape[0],p=l.shape[1],h=n.data.get(l.dataId).values,u=[m,i],c=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(u),"int32");for(let e=0;e<m;++e){const t=e*p,n=new Float32Array(p-1);n[0]=h[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+h[t+e];const o=dl.alea(r.toString()),A=e*i;for(let e=0;e<i;++e){const t=o();c[A+e]=n.length;for(let o=0;o<n.length;o++)if(t<n[o]){c[A+e]=o;break}}}return a||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(u,"int32",c)}};function oc(e,t,n){const o=s.D5U.createScalarValue(-1,n);return $p([],t,o,e,n)}const Ac={kernelName:s.kuV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t;Ul(o,"neg");const A=n.data.get(o.dataId).values,[i,r]=oc(A,o.shape,o.dtype);return n.makeTensorInfo(r,o.dtype,i)}},ic=s.GDt.GP,rc={kernelName:s.uv1,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{boxes:A,scores:i}=t,{maxOutputSize:r,iouThreshold:s,scoreThreshold:a}=o;Ul(A,"NonMaxSuppression");const l=n.data.get(A.dataId).values,m=n.data.get(i.dataId).values,{selectedIndices:p}=ic(l,m,r,s,a);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}},sc=s.GDt.qP,ac={kernelName:s.cye,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{boxes:A,scores:i}=t,{maxOutputSize:r,iouThreshold:s,scoreThreshold:a,padToMaxOutputSize:l}=o;Ul(A,"NonMaxSuppressionPadded");const m=n.data.get(A.dataId).values,p=n.data.get(i.dataId).values,{selectedIndices:h,validOutputs:u}=sc(m,p,r,s,a,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([u]))]}},lc=s.GDt.pA,mc={kernelName:s.W0H,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{boxes:A,scores:i}=t,{maxOutputSize:r,iouThreshold:s,scoreThreshold:a,softNmsSigma:l}=o;Ul(A,"NonMaxSuppressionWithScore");const m=n.data.get(A.dataId).values,p=n.data.get(i.dataId).values,h=r,u=s,c=a,d=l,{selectedIndices:I,selectedScores:G}=lc(m,p,h,u,c,d);return[n.makeTensorInfo([I.length],"int32",new Int32Array(I)),n.makeTensorInfo([G.length],"float32",new Float32Array(G))]}},pc=tm(((e,t)=>e!==t?1:0)),hc=fm(s.yQU,pc,null,"bool"),uc={kernelName:s.yQU,backendName:"cpu",kernelFunc:hc},cc={kernelName:s.we_,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{indices:A}=t,{depth:i,onValue:r,offValue:a}=o;Ul(A,"oneHot");const l=s.D5U.sizeFromShape(A.shape),m=new Float32Array(l*i);m.fill(a);const p=n.data.get(A.dataId).values;for(let e=0;e<l;++e)p[e]>=0&&p[e]<i&&(m[e*i+p[e]]=r);return n.makeTensorInfo([...A.shape,i],"int32",m)}};function dc(e){const{inputs:t,backend:n}=e,{x:o}=t;if("string"===o.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===o.dtype){const e=Gm({inputs:{input:o},backend:n}),t=dc({inputs:{x:e},backend:n}),A=Jp({inputs:{input:o},backend:n}),i=dc({inputs:{x:A},backend:n}),r=cm({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(i),r}return Lh({backend:n,attrs:{shape:o.shape,value:0,dtype:o.dtype}})}const Ic={kernelName:s.RuY,backendName:"cpu",kernelFunc:dc},Gc={kernelName:s.qWM,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:o}=t,{x:A}=n;if("string"===A.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===A.dtype){const t=Gm({inputs:{input:A},backend:o}),n=e({inputs:{x:t},backend:o}),i=Jp({inputs:{input:A},backend:o}),r=dc({inputs:{x:i},backend:o}),s=cm({inputs:{real:n,imag:r},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(n),o.disposeIntermediateTensorInfo(i),o.disposeIntermediateTensorInfo(r),s}return Lh({backend:o,attrs:{shape:A.shape,value:1,dtype:A.dtype}})}};function Ec(e){const{inputs:t,backend:n,attrs:o}=e,{axis:A}=o;if(1===t.length)return fh({inputs:{input:t[0]},backend:n,attrs:{dim:A}});const i=t[0].shape,r=t[0].dtype;t.forEach((e=>{s.D5U.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),s.D5U.assert(r===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const a=[],l=t.map((e=>{const t=fh({inputs:{input:e},backend:n,attrs:{dim:A}});return a.push(t),t})),m=jp({inputs:l,backend:n,attrs:{axis:A}});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}const kc={kernelName:s.QiL,backendName:"cpu",kernelFunc:Ec},gc={kernelName:s.lyA,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{paddings:i,constantValue:r}=o;Ul(A,"pad");const a=i.map(((e,t)=>e[0]+A.shape[t]+e[1])),l=i.map((e=>e[0])),m=n.data.get(A.dataId).values,p=s.D5U.sizeFromShape(A.shape),h=A.shape.length,u=s.D5U.computeStrides(A.shape),c=s.D5U.sizeFromShape(a),d=a.length,I=s.D5U.computeStrides(a),G=s.D5U.getTypedArrayFromDType(A.dtype,c);0!==r&&G.fill(r);for(let e=0;e<p;e++){const t=s.D5U.indexToLoc(e,h,u).map(((e,t)=>e+l[t]));G[s.D5U.locToIndex(t,d,I)]=m[e]}return{dataId:n.write(G,a,A.dtype),shape:a,dtype:A.dtype}}},fc=tm(((e,t)=>Math.pow(e,t))),Hc=fm(s.pe_,fc),Fc={kernelName:s.pe_,backendName:"cpu",kernelFunc:Hc};function Cc(e,t,n,o){const[A,i]=s.Wap.computeOutAndReduceShapes(e,o),r=(0,s.x8V)(t,"int32"),a=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(A),r),l=s.D5U.sizeFromShape(i);for(let e=0;e<a.length;++e){const t=e*l;let o=1;for(let e=0;e<l;++e)o*=n[t+e];a[e]=o}return{outVals:a,outShape:A,outDtype:r}}const Dc={kernelName:s.DlI,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o;Ul(A,"prod");const a=A.shape.length,l=s.D5U.parseAxisParam(i,A.shape),m=s.Wap.getAxesPermutation(l,a);let p=l,h=A;const u=[];null!=m&&(h=Nm({inputs:{x:A},backend:n,attrs:{perm:m}}),u.push(h),p=s.Wap.getInnerMostAxes(p.length,a));const c=n.data.get(h.dataId).values,{outVals:d,outShape:I,outDtype:G}=Cc(h.shape,h.dtype,c,p);let E=I;return r&&(E=s.Wap.expandShapeToKeepDim(I,l)),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(E,G,d)}};function Jc(e,t,n,o){if(e===t||e<t&&n<0||t<e&&n>1)return s.D5U.makeZerosTypedArray(0,o);const A=Math.abs(Math.ceil((t-e)/n)),i=s.D5U.makeZerosTypedArray(A,o);t<e&&1===n&&(n=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+n;return i}const vc={kernelName:s.e6w,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:o,stop:A,dtype:i,step:r}=n,s=Jc(o,A,r,i);return t.makeTensorInfo([s.length],i,s)}},jc=_l(s.$HU,(e=>1/e)),Kc={kernelName:s.$HU,backendName:"cpu",kernelFunc:jc},yc={kernelName:s._Yw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A}=t,{alignCorners:i,halfPixelCenters:r,size:a}=o;Ul(A,"resizeBilinear");const l=s.D5U.computeStrides(A.shape),[m,p]=a,[h,u,c,d]=A.shape,I=n.data.get(A.dataId).values,G=new Float32Array(s.D5U.sizeFromShape([h,m,p,d])),E=[i&&m>1?u-1:u,i&&p>1?c-1:c],k=[i&&m>1?m-1:m,i&&p>1?p-1:p];let g=0;const f=E[0]/k[0],H=E[1]/k[1];for(let e=0;e<h;e++)for(let t=0;t<m;t++){let n;n=r?f*(t+.5)-.5:f*t;const o=Math.max(0,Math.floor(n)),A=n-o,i=Math.min(u-1,Math.ceil(n)),s=e*l[0]+o*l[1],a=e*l[0]+i*l[1];for(let e=0;e<p;e++){let t;t=r?H*(e+.5)-.5:H*e;const n=Math.max(0,Math.floor(t)),o=t-n,i=Math.min(c-1,Math.ceil(t)),m=s+n*l[2],p=a+n*l[2],h=s+i*l[2],u=a+i*l[2];for(let e=0;e<d;e++){const t=I[m+e],n=I[p+e],i=t+(I[h+e]-t)*o,r=i+(n+(I[u+e]-n)*o-i)*A;G[g++]=r}}}return n.makeTensorInfo([h,m,p,d],"float32",G)}},bc={kernelName:s.zbQ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A,dy:i}=t,{alignCorners:r}=o;Ul([i,A],"resizeBilinearGrad");const a=s.D5U.computeStrides(A.shape),[l,m,p,h]=A.shape,[,u,c]=i.shape,d=new Float32Array(l*m*p*h),I=[r&&u>1?m-1:m,r&&c>1?p-1:p],G=[r&&u>1?u-1:u,r&&c>1?c-1:c],E=I[0]/G[0],k=I[1]/G[1],g=n.data.get(i.dataId).values;let f=0;for(let e=0;e<l;e++){const t=e*a[0];for(let e=0;e<u;e++){const n=e*E,o=Math.floor(n),A=Math.min(Math.ceil(n),m-1),i=t+o*a[1],r=t+A*a[1],s=n-o,l=1-s;for(let e=0;e<c;e++){const t=e*k,n=Math.floor(t),o=Math.min(Math.ceil(t),p-1),A=t-n,m=1-A,u=i+n*a[2],c=i+o*a[2],I=r+n*a[2],G=r+o*a[2],E=l*m,H=l*A,F=s*m,C=s*A;for(let e=0;e<h;e++){const t=g[f++];d[u+e]+=t*E,d[c+e]+=t*H,d[I+e]+=t*F,d[G+e]+=t*C}}}}return n.makeTensorInfo([l,p,m,h],"float32",d)}},qc={kernelName:s.dpD,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A}=t,{alignCorners:i,halfPixelCenters:r,size:a}=o;Ul(A,"resizeNearestNeighbor");const l=s.D5U.computeStrides(A.shape),[m,p]=a,[h,u,c,d]=A.shape,I=n.data.get(A.dataId).values,G=new Float32Array(h*m*p*d),E=[i&&m>1?u-1:u,i&&p>1?c-1:c],k=[i&&m>1?m-1:m,i&&p>1?p-1:p],g=E[0]/k[0],f=E[1]/k[1];let H=0;for(let e=0;e<h;e++){const t=e*l[0];for(let e=0;e<m;e++){const n=r?g*(e+.5):g*e;let o=Math.min(u-1,i?Math.round(n):Math.floor(n));r&&(o=Math.max(0,o));const A=t+o*l[1];for(let e=0;e<p;e++){const t=r?f*(e+.5):f*e;let n=Math.min(c-1,i?Math.round(t):Math.floor(t));r&&(n=Math.max(0,n));const o=A+n*l[2];for(let e=0;e<d;e++){const t=I[o+e];G[H++]=t}}}}return n.makeTensorInfo([h,m,p,d],A.dtype,G)}},xc={kernelName:s.Hmb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A,dy:i}=t,{alignCorners:r}=o;Ul([i,A],"resizeNearestNeighborGrad");const a=s.D5U.computeStrides(A.shape),l=s.D5U.computeStrides(i.shape),[m,p,h,u]=A.shape,[,c,d]=i.shape,I=new Float32Array(m*p*h*u),G=n.data.get(i.dataId).values,E=[r&&c>1?p-1:p,r&&d>1?h-1:h],k=[r&&c>1?c-1:c,r&&d>1?d-1:d],g=E[0]/k[0],f=E[1]/k[1],H=1/g,F=1/f,C=2*Math.ceil(H)+2,D=2*Math.ceil(F)+2;for(let e=0;e<m;e++){const t=e*a[0];for(let e=0;e<p;e++){const n=t+e*a[1],o=Math.floor(e*H),A=Math.floor(o-C/2);for(let o=0;o<h;o++){const i=n+o*a[2],s=Math.floor(o*F),m=Math.floor(s-D/2);for(let n=0;n<u;n++){let s=0;for(let i=0;i<C;i++){const a=i+A;if(a<0||a>=c)continue;const u=t+a*l[1],I=a*g;if(e===Math.min(p-1,r?Math.round(I):Math.floor(I)))for(let e=0;e<D;e++){const t=e+m;if(t<0||t>=d)continue;const A=u+t*l[2],i=t*f;o===Math.min(h-1,r?Math.round(i):Math.floor(i))&&(s+=G[A+n])}}I[i+n]=s}}}}return n.makeTensorInfo(A.shape,A.dtype,I)}},Bc={kernelName:s.mKl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{dims:i}=o;Ul(A,"reverse");const r=A.shape.length,a=s.D5U.parseAxisParam(i,A.shape);if(0===r)return Zl({inputs:{x:A},backend:n});const l=new s.YDk(A.shape,A.dtype),m=n.bufferSync(A);for(let e=0;e<l.size;e++){const t=l.indexToLoc(e),n=t.slice();a.forEach((e=>n[e]=A.shape[e]-1-n[e])),l.set(m.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},wc={kernelName:s.b9H,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:o}=e,{radians:A,fillValue:i,center:r}=t,a=n,l=s.D5U.getTypedArrayFromDType(o.dtype,s.D5U.sizeFromShape(o.shape)),[m,p,h,u]=o.shape,[c,d]=s.Wap.getImageCenter(r,p,h),I=Math.sin(A),G=Math.cos(A),E=a.data.get(o.dataId).values;for(let e=0;e<m;e++){const t=e*h*p*u;for(let e=0;e<p;e++){const n=e*(h*u);for(let o=0;o<h;o++){const A=o*u;for(let r=0;r<u;r++){const s=[m,e,o,r],a=s[2],k=s[1];let g=(a-c)*G-(k-d)*I,f=(a-c)*I+(k-d)*G;g=Math.round(g+c),f=Math.round(f+d);let H=i;"number"!=typeof i&&(H=3===r?255:i[r]),g>=0&&g<h&&f>=0&&f<p&&(H=E[t+f*(h*u)+g*u+r]),l[t+n+A+r]=H}}}}return{dataId:a.write(l,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},Mc=_l(s.e07,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),Lc={kernelName:s.e07,backendName:"cpu",kernelFunc:Mc},Sc=lm((e=>1/Math.sqrt(e))),Tc=zl(s.bV0,Sc),Nc={kernelName:s.bV0,backendName:"cpu",kernelFunc:Tc};function Rc(e,t,n,o,A,i,r,a,l,m){const p=[o/A,A],h=e.values,u=t.values;if(0===o)return(0,s.f3b)(n,t.dtype);const c=(0,s.f3b)(p,t.dtype);c.values.fill(l);for(let e=0;e<i;e++){const i=[];let s=0;for(let t=0;t<r;t++){const n=h[e*r+t];i.push(n),s+=n*a[t]}if(s<0||s>=o/A)throw new Error(`Invalid indices: ${i} does not index into ${n}`);for(let n=0;n<A;n++)m?c.values[s*A+n]+=u[e*A+n]:c.values[s*A+n]=0===t.rank?u[0]:u[e*A+n]}return c}const Oc={kernelName:s.xQA,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{indices:A,updates:i}=t,{shape:r}=o,{sliceRank:a,numUpdates:l,sliceSize:m,strides:p,outputSize:h}=s.Wap.calculateShapes(i,A,r),u=Rc(n.bufferSync(A),n.bufferSync(i),r,h,m,l,a,p,0,!0);return n.makeTensorInfo(r,u.dtype,u.values)}},Pc={kernelName:s.PhF,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:o,t:A,e:i}=t;Ul([o,A,i],"select");const r=o.shape.length,a=n.data.get(o.dataId).values,l=n.data.get(A.dataId).values,m=n.data.get(i.dataId).values,p=(0,s.x8V)(A.dtype,i.dtype),h=s.D5U.makeZerosTypedArray(s.D5U.sizeFromShape(A.shape),p);let u=0;const c=0===r||r>1||1===A.shape.length?1:s.D5U.sizeFromShape(A.shape.slice(1));for(let e=0;e<a.length;e++)for(let t=0;t<c;t++)1===a[e]?h[u++]=l[e]:h[u++]=m[e];return n.makeTensorInfo(A.shape,p,h)}},Uc=s.Wap.SELU_SCALEALPHA,Vc=s.Wap.SELU_SCALE,Wc=_l(s.oFR,(e=>e>=0?Vc*e:Uc*(Math.exp(e)-1))),_c={kernelName:s.oFR,backendName:"cpu",kernelFunc:Wc},zc=_l(s.i5y,(e=>e<0?-1:e>0?1:0)),Xc={kernelName:s.i5y,backendName:"cpu",kernelFunc:zc},Qc=_l(s.RQH,(e=>Math.sin(e))),Zc={kernelName:s.RQH,backendName:"cpu",kernelFunc:Qc},Yc=_l(s.wYB,(e=>Math.sinh(e))),$c={kernelName:s.wYB,backendName:"cpu",kernelFunc:Yc},ed=Math.log(1.1920928955078125e-7)+2,td=_l(s.MRv,(e=>{const t=e>-ed,n=e<ed,o=Math.exp(e);let A;return A=n?o:t?e:Math.log(1+o),A})),nd={kernelName:s.MRv,backendName:"cpu",kernelFunc:td},od={kernelName:s.TQc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{blockShape:i,paddings:r}=o;Ul([A],"spaceToBatchND");const a=s.D5U.sizeFromShape(i),l=[[0,0]];l.push(...r);for(let e=1+i.length;e<A.shape.length;++e)l.push([0,0]);const m=gc.kernelFunc({inputs:{x:A},backend:n,attrs:{paddings:l,constantValue:0}}),p=s.Wap.getReshaped(m.shape,i,a,!1),h=s.Wap.getPermuted(p.length,i.length,!1),u=s.Wap.getReshapedPermuted(m.shape,i,a,!1),c=vm({inputs:{x:m},backend:n,attrs:{shape:p}}),d=Nm({inputs:{x:c},backend:n,attrs:{perm:h}}),I=vm({inputs:{x:d},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),I}};function Ad(e,t,n,o,A,i,r){const a=t[0],l=i[0],m=new Array(l),p=new Array(a),h=t[1];if(0===l){if(0!==a)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${a}`);return[s.D5U.getArrayFromDType(n,0),[0,h],s.D5U.getArrayFromDType(A,0),m,p]}let u=!0,c=0;const d=new Array(l).fill(0);for(let t=0;t<a;++t){const n=e[t*h];if(n<0)throw new Error(`indices(${t}, 0) is invalid: ${n} < 0`);if(n>=l)throw new Error(`indices(${t}, 0) is invalid: ${n} >= ${l}`);++d[n],u=u&&n>=c,c=n}let I=!0;for(let e=0;e<l;++e){const t=0===d[e];m[e]=t,I=I&&!t,d[e]=Math.max(d[e],1),e>0&&(d[e]+=d[e-1])}if(I&&u){const t=e,n=o;for(let e=0;e<a;++e)p[e]=e;return[t,[a,h],n,m,p]}{const t=d[l-1],i=s.D5U.getArrayFromDType(n,t*h),u=s.D5U.getArrayFromDType(A,t),c=new Array(l).fill(0);for(let t=0;t<a;++t){const n=e[t*h],A=c[n],r=(0===n?0:d[n-1])+A;c[n]++;for(let n=0;n<h;++n)i[r*h+n]=e[t*h+n];u[r]=o[t],p[t]=r}for(let e=0;e<l;++e)if(0===c[e]){const t=0===e?0:d[e-1];i[t*h+0]=e;for(let e=1;e<h;++e)i[t*h+e]=0;u[t]=r}return[i,[t,h],u,m,p]}}const id={kernelName:s.O3z,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:o,values:A,denseShape:i,defaultValue:r}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==o.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${o.shape}`);if(1!==A.shape.length)throw new Error(`Values must be a vector, saw:\n        ${A.shape}`);if(0!==r.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${r.shape}`);const s=n.data.get(o.dataId).values,a=n.data.get(A.dataId).values,l=n.data.get(i.dataId).values,m=n.data.get(r.dataId).values[0],[p,h,u,c,d]=Ad(s,o.shape,o.dtype,a,A.dtype,l,m);return[n.makeTensorInfo(h,o.dtype,p),n.makeTensorInfo([h[0]],A.dtype,u),n.makeTensorInfo([c.length],"bool",new Uint8Array(c.map((e=>Number(e))))),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function rd(e,t,n,o,A){const i=s.D5U.sizeFromShape(o),r=t[0],a=A.length,l=[];let m=1,p=-1;for(let e=0;e<a;++e){const t=A[e];if(-1===t){if(-1!==p)throw new Error(`only one output dimension may be -1, not both ${p} and ${e}`);p=e,l.push(1)}else{if(t<0)throw new Error(`size ${e} must be non-negative, not ${t}`);m*=t,l.push(t)}}if(-1!==p){if(m<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(i/m);if(m*e!==i)throw new Error(`Input to reshape is a SparseTensor with ${i}\n          dense values, but the requested shape requires a multiple of ${m}. inputShape=${o} outputShape= ${l}`);l[p]=e}const h=s.D5U.sizeFromShape(l);if(h!==i)throw new Error(`Input to reshape is a tensor with ${i} dense values, but the requested shape has ${h}. inputShape=${o} outputShape=${l}`);const u=o.length,c=[];if(u>0){c[u-1]=1;for(let e=u-2;e>=0;--e)c[e]=c[e+1]*o[e+1]}const d=[];if(a>0){d[a-1]=1;for(let e=a-2;e>=0;--e)d[e]=d[e+1]*l[e+1]}const I=s.D5U.getArrayFromDType(n,r*a);for(let t=0;t<r;++t){let n=0;for(let o=0;o<u;++o)n+=e[t*u+o]*c[o];for(let e=0;e<a;++e)I[t*a+e]=Math.trunc(n/d[e]),n%=d[e]}return[I,[r,a],l]}const sd={kernelName:s.nhH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:o,inputShape:A,newShape:i}=t;if(2!==o.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${o.shape}`);if(1!==A.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${A.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const r=Array.from(n.data.get(A.dataId).values),s=n.data.get(o.dataId).values,a=Array.from(n.data.get(i.dataId).values),[l,m,p]=rd(s,o.shape,o.dtype,r,a);return[n.makeTensorInfo(m,o.dtype,l),n.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}};function ad(e,t,n,o,A,i=!1,r=0){const a=o.length;if(a!==A.length)throw new Error("segmentIds and indices should have same size.");const l=[t[0],e.length/t[0]],m=l[1],p=a>0?A[a-1]+1:0;if(p<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=p;const u=h.reduce(((e,t)=>e*t),1),c=s.D5U.getArrayFromDType(n,u);if(0===a)return p>0&&c.fill(r),[c,h];if(p<=0)throw new Error("segment ids must be >= 0");let d=0,I=1,G=0,E=A[d];for(;;){let t=0;if(I<a){if(t=A[I],E===t){++I;continue}if(E>=t)throw new Error("segment ids are not increasing")}if(E<0||E>=p)throw new Error(`Segment id ${E} out of range [0, ${p}), possibly because segmentIds input is not sorted.`);E>G&&c.fill(r,G*m,E*m);for(let t=d;t<I;++t){const n=o[t];if(n<0||n>=l[0])throw new Error(`Bad: indices[${t}] == ${o[t]} out of range [0, ${l[0]})`);for(let t=0;t<m;t++)c[E*m+t]+=e[n*m+t]}if(i)for(let e=0;e<m;e++)c[E*m+e]/=I-d;if(d=I,++I,G=E+1,E=t,I>a)break}return G<p&&c.fill(r,G*m,p*m),[c,h]}const ld={kernelName:s.w3H,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:o,indices:A,segmentIds:i}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==A.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${A.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);const r=n.data.get(o.dataId).values,s=n.data.get(A.dataId).values,a=n.data.get(i.dataId).values,[l,m]=ad(r,o.shape,o.dtype,s,a,!0);return n.makeTensorInfo(m,o.dtype,l)}},md={kernelName:s.ZjV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:o,indices:A,segmentIds:i}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==A.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${A.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);const r=n.data.get(o.dataId).values,s=n.data.get(A.dataId).values,a=n.data.get(i.dataId).values,[l,m]=ad(r,o.shape,o.dtype,s,a);return n.makeTensorInfo(m,o.dtype,l)}},pd={kernelName:s.D2d,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{sparseIndices:A,sparseValues:i,defaultValue:r}=t,{outputShape:a}=o,{sliceRank:l,numUpdates:m,sliceSize:p,strides:h,outputSize:u}=s.Wap.calculateShapes(i,A,a),c=Rc(n.bufferSync(A),n.bufferSync(i),a,u,p,m,l,h,n.data.get(r.dataId).values[0],!1);return n.makeTensorInfo(a,c.dtype,c.values)}},hd={kernelName:s.L8s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{numOrSizeSplits:i,axis:r}=o,a=s.D5U.parseAxisParam(r,A.shape)[0],l=s.Wap.prepareSplitSize(A,i,a),m=new Array(A.shape.length).fill(0),p=A.shape.slice();return l.map((e=>{const t=[...p];t[a]=e;const o=hp({inputs:{x:A},backend:n,attrs:{begin:m,size:t}});return m[a]+=e,o}))}},ud=lm((e=>Math.sqrt(e))),cd=_l(s.FKq,(e=>Math.sqrt(e))),dd={kernelName:s.FKq,backendName:"cpu",kernelFunc:cd},Id={kernelName:s.bK0,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,o=t;Ul(n,"square");const A=o.data.get(n.dataId).values,i=new Float32Array(A.length);for(let e=0;e<A.length;++e){const t=A[e];i[e]=t*t}return{dataId:o.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Gd=tm(((e,t)=>{const n=e-t;return n*n})),Ed=fm(s._tC,Gd),kd={kernelName:s._tC,backendName:"cpu",kernelFunc:Ed},gd=_l(s.h8e,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),fd={kernelName:s.h8e,backendName:"cpu",kernelFunc:gd};function Hd(e,t,n,o){const A=(0,s.f3b)(e,t.dtype);for(let e=0;e<A.size;e++){const i=A.indexToLoc(e),r=new Array(i.length);for(let e=0;e<r.length;e++)r[e]=i[e]*n[e]+o[e];A.set(t.get(...r),...i)}return A}const Fd={kernelName:s.jQk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{begin:i,end:r,strides:a,beginMask:l,endMask:m,ellipsisMask:p,newAxisMask:h,shrinkAxisMask:u}=o;Ul(A,"stridedSlice");const{finalShapeSparse:c,finalShape:d,isIdentity:I,sliceDim0:G,isSimpleSlice:E,begin:k,end:g,strides:f}=s.kuN.sliceInfo(A.shape,i,r,a,l,m,p,h,u);let H;if(I)H=vm({inputs:{x:A},backend:n,attrs:{shape:d}});else if(G||E){s.D5U.assert(A.shape.length>=1,(()=>`Input must have rank at least 1, got: ${A.shape.length}`));const e=s.kuN.computeOutShape(k,g,f),t=hp({inputs:{x:A},backend:n,attrs:{begin:k,size:e}});H=vm({inputs:{x:t},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(t)}else{const e=Hd(c,n.bufferSync(A),f,k);H=n.makeTensorInfo(d,e.dtype,e.values)}return H}};class Cd{constructor(e,t,n,o,A,i){this.separator=s.D5U.encodeString(e),this.nGramWidths=t,this.leftPad=s.D5U.encodeString(n),this.rightPad=s.D5U.encodeString(o),this.padWidth=A,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,o,A,i){for(let r=0;r<A;++r){const s=this.getPadWidth(i),a=Math.max(0,s-r),l=Math.max(0,s-(A-(r+1))),m=i-(a+l),p=t+(a>0?0:r-s);let h=0;h+=a*this.leftPad.length;for(let t=0;t<m;++t)h+=e[p+t].length;h+=l*this.rightPad.length,h+=(a+l+m-1)*this.separator.length,n[o+r]=new Uint8Array(h);const u=n[o+r];let c=0;const d=e=>e.forEach((e=>u[c++]=e));for(let e=0;e<a;++e)d(this.leftPad),d(this.separator);for(let t=0;t<m-1;++t)d(e[p+t]),d(this.separator);if(m>0){d(e[p+m-1]);for(let e=0;e<l;++e)d(this.separator),d(this.rightPad)}else{for(let e=0;e<l-1;++e)d(this.rightPad),d(this.separator);d(this.rightPad)}}}compute(e,t){const n=e.length,o=t.length;if(o>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let A=1;A<o;++A){let o=t[A]>=e;if(o=o&&t[A]<=n,!o)throw new Error(`Invalid split value ${t[A]}, must be in [${e}, ${n}]`);e=t[A]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const A=o-1,i=s.D5U.getArrayFromDType("int32",o);if(0===n||0===o){const e=new Array(n);for(let e=0;e<=A;++e)i[e]=0;return[e,i]}i[0]=0;for(let e=1;e<=A;++e){const n=t[e]-t[e-1];let o=0;this.nGramWidths.forEach((e=>{o+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===o&&(o=1),i[e]=i[e-1]+o}const r=new Array(i[A]);for(let n=0;n<A;++n){const o=t[n];let A=i[n];if(this.nGramWidths.forEach((i=>{const s=t[n+1]-t[n],a=this.getNumNGrams(s,i);this.createNGrams(e,o,r,A,a,i),A+=a})),this.preserveShort&&A===i[n]){const i=t[n+1]-t[n];if(0===i)continue;const s=i+2*this.padWidth,a=1;this.createNGrams(e,o,r,A,a,s)}}return[r,i]}}function Dd(e,t,n,o,A,i,r,s){return new Cd(n,o,A,i,r,s).compute(e,t)}const Jd={kernelName:s._JP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{separator:A,nGramWidths:i,leftPad:r,rightPad:s,padWidth:a,preserveShortSequences:l}=o,{data:m,dataSplits:p}=t,h=n.data.get(m.dataId).values,u=n.data.get(p.dataId).values,[c,d]=Dd(h,u,A,i,r,s,a,l);return[n.makeTensorInfo([c.length],"string",c),n.makeTensorInfo(p.shape,"int32",d)]}};function vd(e,t,n,o){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)o.push(e.subarray(t,t+1));return}if(1===t.length){const A=t[0];let i=e.indexOf(A);for(;-1!==i;){const t=e.subarray(0,i);n&&0===t.length||o.push(t),i=(e=e.subarray(i+1)).indexOf(A)}return void(n&&0===e.length||o.push(e))}let A=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){const t=e.subarray(A,i);n&&0===t.length||o.push(t),A=i+1}}function jd(e,t,n){const o=e.length,A=[];let i=0,r=0;const a=new Array(o);for(let s=0;s<o;++s){const o=A.length;vd(e[s],t,n,A);const l=A.length-o;a[s]=l,i+=l,r=Math.max(r,l)}const l=s.D5U.getArrayFromDType("int32",2*i),m=new Array(i),p=[o,r];let h=0;for(let e=0;e<o;++e)for(let t=0;t<a[e];++t)l[2*h]=e,l[2*h+1]=t,m[h]=A[h],++h;return[l,m,p]}const Kd={kernelName:s.s1s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{skipEmpty:A}=o,{input:i,delimiter:r}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==r.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const s=n.data.get(i.dataId).values,a=n.data.get(r.dataId).values[0],[l,m,p]=jd(s,a,A),h=m.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",m),n.makeTensorInfo([2],"int32",new Int32Array(p))]}};function yd(e,t){const n=s.D5U.getArrayFromDType("int32",e.length);for(let o=0;o<e.length;++o)n[o]=s.D5U.fingerPrint64(e[o]).modulo(t).getLowBitsUnsigned();return n}const bd={kernelName:s.XkS,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{numBuckets:A}=o,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(A<=0)throw new Error("Number of buckets must be at least 1");const r=yd(n.data.get(i.dataId).values,A);return n.makeTensorInfo(i.shape,"int32",r)}},qd=_l(s.sEM,(e=>Math.tan(e))),xd={kernelName:s.sEM,backendName:"cpu",kernelFunc:qd},Bd=_l(s.MIZ,(e=>Math.tanh(e))),wd={kernelName:s.MIZ,backendName:"cpu",kernelFunc:Bd};function Md(e,t){const n=new Array(e.rank);for(let o=0;o<n.length;o++)n[o]=e.shape[o]*t[o];const o=(0,s.f3b)(n,e.dtype);for(let t=0;t<o.values.length;++t){const n=o.indexToLoc(t),A=new Array(e.rank);for(let t=0;t<A.length;t++)A[t]=n[t]%e.shape[t];const i=e.locToIndex(A);o.values[t]=e.values[i]}return o}const Ld={kernelName:s.n9L,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{reps:i}=o;Ul(A,"tile");const r=Md(n.bufferSync(A),i);return n.makeTensorInfo(r.shape,r.dtype,r.values)}},Sd=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Td(e,t,n=0,o=e.length-1){for(;o>n;){if(o-n>600){const A=o-n+1,i=t-n+1,r=Math.log(A),s=.5*Math.exp(2*r/3),a=.5*Math.sqrt(r*s*(A-s)/A)*Math.sign(i-A/2);Td(e,t,Math.max(n,Math.floor(t-i*s/A+a)),Math.min(o,Math.floor(t+(A-i)*s/A+a)))}const A=e[t];let i=n,r=o;for(s.D5U.swap(e,n,t),Sd(e[o],A)>0&&s.D5U.swap(e,n,o);i<r;){for(s.D5U.swap(e,i,r),i++,r--;Sd(e[i],A)<0;)i+=1;for(;Sd(e[r],A)>0;)r-=1}0===Sd(e[n],A)?s.D5U.swap(e,n,r):(r+=1,s.D5U.swap(e,r,o)),r<=t&&(n=r+1),t<=r&&(o=r-1)}}function Nd(e,t,n,o,A){const i=t[t.length-1],[r,a]=[e.length/i,i],l=s.D5U.getTypedArrayFromDType(n,r*o),m=s.D5U.getTypedArrayFromDType("int32",r*o);for(let t=0;t<r;t++){const n=t*a,i=e.subarray(n,n+a);let r=new Array(i.length);i.forEach(((e,t)=>r[t]={value:e,index:t})),o<r.length&&(Td(r,o),r=r.slice(0,o)),A&&r.sort(Sd);const s=t*o,p=l.subarray(s,s+o),h=m.subarray(s,s+o);for(let e=0;e<o;e++)p[e]=r[e].value,h[e]=r[e].index}const p=t.slice();return p[p.length-1]=o,[(0,s.f3b)(p,n,l),(0,s.f3b)(p,"int32",m)]}const Rd={kernelName:s.cWu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{k:i,sorted:r}=o;Ul(A,"topk");const s=n.data.get(A.dataId).values,[a,l]=Nd(s,A.shape,A.dtype,i,r);return[n.makeTensorInfo(a.shape,a.dtype,a.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},Od={kernelName:s.wx7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:o}=e,{image:A,transforms:i}=t,{interpolation:r,fillMode:a,fillValue:l,outputShape:m}=n,[p,h,u,c]=A.shape,[d,I]=null!=m?m:[h,u],G=[p,d,I,c],E=s.D5U.computeStrides(A.shape),k=E[0],g=E[1],f=E[2],H=s.D5U.getTypedArrayFromDType(A.dtype,s.D5U.sizeFromShape(G));H.fill(l);const F=o.data.get(A.dataId).values,C=o.data.get(i.dataId).values;for(let e=0;e<p;++e){const t=1===i.shape[0]?C:C.subarray(8*e,8*e+8);for(let n=0;n<d;++n)for(let o=0;o<I;++o)for(let A=0;A<c;++A){let i;const s=t[6]*o+t[7]*n+1;if(0===s)continue;const m=(t[0]*o+t[1]*n+t[2])/s,p=(t[3]*o+t[4]*n+t[5])/s,c=Pd(m,u,a),d=Pd(p,h,a);switch(r){case"nearest":i=Vd(F,h,u,k,g,f,e,d,c,A,l);break;case"bilinear":i=Wd(F,h,u,k,g,f,e,d,c,A,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${r}`)}H[e*k+n*g+o*f+A]=i}return o.makeTensorInfo(G,A.dtype,H)}return{dataId:o.write(H,G,A.dtype),shape:A.shape,dtype:A.dtype}}};function Pd(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return s.D5U.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return s.D5U.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return s.D5U.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function Ud(e,t,n,o,A,i,r,s,a,l,m){return 0<=s&&s<t&&0<=a&&a<n?e[r*o+s*A+a*i+l]:m}function Vd(e,t,n,o,A,i,r,s,a,l,m){return Ud(e,t,n,o,A,i,r,Math.round(s),Math.round(a),l,m)}function Wd(e,t,n,o,A,i,r,s,a,l,m){const p=Math.floor(s),h=Math.floor(a),u=p+1,c=h+1;return(u-s)*((c-a)*Ud(e,t,n,o,A,i,r,p,h,l,m)+(a-h)*Ud(e,t,n,o,A,i,r,p,c,l,m))+(s-p)*((c-a)*Ud(e,t,n,o,A,i,r,u,h,l,m)+(a-h)*Ud(e,t,n,o,A,i,r,u,c,l,m))}function _d(e,t,n,o){const A=s.D5U.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let e=0;e<A;e++)i[0]*=n[e];i[1]=n[A];for(let e=A+1;e<n.length;e++)i[2]*=n[e];const r={},a=new Int32Array(n[A]),l=new s.YDk(i,o,e),m=[],p=1===i[0]&&1===i[2];for(let t=0;t<n[A];t++){let n;if(p)n=e[t].toString();else{const e=[];for(let n=0;n<i[0];n++)for(let o=0;o<i[2];o++)e.push(l.get(n,t,o));n=e.join(",")}if(void 0!==r[n])a[t]=r[n];else{const e=Object.keys(r).length;r[n]=e,a[t]=e,m.push(t)}}const h=i.slice();h[1]=Object.keys(r).length;const u=new s.YDk(h,o);m.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let o=0;o<i[2];o++)u.set(l.get(n,e,o),n,t,o)}));const c=n.slice();return c[A]=h[1],{outputValues:u.values,outputShape:c,indices:a}}const zd={kernelName:s.kpP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:o}=e,{axis:A}=n,{x:i}=t;Ul(i,"unique");const r=o.data.get(i.dataId).values,{outputValues:s,outputShape:a,indices:l}=_d(r,A,i.shape,i.dtype);return[o.makeTensorInfo(a,i.dtype,s),o.makeTensorInfo([l.length],"int32",l)]}},Xd={kernelName:s.ToN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{value:A}=t;let{axis:i}=o;i<0&&(i+=A.shape.length);const r=A.shape.length,s=A.shape[i],a=new Array(r-1);let l=0;for(let e=0;e<r;e++)e!==i&&(a[l++]=A.shape[e]);const m=new Array(r).fill(0),p=A.shape.slice();p[i]=1;const h=new Array(s);for(let e=0;e<h.length;e++){m[i]=e;const t=hp({inputs:{x:A},backend:n,attrs:{begin:m,size:p}});h[e]=vm({inputs:{x:t},backend:n,attrs:{shape:a}}),n.disposeIntermediateTensorInfo(t)}return h}},Qd={kernelName:s.Qvg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,segmentIds:i}=t,{numSegments:r}=o;Ul(A,"unsortedSegmentSum");const a=[],l=[],m=A.shape.length-i.shape.length;let p=i;for(let e=0;e<m;++e){const t=fh({inputs:{input:p},backend:n,attrs:{dim:e+1}});p=t,l.push(t)}for(let e=0;e<r;++e){const t=s.D5U.createScalarValue(e,"int32"),o=n.makeTensorInfo([],"int32",t),i=ah({inputs:{a:o,b:p},backend:n}),r=km({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),m=th({inputs:{a:r,b:A},backend:n}),h=oh({inputs:{x:m},backend:n,attrs:{axis:0,keepDims:!1}});a.push(h),l.push(o),l.push(i),l.push(r),l.push(m),l.push(h)}const h=Ec({inputs:a,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},Zd=[bm,xm,wm,Lm,Jm,Sm,Om,Pm,Um,Vm,_m,Xm,Zm,ep,np,rp,sp,ap,lp,ym,mp,cp,Gp,Ep,gm,fp,Fp,dm,Cp,Kp,qp,xp,bp,wp,Mp,Bp,Sp,Np,Rp,Op,Pp,Up,Wp,_p,zp,Xp,Qp,Yp,Zp,jh,ih,Ql,rh,lh,Gh,gh,Hh,Dh,Mh,Sh,Th,Oh,Vh,Wh,_h,Xh,Zh,eu,ou,Yl,Au,vp,ru,au,mu,em,uu,Iu,Eu,fu,Fu,Ju,ju,bu,qu,xu,Tu,Nu,Ru,Ou,Pu,Uu,Mu,Vu,Wu,Xu,Qu,$u,nc,nh,Ac,rc,ac,mc,uc,cc,Gc,kc,gc,Fc,Am,Dc,vc,Em,Kc,rm,am,jm,yc,bc,qc,xc,Bc,wc,Lc,Nc,Oc,Pc,_c,hm,Xc,Zc,$c,up,tc,nd,od,id,sd,ld,md,pd,hd,dd,Id,kd,fd,Fd,Jd,Kd,bd,qh,Ah,xd,wd,Ld,Rd,Rm,Od,zd,Xd,Qd,Ic];for(const e of Zd)(0,s.wCN)(e);const Yd={},$d={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function eI(e){if(!(e in Yd)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete Yd[e]}),!1),1===e?t.getContext("webgl",$d)||t.getContext("experimental-webgl",$d):t.getContext("webgl2",$d)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;Yd[e]=t}const t=Yd[e];return t.isContextLost()?(delete Yd[e],eI(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Yd[e])}var tI,nI,oI;function AI(e,t){return[t,e]}function iI(e){const t=s.D5U.sizeFromShape(e),n=Math.ceil(t/4);return s.D5U.sizeToSquarishShape(n)}function rI(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function sI(e,t){const n=e;let o,A,i,r,a,l,m,p,h,u;return 2===(0,s.OBj)().getNumber("WEBGL_VERSION")?(o=n.R32F,A=n.R16F,i=n.RGBA16F,r=n.RGBA32F,a=n.RED,m=4,p=1,h=n.HALF_FLOAT,u=n.FLOAT):(o=e.RGBA,A=e.RGBA,i=e.RGBA,r=n.RGBA,a=e.RGBA,m=4,p=4,h=null!=t?t.HALF_FLOAT_OES:null,u=e.FLOAT),l=e.RGBA,{internalFormatFloat:o,internalFormatHalfFloat:A,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:r,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:m,defaultNumChannels:p,textureTypeHalfFloat:h,textureTypeFloat:u}}function aI(e,t){const n=t();return(0,s.OBj)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function lI(e){return!!((0,s.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function mI(e,t){return EI(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(tI||(tI={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(nI||(nI={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(oI||(oI={}));const pI=/ERROR: [0-9]+:([0-9]+):/g;function hI(e,t){if(aI(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function uI(e,t,n,o,A,i,r){const s=e.getAttribLocation(t,n);return-1!==s&&(aI(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,o))),aI(e,(()=>e.vertexAttribPointer(s,A,e.FLOAT,!1,i,r))),aI(e,(()=>e.enableVertexAttribArray(s))),!0)}function cI(e,t,n,o){aI(e,(()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,o=t+e.TEXTURE0;if(o<e.TEXTURE0||o>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),aI(e,(()=>e.activeTexture(e.TEXTURE0+n))),aI(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,o))),aI(e,(()=>e.uniform1i(n,o)))}function dI(e,t,n){aI(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),aI(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function II(e,t){aI(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),aI(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function GI(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function EI(e,t,n){const o=aI(e,(()=>t()));if(null==o)throw new Error(n);return o}function kI(e,t=2){return s.D5U.sizeFromShape(e.slice(0,e.length-t))}function gI(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function fI(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[kI(e),...gI(e)]),t}function HI(e){return e%2==0}function FI(e,t){if(e=e.slice(-2),t=t.slice(-2),s.D5U.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],o=t.slice(-1)[0];if(n===o)return!0;if(HI(n)&&HI(o)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&HI(e[0])&&HI(t[0])}let CI,DI;function JI(e,t){return null!=e.getExtension(t)}function vI(e){try{if(null!=eI(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function jI(e){const t=sI(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const A=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(o),A}function KI(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&s.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const yI=(0,s.OBj)();function bI(){let e,t,n,o,A,i,r,a,l,m;return 2===(0,s.OBj)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",o="in",A="texture",i="outputColor",r="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",m="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",o="varying",A="texture2D",i="gl_FragColor",r="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",m="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:o,texture2D:A,output:i,defineOutput:r,defineSpecialNaN:a,defineSpecialInf:l,defineRound:m}}function qI(e,t,n="index"){const o=s.D5U.computeStrides(t);return o.map(((t,A)=>`int ${e[A]} = ${n} / ${t}; ${A===o.length-1?`int ${e[A+1]} = ${n} - ${e[A]} * ${t}`:`index -= ${e[A]} * ${t}`};`)).join("")}function xI(e,t,n="index"){const o=s.D5U.computeStrides(t);return o.map(((t,A)=>`int ${e[A]} = ${n} / outShapeStrides[${A}]; ${A===o.length-1?`int ${e[A+1]} = ${n} - ${e[A]} * outShapeStrides[${A}]`:`index -= ${e[A]} * outShapeStrides[${A}]`};`)).join("")}function BI(e){const t=s.D5U.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}yI.registerFlag("HAS_WEBGL",(()=>yI.getNumber("WEBGL_VERSION")>0)),yI.registerFlag("WEBGL_VERSION",(()=>vI(2)?2:vI(1)?1:0)),yI.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),yI.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===yI.get("WEBGL_VERSION"))),yI.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),yI.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),yI.registerFlag("WEBGL_PACK",(()=>yI.getBool("HAS_WEBGL"))),yI.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_CLIP",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_PACK_REDUCE",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_LAZILY_UNPACK",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_CONV_IM2COL",(()=>yI.getBool("WEBGL_PACK"))),yI.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==CI){const t=eI(e);CI=t.getParameter(t.MAX_TEXTURE_SIZE)}return CI}(yI.getNumber("WEBGL_VERSION")))),yI.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==DI){const t=eI(e);DI=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,DI)}(yI.getNumber("WEBGL_VERSION")))),yI.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=yI.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=eI(e);return t=JI(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:JI(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),yI.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>yI.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!s.C2$.isMobile())),yI.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=eI(e);if(1===e){if(!JI(t,"OES_texture_float"))return!1}else if(!JI(t,"EXT_color_buffer_float"))return!1;return jI(t)}(yI.getNumber("WEBGL_VERSION")))),yI.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!yI.getBool("WEBGL_FORCE_F16_TEXTURES")&&yI.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),yI.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(e){if(0===e)return!1;const t=eI(e);if(1!==e){if(JI(t,"EXT_color_buffer_float"))return jI(t);const e="EXT_color_buffer_half_float";if(JI(t,e)){const n=t.getExtension(e);return function(e,t){const n=sI(e,t),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const A=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,A),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(o),e.deleteFramebuffer(A),i}(t,n)}return!1}return!!JI(t,"OES_texture_float")&&!!JI(t,"WEBGL_color_buffer_float")&&jI(t)}(yI.getNumber("WEBGL_VERSION")))),yI.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=yI.getNumber("WEBGL_VERSION"))&&null!=eI(e).fenceSync;var e})),yI.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>yI.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),yI.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),yI.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>s.C2$.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),yI.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),yI.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),yI.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),yI.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));const wI="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:MI}=s.Wap;function LI(e,t,n){const o=[];if(e.forEach((e=>{const t=s.D5U.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?o.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(o.push(`uniform sampler2D ${e.name};`),o.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=_I(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:o.push(`uniform int ${e.name}Shape;`);break;case 2:o.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:o.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:o.push(`uniform ivec4 ${e.name}Shape;`)}o.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;")}o.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{o.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const A=o.join("\n"),i=e.map((e=>function(e,t,n=!1,o){let A="";A+=n?TI(e,o):SI(e,o);const i=e.shapeInfo.logicalShape,r=t.logicalShape;return i.length<=r.length&&(A+=n?function(e,t){const n=e.name,o=n.charAt(0).toUpperCase()+n.slice(1),A="get"+o+"AtOutCoords",i=e.shapeInfo.logicalShape.length,r=t.logicalShape.length,a=MI(e.shapeInfo.logicalShape,t.logicalShape),l=WI(r),m=r-i;let p;const h=["x","y","z","w","u","v"];p=0===i?"":r<2&&a.length>=1?"coords = 0;":a.map((e=>`coords.${h[e+m]} = 0;`)).join("\n");let u="";u=r<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+m]}`)).join(", ");let c="return outputValue;";const d=1===s.D5U.sizeFromShape(e.shapeInfo.logicalShape),I=1===s.D5U.sizeFromShape(t.logicalShape);if(1!==i||d||I){if(d&&!I)c=1===r?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const e=i-2,t=i-1;a.indexOf(e)>-1&&a.indexOf(t)>-1?c="return vec4(outputValue.x);":a.indexOf(e)>-1?c="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(t)>-1&&(c="return vec4(outputValue.xx, outputValue.zz);")}}else c="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${A}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${o}(${u});\n      ${c}\n    }\n  `}(e,t):function(e,t){const n=e.name,o=n.charAt(0).toUpperCase()+n.slice(1),A="get"+o+"AtOutCoords",i=t.texShape,r=e.shapeInfo.texShape,a=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===l&&null==e.shapeInfo.flatOffset&&s.D5U.arraysEqual(r,i))return`\n      float ${A}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const m=WI(l),p=MI(e.shapeInfo.logicalShape,t.logicalShape),h=l-a;let u;const c=["x","y","z","w","u","v"];u=0===a?"":l<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${c[e+h]} = 0;`)).join("\n");let d="";return d=l<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${c[t+h]}`)).join(", "),`\n    float ${A}() {\n      ${m} coords = getOutputCoords();\n      ${u}\n      return get${o}(${d});\n    }\n  `}(e,t)),A}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),r=t.texShape,a=bI(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let m,p,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${NI}\n    ${RI}\n    ${OI}\n  `}(a);return t.isPacked?(m=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===o[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${o[1]}.0);\n      }\n    `:1===o[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${o[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      return 2 * (resTexRC.x * ${o[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(s.D5U.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${o[0]}, ${o[1]}));\n      }\n    `;const A=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n      int r = 2 * (index / ${A});\n      int c = imod(index, ${A}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],A=Math.ceil(e[2]/2),i=A*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${A});\n      int c = imod(index, ${A}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],A=Math.ceil(e[e.length-1]/2),i=A*Math.ceil(e[e.length-2]/2);let r=i,s="",a="b, r, c";for(let t=2;t<e.length-1;t++)r*=e[e.length-t-1],s=`\n      int b${t} = index / ${r};\n      index -= b${t} * ${r};\n    `+s,a=`b${t}, `+a;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n\n      ${s}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${A});\n      int c = imod(index, ${A}) * 2;\n\n      return ivec${e.length}(${a});\n    }\n  `}(e,t,n)}}(t.logicalShape,r,n.enableShapeUniforms),p=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(a)):(m=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return s.D5U.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${xI(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const o=qI(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${o}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${xI(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const o=qI(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${o}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=qI(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=qI(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,r,n.enableShapeUniforms),p=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),n.packedInputs&&(h+=PI),[h,l,p,A,m,i,n.userCode].join("\n")}function SI(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${o}() {return ${n};}`;const[A,i]=e.shapeInfo.texShape;if(1===A&&1===i)return`\n      float ${o}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const r=UI(n);if(t)return`\n    float ${o}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${r});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[s,a]=e.shapeInfo.texShape;return`\n    float ${o}() {\n      vec2 uv = uvFromFlat(${s}, ${a}, ${r});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${o}(int index) {\n        ${VI(e)}\n      }\n    `;const A=e.shapeInfo.texShape,i=A[0],r=A[1];if(1===r&&1===i)return`\n      float ${o}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const s=UI(n);return 1===r?t?`\n      float ${o}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${o}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${i}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===i?t?`\n      float ${o}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${o}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${r}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${o}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${o}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${r}, index + ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,o=e.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),i=e.shapeInfo.texShape;if(null!=i&&s.D5U.arraysEqual(n,i)){if(t)return`\n      float ${A}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `;const e=i[0];return`\n    float ${A}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${e}.0);\n      return sampleTexture(${o}, uv);\n    }\n  `}const{newShape:r,keptDims:a}=s.D5U.squeezeShape(n),l=r;if(l.length<n.length){const n=["row","col"];return`\n      ${SI(zI(e,l),t)}\n      float ${A}(int row, int col) {\n        return ${A}(${XI(n,a)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${A}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${VI(e)}\n      }\n    `;const m=i[0],p=i[1],h=UI(o);return 1===p?t?`\n      float ${A}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${o}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${o}TexShape[0]));\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${A}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${m}.0);\n      return sampleTexture(${o}, uv);\n    }\n  `:1===m?t?`\n      float ${A}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${o}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${o}TexShape[1]), 0.5);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${A}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${o}, uv);\n    }\n  `:t?`\n      float ${A}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n  float ${A}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${m}, ${p}, index);\n    return sampleTexture(${o}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,o=e.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),i=n[1]*n[2],r=n[2],{newShape:a,keptDims:l}=s.D5U.squeezeShape(n),m=a;if(m.length<n.length){const n=["row","col","depth"];return`\n        ${SI(zI(e,m),t)}\n        float ${A}(int row, int col, int depth) {\n          return ${A}(${XI(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${A}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${r}, 1)));\n        ${VI(e)}\n      }\n    `;const p=e.shapeInfo.texShape,h=p[0],u=p[1],c=e.shapeInfo.flatOffset;if(u===i&&null==c)return t?`\n      float ${A}(int row, int col, int depth) {\n        int stride1 = ${o}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n        float ${A}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${r}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${u}.0, ${h}.0);\n          return sampleTexture(${o}, uv);\n        }\n      `;if(u===r&&null==c)return t?`\n      float ${A}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${o}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${A}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}.0, ${h}.0);\n      return sampleTexture(${o}, uv);\n    }\n  `;const d=UI(o);return t?`\n    float ${A}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${o}Shape[1] * ${o}Shape[2];\n      int stride1 = ${o}Shape[2];\n      int index = row * ${i} + col * ${r} + depth + ${d};\n      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);\n      return sampleTexture(${o}, uv);\n    }\n    `:`\n      float ${A}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${r} + depth + ${d};\n        vec2 uv = uvFromFlat(${h}, ${u}, index);\n        return sampleTexture(${o}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,o=e.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),i=n[3],r=n[2]*i,a=n[1]*r,{newShape:l,keptDims:m}=s.D5U.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${SI(zI(e,l),t)}\n      float ${A}(int row, int col, int depth, int depth2) {\n        return ${A}(${XI(n,m)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${A}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${r}, ${i}, 1)));\n        ${VI(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,u=h[0],c=h[1],d=`int stride2 = ${o}Shape[3];`,I=`int stride1 = ${o}Shape[2] * stride2;`,G=`int stride0 = ${o}Shape[1] * stride1;`;if(c===a&&null==p)return t?`\n      float ${A}(int row, int col, int depth, int depth2) {\n        ${d}\n        ${I}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n      float ${A}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${r}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${c}.0, ${u}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `;if(c===i&&null==p)return t?`\n      float ${A}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${o}Shape[1] * ${o}Shape[2], ${o}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n      float ${A}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${c}.0, ${u}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `;const E=UI(o);return t?`\n    float ${A}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${d}\n      ${I}\n      ${G}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${E});\n      return sampleTexture(${o}, uv);\n    }\n  `:`\n    float ${A}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${r} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${u}, ${c}, index + ${E});\n      return sampleTexture(${o}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),A=t[4],i=t[3]*A,r=t[2]*i,a=t[1]*r,{newShape:l,keptDims:m}=s.D5U.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${SI(zI(e,l))}\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        return ${o}(${XI(t,m)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${r}, ${i}, ${A})) +\n          depth3;\n        ${VI(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,u=h[0],c=h[1];if(c===a&&null==p)return`\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${r}, ${i}, ${A}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${c}.0, ${u}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(c===A&&null==p)return`\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${c}.0, ${u}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${o}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${r} + depth * ${i} +\n          depth2 * ${A} + depth3 + ${UI(n)};\n      vec2 uv = uvFromFlat(${u}, ${c}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:A,keptDims:i}=s.D5U.squeezeShape(t);if(A.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${SI(zI(e,A))}\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${o}(${XI(t,i)});\n      }\n    `}const r=t[5],a=t[4]*r,l=t[3]*a,m=t[2]*l,p=t[1]*m;if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${m}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${r}, 1)));\n        ${VI(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,u=e.shapeInfo.texShape,c=u[0],d=u[1];if(d===p&&null==h)return`\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${m}, ${l}, ${a}, ${r})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(d===r&&null==h)return`\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${o}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${m} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${r} + depth4 + ${UI(n)};\n      vec2 uv = uvFromFlat(${c}, ${d}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function TI(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${bI().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),A=e.shapeInfo.texShape,i=bI();if(t)return`\n    vec4 ${o}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `;const r=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)];return`\n    vec4 ${o}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,o=e.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),i=e.shapeInfo.texShape,r=i[0],a=i[1],l=bI();if(null!=i&&s.D5U.arraysEqual(n,i))return t?`\n      vec4 ${A}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n\n        return ${l.texture2D}(${o}, uv);\n      }\n    `:`\n      vec4 ${A}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${r}.0);\n\n        return ${l.texture2D}(${o}, uv);\n      }\n    `;if(t)return`\n    vec4 ${A}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${o}, uv);\n    }\n  `;const m=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${A}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${m[0]}, ${m[1]}, row, col);\n      return ${l.texture2D}(${o}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,o=e.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),i=e.shapeInfo.texShape,r=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){const o=[1,2],i=["b","row","col"];return`\n        ${TI(zI(e,n.slice(1)),t)}\n        vec4 ${A}(int b, int row, int col) {\n          return ${A}(${XI(i,o)});\n        }\n      `}const s=bI();if(t)return`\n    vec4 ${A}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${s.texture2D}(${o}, uv);\n    }\n  `;const a=r[0],l=r[1],m=Math.ceil(n[2]/2);return`\n    vec4 ${A}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${l}, ${m*Math.ceil(n[1]/2)}, ${m}, b, row, col);\n      return ${s.texture2D}(${o}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),A=bI();if(t)return`\n    vec4 ${o}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${A.texture2D}(${n}, uv);\n    }\n  `;const i=e.shapeInfo.logicalShape,r=i.length,s=e.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=a[0],m=a[1],p=Math.ceil(i[r-1]/2);let h=p*Math.ceil(i[r-2]/2),u="int b, int row, int col",c=`b * ${h} + (row / 2) * ${p} + (col / 2)`;for(let e=2;e<r-1;e++)u=`int b${e}, `+u,h*=i[r-e-1],c=`b${e} * ${h} + `+c;return`\n    vec4 ${o}(${u}) {\n      int index = ${c};\n      int texR = index / ${m};\n      int texC = index - texR * ${m};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}, ${l});\n      return ${A.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const NI="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RI="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",OI="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",PI="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function UI(e){return`offset${e}`}function VI(e){const t=e.name,n=s.D5U.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function WI(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function _I(e,t,n){const{newShape:o,keptDims:A}=s.D5U.squeezeShape(t),i=t.length,r=e&&3===i&&1===t[0],a=r?t.slice(1):o,l=!e&&i>1&&!s.D5U.arraysEqual(t,n)&&o.length<i||r;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:A}}function zI(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function XI(e,t){return t.map((t=>e[t])).join(", ")}function QI(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const o=e.logicalShape,A=t[n],i=A.shape;if(!s.D5U.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&A.isUniform)return;const r=e.texShape,a=A.isUniform?null:A.texData.texShape;if(!s.D5U.arraysEqual(r,a))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${r} and ${a} must match`)}))}function ZI(e){return(0,s.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class YI{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=tI.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=bI();this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xI(["r","c","d"],e):qI(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class $I{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=tI.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=bI();this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xI(["r","c","d"],e):qI(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class eG{constructor(e){this.variableNames=["A"],this.outTexUsage=nI.DOWNLOAD;const t=bI();this.outputShape=e,this.userCode=`\n      ${wI}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class tG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=nI.DOWNLOAD;const t=bI();this.outputShape=e,this.userCode=`\n      ${wI}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class nG{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=bI();this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":BI(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class oG{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=bI();this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length);let o="",A="result";t&&(A="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let A=0;A<=1;A++){const i=2*t+A;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${A} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${A};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${i}] = values[0];\n            } else if (offset == 1) {\n              result[${i}] = values[1];\n            } else if (offset == 2) {\n              result[${i}] = values[2];\n            } else {\n              result[${i}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":BI(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${o}\n\n          ${n.output} = ${A};\n        }\n    `}}function AG(e,t,n,o,A,i){!function(e,t){const n=(0,s.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const r=function(e){return EI(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),a=e.TEXTURE_2D;return aI(e,(()=>e.bindTexture(a,r))),aI(e,(()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),aI(e,(()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),aI(e,(()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST))),aI(e,(()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST))),aI(e,(()=>e.texImage2D(a,0,o,t,n,0,A,i,null))),aI(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),r}function iG(e){return e.internalFormatFloat}function rG(e){return e.internalFormatHalfFloat}function sG(e){return e.downloadTextureFormat}function aG(e){return e.internalFormatPackedFloat}function lG(e){return e.internalFormatPackedHalfFloat}class mG{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=(0,s.OBj)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){Yd[e]=t}(t,e)):this.gl=eI(t);let n="WEBGL_color_buffer_float";const o="EXT_color_buffer_half_float";if(1===(0,s.OBj)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=mI(this.gl,e),JI(this.gl,t))this.textureHalfFloatExtension=mI(this.gl,t);else if((0,s.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),JI(this.gl,o))this.colorBufferHalfFloatExtension=mI(this.gl,o);else if((0,s.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",JI(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!JI(this.gl,o))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(o)}this.vertexBuffer=function(e){return function(e,t){const n=EI(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return aI(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),aI(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=EI(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return aI(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),aI(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return EI(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=sI(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,s.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;aI(e,(()=>e.finish())),aI(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),aI(e,(()=>e.deleteFramebuffer(this.framebuffer))),aI(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),aI(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),aI(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,o){const[A,i]=AI(t,n);return AG(e,A,i,iG(o),o.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,o){const[A,i]=AI(t,n);return AG(e,A,i,rG(o),o.textureFormatFloat,o.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,o){const[A,i]=AI(t,n);return AG(e,A,i,sG(o),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){aI(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?aI(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):aI(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),aI(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),function(e,t,n,o,A,i){let r,s,a;aI(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),A instanceof Uint8Array?(r=new Uint8Array(n*o*4),s=e.UNSIGNED_BYTE,a=e.RGBA):(r=new Float32Array(n*o*4),s=e.FLOAT,a=i.internalFormatPackedFloat),r.set(A),aI(e,(()=>e.texImage2D(e.TEXTURE_2D,0,a,n,o,0,e.RGBA,s,r))),aI(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,o){const[A,i]=rI(t,n);return AG(e,A,i,lG(o),e.RGBA,o.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,o){const[A,i]=rI(t,n);return AG(e,A,i,aG(o),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(II(this.gl,this.framebuffer),this.outputTexture=null),aI(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,o){const[A,i]=AI(t,n),r=new Uint8Array(t*n*4);return aI(e,(()=>e.readPixels(0,0,A,i,o.downloadTextureFormat,e.UNSIGNED_BYTE,r))),new Float32Array(r.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,o,A,i){return function(e,t,n,o,A,i,r,s){const a=e,l=new Float32Array(function(e,t){const[n,o]=rI(e,t);return n*o*4}(i,r));return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,l),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,A,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const o=e,A=new Float32Array(n);return o.bindBuffer(o.PIXEL_PACK_BUFFER,t),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,A),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),A}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const o=function(e,t,n,o){const A=e.createBuffer();aI(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,A)));const i=16*t*n;return aI(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ))),aI(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),aI(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),A}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,s.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const o=e,A=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=o.clientWaitSync(A,0,0);return e===o.ALREADY_SIGNALED||e===o.CONDITION_SATISFIED},t=A}else(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const o=new Float32Array(t*n*4);return aI(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,o))),o}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=EI(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(aI(e,(()=>e.shaderSource(n,t))),aI(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=pI.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const o=+n[1],A=e.split("\n"),i=A.length.toString().length+2,r=A.map(((e,t)=>s.D5U.rightPad((t+1).toString(),i)+e));let a=0;for(let e=0;e<r.length;e++)a=Math.max(r[e].length,a);const l=r.slice(0,o-1),m=r.slice(o-1,o),p=r.slice(o);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${s.D5U.rightPad(m[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=bI();return function(e,t){const n=EI(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(aI(e,(()=>e.shaderSource(n,t))),aI(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const o=function(e){return EI(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return aI(t,(()=>t.attachShader(o,this.vertexShader))),aI(t,(()=>t.attachShader(o,n))),function(e,t){if(aI(e,(()=>e.linkProgram(t))),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,o),this.debug&&hI(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=function(e,t,n){return aI(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),uI(e,t,"clipSpacePos",n,3,20,0)&&uI(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&aI(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&hI(this.gl,this.program),aI(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return EI(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),aI(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),cI(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[o,A]=rI(t,n);this.setOutputMatrixTextureDriver(e,o,A)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&hI(this.gl,this.program),GI(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),aI(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),aI(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=mI(this.gl,2===(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await s.D5U.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),o=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||s.D5U.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),dI(this.gl,e,this.framebuffer),this.debug&&GI(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(dI(this.gl,this.outputTexture,this.framebuffer),this.debug&&GI(this.gl)):II(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const o=this.gl;dI(o,e,this.framebuffer),this.debug&&GI(o),this.outputTexture=e,aI(o,(()=>o.viewport(0,0,t,n))),aI(o,(()=>o.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),aI(this.gl,(()=>this.gl.scissor(e,t,n,o)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:pG,bincountImpl:hG,bincountReduceImpl:uG,ceilImpl:cG,concatImpl:dG,equalImpl:IG,expImpl:GG,expm1Impl:EG,floorImpl:kG,gatherNdImpl:gG,gatherV2Impl:fG,greaterImpl:HG,greaterEqualImpl:FG,lessImpl:CG,lessEqualImpl:DG,linSpaceImpl:JG,logImpl:vG,maxImpl:jG,maximumImpl:KG,minimumImpl:yG,multiplyImpl:bG,negImpl:qG,notEqualImpl:xG,prodImpl:BG,rangeImpl:wG,rsqrtImpl:MG,sigmoidImpl:LG,simpleAbsImpl:SG,sliceImpl:TG,sparseFillEmptyRowsImpl:NG,sparseReshapeImpl:RG,sparseSegmentReductionImpl:OG,sqrtImpl:PG,stridedSliceImpl:UG,stringNGramsImpl:VG,stringSplitImpl:WG,stringToHashBucketFastImpl:_G,subImpl:zG,tileImpl:XG,topKImpl:QG,transposeImpl:ZG,uniqueImpl:YG}=e;function $G(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function eE(e,t){return 1===t?[e]:$G(e,t)}class tE{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=eE("rc",t),o=WI(t),A=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let o="";for(let A=e-2;A<e;A++)o+=`${n[A]} >= ${t[A]}`,A<e-1&&(o+="||");return o}(t,e,n),i=function(e,t,n,o){if(1===e)return"";const A=o.slice(-2);return`\n    int r = ${A[0]};\n    int c = ${A[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),r=function(e,t){const n=e.length,o=function(e,t){const n=[];for(let o=0;o<=1;o++)for(let A=0;A<=1;A++){let i=`${0===o?"r":"rp1"}, ${0===A?"c":"cp1"}`;for(let n=2;n<e;n++)i=`${t[t.length-1-n]},`+i;n.push(i)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${o[0]}),\n          cEdge ? 0. : getA(${o[1]}),\n          rEdge ? 0. : getA(${o[2]}),\n          rEdge || cEdge ? 0. : getA(${o[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${o} rc = getOutputCoords();\n\n          if(${A}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${r}));\n          }\n        }\n      `}}}class nE{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var o,A;this.userCode=`\n      ${o=t,A=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${A?function(e,t,n="index"){const o=function(e,t){const n=e.length,o=e.map((e=>`${t}[${e}]`)),A=new Array(n-1);A[n-2]=o[n-1];for(let e=n-3;e>=0;--e)A[e]=`(${A[e+1]} * ${o[e+1]})`;return A}(e.map(((e,t)=>t)),t);return o.map(((t,A)=>`int ${e[A]} = ${n} / ${o[A]}; ${A===o.length-1?`int ${e[A+1]} = ${n} - ${e[A]} * ${o[A]}`:`index -= ${e[A]} * ${o[A]}`};`)).join("")}(["r","c","d"],"inputShape"):qI(["r","c","d"],o)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":BI(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class oE{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const o=iE(t,n),A=rE(e,o,n);A in this.freeTextures||(this.freeTextures[A]=[]),A in this.usedTextures||(this.usedTextures[A]=[]);const i=AE(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[A].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const e=this.freeTextures[A].shift();return this.usedTextures[A].push(e),e}let r;return o===oI.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===oI.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===oI.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===oI.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===oI.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[A].push(r),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),r}releaseTexture(e,t,n,o){if(null==this.freeTextures)return;const A=iE(n,o),i=rE(t,A,o);i in this.freeTextures||(this.freeTextures[i]=[]);const r=AE(t,A,this.gpgpu.gl,this.gpgpu.textureConfig,o),a=(0,s.OBj)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=r):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=r),this.numUsedTextures--;const l=this.usedTextures[i],m=l.indexOf(e);if(m<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(m,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function AE(e,t,n,o,A){const i=function(e,t){switch(e){case oI.PACKED_2X2_FLOAT32:return aG(t);case oI.PACKED_2X2_FLOAT16:return lG(t);case oI.UNPACKED_FLOAT32:return iG(t);case oI.UNPACKED_FLOAT16:return rG(t);case oI.PACKED_4X1_UNSIGNED_BYTE:return sG(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,o);let r;if(A){const[t,n]=rI(e[0],e[1]);r=t*n}else{const[t,n]=AI(e[0],e[1]);r=t*n}const s=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,i);return r*s}function iE(e,t){if(e===nI.UPLOAD)return oI.PACKED_2X2_FLOAT32;if(e===nI.RENDER||null==e)return function(e){return(0,s.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?oI.PACKED_2X2_FLOAT32:oI.UNPACKED_FLOAT32:e?oI.PACKED_2X2_FLOAT16:oI.UNPACKED_FLOAT16}(t);if(e===nI.DOWNLOAD||e===nI.PIXELS)return oI.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function rE(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class sE{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const aE="return abs(x);",lE="return x;";class mE{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class pE{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=eE("rc",t),o=WI(t),A=function(e,t){if(1===e)return"rc";let n="";for(let o=0;o<e;o++)n+=t[o],o<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),r=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${o} rc = getOutputCoords();\n        vec4 packedInput = getA(${A});\n\n        setOutput(getChannel(packedInput, ${r}));\n      }\n    `}}const hE=s.GDt.ZA,uE={},cE=(0,s.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class dE extends s.Zuw{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,s.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=eI((0,s.OBj)().getNumber("WEBGL_VERSION"));this.binaryCache=((t=(0,s.OBj)().getNumber("WEBGL_VERSION"))in uE||(uE[t]={}),uE[t]),this.gpgpu=new mG(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new oE(this.gpgpu),this.numMBBeforeWarning=null==(0,s.OBj)().global.screen?1024:(0,s.OBj)().global.screen.height*(0,s.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new s.JLz(this,(0,s.SRH)())}nextDataId(){return dE.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if(((0,s.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,s.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:nI.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,o,A){if((0,s.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:nI.UPLOAD,refCount:A})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:A,slice:i,shape:r,isPacked:a}=t;if(null!=i){let t;t=a?new mE(r,lE):new sE(r,lE);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:o}],o),A=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),A}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===o)return n;const l=null!=this.activeTimers;let m,p;if(l&&(m=s.D5U.now()),"complex64"===o){const e=this.readSync(A.real.dataId),t=this.readSync(A.imag.dataId);p=s.Wap.mergeRealAndImagArrays(e,t)}else p=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=s.D5U.now()-m),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:o,slice:A,dtype:i,complexTensorInfos:r,isPacked:a}=t;if(null!=A){let t;t=a?new mE(o,lE):new sE(o,lE);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:i}],i),A=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),A}if(null!=n)return this.convertAndCacheOnCPU(e);if(!(0,s.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,s.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,m,p=null;if("complex64"!==i&&(0,s.OBj)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);p=this.gpgpu.createBufferFromTexture(t.texture,...iI(o))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(r.real.dataId),this.read(r.imag.dataId)]),t=e[0],n=e[1];m=s.Wap.mergeRealAndImagArrays(t,n)}else if(null==p)m=this.getValuesFromTexture(e);else{const e=s.D5U.sizeFromShape(o);m=this.gpgpu.downloadFloat32MatrixFromBuffer(p,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=p){const e=this.gpgpu.gl;aI(e,(()=>e.deleteBuffer(p)))}const h=this.convertAndCacheOnCPU(e,m),u=this.pendingRead.get(e);return this.pendingRead.delete(e),u.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,s.SRH)().removeDataId(e,this),this.pendingDeletes--),h}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>s.D5U.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,s.f3b)(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!lI(n)){if((0,s.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:o}=this.texData.get(e),A=s.D5U.sizeFromShape(t);if((0,s.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),o=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(o.texture,...iI(t)).subarray(0,A);return this.disposeIntermediateTensorInfo(n),i}const i=(0,s.OBj)().getBool("WEBGL_PACK")&&!0===o,r=i?fI(t):t,a=i?new tG(r):new eG(r),l=this.runWebGLProgram(a,[{shape:r,dtype:n,dataId:e}],"float32"),m=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture,m.texShape[0],m.texShape[1]).subarray(0,A);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,n=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();const A=s.D5U.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=s.D5U.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,o&&(this.programTimersStack=null);const r={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if((0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(A);r.kernelMs=s.D5U.sum(e),r.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else r.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,r}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:s.D5U.now(),endMs:null}}endTimer(e){return(0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=s.D5U.now(),e)}async getQueryTime(e){if((0,s.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:o,usage:A,isPacked:i,slice:r}=this.texData.get(e),s=r&&r.origDataId||e,a=this.dataRefCount.get(s);a>1?this.dataRefCount.set(s,a-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,A,i)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=cE){return(0,s.OBj)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&s.D5U.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){s.Wap.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return hE(e.shape,t)}packedUnaryOp(e,t,n){const o=new mE(e.shape,t),A=this.compileAndRun(o,[e],n);return(0,s.SRH)().makeTensorFromDataId(A.dataId,A.shape,A.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=SG(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,s.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,aE,e.dtype);const t=new sE(e.shape,aE),n=this.compileAndRun(t,[e]);return(0,s.SRH)().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let o;if("string"===t&&null!=n&&n.length>0&&s.D5U.isString(n[0])){const A=n.map((e=>s.D5U.encodeString(e)));o=this.write(A,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:o}=this.makeTensorInfo(e,t,n);return(0,s.SRH)().makeTensorFromDataId(o,e,t,this)}unpackTensor(e){const t=new pE(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new tE(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[kI(e.shape),...gI(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},A=[kI(t),...gI(t)],i=new nE(A,n),r=[n],s=this.runWebGLProgram(i,[o],e.dtype,r,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:o,dtype:A}=t,i=fI(o);let r;const s=iI(i);r=n?new $I(i):new YI(i);const a=[s];return{dtype:A,shape:o,dataId:this.runWebGLProgram(r,[{shape:i,dtype:A,dataId:e}],A,a,!0).dataId}}runWebGLProgram(e,t,n,o,A=!1){const i=this.makeTensorInfo(e.outputShape,n),r=this.texData.get(i.dataId);if(e.packedOutput&&(r.isPacked=!0),e.outPackingScheme===tI.DENSE){const t=iI(e.outputShape);r.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(r.usage=e.outTexUsage),0===s.D5U.sizeFromShape(i.shape))return r.values=s.D5U.getTypedArrayFromDType(i.dtype,0),i;const a=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&s.D5U.sizeFromShape(t.shape)<=(0,s.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),a.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!FI(n.shape,t.shape)){const e=t,o=t.shape;t.shape=n.shape,t=this.packedReshape(t,o),a.push(t),n=this.texData.get(t.dataId),e.shape=o}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const m={shape:i.shape,texData:r,isUniform:!1},p=function(e,t,n){let o="";t.concat(n).forEach((t=>{const A=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const i=t.texData.texShape,{useSqueezeShape:r,uniformShape:a,keptDims:l}=_I(e.packedInputs,t.shape,i);let m="",p="",h="";if(1===a.length&&e.packedInputs){const e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];m=`${e[0]>1}_${e[1]>1}`}else if(2!==a.length||e.packedInputs){if(a.length>2&&!e.packedInputs){const e=s.D5U.computeStrides(a);h=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else p=`${a[0]>1}_${a[1]>1}`;const u=t.shape.length,c=2===a.length&&s.D5U.arraysEqual(t.shape,i),d=1===s.D5U.sizeFromShape(t.shape),I=s.Wap.getBroadcastDims(t.shape,n.shape),G=!e.packedInputs&&u===n.shape.length&&s.D5U.arraysEqual(i,n.texData.texShape),E=e.packedInputs||a.length>2?"":`${i[0]>1}_${i[1]>1}`;o+=`${u}_${G}_${r?l:""}_${a.length}_${d}_${I}_${c}_${m}_${p}_${h}_${E}_${A}`}else{const e=t.isUniform?"uniform":t.texData.texShape;o+=`${t.shape}_${e}_${A}`}}));const A=e.userCode;let i=e.constructor.name;return i+="_"+o+"_"+A+`${(0,s.OBj)().getNumber("WEBGL_VERSION")}`,i}(e,l,m),h=this.getAndSaveBinary(p,(()=>function(e,t,n,o){const A=n.map(((e,n)=>{const o={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(o.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:o}})),i=A.map((e=>e.shapeInfo)),r={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},a=LI(A,r,t),l=e.createProgram(a);let m=null;const p=e.getUniformLocation(l,"NAN",!1);1===(0,s.OBj)().getNumber("WEBGL_VERSION")&&(m=e.getUniformLocation(l,"INFINITY",!1));const h=!1,u={},c={},d={};for(let n=0;n<t.variableNames.length;n++){const o=t.variableNames[n];u[o]=e.getUniformLocation(l,o,h),u[`offset${o}`]=e.getUniformLocation(l,`offset${o}`,h),t.enableShapeUniforms&&(c[`${o}Shape`]=e.getUniformLocation(l,`${o}Shape`,h),d[`${o}TexShape`]=e.getUniformLocation(l,`${o}TexShape`,h))}let I,G,E;t.enableShapeUniforms&&(I=e.getUniformLocation(l,"outShape",h),E=e.getUniformLocation(l,"outShapeStrides",h),G=e.getUniformLocation(l,"outTexShape",h));const k=[];return t.customUniforms&&t.customUniforms.forEach(((t,n)=>{k[n]=e.getUniformLocation(l,t.name,h)})),{program:t,source:a,webGLProgram:l,uniformLocations:u,customUniformLocations:k,inShapeInfos:i,outShapeInfo:r,infLoc:m,nanLoc:p,inShapesLocations:c,inTexShapesLocations:d,outShapeLocation:I,outShapeStridesLocation:E,outTexShapeLocation:G}}(this.gpgpu,e,l,m))),u=null!=this.activeTimers;let c;u&&(c=this.startTimer()),function(e,t,n,o,A){t.program.enableShapeUniforms||(QI(t.inShapeInfos,n),QI([t.outShapeInfo],[o]));const i=o.texData.texture,r=o.texData.texShape;o.texData.isPacked?e.setOutputPackedMatrixTexture(i,r[0],r[1]):e.setOutputMatrixTexture(i,r[0],r[1]),e.setProgram(t.webGLProgram),1===(0,s.OBj)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,o)=>{const A=t.program.variableNames[o],i=t.uniformLocations[A],r=t.uniformLocations[`offset${A}`],a=t.inShapesLocations[`${A}Shape`],l=t.inTexShapesLocations[`${A}TexShape`];if(a){const{uniformShape:o}=_I(t.program.packedInputs,n.shape,n.texData.texShape);switch(o.length){case 1:e.gl.uniform1iv(a,new Int32Array(o));break;case 2:e.gl.uniform2iv(a,new Int32Array(o));break;case 3:e.gl.uniform3iv(a,new Int32Array(o));break;case 4:e.gl.uniform4iv(a,new Int32Array(o))}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=i)if(n.isUniform)if(s.D5U.sizeFromShape(n.shape)<2)e.gl.uniform1f(i,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(i,t)}else null!=n.texData.slice&&null!=r&&e.gl.uniform1i(r,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,i,o)}));const a=t.outShapeLocation;if(a)switch(o.shape.length){case 1:e.gl.uniform1iv(a,new Int32Array(o.shape));break;case 2:e.gl.uniform2iv(a,new Int32Array(o.shape));break;case 3:e.gl.uniform3iv(a,new Int32Array(o.shape));break;case 4:e.gl.uniform4iv(a,new Int32Array(o.shape))}if(t.outShapeStridesLocation){const n=s.D5U.computeStrides(o.shape);switch(o.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),t.program.customUniforms&&A&&t.program.customUniforms.forEach(((n,o)=>{const i=t.customUniformLocations[o],r=A[o];if("float"===n.type)e.gl.uniform1fv(i,r);else if("vec2"===n.type)e.gl.uniform2fv(i,r);else if("vec3"===n.type)e.gl.uniform3fv(i,r);else if("vec4"===n.type)e.gl.uniform4fv(i,r);else if("int"===n.type)e.gl.uniform1iv(i,r);else if("ivec2"===n.type)e.gl.uniform2iv(i,r);else if("ivec3"===n.type)e.gl.uniform3iv(i,r);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(i,r)}})),e.executeProgram()}(this.gpgpu,h,l,m,o),a.forEach((e=>this.disposeIntermediateTensorInfo(e))),u&&(c=this.endTimer(c),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(c)}));const d=(0,s.OBj)().get("WEBGL_FLUSH_THRESHOLD");if(d>0){const e=s.D5U.now();e-this.lastGlFlushTime>d&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,s.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&r.isPacked&&!1===A){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,o,A=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,A)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,s.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,s.lub)((()=>{if(!(0,s.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,s.OBj)().getBool("DEBUG");(0,s.OBj)().set("DEBUG",!1);const t=this.abs((0,s.iD$)(1e-8)).dataSync()[0];if((0,s.OBj)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:o,values:A,texture:i,usage:r,isPacked:a}=t;if(null!=i)return;const l=null!=this.activeTimers;let m;l&&(m=s.D5U.now());let p=t.texShape;if(null==p&&(p=function(e,t=!1){let n=(0,s.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?s.D5U.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=s.D5U.squeezeShape(e);e=t.newShape}let o=s.D5U.sizeFromShape(e);if(e.length<=1&&o<=n)return[1,o];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=kI(e);let n=2,A=2;return e.length&&([n,A]=gI(e)),o=t*(n/2)*(A/2),s.D5U.sizeToSquarishShape(o).map((e=>2*e))}return s.D5U.sizeToSquarishShape(o)}(n,a),t.texShape=p),null!=A){const e=fI(n);let i,r=p[1],h=p[0];const u=A instanceof Uint8Array||A instanceof Uint8ClampedArray;a?([r,h]=rI(p[0],p[1]),i=new oG(e,u)):i=new nG(e,u);const c=this.makeTensorInfo([h,r],o);this.texData.get(c.dataId).usage=u?nI.PIXELS:nI.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(c.dataId),r,h,A);const d=[[h,r]],I=!0,G=this.runWebGLProgram(i,[c],o,d,I),E=this.texData.get(G.dataId);t.texture=E.texture,t.texShape=E.texShape,t.isPacked=E.isPacked,t.usage=E.usage,this.disposeIntermediateTensorInfo(c),this.texData.delete(G.dataId),t.values=null,l&&(this.uploadWaitMs+=s.D5U.now()-m)}else{const e=this.acquireTexture(p,r,o,a);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:o}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*s.D5U.bytesPerElement(t)}}dE.nextDataId=0,s.C2$.isBrowser()&&(0,s.jqO)("webgl",(()=>new dE),2);class IE{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=s.Wap.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=ZI(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class GE{constructor(e,t,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s.Wap.assertAndGetBroadcastShape(t,n);const A=this.outputShape.length;this.enableShapeUniforms=ZI(A);let i="";if(o)if(0===A||1===s.D5U.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${WI(A)} coords = getOutputCoords();\n        `,1===A)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=eE("coords",A);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[A-2]} + 1) >= outShape[${A} - 2];\n            bool nextColOutOfBounds =\n              (${e[A-1]} + 1) >= outShape[${A} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[A-2]} + 1) >= ${this.outputShape[A-2]};\n            bool nextColOutOfBounds =\n              (${e[A-1]} + 1) >= ${this.outputShape[A-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function EE(e){const{inputs:t,backend:n}=e,{x:o}=t;return n.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}const kE={kernelName:s.iJz,backendName:"webgl",kernelFunc:EE};function gE(e){const{inputs:t,backend:n}=e,{real:o,imag:A}=t,i=n.makeTensorInfo(o.shape,"complex64"),r=n.texData.get(i.dataId),s=EE({inputs:{x:o},backend:n}),a=EE({inputs:{x:A},backend:n});return r.complexTensorInfos={real:s,imag:a},i}const fE={kernelName:s.Zz9,backendName:"webgl",kernelFunc:gE},HE="return (a < 0.) ? b * a : a;",FE="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",CE={kernelName:s.J$2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{alpha:i}=o,r=n.makeTensorInfo([],"float32",s.D5U.createScalarValue(i,"float32")),a=(0,s.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GE(FE,A.shape,r.shape):new IE(HE,A.shape,r.shape),l=n.runWebGLProgram(a,[A,r],"float32");return n.disposeIntermediateTensorInfo(r),l}},DE="return (a < 0.) ? b * a : a;",JE="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",vE={kernelName:s.o0g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o,alpha:A}=t,i=(0,s.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GE(JE,o.shape,A.shape):new IE(DE,o.shape,A.shape);return n.runWebGLProgram(i,[o,A],"float32")}};function jE({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:o}){return({inputs:A,backend:i})=>{const{x:r}=A,a=i,l=o||r.dtype;if(a.shouldExecuteOnCPU([r])&&null!=n){const e=a.texData.get(r.dataId),t=n(e.values,l);return a.makeTensorInfo(r.shape,l,t)}let m;return m=(0,s.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new mE(r.shape,t):new sE(r.shape,e),a.runWebGLProgram(m,[r],l)}}function KE({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:o=!1,cpuKernelImpl:A,dtype:i}){return({inputs:r,backend:a})=>{const{a:l,b:m}=r,p=a;if(o&&"complex64"===l.dtype){const t=p.texData.get(l.dataId),n=p.texData.get(m.dataId),[o,A]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,o]=t,A={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:o.dataId,dtype:o.dtype,shape:m.shape},r=new IE(e,l.shape,m.shape);return p.runWebGLProgram(r,[A,i],(0,s.x8V)(n.dtype,o.dtype))})),i=gE({inputs:{real:o,imag:A},backend:p});return p.disposeIntermediateTensorInfo(o),p.disposeIntermediateTensorInfo(A),i}const h=i||(0,s.x8V)(l.dtype,m.dtype);if(("string"===l.dtype||"string"===m.dtype||p.shouldExecuteOnCPU([l,m]))&&null!=A){const e=p.texData.get(l.dataId).values,t=p.texData.get(m.dataId).values,n="string"===l.dtype?s.Wap.fromUint8ToStringArray(e):e,o="string"===l.dtype?s.Wap.fromUint8ToStringArray(t):t,[i,r]=A(l.shape,m.shape,n,o,h),a=p.makeTensorInfo(r,h);return p.texData.get(a.dataId).values=i,a}let u;return u=(0,s.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new GE(t,l.shape,m.shape,n):new IE(e,l.shape,m.shape),p.runWebGLProgram(u,[l,m],h)}}function yE(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?JE:DE;if("leakyrelu"===e)return t?FE:HE;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class bE{constructor(e,t,n,o=!1,A=!1,i=!1,r=null,s=!1,a=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ZI(this.outputShape.length);const l=o?e[1]:e[2],m=Math.ceil(l/2),p=o?"i * 2, rc.y":"rc.y, i * 2",h=A?"rc.z, i * 2":"i * 2, rc.z",u=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],c=A?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let d="",I="";r&&(d=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,I="result = activation(result);");const G=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha");let E="rc.x",k="rc.x";e[0]<t[0]?E=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(k=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${d}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${m}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${m}; i++) {\n          int batchA = ${E};\n          int batchB = ${k};\n          vec4 a = getMatrixA(batchA, ${p});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${u[0]} * ${c[0]});\n          result += (${u[1]} * ${c[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${G}\n\n        ${I}\n\n        setOutput(result);\n      }\n    `}}class qE{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=s.Wap.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const xE="return a * b;";function BE(e){const{inputs:t,backend:n}=e,{a:o,b:A}=t,i=s.Wap.upcastType(o.dtype,A.dtype);if("complex64"===o.dtype){const e=n.texData.get(o.dataId),t=n.texData.get(A.dataId),i=new qE("return areal * breal - aimag * bimag;",o.shape,A.shape),r=new qE("return areal * bimag + aimag * breal;",o.shape,A.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:o.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:A.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:A.shape}],a=n.runWebGLProgram(i,s,"float32"),l=n.runWebGLProgram(r,s,"float32"),m=gE({inputs:{real:a,imag:l},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),m}if(n.shouldExecuteOnCPU([o,A])){const e=n.texData.get(o.dataId),t=n.texData.get(A.dataId),[r,s]=bG(o.shape,A.shape,e.values,t.values,i),a=n.makeTensorInfo(s,i);return n.texData.get(a.dataId).values=r,a}let r;return r=(0,s.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GE(xE,o.shape,A.shape):new IE(xE,o.shape,A.shape),n.runWebGLProgram(r,[o,A],i)}const wE={kernelName:s.wYn,backendName:"webgl",kernelFunc:BE};function ME(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{shape:i}=o,r=n,a=s.D5U.sizeFromShape(A.shape),l=s.D5U.inferFromImplicitShape(i,a),m=s.D5U.sizeFromShape(l);s.D5U.assert(a===m,(()=>`The new shape (${l}) has ${m} elements and the old shape (${A.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`));const p=r.texData.get(A.dataId);return!p.isPacked||FI(A.shape,l)||null!==p.texture&&FI(p.shape,l)?(r.incRef(A.dataId),{dataId:A.dataId,shape:l,dtype:A.dtype}):function(e,t,n){const o=[kI(e.shape),...gI(e.shape)],A={dtype:e.dtype,shape:o,dataId:e.dataId},i=[kI(t),...gI(t)],r=new nE(i,o),s=[o],a=n.runWebGLProgram(r,[A],e.dtype,s,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}}(A,l,r)}const LE={kernelName:s.HZH,backendName:"webgl",kernelFunc:ME};class SE{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:o,inSize:A,outSize:i}=e;this.outputShape=[o,i];const r=4*Math.floor(n/4),a=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${s.D5U.isInt(e)?e.toPrecision(2):e}, ones);`}let m="";A%n>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${A}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${r}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${r};\n        if (${1===a}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class TE{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:o,inSize:A,outSize:i}=e;this.outputShape=[o,i];let r="0.0",s="";"prod"===t?r="1.0":"min"===t?(r="1.0 / 1e-20",s="min"):"max"===t&&(r="-1.0 / 1e-20",s="max");let a=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?a="sumValue":"prod"===t?a="prodValue":"all"===t?a="allValue":"any"===t&&(a="anyValue");const l=4*Math.floor(n/4),m=n%4;let p=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${s}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${s}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(r="1.0",p="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(r="0.0",p="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let u="";A%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${A}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${r};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${r});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===m}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${2===m}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${3===m}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${p}\n        }\n        setOutput(${a});\n      }\n    `}}function NE(e,t,n,o){const A=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],o=s.Wap.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:o,outSize:Math.ceil(n/o)})}return t}(e.shape);let i=e;for(let r=0;r<A.length;r++){const{inSize:s,windowSize:a,outSize:l}=A[r];let m,p;m="mean"===n?0===r?new SE({windowSize:a,inSize:s,batchSize:e.shape[0],outSize:l},s):new SE({windowSize:a,inSize:s,batchSize:e.shape[0],outSize:l}):new TE({windowSize:a,inSize:s,batchSize:e.shape[0],outSize:l},n),p=i,i=o.runWebGLProgram(m,[i],t),p.dataId!==e.dataId&&o.disposeIntermediateTensorInfo(p)}return i}class RE{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const o=WI(this.rank),A=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],o=new Array(t);for(let t=0;t<e.length;t++)o[e[t]]=n[t];return o.join()}(t);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${A}));\n    }\n    `}}class OE{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const o=WI(this.rank),A=$G("rc",this.rank),i=new Array(this.rank);for(let e=0;e<t.length;e++)i[t[e]]=A[e];const r=`vec2(${i.slice(-2).join()})`,s=`++${A[this.rank-1]} < ${n[this.rank-1]}`,a=`getChannel(getA(${i.join()}), ${r})`;this.userCode=`\n    void main() {\n      ${o} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${a};\n      if(${s}) {\n        result[1] = ${a};\n      }\n      --${A[this.rank-1]};\n      if(++${A[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${a};\n        if(${s}) {\n          result[3] = ${a};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function PE(e,t,n){const o=(0,s.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OE(e.shape,t):new RE(e.shape,t);return n.runWebGLProgram(o,[e],e.dtype)}function UE(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o;return function(e,t,n,o){const A=t,i=e.shape.length,r=s.D5U.parseAxisParam(A,e.shape);let a=r;const l=s.Wap.getAxesPermutation(a,i),m=null!=l;let p=e;m&&(p=PE(e,l,o),a=s.Wap.getInnerMostAxes(a.length,i)),s.Wap.assertAxesAreInnerMostDims("sum",a,i);const[h,u]=s.Wap.computeOutAndReduceShapes(p.shape,a);let c=h;n&&(c=s.Wap.expandShapeToKeepDim(h,r));const d=s.D5U.sizeFromShape(u),I=ME({inputs:{x:p},attrs:{shape:[s.D5U.sizeFromShape(e.shape)/d,d]},backend:o}),G=NE(I,(0,s.z4k)(e.dtype),"sum",o),E=ME({inputs:{x:G},attrs:{shape:c},backend:o});return o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(G),m&&o.disposeIntermediateTensorInfo(p),E}(A,i,r,n)}const VE={kernelName:s.GBy,backendName:"webgl",kernelFunc:UE};function WE(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{perm:i}=o,r=n,s=A.shape.length,a=new Array(s);for(let e=0;e<a.length;e++)a[e]=A.shape[i[e]];let l;if(r.shouldExecuteOnCPU([A])){const e=r.texData.get(A.dataId).values,t=ZG(e,A.shape,A.dtype,i,a);l=r.makeTensorInfo(a,A.dtype),r.texData.get(l.dataId).values=t}else l=PE(A,i,r);return l}const _E={kernelName:s.G3Y,backendName:"webgl",kernelFunc:WE};function zE({a:e,b:t,transposeA:n,transposeB:o,backend:A,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:l=null}){const m=e.shape.length,p=t.shape.length,h=n?e.shape[m-2]:e.shape[m-1],u=o?t.shape[p-1]:t.shape[p-2],c=n?e.shape[m-1]:e.shape[m-2],d=o?t.shape[p-2]:t.shape[p-1],I=e.shape.slice(0,-2),G=t.shape.slice(0,-2),E=s.D5U.sizeFromShape(I),k=s.D5U.sizeFromShape(G),g=E===k||1===E||1===k;s.D5U.assert(m>=2&&p>=2&&g,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${I}) and (${G}).`));const f=(E>k?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([c,d]);s.D5U.assert(h===u,(()=>`Error in matMul: inner shapes (${h}) and (${u}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${o} must match.`));const H=n?[E,h,c]:[E,c,h],F=o?[k,d,u]:[k,u,d],C=ME({inputs:{x:e},backend:A,attrs:{shape:H}}),D=ME({inputs:{x:t},backend:A,attrs:{shape:F}}),J=[C,D],v=Math.max(E,k),j=n?C.shape[1]:C.shape[2],K=null!=i,y=null!=r,b="leakyrelu"===l,q=null!=l?yE(l,!0):null;let x;if((1===c||1===d)&&j>1e3&&!1===(K||y||b||null!=q)){let e=C,t=D;n&&(e=WE({inputs:{x:C},backend:A,attrs:{perm:[0,2,1]}}),J.push(e)),o&&(t=WE({inputs:{x:D},backend:A,attrs:{perm:[0,2,1]}}),J.push(t));const i=1===d;let r=e;1!==d&&(r=ME({inputs:{x:e},backend:A,attrs:{shape:[v,j,1]}}),J.push(r));const s=1===d?2:1;let a=t;i&&(a=ME({inputs:{x:t},backend:A,attrs:{shape:[v,1,j]}}),J.push(a));const l=BE({inputs:{a:r,b:a},backend:A});x=UE({inputs:{x:l},backend:A,attrs:{axis:s,keepDims:!0}}),J.push(l)}else{const l=(0,s.x8V)(e.dtype,t.dtype),m=new bE(H,F,[v,c,d],n,o,K,q,y,b),p=[C,D];if(null!=i&&p.push(i),y&&p.push(r),b){const e=A.makeTensorInfo([],"float32",s.D5U.createScalarValue(a,"float32"));p.push(e),J.push(e)}x=A.runWebGLProgram(m,p,l)}const B=ME({inputs:{x},backend:A,attrs:{shape:f}});J.push(x);for(const e of J)A.disposeIntermediateTensorInfo(e);return B}const XE={kernelName:s.usg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{a:A,b:i,bias:r,preluActivationWeights:s}=t,{transposeA:a,transposeB:l,activation:m,leakyreluAlpha:p}=o;return zE({a:A,b:i,transposeA:a,transposeB:l,backend:n,bias:r,preluActivationWeights:s,leakyreluAlpha:p,activation:m})}},QE="return abs(x);",ZE={kernelName:s.SYM,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t;if(n.shouldExecuteOnCPU([o])&&"complex64"!==o.dtype){const e=n.texData.get(o.dataId),t=SG(e.values);return n.makeTensorInfo(o.shape,o.dtype,t)}let A;return A=(0,s.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mE(o.shape,QE):new sE(o.shape,QE),n.runWebGLProgram(A,[o],o.dtype)}},YE=jE({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),$E={kernelName:s.VGw,backendName:"webgl",kernelFunc:YE},ek=jE({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),tk={kernelName:s.SpW,backendName:"webgl",kernelFunc:ek},nk="return a + b;",ok=KE({opSnippet:nk,packedOpSnippet:nk,supportsComplex:!0,cpuKernelImpl:pG}),Ak={kernelName:s.mm_,backendName:"webgl",kernelFunc:ok};class ik{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const o=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${o};\n        setOutput(result);\n      }\n    `}}class rk{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const o=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${o};\n        setOutput(result);\n      }\n    `}}const sk={kernelName:s.Xze,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:o}=t,A=n;if(1===A.length)return EE({inputs:{x:A[0]},backend:o});if(A.length>(0,s.OBj)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(A.length/2),n=e({inputs:A.slice(0,t),backend:o}),i=e({inputs:A.slice(t),backend:o});return e({inputs:[n,i],backend:o})}const i=A.map((e=>e.dtype)).reduce(((e,t)=>(0,s.x8V)(e,t))),r=A.map((e=>e.shape)),a=(0,s.OBj)().getBool("WEBGL_PACK")?new rk(A[0].shape,r):new ik(A[0].shape,r);return o.runWebGLProgram(a,A,i)}},ak={kernelName:s.oT6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o,a=A.shape.length,l=s.D5U.parseAxisParam(i,A.shape);let m=l;const p=s.Wap.getAxesPermutation(m,a);let h=A;null!=p&&(h=WE({inputs:{x:A},backend:n,attrs:{perm:p}}),m=s.Wap.getInnerMostAxes(m.length,a)),s.Wap.assertAxesAreInnerMostDims("all",m,a);const[u,c]=s.Wap.computeOutAndReduceShapes(h.shape,m),d=ME({inputs:{x:h},backend:n,attrs:{shape:[-1,s.D5U.sizeFromShape(c)]}}),I=NE(d,d.dtype,"all",n);let G;return G=ME(r?{inputs:{x:I},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(u,l)}}:{inputs:{x:I},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(I),null!=p&&n.disposeIntermediateTensorInfo(h),G}},lk={kernelName:s.IKK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o,a=A.shape.length,l=s.D5U.parseAxisParam(i,A.shape);let m=l;const p=s.Wap.getAxesPermutation(m,a);let h=A;null!=p&&(h=WE({inputs:{x:A},backend:n,attrs:{perm:p}}),m=s.Wap.getInnerMostAxes(m.length,a)),s.Wap.assertAxesAreInnerMostDims("any",m,a);const[u,c]=s.Wap.computeOutAndReduceShapes(h.shape,m),d=ME({inputs:{x:h},backend:n,attrs:{shape:[-1,s.D5U.sizeFromShape(c)]}}),I=NE(d,d.dtype,"any",n);let G;return G=ME(r?{inputs:{x:I},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(u,l)}}:{inputs:{x:I},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(I),null!=p&&n.disposeIntermediateTensorInfo(h),G}};class mk{constructor(e,t,n){this.variableNames=["A"];const{windowSize:o,batchSize:A,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[A,i];const r="max"===t?">":"<",s=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${o};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${o}; i++) {\n          int inIdx = ${s};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${r} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class pk{constructor(e,t,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,s.D5U.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const A=e[e.length-1],i=Math.ceil(A/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");const r=this.outputShape,a=r.length,l=WI(a),m=eE("coords",a);let p,h;if(1===i){h=a+1;const e=WI(h);p=`\n        ${e} sourceLocR = ${e}(${m.join()}, 0);\n        ++${m[a-1]};\n        ${e} sourceLocG = ${e}(${m.join()}, 0);\n        ++${m[a-2]};\n        ${e} sourceLocA = ${e}(${m.join()}, 0);\n        --${m[a-1]};\n        ${e} sourceLocB = ${e}(${m.join()}, 0);\n        --${m[a-2]};`}else h=a,p=`\n        ${l} sourceLocR = coords;\n        ++${m[a-1]};\n        ${l} sourceLocG = coords;\n        ++${m[a-2]};\n        ${l} sourceLocA = coords;\n        --${m[a-1]};\n        ${l} sourceLocB = coords;\n        --${m[a-2]};`;const u=["x","y","z","w","u","v"].slice(0,h),c="."+u[h-1],d=u.map((e=>"int "+e)),I=eE("sourceLocR",h-1).concat("inIdx.r"),G=eE("sourceLocG",h-1).concat("inIdx.g"),E=eE("sourceLocB",h-1).concat("inIdx.b"),k=eE("sourceLocA",h-1).concat("inIdx.a"),g="max"===n?"greaterThan":"lessThan",f=o?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${G.join()}),\n                             getBestIndicesAChannel(${E.join()}),\n                             getBestIndicesAChannel(${k.join()})));`,H=`vec4(\n            getAChannel(${I.join()}),\n            hasNextCol ? getAChannel(${G.join()}) : 0.,\n            hasNextRow ? getAChannel(${E.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,F=o?"":`\n      float getBestIndicesAChannel(${d.join()}) {\n        return getChannel(getBestIndicesA(${u.join()}),\n                                          vec2(${u.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${d.join()}) {\n        return getChannel(getA(${u.join()}),\n                               vec2(${u.slice(-2).join()}));\n      }\n      ${F}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${m[a-1]} < ${r[a-1]-1};\n        bool hasNextRow = ${m[a-2]} < ${r[a-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${c}, sourceLocG${c},\n          sourceLocB${c}, sourceLocA${c}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${H};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${f}\n          vec4 candidate = ${H};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${g}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function hk(e,t,n,o=null){let A=t.shape[0],i=t.shape[1];null!=o&&(A=o.shape[0],i=o.shape[1]);const r=s.Wap.computeOptimalWindowSize(i),a={windowSize:r,inSize:i,batchSize:A,outSize:Math.ceil(i/r)},l=new mk(a,n,null==o),m=[t];null!=o&&m.push(o);const p=e.runWebGLProgram(l,m,"int32");if(1===p.shape[1])return p;const h=hk(e,t,n,p);return e.disposeIntermediateTensorInfo(p),h}function uk(e,t,n,o=null){const A=null!=o?o.shape:t.shape,i=A[A.length-1],r=s.Wap.computeOptimalWindowSize(i),a=new pk(A,r,n,null==o),l=null==o?[t]:[t,o],m=e.runWebGLProgram(a,l,"int32");if(m.shape.length===t.shape.length){const o=uk(e,t,n,m);return e.disposeIntermediateTensorInfo(m),o}return m}function ck(e,t,n,o){const A=[n];if(s.Wap.assertAxesAreInnerMostDims("arg"+o.charAt(0).toUpperCase()+o.slice(1),A,t.shape.length),!(0,s.OBj)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],i=e.texData.get(t.dataId);let r=t;null!==i&&i.isPacked&&(r=e.unpackTensor(t),n.push(r));const[a,l]=s.Wap.computeOutAndReduceShapes(r.shape,A),m=s.D5U.sizeFromShape(l),p=ME({inputs:{x:r},backend:e,attrs:{shape:[-1,m]}});n.push(p);const h=hk(e,p,o);n.push(h);const u=ME({inputs:{x:h},backend:e,attrs:{shape:a}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),u}return uk(e,t,o)}const dk={kernelName:s.sJF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i}=o;let r=s.D5U.parseAxisParam(i,A.shape);const a=s.Wap.getAxesPermutation(r,A.shape.length);let l=A;const m=[];null!=a&&(l=WE({inputs:{x:A},backend:n,attrs:{perm:a}}),m.push(l),r=s.Wap.getInnerMostAxes(r.length,l.shape.length)),s.Wap.assertAxesAreInnerMostDims("argMax",[r[0]],l.shape.length);const p=ck(n,l,r[0],"max");return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},Ik={kernelName:s.aJk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i}=o;let r=s.D5U.parseAxisParam(i,A.shape);const a=s.Wap.getAxesPermutation(r,A.shape.length);let l=A;const m=[];null!=a&&(l=WE({inputs:{x:A},backend:n,attrs:{perm:a}}),m.push(l),r=s.Wap.getInnerMostAxes(r.length,l.shape.length)),s.Wap.assertAxesAreInnerMostDims("argMin",[r[0]],l.shape.length);const p=ck(n,l,r[0],"min");return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},Gk=jE({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Ek={kernelName:s.M2y,backendName:"webgl",kernelFunc:Gk},kk=jE({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),gk={kernelName:s.qw7,backendName:"webgl",kernelFunc:kk},fk=jE({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Hk={kernelName:s.jMg,backendName:"webgl",kernelFunc:fk},Fk=KE({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Ck={kernelName:s.QCc,backendName:"webgl",kernelFunc:Fk},Dk=jE({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Jk={kernelName:s.Oyi,backendName:"webgl",kernelFunc:Dk};class vk{constructor(e,t,n,o=!1,A=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,l=e.dilationWidth,m=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=e.padInfo.top,u=e.padInfo.left;this.outputShape=e.outShape;const c="avg"===t,d=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,I=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let G="0.0";if(c||(G="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${r}, ${s});\n        const ivec2 pads = ivec2(${h}, ${u});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${m};\n              wR += ${a}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${o?A?d:I:`wR * ${p} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(E="avgValue / count");const k=4*Math.floor(i/4),g=i%4,f=`\n      if (${c}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${h}, ${u});\n      const float initializationValue = ${G};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${G});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${m};\n            wR += ${a}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${k}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${f}\n          }\n\n          int xC = xCCorner + ${k};\n          if (${1===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${f}\n          } else if (${2===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${f}\n          } else if (${3===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${f}\n          }\n        }\n        setOutput(${E});\n      }\n    `}}class jk{constructor(e,t,n,o=!1,A=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,r=e.strideDepth,s=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,m=e.dilationHeight,p=e.dilationWidth,h=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=e.padInfo.front,I=e.padInfo.top,G=e.padInfo.left;this.outputShape=e.outShape;const E="avg"===t;let k="0.0";if(E||(k="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${r}, ${s}, ${a});\n        const ivec3 pads = ivec3(${d}, ${I}, ${G});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${u};\n                wR += ${m}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${c};\n                  wC += ${p}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${o?A?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${u} * ${c} +\n                      wR * ${c} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const f=4*Math.floor(i/4),H=i%4,F=`\n      if (${E}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${r}, ${s}, ${a});\n      const ivec3 pads = ivec3(${d}, ${I}, ${G});\n      const float initializationValue = ${k};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${k});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${u};\n            wR += ${m}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC += 4) {\n              int xC = xCCorner + wC * ${p};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${p}, ch)\n              );\n\n              ${F}\n            }\n\n            int xC = xCCorner + ${f};\n            if (${1===H}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${F}\n            } else if (${2===H}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${F}\n            } else if (${3===H}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                initializationValue\n              );\n\n              ${F}\n            }\n          }\n          setOutput(${g});\n        }\n      }\n    `}}const Kk={kernelName:s.JhU,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t;KI(A,"avgPool");const{filterSize:i,strides:r,pad:a,dimRoundingMode:l}=o;s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(r,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`));const m=s.Wap.computePool2DInfo(A.shape,i,r,1,a,l);if(1===m.filterWidth&&1===m.filterHeight&&s.D5U.arraysEqual(m.inShape,m.outShape))return EE({inputs:{x:A},backend:n});const p=new vk(m,"avg",!1);return n.runWebGLProgram(p,[A],"float32")}},yk={kernelName:s._k9,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{filterSize:i,strides:r,pad:a,dimRoundingMode:l,dataFormat:m}=o,p=s.Wap.computePool3DInfo(A.shape,i,r,[1,1,1],a,l,m),h=new jk(p,"avg",!1);return n.runWebGLProgram(h,[A],"float32")}};class bk{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,A=e.strideWidth,i=e.dilationHeight,r=e.dilationWidth,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,l=s-1-e.padInfo.top,m=a-1-e.padInfo.left,p=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${m});\n      const float avgMultiplier = float(${p});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a};\n            wC+= ${r}) {\n            float dyC = float(dyCCorner + wC) / ${A}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qk{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,A=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,m=e.effectiveFilterDepth,p=e.effectiveFilterHeight,h=e.effectiveFilterWidth,u=m-1-e.padInfo.front,c=p-1-e.padInfo.top,d=h-1-e.padInfo.left,I=1/(t*n*o);this.userCode=`\n      const ivec3 pads = ivec3(${u}, ${c}, ${d});\n      const float avgMultiplier = float(${I});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${A}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${p};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xk={kernelName:s.IMb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i}=t,r=i,{filterSize:a,strides:l,pad:m,dimRoundingMode:p}=o,h=s.Wap.computePool3DInfo(r.shape,a,l,[1,1,1],m,p),u=new qk(h);return n.runWebGLProgram(u,[A],r.dtype)}},Bk={kernelName:s.ROF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i}=t,r=i;KI([A,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:m}=o,p=s.Wap.computePool2DInfo(r.shape,a,l,1,m),h=new bk(p);return n.runWebGLProgram(h,[A],r.dtype)}},wk={kernelName:s.XLW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{a:A,b:i}=t,{transposeA:r,transposeB:s}=o;return zE({a:A,b:i,transposeA:r,transposeB:s,backend:n})}};class Mk{constructor(e,t,n,o,A,i){this.outputShape=[],this.variableNames=["x","mean","variance"],s.Wap.assertAndGetBroadcastShape(e,t),s.Wap.assertAndGetBroadcastShape(e,n);let r="0.0";null!=o&&(s.Wap.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let a="1.0";null!=A&&(s.Wap.assertAndGetBroadcastShape(e,A),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${r};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Lk{constructor(e,t,n,o,A,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],s.Wap.assertAndGetBroadcastShape(e,t),s.Wap.assertAndGetBroadcastShape(e,n);let r="vec4(0.0)";null!=o&&(s.Wap.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=A&&(s.Wap.assertAndGetBroadcastShape(e,A),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${r};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Sk={kernelName:s.sHE,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,mean:A,variance:i,offset:r,scale:a}=e;s.D5U.assert(A.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),s.D5U.assert(null==r||A.shape.length===r.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),s.D5U.assert(null==a||A.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const m=[o,A,i];let p=null;null!=r&&(p=r.shape,m.push(r));let h=null;null!=a&&(h=a.shape,m.push(a));const u=(0,s.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new Lk(o.shape,A.shape,i.shape,p,h,l):new Mk(o.shape,A.shape,i.shape,p,h,l);return t.runWebGLProgram(u,m,m[0].dtype)}};class Tk{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=WI(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Nk.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let o;o=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Nk[t]} = start[${t}] + coords.${Nk[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${o}\n        setOutput(getSource(${n}));\n      }\n    `}}const Nk=["x","y","z","w","u","v"];class Rk{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=WI(this.rank),n=eE("coords",this.rank),o=eE("sourceLoc",this.rank),A=1===this.rank?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${A})`,r=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${o[this.rank-1]};\n        result.y = ${i};\n        --${o[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${o[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${o[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,a=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${o[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${a}\n        vec4 result = vec4(0.);\n        ${r}\n        ${s}\n        setOutput(result);\n      }\n    `}}function Ok(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{begin:i,size:r}=o,[a,l]=s.kuN.parseSliceParams(A,i,r);if(s.kuN.assertParamsValid(A,a,l),0===s.D5U.sizeFromShape(l))return n.makeTensorInfo(l,A.dtype,[]);if(n.shouldExecuteOnCPU([A])||"string"===A.dtype){const e=n.texData.get(A.dataId),t=TG(e.values,a,l,A.shape,A.dtype);return n.makeTensorInfo(l,A.dtype,t)}const{isPacked:m}=n.texData.get(A.dataId),p=s.kuN.isSliceContinous(A.shape,a,l);if(m||!p){const e=(0,s.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rk(l):new Tk(l),t=[a];return n.runWebGLProgram(e,[A],A.dtype,t)}return n.uploadToGPU(A.dataId),function(e,t,n,o){const A=o.texData.get(e.dataId),i=o.makeTensorInfo(n,e.dtype),r=o.texData.get(i.dataId);Object.assign(r,A),r.refCount=1,r.shape=n,r.dtype=e.dtype;let a=s.kuN.computeFlatOffset(t,s.D5U.computeStrides(e.shape));A.slice&&(a+=A.slice.flatOffset),r.slice={flatOffset:a,origDataId:A.slice&&A.slice.origDataId||e.dataId};const l=o.dataRefCount.get(r.slice.origDataId)||1;return o.dataRefCount.set(r.slice.origDataId,l+1),i}(A,a,l,n)}const Pk={kernelName:s.p2w,backendName:"webgl",kernelFunc:Ok},Uk={kernelName:s.zws,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{blockShape:i,crops:r}=o;s.D5U.assert(A.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const a=i.reduce(((e,t)=>e*t)),l=s.Wap.getReshaped(A.shape,i,a),m=s.Wap.getPermuted(l.length,i.length),p=s.Wap.getReshapedPermuted(A.shape,i,a),h=s.Wap.getSliceBeginCoords(r,i.length),u=s.Wap.getSliceSize(p,r,i.length),c=[],d=ME({inputs:{x:A},backend:n,attrs:{shape:l}}),I=WE({inputs:{x:d},backend:n,attrs:{perm:m}}),G=ME({inputs:{x:I},backend:n,attrs:{shape:p}}),E=Ok({inputs:{x:G},backend:n,attrs:{begin:h,size:u}});return c.push(d),c.push(I),c.push(G),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),E}},Vk={kernelName:s.zvY,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,weights:i}=t,{size:r}=o,s=n.readSync(A.dataId),a=n.readSync(i.dataId),l=hG(s,a,i.dtype,i.shape,r);return n.makeTensorInfo([r],i.dtype,l)}},Wk={kernelName:s.eEB,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:o,s1:A}=t,i=n.readSync(o.dataId),r=n.readSync(A.dataId),a=s.Wap.assertAndGetBroadcastShape(Array.from(i),Array.from(r));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},_k=KE({opSnippet:"return float(a != b);",cpuKernelImpl:xG,dtype:"bool"}),zk={kernelName:s.yQU,backendName:"webgl",kernelFunc:_k};function Xk(e){const{inputs:t,backend:n}=e,{input:o}=t;return EE({inputs:{x:n.texData.get(o.dataId).complexTensorInfos.real},backend:n})}const Qk={kernelName:s.xJR,backendName:"webgl",kernelFunc:Xk},Zk={kernelName:s.RFZ,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:o,attrs:A}=t,{x:i}=n,{dtype:r}=A;if("complex64"===r){if("complex64"===i.dtype)return EE({inputs:{x:i},backend:o});const t=s.lls(i.shape),n=e({inputs:{x:i},backend:o,attrs:{dtype:"float32"}}),A=gE({inputs:{real:n,imag:t},backend:o});return t.dispose(),o.disposeIntermediateTensorInfo(n),A}if("complex64"===i.dtype){const t=Xk({inputs:{input:i},backend:o}),n=e({inputs:{x:t},backend:o,attrs:{dtype:r}});return o.disposeIntermediateTensorInfo(t),n}if(!s.D5U.hasEncodingLoss(i.dtype,r)){const e=EE({inputs:{x:i},backend:o});return{dataId:e.dataId,shape:e.shape,dtype:r}}if("int32"===r)return function(e,t){const n=new sE(e.shape,"return float(int(x));"),o=t.runWebGLProgram(n,[e],"int32");return{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}(i,o);if("bool"===r){const e=o.makeTensorInfo([],"bool",s.D5U.getTypedArrayFromDType("bool",1)),t=_k({inputs:{a:i,b:e},backend:o});return o.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}},Yk="return ceil(x);",$k=jE({opSnippet:Yk,packedOpSnippet:Yk,cpuKernelImpl:cG}),eg={kernelName:s.gJX,backendName:"webgl",kernelFunc:$k};class tg{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class ng{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const og={kernelName:s.xnO,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{clipValueMin:i,clipValueMax:r}=o;let a;a=(0,s.OBj)().getBool("WEBGL_PACK_CLIP")?new ng(A.shape):new tg(A.shape);const l=[[i],[r]];return n.runWebGLProgram(a,[A],A.dtype,l)}};class Ag{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function ig(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const rg={kernelName:s.yj2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t,A=n.texData.get(o.dataId),i=new Ag(o.shape),r=[ig(o,A.complexTensorInfos.real),ig(o,A.complexTensorInfos.imag)];return n.runWebGLProgram(i,r,r[0].dtype)}};class sg{constructor(e){this.outputShape=[],this.outputShape=s.Wap.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const o=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${o}));`)}const o=t.length,A=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${A}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ag{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=s.Wap.computeOutShape(e,t);const n=this.outputShape,o=n.length,A=WI(o),i=eE("coords",o),r=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map(((e,t)=>`T${t}`));const a=new Array(e.length-1);a[0]=e[0][t];for(let n=1;n<a.length;n++)a[n]=a[n-1]+e[n][t];const l=r[t],m=r.slice(-2),p=r.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${m.join()}));\n        }`;for(let e=1;e<a.length;e++){const t=a[e-1];h+=`\n        if (${l} < ${a[e]}  && ${l} >= ${a[e-1]}) {\n          return getChannel(\n            getT${e}(${lg(r,l,t)}),\n            vec2(${lg(m,l,t)}));\n        }`}const u=a.length,c=a[a.length-1];h+=`\n        return getChannel(\n          getT${u}(${lg(r,l,c)}),\n          vec2(${lg(m,l,c)}));`,this.userCode=`\n      float getValue(${r.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${A} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[o-1]} = ${i[o-1]} + 1;\n        if (${i[o-1]} < ${n[o-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[o-2]} = ${i[o-2]} + 1;\n        if (${i[o-2]} < ${n[o-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[o-1]} = ${i[o-1]} - 1;\n        if (${i[o-2]} < ${n[o-2]} &&\n            ${i[o-1]} < ${n[o-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function lg(e,t,n){const o=e.indexOf(t);return e.map(((e,t)=>t===o?`${e} - ${n}`:e)).join()}function mg(e){const{inputs:t,backend:n}=e,{input:o}=t;return EE({inputs:{x:n.texData.get(o.dataId).complexTensorInfos.imag},backend:n})}const pg={kernelName:s.J_u,backendName:"webgl",kernelFunc:mg};function hg(e,t,n){const o=e[0].dtype;if("complex64"===o){const o=e.map((e=>Xk({inputs:{input:e},backend:n}))),A=e.map((e=>mg({inputs:{input:e},backend:n}))),i=hg(o,t,n),r=hg(A,t,n),s=gE({inputs:{real:i,imag:r},backend:n});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),A.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(r),s}let A=n.shouldExecuteOnCPU(e);if("string"===o&&(A=!0),A){const A=e.map((e=>{const o=s.D5U.sizeFromShape(e.shape.slice(t));return ME({inputs:{x:e},backend:n,attrs:{shape:[-1,o]}})})),i=A.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),r=s.Wap.computeOutShape(A.map((e=>e.shape)),1),a=1===A[0].shape[0],l=dG(i,r,o,a),m=s.Wap.computeOutShape(e.map((e=>e.shape)),t),p=n.makeTensorInfo(m,o,l);return A.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}if(e.length>(0,s.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const o=Math.floor(e.length/2),A=hg(e.slice(0,o),t,n),i=hg(e.slice(o),t,n),r=hg([A,i],t,n);return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(i),r}if((0,s.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const A=new ag(e.map((e=>e.shape)),t);return n.runWebGLProgram(A,e,o)}const{tensors2D:i,outShape:r}=function(e,t,n){const o=s.Wap.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>ME({inputs:{x:e},attrs:{shape:[-1,s.D5U.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:o}}(e,t,n),a=new sg(i.map((e=>e.shape))),l=n.runWebGLProgram(a,i,o);i.forEach((e=>n.disposeIntermediateTensorInfo(e)));const m=ME({inputs:{x:l},attrs:{shape:r},backend:n});return n.disposeIntermediateTensorInfo(l),m}function ug(e){const{inputs:t,backend:n,attrs:o}=e,{axis:A}=o,i=s.D5U.parseAxisParam(A,t[0].shape)[0],r=s.Wap.computeOutShape(t.map((e=>e.shape)),i);if(0===s.D5U.sizeFromShape(r))return n.makeTensorInfo(r,t[0].dtype,[]);const a=t.filter((e=>s.D5U.sizeFromShape(e.shape)>0));if(1===a.length)return EE({inputs:{x:a[0]},backend:n});const l=a.map((e=>e.shape));return s.Wap.assertParamsConsistent(l,i),hg(a,i,n)}const cg={kernelName:s.Eh3,backendName:"webgl",kernelFunc:ug};class dg{constructor(e,t=!1,n=null,o=!1,A=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,r=e.padInfo.left,s=e.strideHeight,a=e.strideWidth,l=e.dilationHeight,m=e.dilationWidth,p=e.filterHeight,h=e.filterWidth,u=4*Math.floor(e.inChannels/4),c=e.inChannels%4,d="channelsLast"===e.dataFormat,I=d?1:2,G=d?2:3,E=d?3:1;let k="",g="";n&&(k=o?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:A?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),A&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${k}\n\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${E}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${I}], coords[${G}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${m};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${u}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${d}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===c}) {\n\n              if (${d}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${u}) *\n                    getW(wR, wC, ${u}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${u}, xR, xC) *\n                    getW(wR, wC, ${u}, d2);\n              }\n\n            } else if (${2===c}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${u}, d2),\n                getW(wR, wC, ${u} + 1, d2)\n              );\n\n              if (${d}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${u}),\n                  getX(batch, xR, xC, ${u} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${u}, xR, xC),\n                  getX(batch, ${u} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===c}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${u}, d2),\n                getW(wR, wC, ${u} + 1, d2),\n                getW(wR, wC, ${u} + 2, d2)\n              );\n\n              if (${d}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${u}),\n                  getX(batch, xR, xC, ${u} + 1),\n                  getX(batch, xR, xC, ${u} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${u}, xR, xC),\n                  getX(batch, ${u} + 1, xR, xC),\n                  getX(batch, ${u} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${f}\n        ${g}\n        setOutput(result);\n      }\n    `}}class Ig{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,A=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,m=e.filterDepth,p=e.filterHeight,h=e.filterWidth,u=4*Math.floor(e.inChannels/4),c=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${A}, ${i}, ${r});\n      const ivec3 pads = ivec3(${t}, ${n}, ${o});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p}; wR++) {\n            int xR = xRCorner + wR * ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${u}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===c}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${u}) *\n                  getW(wF, wR, wC, ${u}, d2);\n              } else if (${2===c}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${u}),\n                  getX(batch, xF, xR, xC, ${u} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${u}, d2),\n                  getW(wF, wR, wC, ${u} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===c}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${u}),\n                  getX(batch, xF, xR, xC, ${u} + 1),\n                  getX(batch, xF, xR, xC, ${u} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${u}, d2),\n                  getW(wF, wR, wC, ${u} + 1, d2),\n                  getW(wF, wR, wC, ${u} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Gg{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ZI(this.outputShape.length);const{dataFormat:n}=t,o=bI(),A="channelsLast"===n,i=A?0:1,r=A?1:2,s=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let a="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)a+=`\n          blockIndex = rc.y + ${t};\n          pos = rc.x + ${e};\n\n          ${s}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${r}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${A}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${a}\n\n        ${o.output} = result;\n      }\n    `}}function Eg({x:e,filter:t,convInfo:n,backend:o,bias:A=null,preluActivationWeights:i=null,leakyreluAlpha:r=0,activation:a=null}){const l=e.shape,m=o.texData.get(e.dataId),p=n.inChannels,h=l[0]*l[1]*l[2],u=n.outChannels,c="channelsLast"===n.dataFormat;let d;const I=[];if((1!==h&&1!==u||!(p>1e3))&&m.isPacked&&c&&null!=m.texture&&l[2]%2!=0&&s.D5U.arraysEqual(m.shape.slice(-3),l.slice(-3))){const p=l[0]*l[1]*(l[2]+1),h={dataId:e.dataId,shape:[1,p,n.inChannels],dtype:e.dtype},u=m.shape;m.shape=m.shape.slice(),m.shape[m.shape.length-2]++,s.D5U.assert(FI(m.shape,h.shape),(()=>`packed reshape ${m.shape} to ${h.shape} isn't free`));const c=ME({inputs:{x:t},backend:o,attrs:{shape:[1,n.inChannels,n.outChannels]}});I.push(c);const G=zE({a:h,b:c,backend:o,transposeA:!1,transposeB:!1,bias:A,activation:a,preluActivationWeights:i,leakyreluAlpha:r}),E=o.texData.get(G.dataId);s.D5U.assert(E.isPacked,(()=>"batchMatMul result is expected to be packed")),m.shape=u,E.shape=n.outShape,d=EE({inputs:{x:G},backend:o}),d.shape=n.outShape,I.push(G)}else{const s=ME({inputs:{x:e},backend:o,attrs:{shape:[1,c?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],n.inChannels]}}),m=ME({inputs:{x:t},backend:o,attrs:{shape:[1,n.inChannels,n.outChannels]}}),p=zE({a:s,b:m,transposeA:!1,transposeB:!1,backend:o,bias:A,activation:a,preluActivationWeights:i,leakyreluAlpha:r});d=ME({inputs:{x:p},backend:o,attrs:{shape:n.outShape}}),I.push(s),I.push(m),I.push(p)}for(const e of I)o.disposeIntermediateTensorInfo(e);return d}function kg({x:e,filter:t,convInfo:n,backend:o,bias:A=null,preluActivationWeights:i=null,leakyreluAlpha:r=0,activation:a=null}){const{filterWidth:l,filterHeight:m,inChannels:p,outWidth:h,outHeight:u,dataFormat:c}=n,d="channelsLast"===c,I=l*m*p,G=u*h,E=[I,G],k=[],g=ME({inputs:{x:e},backend:o,attrs:{shape:e.shape.slice(1)}}),f=ME({inputs:{x:t},backend:o,attrs:{shape:[1,I,s.D5U.sizeFromShape(t.shape)/I]}});k.push(g),k.push(f);const H=new Gg(E,n),F=[g.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],C=o.runWebGLProgram(H,[g],"float32",F),D=ME({inputs:{x:C},backend:o,attrs:{shape:[1,E[0],E[1]]}});k.push(C),k.push(D);const J=null!=A,v=null!=i,j="leakyrelu"===a,K=a?yE(a,!0):null,y=new bE(D.shape,f.shape,[1,G,n.outChannels],!0,!1,J,K,v,j),b=[D,f];if(A&&b.push(A),v&&b.push(i),j){const e=o.makeTensorInfo([],"float32",s.D5U.createScalarValue(r,"float32"));b.push(e),k.push(e)}const q=o.runWebGLProgram(y,b,"float32"),x=ME({inputs:{x:q},backend:o,attrs:{shape:d?[1,u,h,n.outChannels]:[1,n.outChannels,u,h]}});k.push(q);for(const e of k)o.disposeIntermediateTensorInfo(e);return x}const gg={kernelName:s.mhS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dataFormat:l,dilations:m,dimRoundingMode:p}=o,h=s.Wap.convertConv2DDataFormat(l),u=s.Wap.computeConv2DInfo(A.shape,i.shape,r,m,a,p,!1,h);let c;if(1!==u.filterHeight||1!==u.filterWidth||1!==u.dilationHeight||1!==u.dilationWidth||1!==u.strideHeight||1!==u.strideWidth||"SAME"!==u.padInfo.type&&"VALID"!==u.padInfo.type)if((0,s.OBj)().getBool("WEBGL_CONV_IM2COL")&&1===A.shape[0])c=kg({x:A,filter:i,convInfo:u,backend:n});else{const e=new dg(u);c=n.runWebGLProgram(e,[A,i],"float32")}else c=Eg({x:A,filter:i,convInfo:u,backend:n});const d=ME({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}};class fg{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,A=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${o};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${A};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${i}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Hg{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,A=e.strideWidth,i="channelsLast"===e.dataFormat,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left,a=i?1:2,l=i?2:3,m=i?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${m}];\n\n        ivec2 dyCorner = ivec2(coords[${a}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${A}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Fg{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,A=e.padInfo.front,i=e.padInfo.top,r=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${A};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${i};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${o} - ${r};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Cg{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,A=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.front,a=n-1-e.padInfo.top,l=o-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${s}, ${a}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${A}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${o}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${o} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Dg={kernelName:s.wUP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,dy:i}=t,{strides:r,pad:a,dataFormat:l,dimRoundingMode:m,filterShape:p}=o,h=s.Wap.convertConv2DDataFormat(l),u=s.Wap.computeConv2DInfo(A.shape,p,r,1,a,m,!1,h),c=new fg(u);return n.runWebGLProgram(c,[A,i],"float32")}},Jg={kernelName:s.wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,filter:i}=t,{inputShape:r,strides:a,pad:l,dataFormat:m,dimRoundingMode:p}=o,h=s.Wap.convertConv2DDataFormat(m),u=s.Wap.computeConv2DInfo(r,i.shape,a,1,l,p,!1,h),c=new Hg(u);return n.runWebGLProgram(c,[A,i],"float32")}},vg={kernelName:s.x12,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dilations:l}=o,m=s.Wap.computeConv3DInfo(A.shape,i.shape,r,l,a),p=new Ig(m);return n.runWebGLProgram(p,[A,i],"float32")}},jg={kernelName:s.o2y,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,dy:i}=t,{strides:r,pad:a,filterShape:l}=o,m=s.Wap.computeConv3DInfo(A.shape,l,r,1,a),p=new Fg(m);return n.runWebGLProgram(p,[A,i],"float32")}},Kg={kernelName:s.ik2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,filter:i}=t,{pad:r,strides:a,inputShape:l}=o,m=s.Wap.computeConv3DInfo(l,i.shape,a,1,r),p=new Cg(m);return n.runWebGLProgram(p,[A,i],"float32")}},yg=jE({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),bg={kernelName:s.mc4,backendName:"webgl",kernelFunc:yg},qg=jE({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),xg={kernelName:s.TR1,backendName:"webgl",kernelFunc:qg};class Bg{constructor(e,t,n,o,A){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,r,s,a]=e,[l]=t,[m,p]=n;this.outputShape=[l,m,p,a];const h="bilinear"===o?1:0,[u,c]=[r-1+".0",s-1+".0"],[d,I,G]=m>1?[""+(r-1)/(m-1),"(y2-y1) * height_ratio",`y1*${u} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${u}`],[E,k,g]=p>1?[""+(s-1)/(p-1),"(x2-x1) * width_ratio",`x1*${c} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${c}`];this.userCode=`\n      const float height_ratio = float(${d});\n      const float width_ratio = float(${E});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${I};\n        float width_scale = ${k};\n\n        float in_y = ${G};\n        if( in_y < 0.0 || in_y > ${u} ) {\n          setOutput(float(${A}));\n          return;\n        }\n        float in_x = ${g};\n        if( in_x < 0.0 || in_x > ${c} ) {\n          setOutput(float(${A}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const wg={kernelName:s.VcC,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{image:A,boxes:i,boxInd:r}=t,{cropSize:s,method:a,extrapolationValue:l}=o,m=new Bg(A.shape,i.shape,s,a,l);return n.runWebGLProgram(m,[A,i,r],"float32")}};class Mg{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const o=e.length,A=t?"0.0":`getX(${Lg(o,"coords")})`,i=e[e.length-1];let r="",s="";t?(r=n?"end != "+(i-1):"end != 0",s=n?"end + 1":"end - 1"):(r=n?`end + pow2 < ${i}`:"end >= pow2",s=n?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${WI(o)} coords = getOutputCoords();\n        int end = ${Sg(o,"coords")};\n        float val = ${A};\n        int pow2 = int(pow(2.0, index));\n        if (${r}) {\n          int idx = ${s};\n          ${Sg(o,"coords")} = idx;\n          val += getX(${Lg(o,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function Lg(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function Sg(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const Tg={kernelName:s.iHb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,exclusive:r,reverse:a}=o,l=A.shape.length,m=s.Wap.getAxesPermutation([i],l);let p=A;null!=m&&(p=WE({inputs:{x:A},backend:n,attrs:{perm:m}}));const h=s.Wap.getInnerMostAxes(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${A.shape.length-1} but got axis=${i}`);const u=p.shape[h];let c=EE({inputs:{x:p},backend:n});for(let e=0;e<=Math.ceil(Math.log2(u))-1;e++){const t=new Mg(p.shape,!1,a),o=[[e]],A=c;c=n.runWebGLProgram(t,[c],c.dtype,o),n.disposeIntermediateTensorInfo(A)}if(r){const e=new Mg(p.shape,r,a),t=c;c=n.runWebGLProgram(e,[c],c.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=m){const e=WE({inputs:{x:c},backend:n,attrs:{perm:s.Wap.getUndoAxesPermutation(m)}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),e}return c}},Ng={kernelName:s.QRR,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,weights:i}=t,{size:r,binaryOutput:s}=o;if(1===A.shape.length){const e=n.readSync(A.dataId),t=n.readSync(i.dataId),o=hG(e,t,i.dtype,i.shape,r);return n.makeTensorInfo([r],i.dtype,o)}if(2===A.shape.length){const e=n.bufferSync(A),t=n.bufferSync(i),o=uG(e,t,r,s);return n.makeTensorInfo(o.shape,i.dtype,o.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${A.shape.length}.`)}};class Rg{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Og={kernelName:s.T0n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{blockSize:i,dataFormat:r}=o,s=A.shape[0],a=("NHWC"===r?A.shape[1]:A.shape[2])*i,l=("NHWC"===r?A.shape[2]:A.shape[3])*i,m=("NHWC"===r?A.shape[3]:A.shape[1])/(i*i),p=new Rg("NHWC"===r?[s,a,l,m]:[s,m,a,l],i,r);return n.runWebGLProgram(p,[A],A.dtype)}};class Pg{constructor(e,t=!1,n=null,o=!1,A=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ZI(this.outputShape.length);const i=e.filterHeight,r=e.filterWidth,s=e.outChannels/e.inChannels;let a="",l="";n&&(a=o?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:A?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),A&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${a}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${l}\n        setOutput(result);\n      }\n    `}}class Ug{constructor(e,t=!1,n=null,o=!1,A=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ZI(this.outputShape.length);const i=e.outChannels/e.inChannels,r=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,m=e.filterHeight,p=e.filterWidth,h=p;let u="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<p;e++)u+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;u+=`\n    for (int r = 0; r < ${m}; r++) {\n      `;for(let e=0;e<p;e++)u+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;u+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(h+1)/2;e++){const t=2*e;if(u+=`\n          xC = xCCorner + ${t*l};\n          `,1===a){if(t<p&&(r%2==1?(u+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,u+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):u+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<p)){const e=r%2==0?s.D5U.nearestLargerEven(l):l;l%2==0&&r%2==1||l%2!=0&&r%2!=1?(u+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,l>1&&(u+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `),u+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `):u+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<p&&(r%2==1?(u+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<p&&(u+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(u+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<p&&(u+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<p&&(u+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<p&&(u+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}u+="\n    }\n  ",u+="\n      }\n    ";let c="",d="";n&&(c=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:A?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,d="result = activation(result);");const I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),A&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${u}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${I}\n        ${d}\n        setOutput(result);\n      }\n    `}}const Vg={kernelName:s.cie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dilations:l,dimRoundingMode:m}=o;let p=l;null==p&&(p=[1,1]),s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(r,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${p}'`));const h=s.Wap.computeConv2DInfo(A.shape,i.shape,r,p,a,m,!0);let u;u=(0,s.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new Ug(h):new Pg(h);const c=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(u,[A,i],"float32",c)}};class Wg{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,A=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${o};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${A};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _g{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,A=e.strideWidth,i=t-1-e.padInfo.top,r=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${A}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const zg={kernelName:s.sL$,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,dy:i}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:m,filterShape:p}=o,h=s.Wap.computeConv2DInfo(A.shape,p,r,a,l,m,!0),u=new Wg(h);return n.runWebGLProgram(u,[A,i],"float32")}},Xg={kernelName:s.y7R,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,filter:i}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:m,inputShape:p}=o,h=s.Wap.computeConv2DInfo(p,i.shape,r,a,l,m,!0),u=new _g(h);return n.runWebGLProgram(u,[A,i],"float32")}};class Qg{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Zg={kernelName:s.$w,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t,A=[...o.shape,...o.shape],i=s.D5U.sizeFromShape(o.shape),r=ME({inputs:{x:o},backend:n,attrs:{shape:[i]}}),a=new Qg(i),l=n.runWebGLProgram(a,[r],r.dtype),m=ME({inputs:{x:l},backend:n,attrs:{shape:A}});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(l),m}};class Yg{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:o,strideHeight:A,strideWidth:i,filterHeight:r,filterWidth:s,dilationHeight:a,dilationWidth:l}=e,{top:m,left:p}=o;this.userCode=`\n      const ivec2 strides = ivec2(${A}, ${i});\n      const ivec2 pads = ivec2(${m}, ${p});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${r}; h++) {\n          int hIn = hBeg + h * ${a};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${s}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const $g={kernelName:s.p4S,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i}=t,{strides:r,pad:a,dilations:l}=o,m=s.Wap.computeDilation2DInfo(A.shape,i.shape,r,a,"NHWC",l);let p;const h=new Yg(m);p=n.runWebGLProgram(h,[A,i],"float32");const u=ME({inputs:{x:p},backend:n,attrs:{shape:m.outShape}});return n.disposeIntermediateTensorInfo(p),u}},ef={kernelName:s.$g6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{equation:A}=o,i=t,{allDims:r,summedDims:a,idDims:l}=s.Wap.decodeEinsumEquation(A,i.length);s.Wap.checkEinsumDimSizes(r.length,l,i);const{path:m,steps:p}=s.Wap.getEinsumComputePath(a,l),h=p.length;let u=null,c=r.length;const d=[];for(let e=0;e<h;++e){for(const t of p[e]){const{permutationIndices:e,expandDims:o}=s.Wap.getEinsumPermutation(c,l[t]);let A;s.Wap.isIdentityPermutation(e)?A=i[t]:(A=WE({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),d.push(A));const r=A.shape.slice();for(let e=0;e<o.length;++e)r.splice(o[e],0,1);s.D5U.arraysEqual(A.shape,r)||(A=ME({inputs:{x:A},backend:n,attrs:{shape:r}}),d.push(A)),null===u?u=A:(u=BE({inputs:{a:A,b:u},backend:n}),d.push(u))}e<h-1&&(m[e]>=0&&(u=UE({inputs:{x:u},backend:n,attrs:{axis:m[e]-(r.length-c),keepDims:!1}}),d.push(u)),c--)}for(const e of d)e!==u&&n.disposeIntermediateTensorInfo(e);return u}},tf=jE({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),nf={kernelName:s.SX0,backendName:"webgl",kernelFunc:tf},of={kernelName:s.HEU,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:o,y:A}=t,i=(0,s.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GE("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",o.shape,A.shape):new IE("return (b >= 1.0) ? a : a * (b + 1.0);",o.shape,A.shape);return n.runWebGLProgram(i,[o,A],o.dtype)}},Af=KE({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:IG}),rf={kernelName:s.hdR,backendName:"webgl",kernelFunc:Af},sf=jE({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${s.Wap.ERF_P};\n  float a1 = ${s.Wap.ERF_A1};\n  float a2 = ${s.Wap.ERF_A2};\n  float a3 = ${s.Wap.ERF_A3};\n  float a4 = ${s.Wap.ERF_A4};\n  float a5 = ${s.Wap.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),af={kernelName:s.Omj,backendName:"webgl",kernelFunc:sf},lf="return exp(x);",mf=jE({opSnippet:lf,packedOpSnippet:lf,cpuKernelImpl:GG,dtype:"float32"}),pf={kernelName:s.NEP,backendName:"webgl",kernelFunc:mf};function hf(e){const{inputs:t,attrs:n,backend:o}=e,{dim:A}=n,{input:i}=t,r=i.shape.length,a=i.shape.slice();let l=A;return A<0&&(s.D5U.assert(-(r+1)<=A,(()=>`Axis must be in the interval [${-(r+1)}, ${r}]`)),l=r+A+1),a.splice(l,0,1),ME({inputs:{x:i},backend:o,attrs:{shape:a}})}const uf={kernelName:s.YFo,backendName:"webgl",kernelFunc:hf},cf="return exp(x) - 1.0;",df=jE({opSnippet:cf,packedOpSnippet:cf,cpuKernelImpl:EG}),If={kernelName:s.Y0y,backendName:"webgl",kernelFunc:df};class Gf{constructor(e,t,n){this.variableNames=["real","imag"];const o=t[1];this.outputShape=t;const A=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0";let r;if("real"===e)r="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);r="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${A};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${r}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${o});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${o}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Ef(e,t,n){const o=n.texData.get(e.dataId),A=s.D5U.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],r=ME({inputs:{x:e},backend:n,attrs:{shape:[A/i,i]}}),a=r.shape,l=new Gf("real",a,t),m=new Gf("imag",a,t),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a}],h=n.runWebGLProgram(l,p,"float32"),u=n.runWebGLProgram(m,p,"float32"),c=gE({inputs:{real:h,imag:u},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u);const d=ME({inputs:{x:c},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(c),d}const kf={kernelName:s.vwp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:o}=t;return Ef(o,!1,n)}};class gf{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function ff(e){const{backend:t,attrs:n}=e,{shape:o,value:A}=n;let{dtype:i}=n;if(i=i||s.D5U.inferDtype(A),"string"===i){const e=s.D5U.getArrayFromDType(i,s.D5U.sizeFromShape(o));return e.fill(A),t.makeTensorInfo(o,i,e)}{const e=new gf(o,A),n=[[A]];return t.runWebGLProgram(e,[],i,n)}}const Hf={kernelName:s.deh,backendName:"webgl",kernelFunc:ff};class Ff{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Cf={kernelName:s.Uyb,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,o=t,A=new Ff(n.shape);return o.runWebGLProgram(A,[n],n.dtype)}},Df="return floor(x);",Jf=jE({opSnippet:Df,packedOpSnippet:Df,cpuKernelImpl:kG}),vf={kernelName:s.OR,backendName:"webgl",kernelFunc:Jf},jf=KE({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Kf={kernelName:s.jeX,backendName:"webgl",kernelFunc:jf};class yf{constructor(e){this.variableNames=["A"];const t=bI(),[n,o]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class bf{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=bI(),[n,o]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${o}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const qf={kernelName:s.eBW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e;let{pixels:A}=t;const{numChannels:i}=o,r="undefined"!=typeof HTMLVideoElement&&A instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&A instanceof HTMLImageElement,[l,m]=r?[A.videoWidth,A.videoHeight]:[A.width,A.height],p=[m,l],h=[m,l,i];(a||r)&&(null==xf&&(xf=document.createElement("canvas").getContext("2d")),xf.canvas.width=l,xf.canvas.height=m,xf.drawImage(A,0,0,l,m),A=xf.canvas);const u=n.makeTensorInfo(p,"int32");n.texData.get(u.dataId).usage=nI.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(u.dataId),A);const c=(0,s.OBj)().getBool("WEBGL_PACK")?new bf(h):new yf(h),d=n.runWebGLProgram(c,[u],"int32");return n.disposeData(u.dataId),d}};let xf;const Bf={kernelName:s._V0,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i,bias:r,preluActivationWeights:a}=t,{strides:l,pad:m,dataFormat:p,dilations:h,dimRoundingMode:u,activation:c,leakyreluAlpha:d}=o,I=s.Wap.convertConv2DDataFormat(p),G=s.Wap.computeConv2DInfo(A.shape,i.shape,l,h,m,u,!1,I);let E;const k=[];if(1!==G.filterHeight||1!==G.filterWidth||1!==G.dilationHeight||1!==G.dilationWidth||1!==G.strideHeight||1!==G.strideWidth||"SAME"!==G.padInfo.type&&"VALID"!==G.padInfo.type)if((0,s.OBj)().getBool("WEBGL_CONV_IM2COL")&&1===A.shape[0])E=kg({x:A,filter:i,convInfo:G,backend:n,bias:r,activation:c,preluActivationWeights:a,leakyreluAlpha:d});else{const e=null!=r,t=null!=a,o="leakyrelu"===c,l=c?yE(c,!1):null,m=new dg(G,e,l,t,o),p=[A,i];if(r&&p.push(r),a&&p.push(a),o){const e=n.makeTensorInfo([],"float32",s.D5U.createScalarValue(d,"float32"));p.push(e),k.push(e)}E=n.runWebGLProgram(m,p,"float32")}else E=Eg({x:A,filter:i,convInfo:G,backend:n,bias:r,activation:c,preluActivationWeights:a,leakyreluAlpha:d});const g=ME({inputs:{x:E},backend:n,attrs:{shape:G.outShape}});return k.push(E),k.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}},wf={kernelName:s.luS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,filter:i,bias:r,preluActivationWeights:a}=t,{strides:l,pad:m,dilations:p,dimRoundingMode:h,activation:u,leakyreluAlpha:c}=o,d=[];let I=p;null==I&&(I=[1,1]),s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(l,I),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${I}'`));const G=s.Wap.computeConv2DInfo(A.shape,i.shape,l,I,m,h,!0),E=(0,s.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&G.strideWidth<=2&&G.outChannels/G.inChannels==1,k=u?yE(u,E):null,g=[A,i],f=null!=r,H=null!=a,F="leakyrelu"===u;if(f&&g.push(r),H&&g.push(a),F){const e=n.makeTensorInfo([],"float32",s.D5U.createScalarValue(c,"float32"));g.push(e),d.push(e)}let C;C=E?new Ug(G,f,k,H,F):new Pg(G,f,k,H,F);const D=[[G.padInfo.top,G.padInfo.left],[G.strideHeight,G.strideWidth],[G.dilationHeight,G.dilationWidth],[G.inHeight,G.inWidth]],J=n.runWebGLProgram(C,g,"float32",D);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),J}};class Mf{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const o=WI(t.length),A=WI(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${this.strides});\n         void main() {\n          ${A} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${i};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const Lf={kernelName:s.q1x,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:o,indices:A}=t,i=A.shape,r=i[i.length-1],a=s.D5U.sizeFromShape(o.shape),[l,m,p,h]=s.Wap.prepareAndValidate(o,A),u=ME({inputs:{x:A},backend:n,attrs:{shape:[m,r]}}),c=ME({inputs:{x:o},backend:n,attrs:{shape:[s.D5U.sizeFromShape(o.shape)/p,p]}});if(n.shouldExecuteOnCPU([o,A])||"string"===o.dtype){const e=n.readSync(A.dataId),t=n.bufferSync(o),i=gG(e,t,o.dtype,m,r,p,h,o.shape,a);return n.makeTensorInfo(l,o.dtype,i.values)}const d=new Mf(r,h,[m,p]),I=n.runWebGLProgram(d,[c,u],c.dtype),G=ME({inputs:{x:I},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(I),G}};class Sf{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=WI(this.rank),o=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let t=0;t<e.length;t++)2===t?o.push("int(getIndices(resRC.x, resRC.z))"):o.push(`${n[t]}`);return o.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function Tf(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,indices:i}=t,{axis:r,batchDims:a}=o,l=s.D5U.parseAxisParam(r,A.shape)[0],m=n.readSync(i.dataId),p=A.shape[l];for(let e=0;e<m.length;++e){const t=m[e];s.D5U.assert(t<=p-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${p-1}]`))}const h=s.Wap.segment_util.collectGatherOpShapeInfo(A,i,l,a),u=s.D5U.sizeFromShape(i.shape),c=[],d=ME({inputs:{x:A},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),I=ME({inputs:{x:i},backend:n,attrs:{shape:[h.batchSize,u/h.batchSize]}});c.push(d),c.push(I);const G=[h.batchSize,h.outerSize,u/h.batchSize,h.sliceSize];if(n.shouldExecuteOnCPU([A,i])||"string"===A.dtype){const e=n.bufferSync(I),t=n.bufferSync(d),o=fG(t,e,G);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(h.outputShape,o.dtype,o.values)}const E=new Sf(d.shape,G),k=n.runWebGLProgram(E,[d,I],d.dtype);c.push(k);const g=ME({inputs:{x:k},backend:n,attrs:{shape:h.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}const Nf={kernelName:s.qi_,backendName:"webgl",kernelFunc:Tf},Rf=KE({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:HG,dtype:"bool"}),Of={kernelName:s.iZT,backendName:"webgl",kernelFunc:Rf},Pf=KE({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:FG}),Uf={kernelName:s.Acj,backendName:"webgl",kernelFunc:Pf},Vf={kernelName:s.Qg5,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:o}=t;return Ef(o,!0,n)}},Wf=jE({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),_f={kernelName:s.avt,backendName:"webgl",kernelFunc:Wf},zf=jE({opSnippet:"return float(isinf(x));",dtype:"bool"}),Xf={kernelName:s.iWB,backendName:"webgl",kernelFunc:zf},Qf=jE({opSnippet:"return float(isnan(x));",dtype:"bool"}),Zf={kernelName:s.r7n,backendName:"webgl",kernelFunc:Qf},Yf=KE({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:CG,dtype:"bool"}),$f={kernelName:s.vtC,backendName:"webgl",kernelFunc:Yf},eH=KE({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:DG,dtype:"bool"}),tH={kernelName:s.CAk,backendName:"webgl",kernelFunc:eH},nH={kernelName:s.e7N,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:o,stop:A,num:i}=n,r=JG(o,A,i);return t.makeTensorInfo([r.length],"float32",r)}},oH=jE({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:vG}),AH={kernelName:s.ZbH,backendName:"webgl",kernelFunc:oH},iH=jE({opSnippet:"return log(1.0 + x);"}),rH={kernelName:s.kU,backendName:"webgl",kernelFunc:iH},sH=KE({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),aH={kernelName:s.PYm,backendName:"webgl",kernelFunc:sH},lH=jE({opSnippet:"return float(!(x >= 1.0));"}),mH={kernelName:s.VfG,backendName:"webgl",kernelFunc:lH},pH=KE({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),hH={kernelName:s.MZg,backendName:"webgl",kernelFunc:pH};class uH{constructor(e,t,n,o,A){this.variableNames=["x"],this.outputShape=[];const i=t,r=e[3]-1;let s;this.outputShape=e;const a=`float(${n}) + float(${o}) * sum`;s=.5===A?`inversesqrt(${a})`:1===A?`1.0/(${a})`:`exp(log(${a}) * float(-${A}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${r}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${s};\n        setOutput(val);\n      }\n    `}}class cH{constructor(e,t,n,o,A){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,r=e[3]-1;let s;this.outputShape=e;const a=`float(${n}) + float(${o}) * sum`;s=.5===A?`inversesqrt(${a})`:1===A?`1.0/(${a})`:`exp(log(${a}) * float(-${A}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${r}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `}}const dH={kernelName:s.eZ0,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{depthRadius:i,bias:r,alpha:a,beta:l}=o,m=(0,s.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new cH(A.shape,i,r,a,l):new uH(A.shape,i,r,a,l);return n.runWebGLProgram(m,[A],A.dtype)}};class IH{constructor(e,t,n,o,A){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=A,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${o}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${o})\n                * float(${A})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${A});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const GH={kernelName:s.Hhh,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{x:A,y:i,dy:r}=t,{depthRadius:s,bias:a,alpha:l,beta:m}=o,p=new IH(A.shape,s,a,l,m);return n.runWebGLProgram(p,[A,i,r],A.dtype)}};function EH(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{reductionIndices:i,keepDims:r}=o,a=A.shape.length,l=s.D5U.parseAxisParam(i,A.shape);let m=l;const p=s.Wap.getAxesPermutation(m,a),h=null!=p,u=n.shouldExecuteOnCPU([A]);let c=A;if(h){if(u){const e=n.texData.get(c.dataId).values,t=new Array(a);for(let e=0;e<t.length;e++)t[e]=A.shape[p[e]];const o=ZG(e,A.shape,A.dtype,p,t);c=n.makeTensorInfo(t,A.dtype),n.texData.get(c.dataId).values=o}else c=PE(A,p,n);m=s.Wap.getInnerMostAxes(m.length,a)}s.Wap.assertAxesAreInnerMostDims("max",m,a);const[d,I]=s.Wap.computeOutAndReduceShapes(c.shape,m);let G,E=d;if(r&&(E=s.Wap.expandShapeToKeepDim(d,l)),u){const e=n.texData.get(c.dataId).values,t=jG(e,s.D5U.sizeFromShape(I),E,A.dtype);G=n.makeTensorInfo(E,A.dtype),n.texData.get(G.dataId).values=t}else G=function(e,t,n,o){const A=s.D5U.sizeFromShape(t),i=ME({inputs:{x:e},attrs:{shape:[s.D5U.sizeFromShape(e.shape)/A,A]},backend:o}),r=NE(i,e.dtype,"max",o),a=ME({inputs:{x:r},attrs:{shape:n},backend:o});return o.disposeIntermediateTensorInfo(i),o.disposeIntermediateTensorInfo(r),a}(c,I,E,n);return h&&n.disposeIntermediateTensorInfo(c),G}const kH={kernelName:s.YoZ,backendName:"webgl",kernelFunc:EH},gH=KE({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:KG}),fH={kernelName:s.BMI,backendName:"webgl",kernelFunc:gH},HH={kernelName:s.mTV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t;KI(A,"maxPool");const{filterSize:i,strides:r,pad:a,dimRoundingMode:l}=o;s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(r,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`));const m=s.Wap.computePool2DInfo(A.shape,i,r,1,a,l);if(1===m.filterWidth&&1===m.filterHeight&&s.D5U.arraysEqual(m.inShape,m.outShape))return EE({inputs:{x:A},backend:n});const p=new vk(m,"max",!1);return n.runWebGLProgram(p,[A],A.dtype)}},FH={kernelName:s.OAf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{filterSize:i,strides:r,pad:a,dataFormat:l,dimRoundingMode:m}=o,p=s.Wap.computePool3DInfo(A.shape,i,r,[1,1,1],a,m,l),h=new jk(p,"max",!1);return n.runWebGLProgram(h,[A],A.dtype)}};class CH{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,A=e.effectiveFilterHeight,i=e.effectiveFilterWidth,r=A-1-e.padInfo.top,s=i-1-e.padInfo.left,a=A*i-1;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${A};\n          wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class DH{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,A=e.dilationDepth,i=e.dilationHeight,r=e.dilationWidth,s=e.effectiveFilterDepth,a=e.effectiveFilterHeight,l=e.effectiveFilterWidth,m=s-1-e.padInfo.front,p=a-1-e.padInfo.top,h=l-1-e.padInfo.left,u=s*a*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${m}, ${p}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n           wD += ${A}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${a};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${r}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${u} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${a} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const JH={kernelName:s.OU7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i}=t,r=i,{filterSize:a,strides:l,pad:m,dimRoundingMode:p}=o,h=s.Wap.computePool3DInfo(r.shape,a,l,[1,1,1],m,p),u=new jk(h,"max",!0),c=n.runWebGLProgram(u,[r],r.dtype),d=new DH(h),I=n.runWebGLProgram(d,[A,c],r.dtype);return n.disposeIntermediateTensorInfo(c),I}},vH={kernelName:s.OV7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:A,input:i,output:r}=t,a=i;KI([i,r],"maxPoolGrad");const{filterSize:l,strides:m,pad:p,dimRoundingMode:h}=o,u=s.Wap.computePool2DInfo(a.shape,l,m,1,p,h),c=new vk(u,"max",!0),d=n.runWebGLProgram(c,[a],a.dtype),I=new CH(u),G=n.runWebGLProgram(I,[A,d],a.dtype);return n.disposeIntermediateTensorInfo(d),G}},jH={kernelName:s.vFR,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:o}=e,{filterSize:A,strides:i,pad:r,includeBatchInIndex:a}=t,l=n;s.D5U.assert(4===o.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.shape.length}.`));const m=[1,1];s.D5U.assert(s.Wap.eitherStridesOrDilationsAreOne(i,m),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`));const p=s.Wap.computePool2DInfo(o.shape,A,i,m,r),[h,u]=function(e,t,n,o){let A=new vk(n,"max",!1);const i=o.runWebGLProgram(A,[e],"float32");return A=new vk(n,"max",!0,!0,t),[i,o.runWebGLProgram(A,[e],"float32")]}(o,a,p,l);return[h,u]}},KH={kernelName:s.q2K,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:o}=e,{keepDims:A,axis:i}=t,r=n,a=o.shape.length,l=s.D5U.parseAxisParam(i,o.shape);let m=l;const p=s.Wap.getAxesPermutation(m,a),h=null!=p,u=r.shouldExecuteOnCPU([o]),c=[];let d=o;if(h){if(u){const e=r.texData.get(d.dataId).values,t=new Array(a);for(let e=0;e<t.length;e++)t[e]=o.shape[p[e]];const n=ZG(e,o.shape,o.dtype,p,t);d=r.makeTensorInfo(t,o.dtype),r.texData.get(d.dataId).values=n}else d=PE(o,p,r);c.push(d),m=s.Wap.getInnerMostAxes(m.length,a)}s.Wap.assertAxesAreInnerMostDims("sum",m,a);const[I,G]=s.Wap.computeOutAndReduceShapes(d.shape,m);let E=I;A&&(E=s.Wap.expandShapeToKeepDim(I,l));const k=function(e,t,n,o){const A=s.D5U.sizeFromShape(t),i=ME({inputs:{x:e},attrs:{shape:[s.D5U.sizeFromShape(e.shape)/A,A]},backend:o}),r=NE(i,"float32","mean",o),a=ME({inputs:{x:r},attrs:{shape:n},backend:o});return o.disposeIntermediateTensorInfo(i),o.disposeIntermediateTensorInfo(r),a}(d,G,E,r);for(const e of c)r.disposeIntermediateTensorInfo(e);return k}},yH={kernelName:s.c17,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o,a=A.shape.length,l=s.D5U.parseAxisParam(i,A.shape);let m=l;const p=s.Wap.getAxesPermutation(m,a);let h=A;null!=p&&(h=WE({inputs:{x:A},backend:n,attrs:{perm:p}}),m=s.Wap.getInnerMostAxes(m.length,A.shape.length)),s.Wap.assertAxesAreInnerMostDims("min",m,a);const[u,c]=s.Wap.computeOutAndReduceShapes(h.shape,m),d=ME({inputs:{x:h},backend:n,attrs:{shape:[-1,s.D5U.sizeFromShape(c)]}}),I=NE(d,d.dtype,"min",n);let G;return G=ME(r?{inputs:{x:I},backend:n,attrs:{shape:s.Wap.expandShapeToKeepDim(u,l)}}:{inputs:{x:I},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(I),null!=p&&n.disposeIntermediateTensorInfo(h),G}},bH=KE({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:yG}),qH={kernelName:s.q8u,backendName:"webgl",kernelFunc:bH};class xH{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const o=e.length,A=WI(o),i=t.map((e=>e[0])).join(","),r=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),a="reflect"===n?0:1;this.userCode=1!==o?`\n      ${A} start = ${A}(${i});\n      ${A} end = ${A}(${r});\n\n      void main() {\n        ${A} outC = getOutputCoords();\n        for (int i = 0; i < ${o}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${a};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${a};\n          }\n        }\n        ${A} coords = outC - start;\n        setOutput(getX(${s}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${r};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${a};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${a};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class BH{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const o=e.length,A=WI(o),i=t.map((e=>e[0])).join(","),r=t.map(((t,n)=>t[0]+e[n])).join(","),s=eE("rc",o),a=eE("source",o),l=`${s[o-1]} < ${this.outputShape[o-1]}`,m=1===o?"source":`vec2(${a.slice(-2).join()})`,p="reflect"===n?0:1;let h="";if(1===o){const e=`\n        ${A} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${p};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${p};\n        }\n        source -= start;\n      `;h=`\n        ${A} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${a.join()}), ${m});\n        ${s[o-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${a.join()}), ${m});\n        }\n      `}else{const e=`\n        ${A} source = rc;\n        ${A} lt = ${A}(lessThan(source, start));\n        ${A} gte = ${A}(greaterThanEqual(source, end));\n        ${A} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${p}) +\n                gte * ((end - 1) * 2 - source + ${p});\n        source -= start;\n      `;h=`\n        ${A} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${a.join()}), ${m});\n        ${s[o-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${a.join()}), ${m});\n        }\n        rc = outputLoc;\n        ${s[o-2]} += 1;\n        if(${s[o-2]} < ${this.outputShape[o-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${a.join()}), ${m});\n          ${s[o-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${a.join()}), ${m});\n          }\n        }\n      `}this.userCode=`\n      const ${A} start = ${A}(${i});\n      const ${A} end = ${A}(${r});\n\n      void main() {\n        ${A} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const wH={kernelName:s.jQs,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o}=e,{paddings:A,mode:i}=n,r=(0,s.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new BH(o.shape,A,i):new xH(o.shape,A,i);return t.runWebGLProgram(r,[o],o.dtype)}},MH=KE({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),LH={kernelName:s.Vbg,backendName:"webgl",kernelFunc:MH};class SH{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const TH=KE({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),NH={kernelName:s.oHH,backendName:"webgl",kernelFunc:TH},RH="return a - b;",OH=KE({opSnippet:RH,packedOpSnippet:RH,supportsComplex:!0,cpuKernelImpl:zG}),PH={kernelName:s.Tr8,backendName:"webgl",kernelFunc:OH};function UH(e){const{inputs:t,backend:n,attrs:o}=e,{logits:A}=t,{dim:i}=o,r=s.D5U.parseAxisParam([i],A.shape),a=EH({inputs:{x:A},backend:n,attrs:{reductionIndices:r,keepDims:!1}}),l=s.Wap.expandShapeToKeepDim(a.shape,r),m=ME({inputs:{x:a},backend:n,attrs:{shape:l}}),p=OH({inputs:{a:A,b:m},backend:n}),h=mf({inputs:{x:p},backend:n}),u=UE({inputs:{x:h},backend:n,attrs:{axis:r,keepDims:!1}}),c=ME({inputs:{x:u},backend:n,attrs:{shape:l}}),d=TH({inputs:{a:h,b:c},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),d}const VH={kernelName:s.Gcp,backendName:"webgl",kernelFunc:UH},WH={kernelName:s.NZg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{logits:A}=t,{numSamples:i,seed:r,normalized:s}=o,a=s?A:UH({inputs:{logits:A},backend:n,attrs:{dim:A.shape.length-1}}),l=a.shape[0],m=a.shape[1],p=new SH(l,m,i),h=[[r]],u=n.runWebGLProgram(p,[a],"int32",h);return s||n.disposeIntermediateTensorInfo(a),u}},_H="return -x;",zH={kernelName:s.kuV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t;if(n.shouldExecuteOnCPU([o])){const e=n.texData.get(o.dataId),[t,A]=qG(e.values,o.shape,o.dtype);return n.makeTensorInfo(A,o.dtype,t)}let A;return A=(0,s.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mE(o.shape,_H):new sE(o.shape,_H),n.runWebGLProgram(A,[o],o.dtype)}},XH=s.GDt.GP,QH={kernelName:s.uv1,backendName:"webgl",kernelFunc:function(e){s.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:o}=e,{boxes:A,scores:i}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l}=o,m=n.readSync(A.dataId),p=n.readSync(i.dataId),{selectedIndices:h}=XH(m,p,r,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},ZH=s.GDt.qP,YH={kernelName:s.cye,backendName:"webgl",kernelFunc:function(e){s.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:o}=e,{boxes:A,scores:i}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:m}=o,p=n.readSync(A.dataId),h=n.readSync(i.dataId),{selectedIndices:u,validOutputs:c}=ZH(p,h,r,a,l,m);return[n.makeTensorInfo([u.length],"int32",new Int32Array(u)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}},$H=s.GDt.pA,eF={kernelName:s.W0H,backendName:"webgl",kernelFunc:function(e){s.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:o}=e,{boxes:A,scores:i}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l,softNmsSigma:m}=o,p=n.readSync(A.dataId),h=n.readSync(i.dataId),u=r,c=a,d=l,I=m,{selectedIndices:G,selectedScores:E}=$H(p,h,u,c,d,I);return[n.makeTensorInfo([G.length],"int32",new Int32Array(G)),n.makeTensorInfo([E.length],"float32",new Float32Array(E))]}};class tF{constructor(e,t,n,o){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${o}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const nF={kernelName:s.we_,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{indices:A}=t,{depth:i,onValue:r,offValue:a}=o,l=s.D5U.sizeFromShape(A.shape),m=new tF(l,i,r,a),p=ME({inputs:{x:A},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(m,[p],A.dtype);n.disposeIntermediateTensorInfo(p);const u=ME({inputs:{x:h},backend:n,attrs:{shape:[...A.shape,i]}});return n.disposeIntermediateTensorInfo(h),u}};function oF(e){const{inputs:t,backend:n}=e,{x:o}=t;if("complex64"===o.dtype){const e=Xk({inputs:{input:o},backend:n}),t=oF({inputs:{x:e},backend:n}),A=mg({inputs:{input:o},backend:n}),i=oF({inputs:{x:A},backend:n}),r=gE({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(i),r}return ff({attrs:{shape:o.shape,dtype:o.dtype,value:"string"===o.dtype?"":0},backend:n})}const AF={kernelName:s.RuY,backendName:"webgl",kernelFunc:oF},iF={kernelName:s.qWM,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:o}=t,{x:A}=n;if("string"===A.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===A.dtype){const t=Xk({inputs:{input:A},backend:o}),n=e({inputs:{x:t},backend:o}),i=mg({inputs:{input:A},backend:o}),r=oF({inputs:{x:i},backend:o}),s=gE({inputs:{real:n,imag:r},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(n),o.disposeIntermediateTensorInfo(i),o.disposeIntermediateTensorInfo(r),s}return ff({attrs:{shape:A.shape,dtype:A.dtype,value:1},backend:o})}},rF={kernelName:s.QiL,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{axis:A}=o;if(1===t.length)return hf({inputs:{input:t[0]},backend:n,attrs:{dim:A}});const i=t[0].shape,r=t[0].dtype;t.forEach((e=>{s.D5U.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),s.D5U.assert(r===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const a=[],l=t.map((e=>{const t=hf({inputs:{input:e},backend:n,attrs:{dim:A}});return a.push(t),t})),m=ug({inputs:l,backend:n,attrs:{axis:A}});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}};class sF{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const o=e.length,A=WI(o),i=t.map((e=>e[0])).join(","),r=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);this.userCode=1!==o?`\n      ${A} start = ${A}(${i});\n      ${A} end = ${A}(${r});\n\n      void main() {\n        ${A} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${A} coords = outC - start;\n          setOutput(getX(${s}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${r};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class aF{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const o=e.length,A=WI(o),i=t.map((e=>e[0])).join(","),r=t.map(((t,n)=>t[0]+e[n])).join(","),s=eE("rc",o),a=eE("source",o),l=`${s[o-1]} < ${this.outputShape[o-1]}`,m=1===o?"source":`vec2(${a.slice(-2).join()})`,p=[`${A} rc = outputLoc;`,`${s[o-1]} += 1;\n       if(${l}) {\n      `,1===o?"":`}\n       rc = outputLoc;\n       ${s[o-2]} += 1;\n       if(${s[o-2]} < ${this.outputShape[o-2]}) {`,1===o?"":`  ${s[o-1]} += 1;\n         if(${l}) {`],h=1===o?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let u="";for(let e=0,t=1===o?2:4;e<t;e++)u+=`\n        ${p[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${A} source = rc - start;\n          result[${e}] = getChannel(getX(${a.join()}), ${m});\n        }\n      `;u+=1===o?"} ":"}}",this.userCode=`\n      const ${A} start = ${A}(${i});\n      const ${A} end = ${A}(${r});\n\n      void main() {\n        ${A} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${u}\n        setOutput(result);\n      }\n    `}}const lF=e=>{const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{paddings:i,constantValue:r}=o;if(0===s.D5U.sizeFromShape(A.shape)){const e=i.map(((e,t)=>e[0]+A.shape[t]+e[1]));return ff({backend:n,attrs:{shape:e,value:r,dtype:A.dtype}})}const a=(0,s.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aF(A.shape,i,r):new sF(A.shape,i,r),l=[[r]];return n.runWebGLProgram(a,[A],A.dtype,l)},mF={kernelName:s.lyA,backendName:"webgl",kernelFunc:lF},pF=KE({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),hF={kernelName:s.pe_,backendName:"webgl",kernelFunc:pF},uF={kernelName:s.DlI,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{axis:i,keepDims:r}=o,a=A.shape.length,l=[],m=s.D5U.parseAxisParam(i,A.shape);let p=m;const h=s.Wap.getAxesPermutation(p,a);let u,c=A;if(null!=h&&(c=WE({inputs:{x:A},backend:n,attrs:{perm:h}}),p=s.Wap.getInnerMostAxes(p.length,a),l.push(c)),s.Wap.assertAxesAreInnerMostDims("prod",p,a),n.shouldExecuteOnCPU([c])){const e=n.texData.get(c.dataId).values,{outVals:t,outShape:o,outDtype:A}=BG(c.shape,c.dtype,e,p);u=n.makeTensorInfo(o,A,t)}else{const[e,t]=s.Wap.computeOutAndReduceShapes(c.shape,p),o=s.D5U.sizeFromShape(t),i=ME({inputs:{x:c},backend:n,attrs:{shape:[-1,o]}}),r=NE(i,(0,s.z4k)(A.dtype),"prod",n);u=ME({inputs:{x:r},backend:n,attrs:{shape:e}}),l.push(i),l.push(r)}if(r){l.push(u);const e=s.Wap.expandShapeToKeepDim(u.shape,m);u=ME({inputs:{x:u},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},cF=e=>{const{backend:t,attrs:n}=e,{start:o,stop:A,step:i,dtype:r}=n,s=wG(o,A,i,r);return t.makeTensorInfo([s.length],r,s)},dF={kernelName:s.e6w,backendName:"webgl",kernelFunc:cF},IF=jE({opSnippet:"return 1.0 / x;"}),GF={kernelName:s.$HU,backendName:"webgl",kernelFunc:IF},EF=jE({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),kF={kernelName:s.qkr,backendName:"webgl",kernelFunc:EF},gF=jE({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),fF={kernelName:s.SbG,backendName:"webgl",kernelFunc:gF};class HF{constructor(e,t,n,o,A){this.variableNames=["A"],this.outputShape=[];const[i,r,s,a]=e;this.outputShape=[i,t,n,a];const l=[o&&t>1?r-1:r,o&&n>1?s-1:s],m=[o&&t>1?t-1:t,o&&n>1?n-1:n];let p;p=A?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/m[0]},\n          ${l[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${r}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class FF{constructor(e,t,n,o,A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,r,s,a]=e;this.outputShape=[i,t,n,a];const l=[o&&t>1?r-1:r,o&&n>1?s-1:s],m=[o&&t>1?t-1:t,o&&n>1?n-1:n];let p;p=A?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/m[0]},\n          ${l[1]/m[1]},\n          ${l[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${r}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const CF={kernelName:s._Yw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A}=t,{alignCorners:i,halfPixelCenters:r,size:a}=o,[l,m]=a,p=(0,s.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new FF(A.shape,l,m,i,r):new HF(A.shape,l,m,i,r);return n.runWebGLProgram(p,[A],"float32")}};class DF{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,o,A]=t,[,i,r]=e,s=[n&&i>1?o-1:o,n&&r>1?A-1:A],a=[n&&i>1?i-1:i,n&&r>1?r-1:r],l=s[0]/a[0],m=s[1]/a[1],p=1/l,h=1/m,u=2*Math.ceil(p)+2,c=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${u});\n        const int winWidth = int(${c});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${r}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${A-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const JF={kernelName:s.zbQ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A,dy:i}=t,{alignCorners:r}=o,s=new DF(i.shape,A.shape,r);return n.runWebGLProgram(s,[i],i.dtype)}};class vF{constructor(e,t,n,o,A){this.variableNames=["A"],this.outputShape=[];const[i,r,s,a]=e;this.outputShape=[i,t,n,a];const l=[o&&t>1?r-1:r,o&&n>1?s-1:s],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],p=o?"0.5":"0.0";let h;h=A?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/m[0]},\n          ${l[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${r}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class jF{constructor(e,t,n,o,A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,r,s,a]=e;this.outputShape=[i,t,n,a];const l=[o&&t>1?r-1:r,o&&n>1?s-1:s],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],p=o?"0.5":"0.0";let h;h=A?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/m[0]},\n          ${l[1]/m[1]},\n          ${l[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${r}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const KF={kernelName:s.dpD,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A}=t,{alignCorners:i,halfPixelCenters:r,size:a}=o,[l,m]=a,p=(0,s.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new jF(A.shape,l,m,i,r):new vF(A.shape,l,m,i,r);return n.runWebGLProgram(p,[A],A.dtype)}};class yF{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,o,A]=t,[,i,r]=e,s=[n&&i>1?o-1:o,n&&r>1?A-1:A],a=[n&&i>1?i-1:i,n&&r>1?r-1:r],l=s[0]/a[0],m=s[1]/a[1],p=1/l,h=1/m,u=2*Math.ceil(p)+2,c=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${u});\n        const int winWidth = int(${c});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${r}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${a[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${a[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${A}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const bF={kernelName:s.Hmb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:A,dy:i}=t,{alignCorners:r}=o,s=new yF(i.shape,A.shape,r);return n.runWebGLProgram(s,[i],i.dtype)}};class qF{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const o=e.map(((n,o)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(o))).join(","),A=WI(n);this.userCode=`\n      void main() {\n        ${A} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class xF{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const o=eE("rc",n),A=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,r=WI(n);function s(n){const o=e.map(((o,A)=>function(n,o){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${o[n]} - 1`:`${o[n]}`}(A,n)));return`getChannel(getX(${o.join(",")}), vec2(${o.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${A}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${r} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return s(e)}(o.slice())};\n          if(${A}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",s(e)}(o.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",s(e)}(o.slice())};\n            if(${A}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",s(e)}(o.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const BF={kernelName:s.mKl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{dims:i}=o,r=A.shape.length,a=s.D5U.parseAxisParam(i,A.shape);if(0===r)return EE({inputs:{x:A},backend:n});const l=(0,s.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xF(A.shape,a):new qF(A.shape,a);return n.runWebGLProgram(l,[A],A.dtype)}};class wF{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],o=e[2];this.outputShape=e;let A="";A="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${A}\n          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const MF={kernelName:s.b9H,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:o}=e,{radians:A,fillValue:i,center:r}=t,a=n,l=new wF(o.shape,i),[m,p]=s.Wap.getImageCenter(r,o.shape[1],o.shape[2]),h=[[m,p,Math.sin(A),Math.cos(A)]];return a.runWebGLProgram(l,[o],o.dtype,h)}},LF=jE({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),SF={kernelName:s.e07,backendName:"webgl",kernelFunc:LF},TF=jE({opSnippet:"return inversesqrt(x);",cpuKernelImpl:MG}),NF={kernelName:s.bV0,backendName:"webgl",kernelFunc:TF};class RF{constructor(e,t,n,o,A,i,r=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const s=WI(A.length),a=WI(i.length);let l="";1===n?l="i":2===n&&(l="i, j");const m=`getIndices(${l})`;let p="";1===o?p="i":2===o&&(p="i, coords[1]");const h=`getUpdates(${p})`,u=t>1?"strides[j]":"strides";this.userCode=`\n        ${s} strides = ${s}(${A});\n\n        void main() {\n          ${a} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${m});\n              flattenedIndex += index * ${u};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const OF={kernelName:s.xQA,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{indices:A,updates:i}=t,{shape:r}=o,{sliceRank:a,numUpdates:l,sliceSize:m,strides:p,outputSize:h}=s.Wap.calculateShapes(i,A,r),u=[h/m,m];if(0===h)return n.makeTensorInfo(r,A.dtype);const c=ME({inputs:{x:A},backend:n,attrs:{shape:[l,a]}}),d=ME({inputs:{x:i},backend:n,attrs:{shape:[l,m]}}),I=n.makeTensorInfo([],"float32",new Float32Array([0])),G=new RF(l,a,c.shape.length,d.shape.length,p,u),E=n.runWebGLProgram(G,[d,c,I],d.dtype),k=ME({inputs:{x:E},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(E),n.disposeIntermediateTensorInfo(I),k}};class PF{constructor(e,t,n){let o,A;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)A="resRC",o="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],r=[];for(let o=0;o<t.length;o++)r.push(`${n[o]}`),o<e&&i.push(`${n[o]}`);o=i.join(),A=r.join()}const i=WI(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${o});\n        if (cVal >= 1.0) {\n          setOutput(getA(${A}));\n        } else {\n          setOutput(getB(${A}));\n        }\n      }\n    `}}const UF={kernelName:s.PhF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:o,t:A,e:i}=t,r=new PF(o.shape.length,A.shape,A.shape.length);return n.runWebGLProgram(r,[o,A,i],(0,s.x8V)(A.dtype,i.dtype))}},VF=jE({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${s.Wap.SELU_SCALEALPHA};\n  float scale = ${s.Wap.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),WF={kernelName:s.oFR,backendName:"webgl",kernelFunc:VF},_F="return 1.0 / (1.0 + exp(-1.0 * x));",zF=jE({opSnippet:_F,packedOpSnippet:_F,cpuKernelImpl:LG}),XF={kernelName:s.a5O,backendName:"webgl",kernelFunc:zF},QF=jE({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),ZF={kernelName:s.i5y,backendName:"webgl",kernelFunc:QF},YF=jE({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),$F={kernelName:s.RQH,backendName:"webgl",kernelFunc:YF},eC=jE({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tC={kernelName:s.wYB,backendName:"webgl",kernelFunc:eC},nC=jE({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),oC={kernelName:s.MRv,backendName:"webgl",kernelFunc:nC},AC={kernelName:s.TQc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{blockShape:i,paddings:r}=o;s.D5U.assert(A.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const a=i.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...r);for(let e=1+i.length;e<A.shape.length;++e)l.push([0,0]);const m=[],p=lF({inputs:{x:A},backend:n,attrs:{paddings:l,constantValue:0}}),h=s.Wap.getReshaped(p.shape,i,a,!1),u=s.Wap.getPermuted(h.length,i.length,!1),c=s.Wap.getReshapedPermuted(p.shape,i,a,!1),d=ME({inputs:{x:p},backend:n,attrs:{shape:h}}),I=WE({inputs:{x:d},backend:n,attrs:{perm:u}}),G=ME({inputs:{x:I},backend:n,attrs:{shape:c}});return m.push(p),m.push(d),m.push(I),m.forEach((e=>n.disposeIntermediateTensorInfo(e))),G}},iC={kernelName:s.O3z,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:o,values:A,denseShape:i,defaultValue:r}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==o.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${o.shape}`);if(1!==A.shape.length)throw new Error(`Values must be a vector, saw:\n         ${A.shape}`);if(0!==r.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${r.shape}`);const s=n.readSync(o.dataId),a=n.readSync(A.dataId),l=n.readSync(i.dataId),m=n.readSync(r.dataId)[0],[p,h,u,c,d]=NG(s,o.shape,o.dtype,a,A.dtype,l,m);return[n.makeTensorInfo(h,o.dtype,p),n.makeTensorInfo([h[0]],A.dtype,u),n.makeTensorInfo([c.length],"bool",new Uint8Array(c.map((e=>Number(e))))),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},rC={kernelName:s.nhH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:o,inputShape:A,newShape:i}=t;if(2!==o.shape.length)throw new Error(`Input indices should be a matrix but received shape ${o.shape}`);if(1!==A.shape.length)throw new Error(`Input shape should be a vector but received shape ${A.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const r=Array.from(n.readSync(A.dataId)),s=n.readSync(o.dataId),a=Array.from(n.readSync(i.dataId)),[l,m,p]=RG(s,o.shape,o.dtype,r,a);return[n.makeTensorInfo(m,o.dtype,l),n.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}},sC={kernelName:s.w3H,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:o,indices:A,segmentIds:i}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==A.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${A.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const r=n.readSync(o.dataId),s=n.readSync(A.dataId),a=n.readSync(i.dataId),[l,m]=OG(r,o.shape,o.dtype,s,a,!0);return n.makeTensorInfo(m,o.dtype,l)}},aC={kernelName:s.ZjV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:o,indices:A,segmentIds:i}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==A.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${A.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const r=n.readSync(o.dataId),s=n.readSync(A.dataId),a=n.readSync(i.dataId),[l,m]=OG(r,o.shape,o.dtype,s,a);return n.makeTensorInfo(m,o.dtype,l)}},lC={kernelName:s.D2d,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{sparseIndices:A,sparseValues:i,defaultValue:r}=t,{outputShape:a}=o,{sliceRank:l,numUpdates:m,strides:p,outputSize:h}=s.Wap.calculateShapes(i,A,a),u=new RF(m,l,A.shape.length,i.shape.length,p,[h,1],!1),c=n.runWebGLProgram(u,[i,A,r],i.dtype),d=ME({inputs:{x:c},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(c),d}},mC={kernelName:s.L8s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{numOrSizeSplits:i,axis:r}=o,a=s.D5U.parseAxisParam(r,A.shape)[0],l=s.Wap.prepareSplitSize(A,i,a),m=A.shape.length,p=new Array(m).fill(0),h=A.shape.slice();return l.map((e=>{const t=[...h];t[a]=e;const o=Ok({inputs:{x:A},backend:n,attrs:{begin:p,size:t}});return p[a]+=e,o}))}},pC="return sqrt(x);",hC=jE({opSnippet:pC,packedOpSnippet:pC,cpuKernelImpl:PG}),uC={kernelName:s.FKq,backendName:"webgl",kernelFunc:hC},cC=jE({opSnippet:"return x * x;"}),dC={kernelName:s.bK0,backendName:"webgl",kernelFunc:cC},IC="return (a - b) * (a - b);",GC=KE({opSnippet:IC,packedOpSnippet:IC}),EC={kernelName:s._tC,backendName:"webgl",kernelFunc:GC},kC={kernelName:s.h8e,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:o}=e,A=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,i=new sE(o.shape,A);return n.runWebGLProgram(i,[o],o.dtype)}};class gC{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const o=n.length,A=WI(n.length),i=WI(n.length);let r="";if(1===o)r="coords * strides + begin";else{let e=0;r=n.map(((t,o)=>(e++,1===n.length?`coords * strides[${o}] + begin[${o}]`:`coords[${e-1}] * strides[${o}] + begin[${o}]`))).join(",")}this.userCode=`\n      ${A} begin = ${A}(${e});\n      ${A} strides = ${A}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}const fC={kernelName:s.jQk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{begin:i,end:r,strides:a,beginMask:l,endMask:m,ellipsisMask:p,newAxisMask:h,shrinkAxisMask:u}=o,{finalShapeSparse:c,finalShape:d,isIdentity:I,sliceDim0:G,isSimpleSlice:E,begin:k,end:g,strides:f}=s.kuN.sliceInfo(A.shape,i,r,a,l,m,p,h,u);let H;if(I)H=ME({inputs:{x:A},backend:n,attrs:{shape:d}});else if(G||E){s.D5U.assert(A.shape.length>=1,(()=>`Input must have rank at least 1, got: ${A.shape.length}`));const e=s.kuN.computeOutShape(k,g,f),t=Ok({inputs:{x:A},backend:n,attrs:{begin:k,size:e}});H=ME({inputs:{x:t},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([A])){const e=n.readSync(A.dataId),t=(0,s.f3b)(A.shape,A.dtype,e),o=UG(c,t,f,k);H=n.makeTensorInfo(d,A.dtype,o.values)}else{const e=new gC(k,f,c);H=n.runWebGLProgram(e,[A],A.dtype)}const F=ME({inputs:{x:H},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(H),F}},HC={kernelName:s._JP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{separator:A,nGramWidths:i,leftPad:r,rightPad:s,padWidth:a,preserveShortSequences:l}=o,{data:m,dataSplits:p}=t,h=n.readSync(m.dataId),u=n.readSync(p.dataId),[c,d]=VG(h,u,A,i,r,s,a,l);return[n.makeTensorInfo([c.length],"string",c),n.makeTensorInfo(p.shape,"int32",d)]}},FC={kernelName:s.s1s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{skipEmpty:A}=o,{input:i,delimiter:r}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==r.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const s=n.readSync(i.dataId),a=n.readSync(r.dataId)[0],[l,m,p]=WG(s,a,A),h=m.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",m),n.makeTensorInfo([2],"int32",new Int32Array(p))]}},CC={kernelName:s.XkS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{numBuckets:A}=o,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(A<=0)throw new Error("Number of buckets must be at least 1");const r=n.readSync(i.dataId),s=_G(r,A);return n.makeTensorInfo(i.shape,"int32",s)}},DC=jE({opSnippet:"return tan(x);"}),JC={kernelName:s.sEM,backendName:"webgl",kernelFunc:DC},vC=jE({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),jC={kernelName:s.MIZ,backendName:"webgl",kernelFunc:vC};class KC{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const o=WI(this.rank),A=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],o=[];for(let t=0;t<e.length;t++)o.push(`imod(${n[t]}, ${e[t]})`);return o.join()}(e);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${A}));\n      }\n    `}}function yC(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{reps:i}=o;if("string"===A.dtype||A.shape.length>5){const e=n.readSync(A.dataId),t="string"===A.dtype?e.map((e=>s.D5U.decodeString(e))):e,o=(0,s.f3b)(A.shape,A.dtype,t),r=XG(o,i);return n.makeTensorInfo(r.shape,r.dtype,r.values)}const r=new KC(A.shape,i);return n.runWebGLProgram(r,[A],A.dtype)}const bC={kernelName:s.n9L,backendName:"webgl",kernelFunc:yC};class qC{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class xC{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function BC(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function wC(e){let t=1;for(;t<e;)t*=2;return t}const MC={kernelName:s.cWu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A}=t,{k:i,sorted:r}=o,a=(0,s.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,s.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),m=A.shape,p=m[m.length-1];if(n.shouldExecuteOnCPU([A])||p<a||i>l){const e=n.readSync(A.dataId),[t,o]=QG(e,m,A.dtype,i,r);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(o.shape,o.dtype,o.values)]}if(0===i)return m[m.length-1]=0,[n.makeTensorInfo(m,A.dtype,[]),n.makeTensorInfo(m,"int32",[])];if(1===p)return[A,ff({attrs:{shape:m,dtype:"int32",value:0},backend:n})];const h=n.texData.get(A.dataId),u=null!==h&&h.isPacked,c=u?n.unpackTensor(A):A,d=s.D5U.sizeFromShape(m)/p,I=ME({inputs:{x:c},attrs:{shape:[d,p]},backend:n});u&&BC(n,c);const G=wC(i),E=wC(p);let k=null;const g=()=>null===k?[I,I]:[I,k],f=(e,t,o)=>{const A=g(),i=new qC(o),r=[[p],[null===k?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],s=k;k=n.runWebGLProgram(i,A,"int32",r),BC(n,s)};for(let e=1;e<G;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)f(t,n,[d,E])}for(let e=E;e>G;e/=2){const t=g(),o=new xC([d,e/2]),A=[[p],[null===k?1:0],[G]],i=k;k=n.runWebGLProgram(o,t,"int32",A),BC(n,i);const r=G/2,s=2*r;for(let e=r;e>=1;e/=2)f(s,e,k.shape)}let H=k;k=Ok({inputs:{x:k},backend:n,attrs:{begin:0,size:[d,i]}}),BC(n,H);let F=Tf({inputs:{x:I,indices:k},backend:n,attrs:{axis:1,batchDims:1}});BC(n,I);const C=m.slice(0,-1);C.push(i),H=k,k=ME({inputs:{x:k},attrs:{shape:C},backend:n}),BC(n,H);const D=F;return F=ME({inputs:{x:F},attrs:{shape:C},backend:n}),BC(n,D),[F,k]}};class LC{constructor(e,t,n,o,A,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const r="nearest"===n?1:2;let s;switch(o){case"constant":default:s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${s} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${A});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${A});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${r} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const SC={kernelName:s.wx7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{image:A,transforms:i}=t,{interpolation:r,fillMode:s,fillValue:a,outputShape:l}=o,[m,p,h,u]=A.shape,[c,d]=null!=l?l:[p,h],I=new LC(p,h,r,s,a,[m,c,d,u]);return n.runWebGLProgram(I,[A,i],"float32")}},TC={kernelName:s.kpP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:o}=e,{axis:A}=n,{x:i}=t;KI(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const r=o.readSync(i.dataId),{outputValues:s,outputShape:a,indices:l}=YG(r,A,i.shape,i.dtype);return[o.makeTensorInfo(a,i.dtype,s),o.makeTensorInfo([l.length],"int32",l)]}},NC={kernelName:s.ToN,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{value:A}=t;let{axis:i}=o;i<0&&(i+=A.shape.length);const r=A,s=r.shape.length,a=A.shape[i],l=new Array(s-1);let m=0;for(let e=0;e<s;e++)e!==i&&(l[m++]=r.shape[e]);const p=[],h=new Array(s).fill(0),u=r.shape.slice();u[i]=1;const c=new Array(a);for(let e=0;e<c.length;e++){h[i]=e;const t=Ok({inputs:{x:r},backend:n,attrs:{begin:h,size:u}}),o=ME({inputs:{x:t},backend:n,attrs:{shape:l}});c[e]=o,p.push(t)}return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};class RC{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,o=e.batchSize,A=e.inSize,i=e.numSegments,r=i*Math.ceil(A/n);this.outputShape=[o,r];const s=4*Math.floor(n/4),a=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let m="";A%n>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${A}) {\n          return initializationValue;\n        }\n      `);let p="";A%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${A}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const OC={kernelName:s.Qvg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:A,segmentIds:i}=t,{numSegments:r}=o,a=A.shape.length,l=[];let m=0;const p=s.Wap.getAxesPermutation([m],a);let h=A;null!=p&&(h=WE({inputs:{x:A},backend:n,attrs:{perm:p}}),l.push(h),m=s.Wap.getInnerMostAxes(1,a)[0]);const u=s.Wap.segment_util.computeOutShape(h.shape,m,r),c=s.D5U.sizeFromShape([h.shape[m]]),d=ME({inputs:{x:h},backend:n,attrs:{shape:[-1,c]}});l.push(d);const I=(0,s.z4k)(A.dtype),G=(e,t,o,A,i)=>{const r=e.shape[0],a=e.shape[1],m=s.Wap.segment_util.segOpComputeOptimalWindowSize(a,i),p=new RC({windowSize:m,inSize:a,batchSize:r,numSegments:i},t),h=n.compileAndRun(p,[e,o],A);if(l.push(h),h.shape[1]===i)return h;const u=cF({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),c=yC({inputs:{x:u},backend:n,attrs:{reps:[a/m]}});return l.push(u),l.push(c),G(h,t,c,A,i)},E=ME({inputs:{x:G(d,"unsortedSegmentSum",i,I,r)},backend:n,attrs:{shape:u}});let k=E;if(null!=p){l.push(E);const e=s.Wap.getUndoAxesPermutation(p);k=WE({inputs:{x:k},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),k}},PC=[dH,GH,XE,ZE,$E,tk,Ak,sk,ak,lk,dk,Ik,Ek,gk,Ck,Hk,Jk,yk,Kk,xk,Bk,wk,Sk,Uk,Vk,Wk,Zk,eg,og,rg,fE,cg,Dg,Jg,gg,jg,Kg,vg,bg,xg,wg,Tg,Ng,Og,zg,Xg,Vg,Zg,$g,ef,nf,of,rf,af,pf,uf,If,kf,Hf,Cf,vf,Kf,qf,Bf,wf,Lf,Nf,Of,Uf,kE,Vf,pg,_f,Xf,Zf,CE,$f,tH,nH,rH,AH,aH,mH,hH,kH,FH,HH,JH,vH,jH,fH,KH,yH,qH,wH,LH,WH,wE,zH,QH,YH,eF,zk,nF,iF,rF,mF,hF,vE,uF,dF,Qk,NH,GF,fF,kF,LE,CF,JF,KF,bF,BF,MF,SF,NF,OF,UF,WF,XF,ZF,$F,tC,Pk,VH,oC,AC,iC,rC,sC,aC,lC,mC,uC,dC,EC,kC,fC,HC,FC,CC,PH,VE,JC,jC,bC,MC,SC,_E,TC,NC,OC,AF];for(const e of PC)(0,s.wCN)(e);s.jTM,cl.gJ;var UC=function(){function e(e){i.Loader.call(this,e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new r(e)})),this.register((function(e){return new a(e)})),this.register((function(e){return new l(e)})),this.register((function(e){return new s(e)})),this.register((function(e){return new o(e)})),this.register((function(e){return new m(e)}))}function t(){var e={};return{get:function(t){return e[t]},add:function(t,n){e[t]=n},remove:function(t){delete e[t]},removeAll:function(){e={}}}}e.prototype=Object.assign(Object.create(i.Loader.prototype),{constructor:e,load:function(e,t,n,o){var A,r=this;A=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:i.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);var s=function(t){o?o(t):console.error(t),r.manager.itemError(e),r.manager.itemEnd(e)},a=new i.FileLoader(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){try{r.parse(n,A,(function(n){t(n),r.manager.itemEnd(e)}),s)}catch(e){s(e)}}),n,s)},setDRACOLoader:function(e){return this.dracoLoader=e,this},setDDSLoader:function(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')},setKTX2Loader:function(e){return this.ktx2Loader=e,this},setMeshoptDecoder:function(e){return this.meshoptDecoder=e,this},register:function(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this},unregister:function(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this},parse:function(e,t,o,r){var s,a={},l={};if("string"==typeof e)s=e;else if(i.LoaderUtils.decodeText(new Uint8Array(e,0,4))===p){try{a[n.KHR_BINARY_GLTF]=new h(e)}catch(e){return void(r&&r(e))}s=a[n.KHR_BINARY_GLTF].content}else s=i.LoaderUtils.decodeText(new Uint8Array(e));var m=JSON.parse(s);if(void 0===m.asset||m.asset.version[0]<2)r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));else{var d=new b(m,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});d.fileLoader.setRequestHeader(this.requestHeader);for(var E=0;E<this.pluginCallbacks.length;E++){var k=this.pluginCallbacks[E](d);l[k.name]=k,a[k.name]=!0}if(m.extensionsUsed)for(E=0;E<m.extensionsUsed.length;++E){var g=m.extensionsUsed[E],f=m.extensionsRequired||[];switch(g){case n.KHR_MATERIALS_UNLIT:a[g]=new A;break;case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[g]=new I;break;case n.KHR_DRACO_MESH_COMPRESSION:a[g]=new u(m,this.dracoLoader);break;case n.KHR_TEXTURE_TRANSFORM:a[g]=new c;break;case n.KHR_MESH_QUANTIZATION:a[g]=new G;break;default:f.indexOf(g)>=0&&void 0===l[g]&&console.warn('THREE.GLTFLoader: Unknown extension "'+g+'".')}}d.setExtensions(a),d.setPlugins(l),d.parse(o,r)}}});var n={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};function o(e){this.parser=e,this.name=n.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}function A(){this.name=n.KHR_MATERIALS_UNLIT}function r(e){this.parser=e,this.name=n.KHR_MATERIALS_CLEARCOAT}function s(e){this.parser=e,this.name=n.KHR_MATERIALS_TRANSMISSION}function a(e){this.parser=e,this.name=n.KHR_TEXTURE_BASISU}function l(e){this.parser=e,this.name=n.EXT_TEXTURE_WEBP,this.isSupported=null}function m(e){this.name=n.EXT_MESHOPT_COMPRESSION,this.parser=e}o.prototype._markDefs=function(){for(var e=this.parser,t=this.parser.json.nodes||[],n=0,o=t.length;n<o;n++){var A=t[n];A.extensions&&A.extensions[this.name]&&void 0!==A.extensions[this.name].light&&e._addNodeRef(this.cache,A.extensions[this.name].light)}},o.prototype._loadLight=function(e){var t=this.parser,n="light:"+e,o=t.cache.get(n);if(o)return o;var A,r=t.json,s=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e],a=new i.Color(16777215);void 0!==s.color&&a.fromArray(s.color);var l=void 0!==s.range?s.range:0;switch(s.type){case"directional":(A=new i.DirectionalLight(a)).target.position.set(0,0,-1),A.add(A.target);break;case"point":(A=new i.PointLight(a)).distance=l;break;case"spot":(A=new i.SpotLight(a)).distance=l,s.spot=s.spot||{},s.spot.innerConeAngle=void 0!==s.spot.innerConeAngle?s.spot.innerConeAngle:0,s.spot.outerConeAngle=void 0!==s.spot.outerConeAngle?s.spot.outerConeAngle:Math.PI/4,A.angle=s.spot.outerConeAngle,A.penumbra=1-s.spot.innerConeAngle/s.spot.outerConeAngle,A.target.position.set(0,0,-1),A.add(A.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+s.type)}return A.position.set(0,0,0),A.decay=2,void 0!==s.intensity&&(A.intensity=s.intensity),A.name=t.createUniqueName(s.name||"light_"+e),o=Promise.resolve(A),t.cache.add(n,o),o},o.prototype.createNodeAttachment=function(e){var t=this,n=this.parser,o=n.json.nodes[e],A=(o.extensions&&o.extensions[this.name]||{}).light;return void 0===A?null:this._loadLight(A).then((function(e){return n._getNodeRef(t.cache,A,e)}))},A.prototype.getMaterialType=function(){return i.MeshBasicMaterial},A.prototype.extendParams=function(e,t,n){var o=[];e.color=new i.Color(1,1,1),e.opacity=1;var A=t.pbrMetallicRoughness;if(A){if(Array.isArray(A.baseColorFactor)){var r=A.baseColorFactor;e.color.fromArray(r),e.opacity=r[3]}void 0!==A.baseColorTexture&&o.push(n.assignTexture(e,"map",A.baseColorTexture))}return Promise.all(o)},r.prototype.getMaterialType=function(e){var t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.MeshPhysicalMaterial:null},r.prototype.extendMaterialParams=function(e,t){var n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();var A=[],r=o.extensions[this.name];if(void 0!==r.clearcoatFactor&&(t.clearcoat=r.clearcoatFactor),void 0!==r.clearcoatTexture&&A.push(n.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),void 0!==r.clearcoatRoughnessFactor&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),void 0!==r.clearcoatRoughnessTexture&&A.push(n.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),void 0!==r.clearcoatNormalTexture&&(A.push(n.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),void 0!==r.clearcoatNormalTexture.scale)){var s=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new i.Vector2(s,-s)}return Promise.all(A)},s.prototype.getMaterialType=function(e){var t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.MeshPhysicalMaterial:null},s.prototype.extendMaterialParams=function(e,t){var n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();var A=[],i=o.extensions[this.name];return void 0!==i.transmissionFactor&&(t.transmission=i.transmissionFactor),void 0!==i.transmissionTexture&&A.push(n.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(A)},a.prototype.loadTexture=function(e){var t=this.parser,n=t.json,o=n.textures[e];if(!o.extensions||!o.extensions[this.name])return null;var A=o.extensions[this.name],i=n.images[A.source],r=t.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i,r)},l.prototype.loadTexture=function(e){var t=this.name,n=this.parser,o=n.json,A=o.textures[e];if(!A.extensions||!A.extensions[t])return null;var i=A.extensions[t],r=o.images[i.source],s=n.textureLoader;if(r.uri){var a=n.options.manager.getHandler(r.uri);null!==a&&(s=a)}return this.detectSupport().then((function(A){if(A)return n.loadTextureImage(e,r,s);if(o.extensionsRequired&&o.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)}))},l.prototype.detectSupport=function(){return this.isSupported||(this.isSupported=new Promise((function(e){var t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported},m.prototype.loadBufferView=function(e){var t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){var o=n.extensions[this.name],A=this.parser.getDependency("buffer",o.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([A,i.ready]).then((function(e){var t=o.byteOffset||0,n=o.byteLength||0,A=o.count,r=o.byteStride,s=new ArrayBuffer(A*r),a=new Uint8Array(e[0],t,n);return i.decodeGltfBuffer(new Uint8Array(s),A,r,a,o.mode,o.filter),s}))}return null};var p="glTF";function h(e){this.name=n.KHR_BINARY_GLTF,this.content=null,this.body=null;var t=new DataView(e,0,12);if(this.header={magic:i.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==p)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");for(var o=this.header.length-12,A=new DataView(e,12),r=0;r<o;){var s=A.getUint32(r,!0);r+=4;var a=A.getUint32(r,!0);if(r+=4,1313821514===a){var l=new Uint8Array(e,12+r,s);this.content=i.LoaderUtils.decodeText(l)}else if(5130562===a){var m=12+r;this.body=e.slice(m,m+s)}r+=s}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}function u(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=n.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}function c(){this.name=n.KHR_TEXTURE_TRANSFORM}function d(e){i.MeshStandardMaterial.call(this),this.isGLTFSpecularGlossinessMaterial=!0;var t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),n=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),o=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\ttexelSpecular = sRGBToLinear( texelSpecular );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),A=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),r=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),s={specular:{value:(new i.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=s,this.onBeforeCompile=function(e){for(var i in s)e.uniforms[i]=s[i];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",o).replace("#include <metalnessmap_fragment>",A).replace("#include <lights_physical_fragment>",r)},Object.defineProperties(this,{specular:{get:function(){return s.specular.value},set:function(e){s.specular.value=e}},specularMap:{get:function(){return s.specularMap.value},set:function(e){s.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return s.glossiness.value},set:function(e){s.glossiness.value=e}},glossinessMap:{get:function(){return s.glossinessMap.value},set:function(e){s.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}function I(){return{name:n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,specularGlossinessParams:["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"],getMaterialType:function(){return d},extendParams:function(e,t,n){var o=t.extensions[this.name];e.color=new i.Color(1,1,1),e.opacity=1;var A=[];if(Array.isArray(o.diffuseFactor)){var r=o.diffuseFactor;e.color.fromArray(r),e.opacity=r[3]}if(void 0!==o.diffuseTexture&&A.push(n.assignTexture(e,"map",o.diffuseTexture)),e.emissive=new i.Color(0,0,0),e.glossiness=void 0!==o.glossinessFactor?o.glossinessFactor:1,e.specular=new i.Color(1,1,1),Array.isArray(o.specularFactor)&&e.specular.fromArray(o.specularFactor),void 0!==o.specularGlossinessTexture){var s=o.specularGlossinessTexture;A.push(n.assignTexture(e,"glossinessMap",s)),A.push(n.assignTexture(e,"specularMap",s))}return Promise.all(A)},createMaterial:function(e){var t=new d(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=i.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}}function G(){this.name=n.KHR_MESH_QUANTIZATION}function E(e,t,n,o){i.Interpolant.call(this,e,t,n,o)}u.prototype.decodePrimitive=function(e,t){var n=this.json,o=this.dracoLoader,A=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,r={},s={},a={};for(var l in i){var m=F[l]||l.toLowerCase();r[m]=i[l]}for(l in e.attributes)if(m=F[l]||l.toLowerCase(),void 0!==i[l]){var p=n.accessors[e.attributes[l]],h=k[p.componentType];a[m]=h,s[m]=!0===p.normalized}return t.getDependency("bufferView",A).then((function(e){return new Promise((function(t){o.decodeDracoFile(e,(function(e){for(var n in e.attributes){var o=e.attributes[n],A=s[n];void 0!==A&&(o.normalized=A)}t(e)}),r,a)}))}))},c.prototype.extendTexture=function(e,t){return e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.needsUpdate=!0,e},d.prototype=Object.create(i.MeshStandardMaterial.prototype),d.prototype.constructor=d,d.prototype.copy=function(e){return i.MeshStandardMaterial.prototype.copy.call(this,e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this},E.prototype=Object.create(i.Interpolant.prototype),E.prototype.constructor=E,E.prototype.copySampleValue_=function(e){for(var t=this.resultBuffer,n=this.sampleValues,o=this.valueSize,A=e*o*3+o,i=0;i!==o;i++)t[i]=n[A+i];return t},E.prototype.beforeStart_=E.prototype.copySampleValue_,E.prototype.afterEnd_=E.prototype.copySampleValue_,E.prototype.interpolate_=function(e,t,n,o){for(var A=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=2*r,a=3*r,l=o-t,m=(n-t)/l,p=m*m,h=p*m,u=e*a,c=u-a,d=-2*h+3*p,I=h-p,G=1-d,E=I-p+m,k=0;k!==r;k++){var g=i[c+k+r],f=i[c+k+s]*l,H=i[u+k+r],F=i[u+k]*l;A[k]=G*g+E*f+d*H+I*F}return A};var k={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},g={9728:i.NearestFilter,9729:i.LinearFilter,9984:i.NearestMipmapNearestFilter,9985:i.LinearMipmapNearestFilter,9986:i.NearestMipmapLinearFilter,9987:i.LinearMipmapLinearFilter},f={33071:i.ClampToEdgeWrapping,33648:i.MirroredRepeatWrapping,10497:i.RepeatWrapping},H={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},F={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},C={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},D={CUBICSPLINE:void 0,LINEAR:i.InterpolateLinear,STEP:i.InterpolateDiscrete};function J(e,t){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}function v(e,t,n){for(var o in n.extensions)void 0===e[o]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[o]=n.extensions[o])}function j(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function K(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(var n=0,o=t.weights.length;n<o;n++)e.morphTargetInfluences[n]=t.weights[n];if(t.extras&&Array.isArray(t.extras.targetNames)){var A=t.extras.targetNames;if(e.morphTargetInfluences.length===A.length)for(e.morphTargetDictionary={},n=0,o=A.length;n<o;n++)e.morphTargetDictionary[A[n]]=n;else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function y(e){for(var t="",n=Object.keys(e).sort(),o=0,A=n.length;o<A;o++)t+=n[o]+":"+e[n[o]]+";";return t}function b(e,n){this.json=e||{},this.extensions={},this.plugins={},this.options=n||{},this.cache=new t,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.nodeNamesUsed={},"undefined"!=typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?this.textureLoader=new i.ImageBitmapLoader(this.options.manager):this.textureLoader=new i.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new i.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}function q(e,t,n){var o=t.attributes,A=[];function r(t,o){return n.getDependency("accessor",t).then((function(t){e.setAttribute(o,t)}))}for(var s in o){var a=F[s]||s.toLowerCase();a in e.attributes||A.push(r(o[s],a))}if(void 0!==t.indices&&!e.index){var l=n.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));A.push(l)}return j(e,t),function(e,t,n){var o=t.attributes,A=new i.Box3;if(void 0!==o.POSITION){var r=(u=n.json.accessors[o.POSITION]).min,s=u.max;if(void 0!==r&&void 0!==s){A.set(new i.Vector3(r[0],r[1],r[2]),new i.Vector3(s[0],s[1],s[2]));var a=t.targets;if(void 0!==a){for(var l=new i.Vector3,m=new i.Vector3,p=0,h=a.length;p<h;p++){var u,c=a[p];void 0!==c.POSITION&&(r=(u=n.json.accessors[c.POSITION]).min,s=u.max,void 0!==r&&void 0!==s?(m.setX(Math.max(Math.abs(r[0]),Math.abs(s[0]))),m.setY(Math.max(Math.abs(r[1]),Math.abs(s[1]))),m.setZ(Math.max(Math.abs(r[2]),Math.abs(s[2]))),l.max(m)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."))}A.expandByVector(l)}e.boundingBox=A;var d=new i.Sphere;A.getCenter(d.center),d.radius=A.min.distanceTo(A.max)/2,e.boundingSphere=d}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}(e,t,n),Promise.all(A).then((function(){return void 0!==t.targets?function(e,t,n){for(var o=!1,A=!1,i=0,r=t.length;i<r&&(void 0!==(l=t[i]).POSITION&&(o=!0),void 0!==l.NORMAL&&(A=!0),!o||!A);i++);if(!o&&!A)return Promise.resolve(e);var s=[],a=[];for(i=0,r=t.length;i<r;i++){var l=t[i];if(o){var m=void 0!==l.POSITION?n.getDependency("accessor",l.POSITION):e.attributes.position;s.push(m)}A&&(m=void 0!==l.NORMAL?n.getDependency("accessor",l.NORMAL):e.attributes.normal,a.push(m))}return Promise.all([Promise.all(s),Promise.all(a)]).then((function(t){var n=t[0],i=t[1];return o&&(e.morphAttributes.position=n),A&&(e.morphAttributes.normal=i),e.morphTargetsRelative=!0,e}))}(e,t.targets,n):e}))}function x(e,t){var n=e.getIndex();if(null===n){var o=[],A=e.getAttribute("position");if(void 0===A)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var r=0;r<A.count;r++)o.push(r);e.setIndex(o),n=e.getIndex()}var s=n.count-2,a=[];if(t===i.TriangleFanDrawMode)for(r=1;r<=s;r++)a.push(n.getX(0)),a.push(n.getX(r)),a.push(n.getX(r+1));else for(r=0;r<s;r++)r%2==0?(a.push(n.getX(r)),a.push(n.getX(r+1)),a.push(n.getX(r+2))):(a.push(n.getX(r+2)),a.push(n.getX(r+1)),a.push(n.getX(r)));a.length/3!==s&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var l=e.clone();return l.setIndex(a),l}return b.prototype.setExtensions=function(e){this.extensions=e},b.prototype.setPlugins=function(e){this.plugins=e},b.prototype.parse=function(e,t){var n=this,o=this.json,A=this.extensions;this.cache.removeAll(),this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])})).then((function(t){var i={scene:t[0][o.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:o.asset,parser:n,userData:{}};v(A,i,o),j(i,o),Promise.all(n._invokeAll((function(e){return e.afterRoot&&e.afterRoot(i)}))).then((function(){e(i)}))})).catch(t)},b.prototype._markDefs=function(){for(var e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[],o=0,A=t.length;o<A;o++)for(var i=t[o].joints,r=0,s=i.length;r<s;r++)e[i[r]].isBone=!0;for(var a=0,l=e.length;a<l;a++){var m=e[a];void 0!==m.mesh&&(this._addNodeRef(this.meshCache,m.mesh),void 0!==m.skin&&(n[m.mesh].isSkinnedMesh=!0)),void 0!==m.camera&&this._addNodeRef(this.cameraCache,m.camera)}},b.prototype._addNodeRef=function(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)},b.prototype._getNodeRef=function(e,t,n){if(e.refs[t]<=1)return n;var o=n.clone();return o.name+="_instance_"+e.uses[t]++,o},b.prototype._invokeOne=function(e){var t=Object.values(this.plugins);t.push(this);for(var n=0;n<t.length;n++){var o=e(t[n]);if(o)return o}},b.prototype._invokeAll=function(e){var t=Object.values(this.plugins);t.unshift(this);for(var n=[],o=0;o<t.length;o++){var A=e(t[o]);A&&n.push(A)}return n},b.prototype.getDependency=function(e,t){var n=e+":"+t,o=this.cache.get(n);if(!o){switch(e){case"scene":o=this.loadScene(t);break;case"node":o=this.loadNode(t);break;case"mesh":o=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":o=this.loadAccessor(t);break;case"bufferView":o=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":o=this.loadBuffer(t);break;case"material":o=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":o=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":o=this.loadSkin(t);break;case"animation":o=this.loadAnimation(t);break;case"camera":o=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,o)}return o},b.prototype.getDependencies=function(e){var t=this.cache.get(e);if(!t){var n=this,o=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(o.map((function(t,o){return n.getDependency(e,o)}))),this.cache.add(e,t)}return t},b.prototype.loadBuffer=function(e){var t=this.json.buffers[e],o=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);var A=this.options;return new Promise((function(e,n){o.load(J(t.uri,A.path),e,void 0,(function(){n(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))},b.prototype.loadBufferView=function(e){var t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){var n=t.byteLength||0,o=t.byteOffset||0;return e.slice(o,o+n)}))},b.prototype.loadAccessor=function(e){var t=this,n=this.json,o=this.json.accessors[e];if(void 0===o.bufferView&&void 0===o.sparse)return Promise.resolve(null);var A=[];return void 0!==o.bufferView?A.push(this.getDependency("bufferView",o.bufferView)):A.push(null),void 0!==o.sparse&&(A.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),A.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(A).then((function(e){var A,r,s=e[0],a=H[o.type],l=k[o.componentType],m=l.BYTES_PER_ELEMENT,p=m*a,h=o.byteOffset||0,u=void 0!==o.bufferView?n.bufferViews[o.bufferView].byteStride:void 0,c=!0===o.normalized;if(u&&u!==p){var d=Math.floor(h/u),I="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+d+":"+o.count,G=t.cache.get(I);G||(A=new l(s,d*u,o.count*u/m),G=new i.InterleavedBuffer(A,u/m),t.cache.add(I,G)),r=new i.InterleavedBufferAttribute(G,a,h%u/m,c)}else A=null===s?new l(o.count*a):new l(s,h,o.count*a),r=new i.BufferAttribute(A,a,c);if(void 0!==o.sparse){var E=H.SCALAR,g=k[o.sparse.indices.componentType],f=o.sparse.indices.byteOffset||0,F=o.sparse.values.byteOffset||0,C=new g(e[1],f,o.sparse.count*E),D=new l(e[2],F,o.sparse.count*a);null!==s&&(r=new i.BufferAttribute(r.array.slice(),r.itemSize,r.normalized));for(var J=0,v=C.length;J<v;J++){var j=C[J];if(r.setX(j,D[J*a]),a>=2&&r.setY(j,D[J*a+1]),a>=3&&r.setZ(j,D[J*a+2]),a>=4&&r.setW(j,D[J*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return r}))},b.prototype.loadTexture=function(e){var t=this.json,n=this.options,o=t.textures[e],A=t.images[o.source],i=this.textureLoader;if(A.uri){var r=n.manager.getHandler(A.uri);null!==r&&(i=r)}return this.loadTextureImage(e,A,i)},b.prototype.loadTextureImage=function(e,t,n){var o=this,A=this.json,r=this.options,s=A.textures[e],a=self.URL||self.webkitURL,l=t.uri,m=!1,p=!0;if("image/jpeg"===t.mimeType&&(p=!1),void 0!==t.bufferView)l=o.getDependency("bufferView",t.bufferView).then((function(e){if("image/png"===t.mimeType){var n=new DataView(e,25,1).getUint8(0,!1);p=6===n||4===n||3===n}m=!0;var o=new Blob([e],{type:t.mimeType});return l=a.createObjectURL(o)}));else if(void 0===t.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");return Promise.resolve(l).then((function(e){return new Promise((function(t,o){var A=t;!0===n.isImageBitmapLoader&&(A=function(e){t(new i.CanvasTexture(e))}),n.load(J(e,r.path),A,void 0,o)}))})).then((function(t){!0===m&&a.revokeObjectURL(l),t.flipY=!1,s.name&&(t.name=s.name),p||(t.format=i.RGBFormat);var n=(A.samplers||{})[s.sampler]||{};return t.magFilter=g[n.magFilter]||i.LinearFilter,t.minFilter=g[n.minFilter]||i.LinearMipmapLinearFilter,t.wrapS=f[n.wrapS]||i.RepeatWrapping,t.wrapT=f[n.wrapT]||i.RepeatWrapping,o.associations.set(t,{type:"textures",index:e}),t}))},b.prototype.assignTexture=function(e,t,o){var A=this;return this.getDependency("texture",o.index).then((function(i){if(void 0===o.texCoord||0==o.texCoord||"aoMap"===t&&1==o.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+o.texCoord+" for texture "+t+" not yet supported."),A.extensions[n.KHR_TEXTURE_TRANSFORM]){var r=void 0!==o.extensions?o.extensions[n.KHR_TEXTURE_TRANSFORM]:void 0;if(r){var s=A.associations.get(i);i=A.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(i,r),A.associations.set(i,s)}}e[t]=i}))},b.prototype.assignFinalMaterial=function(e){var t=e.geometry,n=e.material,o=void 0!==t.attributes.tangent,A=void 0!==t.attributes.color,r=void 0===t.attributes.normal,s=!0===e.isSkinnedMesh,a=Object.keys(t.morphAttributes).length>0,l=a&&void 0!==t.morphAttributes.normal;if(e.isPoints){var m="PointsMaterial:"+n.uuid,p=this.cache.get(m);p||(p=new i.PointsMaterial,i.Material.prototype.copy.call(p,n),p.color.copy(n.color),p.map=n.map,p.sizeAttenuation=!1,this.cache.add(m,p)),n=p}else if(e.isLine){m="LineBasicMaterial:"+n.uuid;var h=this.cache.get(m);h||(h=new i.LineBasicMaterial,i.Material.prototype.copy.call(h,n),h.color.copy(n.color),this.cache.add(m,h)),n=h}if(o||A||r||s||a){m="ClonedMaterial:"+n.uuid+":",n.isGLTFSpecularGlossinessMaterial&&(m+="specular-glossiness:"),s&&(m+="skinning:"),o&&(m+="vertex-tangents:"),A&&(m+="vertex-colors:"),r&&(m+="flat-shading:"),a&&(m+="morph-targets:"),l&&(m+="morph-normals:");var u=this.cache.get(m);u||(u=n.clone(),s&&(u.skinning=!0),A&&(u.vertexColors=!0),r&&(u.flatShading=!0),a&&(u.morphTargets=!0),l&&(u.morphNormals=!0),o&&(u.vertexTangents=!0,u.normalScale&&(u.normalScale.y*=-1),u.clearcoatNormalScale&&(u.clearcoatNormalScale.y*=-1)),this.cache.add(m,u),this.associations.set(u,this.associations.get(n))),n=u}n.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=n},b.prototype.getMaterialType=function(){return i.MeshStandardMaterial},b.prototype.loadMaterial=function(e){var t,o=this,A=this.json,r=this.extensions,s=A.materials[e],a={},l=s.extensions||{},m=[];if(l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){var p=r[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];t=p.getMaterialType(),m.push(p.extendParams(a,s,o))}else if(l[n.KHR_MATERIALS_UNLIT]){var h=r[n.KHR_MATERIALS_UNLIT];t=h.getMaterialType(),m.push(h.extendParams(a,s,o))}else{var u=s.pbrMetallicRoughness||{};if(a.color=new i.Color(1,1,1),a.opacity=1,Array.isArray(u.baseColorFactor)){var c=u.baseColorFactor;a.color.fromArray(c),a.opacity=c[3]}void 0!==u.baseColorTexture&&m.push(o.assignTexture(a,"map",u.baseColorTexture)),a.metalness=void 0!==u.metallicFactor?u.metallicFactor:1,a.roughness=void 0!==u.roughnessFactor?u.roughnessFactor:1,void 0!==u.metallicRoughnessTexture&&(m.push(o.assignTexture(a,"metalnessMap",u.metallicRoughnessTexture)),m.push(o.assignTexture(a,"roughnessMap",u.metallicRoughnessTexture))),t=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),m.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,a)}))))}!0===s.doubleSided&&(a.side=i.DoubleSide);var I=s.alphaMode||"OPAQUE";return"BLEND"===I?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,"MASK"===I&&(a.alphaTest=void 0!==s.alphaCutoff?s.alphaCutoff:.5)),void 0!==s.normalTexture&&t!==i.MeshBasicMaterial&&(m.push(o.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new i.Vector2(1,-1),void 0!==s.normalTexture.scale&&a.normalScale.set(s.normalTexture.scale,-s.normalTexture.scale)),void 0!==s.occlusionTexture&&t!==i.MeshBasicMaterial&&(m.push(o.assignTexture(a,"aoMap",s.occlusionTexture)),void 0!==s.occlusionTexture.strength&&(a.aoMapIntensity=s.occlusionTexture.strength)),void 0!==s.emissiveFactor&&t!==i.MeshBasicMaterial&&(a.emissive=(new i.Color).fromArray(s.emissiveFactor)),void 0!==s.emissiveTexture&&t!==i.MeshBasicMaterial&&m.push(o.assignTexture(a,"emissiveMap",s.emissiveTexture)),Promise.all(m).then((function(){var A;return A=t===d?r[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a):new t(a),s.name&&(A.name=s.name),A.map&&(A.map.encoding=i.sRGBEncoding),A.emissiveMap&&(A.emissiveMap.encoding=i.sRGBEncoding),j(A,s),o.associations.set(A,{type:"materials",index:e}),s.extensions&&v(r,A,s),A}))},b.prototype.createUniqueName=function(e){for(var t=i.PropertyBinding.sanitizeNodeName(e||""),n=t,o=1;this.nodeNamesUsed[n];++o)n=t+"_"+o;return this.nodeNamesUsed[n]=!0,n},b.prototype.loadGeometries=function(e){var t=this,o=this.extensions,A=this.primitiveCache;function r(e){return o[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(n){return q(n,e,t)}))}for(var s,a,l=[],m=0,p=e.length;m<p;m++){var h,u=e[m],c=(void 0,(a=(s=u).extensions&&s.extensions[n.KHR_DRACO_MESH_COMPRESSION])?"draco:"+a.bufferView+":"+a.indices+":"+y(a.attributes):s.indices+":"+y(s.attributes)+":"+s.mode),d=A[c];d?l.push(d.promise):(h=u.extensions&&u.extensions[n.KHR_DRACO_MESH_COMPRESSION]?r(u):q(new i.BufferGeometry,u,t),A[c]={primitive:u,promise:h},l.push(h))}return Promise.all(l)},b.prototype.loadMesh=function(e){for(var t,n=this,o=this.json,A=this.extensions,r=o.meshes[e],s=r.primitives,a=[],l=0,m=s.length;l<m;l++){var p=void 0===s[l].material?(void 0===(t=this.cache).DefaultMaterial&&(t.DefaultMaterial=new i.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:i.FrontSide})),t.DefaultMaterial):this.getDependency("material",s[l].material);a.push(p)}return a.push(n.loadGeometries(s)),Promise.all(a).then((function(t){for(var o=t.slice(0,t.length-1),a=t[t.length-1],l=[],m=0,p=a.length;m<p;m++){var h,u=a[m],c=s[m],d=o[m];if(4===c.mode||5===c.mode||6===c.mode||void 0===c.mode)!0!==(h=!0===r.isSkinnedMesh?new i.SkinnedMesh(u,d):new i.Mesh(u,d)).isSkinnedMesh||h.geometry.attributes.skinWeight.normalized||h.normalizeSkinWeights(),5===c.mode?h.geometry=x(h.geometry,i.TriangleStripDrawMode):6===c.mode&&(h.geometry=x(h.geometry,i.TriangleFanDrawMode));else if(1===c.mode)h=new i.LineSegments(u,d);else if(3===c.mode)h=new i.Line(u,d);else if(2===c.mode)h=new i.LineLoop(u,d);else{if(0!==c.mode)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+c.mode);h=new i.Points(u,d)}Object.keys(h.geometry.morphAttributes).length>0&&K(h,r),h.name=n.createUniqueName(r.name||"mesh_"+e),j(h,r),c.extensions&&v(A,h,c),n.assignFinalMaterial(h),l.push(h)}if(1===l.length)return l[0];var I=new i.Group;for(m=0,p=l.length;m<p;m++)I.add(l[m]);return I}))},b.prototype.loadCamera=function(e){var t,n=this.json.cameras[e],o=n[n.type];if(o)return"perspective"===n.type?t=new i.PerspectiveCamera(i.MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):"orthographic"===n.type&&(t=new i.OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),j(t,n),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")},b.prototype.loadSkin=function(e){var t=this.json.skins[e],n={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(n):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return n.inverseBindMatrices=e,n}))},b.prototype.loadAnimation=function(e){for(var t=this.json.animations[e],n=[],o=[],A=[],r=[],s=[],a=0,l=t.channels.length;a<l;a++){var m=t.channels[a],p=t.samplers[m.sampler],h=m.target,u=void 0!==h.node?h.node:h.id,c=void 0!==t.parameters?t.parameters[p.input]:p.input,d=void 0!==t.parameters?t.parameters[p.output]:p.output;n.push(this.getDependency("node",u)),o.push(this.getDependency("accessor",c)),A.push(this.getDependency("accessor",d)),r.push(p),s.push(h)}return Promise.all([Promise.all(n),Promise.all(o),Promise.all(A),Promise.all(r),Promise.all(s)]).then((function(n){for(var o=n[0],A=n[1],r=n[2],s=n[3],a=n[4],l=[],m=0,p=o.length;m<p;m++){var h=o[m],u=A[m],c=r[m],d=s[m],I=a[m];if(void 0!==h){var G;switch(h.updateMatrix(),h.matrixAutoUpdate=!0,C[I.path]){case C.weights:G=i.NumberKeyframeTrack;break;case C.rotation:G=i.QuaternionKeyframeTrack;break;default:G=i.VectorKeyframeTrack}var k=h.name?h.name:h.uuid,g=void 0!==d.interpolation?D[d.interpolation]:i.InterpolateLinear,f=[];C[I.path]===C.weights?h.traverse((function(e){!0===e.isMesh&&e.morphTargetInfluences&&f.push(e.name?e.name:e.uuid)})):f.push(k);var H=c.array;if(c.normalized){var F;if(H.constructor===Int8Array)F=1/127;else if(H.constructor===Uint8Array)F=1/255;else if(H.constructor==Int16Array)F=1/32767;else{if(H.constructor!==Uint16Array)throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");F=1/65535}for(var J=new Float32Array(H.length),v=0,j=H.length;v<j;v++)J[v]=H[v]*F;H=J}for(v=0,j=f.length;v<j;v++){var K=new G(f[v]+"."+C[I.path],u.array,H,g);"CUBICSPLINE"===d.interpolation&&(K.createInterpolant=function(e){return new E(this.times,this.values,this.getValueSize()/3,e)},K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(K)}}}var y=t.name?t.name:"animation_"+e;return new i.AnimationClip(y,void 0,l)}))},b.prototype.loadNode=function(e){var t,n=this.json,o=this.extensions,A=this,r=n.nodes[e],s=r.name?A.createUniqueName(r.name):"";return(t=[],void 0!==r.mesh&&t.push(A.getDependency("mesh",r.mesh).then((function(e){var t=A._getNodeRef(A.meshCache,r.mesh,e);return void 0!==r.weights&&t.traverse((function(e){if(e.isMesh)for(var t=0,n=r.weights.length;t<n;t++)e.morphTargetInfluences[t]=r.weights[t]})),t}))),void 0!==r.camera&&t.push(A.getDependency("camera",r.camera).then((function(e){return A._getNodeRef(A.cameraCache,r.camera,e)}))),A._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){t.push(e)})),Promise.all(t)).then((function(t){var n;if((n=!0===r.isBone?new i.Bone:t.length>1?new i.Group:1===t.length?t[0]:new i.Object3D)!==t[0])for(var a=0,l=t.length;a<l;a++)n.add(t[a]);if(r.name&&(n.userData.name=r.name,n.name=s),j(n,r),r.extensions&&v(o,n,r),void 0!==r.matrix){var m=new i.Matrix4;m.fromArray(r.matrix),n.applyMatrix4(m)}else void 0!==r.translation&&n.position.fromArray(r.translation),void 0!==r.rotation&&n.quaternion.fromArray(r.rotation),void 0!==r.scale&&n.scale.fromArray(r.scale);return A.associations.set(n,{type:"nodes",index:e}),n}))},b.prototype.loadScene=function(){function e(t,n,o,A){var r=o.nodes[t];return A.getDependency("node",t).then((function(e){return void 0===r.skin?e:A.getDependency("skin",r.skin).then((function(e){for(var n=[],o=0,i=(t=e).joints.length;o<i;o++)n.push(A.getDependency("node",t.joints[o]));return Promise.all(n)})).then((function(n){return e.traverse((function(e){if(e.isMesh){for(var o=[],A=[],r=0,s=n.length;r<s;r++){var a=n[r];if(a){o.push(a);var l=new i.Matrix4;void 0!==t.inverseBindMatrices&&l.fromArray(t.inverseBindMatrices.array,16*r),A.push(l)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[r])}e.bind(new i.Skeleton(o,A),e.matrixWorld)}})),e}));var t})).then((function(t){n.add(t);var i=[];if(r.children)for(var s=r.children,a=0,l=s.length;a<l;a++){var m=s[a];i.push(e(m,t,o,A))}return Promise.all(i)}))}return function(t){var n=this.json,o=this.extensions,A=this.json.scenes[t],r=new i.Group;A.name&&(r.name=this.createUniqueName(A.name)),j(r,A),A.extensions&&v(o,r,A);for(var s=A.nodes||[],a=[],l=0,m=s.length;l<m;l++)a.push(e(s[l],r,n,this));return Promise.all(a).then((function(){return r}))}}(),e}(),VC=n(5135);n(4519);const WC=document.querySelector("canvas.webgl"),_C=new i.Scene,zC=(n(9817),n(6824)),XC=document.getElementById("webcam");document.getElementById("webcamCanvas");let QC=["\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = PI * 2.;\nuniform vec2 uResolution;\nuniform vec2 uMouse;\n\nuniform float uA;\nuniform float uB;\nuniform float uC;\nuniform float uD;\n\nvarying vec2 vUv;\nvarying float vTime;\n\nconst vec2 v60 = vec2( cos(PI/3.0), sin(PI/3.0));\nconst vec2 vm60 = vec2(cos(-PI/3.0), sin(-PI/3.0));\nconst mat2 rot60 = mat2(v60.x,-v60.y,v60.y,v60.x);\nconst mat2 rotm60 = mat2(vm60.x,-vm60.y,vm60.y,vm60.x);\n\n\n//\tClassic Perlin 2D Noise\n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x)\n{\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 *\n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.x*uv.y;\n}\n\nfloat wiggly(float cx, float cy, float amplitude, float frequency, float spread){\n\n  float w = sin(cx * amplitude * frequency * PI) * cos(cy * amplitude * frequency * PI) * spread;\n\n  return w;\n}\n\n\n\nvoid coswarp(inout vec3 trip, float warpsScale ){\n\n  trip.xyz += warpsScale * .1 * cos(3. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .05 * sin(11. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .025 * cos(17. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .0125 * sin(21. * trip.zyx + (vTime * .5));\n}\n\nfloat triangleGrid(vec2 p, float stepSize,float vertexSize,float lineSize)\n{\n    // equilateral triangle grid\n    vec2 fullStep= vec2( stepSize , stepSize*v60.y);\n    vec2 halfStep=fullStep/2.0;\n    vec2 grid = floor(p/fullStep);\n    vec2 offset = vec2( (mod(grid.y,2.0)==1.0) ? halfStep.x : 0. , 0.);\n   \t// tiling\n    vec2 uv = mod(p+offset,fullStep)-halfStep;\n    float d2=dot(uv,uv);\n    return vertexSize/d2 + // vertices\n    \tmax( abs(lineSize/(uv*rotm60).y), // lines -60deg\n        \t max ( abs(lineSize/(uv*rot60).y), // lines 60deg\n        \t  \t   abs(lineSize/(uv.y)) )); // h lines\n}\n\nfloat stroke(float x, float s, float w){\n  float d = step(s, x+ w * .5) - step(s, x - w * .5);\n  return clamp(d, 0., 1.);\n}\n\nvec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {\n  mat2 rotation_matrix=mat2(  vec2(sin(rotation),-cos(rotation)),\n                              vec2(cos(rotation),sin(rotation))\n                              );\n  uv -= pivot;\n  uv= uv*rotation_matrix;\n  uv += pivot;\n  return uv;\n}\n\nfloat triangleDF(vec2 uv){\n  uv =(uv * 2. -1.) * 2.;\n  return max(\n    abs(uv.x) * 0.866025 + uv.y * 0.5 ,\n     -1. * uv.y * 0.5);\n}\n\nvoid main(){\n\n  float alpha = 1.;\n  vec2 uv = vUv ;\n\n  float b = circle(vec2(uv.x -.15, uv.y -.1), .055 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.007));\n\n  b += circle(vec2(uv.x +.15, uv.y -.1), .055 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.007));\n\n  vec2 rote = rotateUV(uv, vec2(.0), PI * vTime * .05);\n  vec2 roteC = rotateUV(uv, vec2(.0), -PI * vTime * .05);\n\n  float g = stroke(triangleDF(vec2(uv.x, uv.y+ .01)), .02 , .12);\n\n\n\n  float r = box(vec2(uv.x, uv.y +.25), vec2(.5, uC), .01);\n\n  vec3 color = vec3(1.- (r+ b + g));\n  // color.b = b;\n  // color.r = r;\n  if( color == vec3(1.)){\n    color = vec3(uv.x, uv.y, 1.);\n    coswarp(color, uB);\n  }\n\n  if( color == vec3(0.)){\n  r *= stroke(triangleGrid(uv, uA, 0.000005,0.001), .1, .1 * sin(vTime) +.2 );\n\n  b *= cnoise(rote * 3. * uD * cnoise(roteC * 9. * uD));\n\n    g *= cnoise(roteC * 13. * uD * cnoise(rote * 2. *uD));\n\n  color = vec3(1.- (r+ b + g));\n  }\n\n\n\n gl_FragColor =  vec4(color, alpha);\n\n}\n","\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = PI * 2.;\nuniform vec2 uResolution;\nuniform vec2 uMouse;\n\nuniform float uA;\nuniform float uB;\nuniform float uC;\nuniform float uD;\n\nvarying vec2 vUv;\nvarying float vTime;\n\nconst vec2 v60 = vec2( cos(PI/3.0), sin(PI/3.0));\nconst vec2 vm60 = vec2(cos(-PI/3.0), sin(-PI/3.0));\nconst mat2 rot60 = mat2(v60.x,-v60.y,v60.y,v60.x);\nconst mat2 rotm60 = mat2(vm60.x,-vm60.y,vm60.y,vm60.x);\n\n\n//\tClassic Perlin 2D Noise\n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x)\n{\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 *\n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.x*uv.y;\n}\n\nfloat wiggly(float cx, float cy, float amplitude, float frequency, float spread){\n\n  float w = sin(cx * amplitude * frequency * PI) * cos(cy * amplitude * frequency * PI) * spread;\n\n  return w;\n}\n\n\n\nvoid coswarp(inout vec3 trip, float warpsScale ){\n\n  trip.xyz += warpsScale * .1 * cos(3. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .05 * sin(11. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .025 * cos(17. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .0125 * sin(21. * trip.zyx + (vTime * .5));\n}\n\nfloat triangleGrid(vec2 p, float stepSize,float vertexSize,float lineSize)\n{\n    // equilateral triangle grid\n    vec2 fullStep= vec2( stepSize , stepSize*v60.y);\n    vec2 halfStep=fullStep/2.0;\n    vec2 grid = floor(p/fullStep);\n    vec2 offset = vec2( (mod(grid.y,2.0)==1.0) ? halfStep.x : 0. , 0.);\n   \t// tiling\n    vec2 uv = mod(p+offset,fullStep)-halfStep;\n    float d2=dot(uv,uv);\n    return vertexSize/d2 + // vertices\n    \tmax( abs(lineSize/(uv*rotm60).y), // lines -60deg\n        \t max ( abs(lineSize/(uv*rot60).y), // lines 60deg\n        \t  \t   abs(lineSize/(uv.y)) )); // h lines\n}\n\nfloat stroke(float x, float s, float w){\n  float d = step(s, x+ w * .5) - step(s, x - w * .5);\n  return clamp(d, 0., 1.);\n}\n\nvec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {\n  mat2 rotation_matrix=mat2(  vec2(sin(rotation),-cos(rotation)),\n                              vec2(cos(rotation),sin(rotation))\n                              );\n  uv -= pivot;\n  uv= uv*rotation_matrix;\n  uv += pivot;\n  return uv;\n}\n\nfloat triangleDF(vec2 uv){\n  uv =(uv * 2. -1.) * 2.;\n  return max(\n    abs(uv.x) * 0.866025 + uv.y * 0.5 ,\n     -1. * uv.y * 0.5);\n}\n\nvoid main(){\n\n  float alpha = 1.;\n  vec2 uv = vUv ;\n\n  vec2 rote = rotateUV(uv, vec2(.0), PI * vTime * .05);\n  vec2 roteC = rotateUV(uv, vec2(.0), -PI * vTime * .05);\n\n  float b = stroke(triangleDF(vec2(uv.x -.15, uv.y -.1)), .055 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.005), .22);\n\n  b += stroke(triangleDF(vec2(uv.x +.15, uv.y -.1)), .055 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.005), .22);\n\n\n\n  float g = circle(vec2(uv.x, uv.y +.05 ), .009 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.007));\n\n\n\n  float r = box(vec2(uv.x, uv.y +.25), vec2(.5 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.005), uC+ wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.005)), .01);\n\n  vec3 color = vec3(1.- (r+ b + g));\n\n  if( color == vec3(1.)){\n    color = vec3(uv.y, uB *.1, uv.x);\n    coswarp(color, 2.);\n  }\n\n  if( color == vec3(0.)){\n  r *= stroke(triangleGrid(uv, 0.2, 0.00005,0.001), uA, .1 * sin(vTime) +.2 );\n\n  b *= cnoise(rote * 3. *uD * cnoise(roteC * 9. * uD));\n  g *= cnoise(roteC * 13. * uD * cnoise(rote * 2. * uD));\n  color = vec3(r,g,b);\n  }\n\n\n\n gl_FragColor =  vec4(color, alpha);\n\n}\n","\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = PI * 2.;\nuniform vec2 uResolution;\nuniform vec2 uMouse;\n\nuniform float uA;\nuniform float uB;\nuniform float uC;\nuniform float uD;\n\nvarying vec2 vUv;\nvarying float vTime;\n\nconst vec2 v60 = vec2( cos(PI/3.0), sin(PI/3.0));\nconst vec2 vm60 = vec2(cos(-PI/3.0), sin(-PI/3.0));\nconst mat2 rot60 = mat2(v60.x,-v60.y,v60.y,v60.x);\nconst mat2 rotm60 = mat2(vm60.x,-vm60.y,vm60.y,vm60.x);\n\n\n//\tClassic Perlin 2D Noise\n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x)\n{\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 *\n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.x*uv.y;\n}\n\nfloat wiggly(float cx, float cy, float amplitude, float frequency, float spread){\n\n  float w = sin(cx * amplitude * frequency * PI) * cos(cy * amplitude * frequency * PI) * spread;\n\n  return w;\n}\n\n\n\nvoid coswarp(inout vec3 trip, float warpsScale ){\n\n  trip.xyz += warpsScale * .1 * cos(3. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .05 * sin(11. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .025 * cos(17. * trip.zyx + (vTime * .5));\n  trip.xyz += warpsScale * .0125 * sin(21. * trip.zyx + (vTime * .5));\n}\n\nfloat triangleGrid(vec2 p, float stepSize,float vertexSize,float lineSize)\n{\n    // equilateral triangle grid\n    vec2 fullStep= vec2( stepSize , stepSize*v60.y);\n    vec2 halfStep=fullStep/2.0;\n    vec2 grid = floor(p/fullStep);\n    vec2 offset = vec2( (mod(grid.y,2.0)==1.0) ? halfStep.x : 0. , 0.);\n   \t// tiling\n    vec2 uv = mod(p+offset,fullStep)-halfStep;\n    float d2=dot(uv,uv);\n    return vertexSize/d2 + // vertices\n    \tmax( abs(lineSize/(uv*rotm60).y), // lines -60deg\n        \t max ( abs(lineSize/(uv*rot60).y), // lines 60deg\n        \t  \t   abs(lineSize/(uv.y)) )); // h lines\n}\n\nfloat stroke(float x, float s, float w){\n  float d = step(s, x+ w * .5) - step(s, x - w * .5);\n  return clamp(d, 0., 1.);\n}\n\nvec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {\n  mat2 rotation_matrix=mat2(  vec2(sin(rotation),-cos(rotation)),\n                              vec2(cos(rotation),sin(rotation))\n                              );\n  uv -= pivot;\n  uv= uv*rotation_matrix;\n  uv += pivot;\n  return uv;\n}\n\nfloat triangleDF(vec2 uv){\n  uv =(uv * 2. -1.) * 2.;\n  return max(\n    abs(uv.x) * 0.866025 + uv.y * 0.5 ,\n     -1. * uv.y * 0.5);\n}\n\nvoid main(){\n\n  float alpha = 1.;\n  vec2 uv = vUv ;\n\n  vec2 rote = rotateUV(uv, vec2(.0), PI * vTime * .05);\n  vec2 roteC = rotateUV(uv, vec2(.0), -PI * vTime * .05);\n\n\n\n\n  float b = box(vec2(uv.x -.15, uv.y -.1), vec2(.2 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.005)), .01);\n\n  b+=  box(vec2(uv.x +.15, uv.y -.1), vec2(.2 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.005)), .01);\n\n\n\n\n\n  float g = stroke(triangleDF(vec2(uv.x, uv.y+ .01)), .02 + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.007) , .12);\n\n\n\n  float r = circle(vec2(uv.x, uv.y +.25 ), (uC * .5) + wiggly(uv.x + vTime * .05, uv.y + vTime * .05, 2., 6., 0.007));\n\n\n\n\n  vec3 color = vec3(1.- (r+ b + g));\n\n  if( color == vec3(1.)){\n    color = vec3(uB *.1, uv.x, uv.y);\n    color -= cnoise(roteC * 13. * uD * cnoise(rote * 2. * uD));\n    coswarp(color, 2.);\n  }\n\n  if( color == vec3(0.)){\n  r *= stroke(triangleGrid(uv, 0.2, 0.00005,0.001), uA, .1 * sin(vTime) +.2 );\n\n  b *= cnoise(rote * 3. *uD * cnoise(roteC * 9. * uD));\n  g *= cnoise(roteC * 13. * uD * cnoise(rote * 2. * uD));\n  color = vec3(g,r, b);\n  }\n\n\n\n gl_FragColor =  vec4(color, alpha);\n\n}\n"],ZC=0,YC=2.3;new Promise(((e,t)=>{const n=navigator;navigator.getUserMedia=navigator.getUserMedia||n.webkitGetUserMedia||n.mozGetUserMedia||n.msGetUserMedia,navigator.getUserMedia?navigator.getUserMedia({video:!0},(t=>{XC.srcObject=t,XC.addEventListener("loadeddata",(()=>{e(),VC.init({canvasId:"webcamCanvas",NNC:zC,callbackReady:function(e,t){e?console.log("AN ERROR HAPPENS. ERR =",e):console.log("INFO: JEELIZFACEFILTER IS READY")},callbackTrack:function(e){rD.position.x=e.x,rD.position.y=e.y,rD.rotation.x=e.rx,rD.rotation.y=e.ry,rD.rotation.z=e.rz,rD.scale.set(e.s*YC,e.s*YC,e.s*YC)}})}),!1)}),(e=>t())):t()}));const $C=new i.ShaderMaterial({transparent:!0,depthWrite:!0,uniforms:{uTime:{value:0},uResolution:{type:"v2",value:new i.Vector2},uMouse:{value:{x:.5,y:.5}},uA:{value:.03},uB:{value:3},uC:{value:.2},uD:{value:1}},vertexShader:"varying vec2 vUv;\nuniform float uTime;\nvarying float vTime;\n\nvoid main(){\n  vec4 modelPosition = modelMatrix * vec4(position, 1.);\n\n  vec4 viewPosition = viewMatrix * modelPosition;\n\n  vec4 projectionPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectionPosition;\n  vUv = uv;\n  vTime = uTime;\n}\n",fragmentShader:QC[ZC],side:i.DoubleSide});function eD(){ZC<QC.length-1?ZC++:ZC===QC.length-1?(ZC++,_C.remove(rD),_C.add(lD),rD=lD,YC=4.6):(ZC=0,_C.remove(lD),rD=iD,_C.add(rD),YC=2.6),$C.needsUpdate=!0,$C.fragmentShader=QC[ZC]}document.querySelector("#change").addEventListener("click",(e=>{eD()})),document.querySelector("#change2").addEventListener("click",(e=>{eD()}));const tD={width:window.innerWidth,height:window.innerHeight};window.addEventListener("resize",(()=>{tD.width=window.innerWidth,tD.height=window.innerHeight,nD.aspect=tD.width/tD.height,nD.updateProjectionMatrix(),oD.setSize(tD.width,tD.height),oD.setPixelRatio(Math.min(window.devicePixelRatio,2))}));const nD=new i.PerspectiveCamera(45,tD.width/tD.height,.1,100);nD.position.z=15,_C.add(nD);const oD=new i.WebGLRenderer({canvas:WC,antialias:!0,alpha:!0});oD.outputEncoding=i.sRGBEncoding,oD.setSize(tD.width,tD.height),oD.setPixelRatio(Math.min(window.devicePixelRatio,2)),oD.setClearColor(0,0),new i.Vector2;var AD=new i.SphereGeometry(4,64,64,0,3);let iD=new i.Mesh(AD,$C),rD=iD;_C.add(rD);const sD=new i.AmbientLight(4210752);_C.add(sD);const aD=new i.DirectionalLight(16777215,1.25);let lD;_C.add(aD),(new UC).load("duck.glb",(e=>{console.log(e),lD=e.scene,lD.needsUpdate=!0,lD.position.y=2}));const mD={uA:.03,uB:3,uC:.2,uD:1},pD=new r.Pane;pD.addInput(mD,"uA",{min:.03,max:1,step:.01}).on("change",(function(e){$C.uniforms.uA.value=e.value})),pD.addInput(mD,"uB",{min:3,max:10,step:1}).on("change",(function(e){$C.uniforms.uB.value=e.value})),pD.addInput(mD,"uC",{min:.2,max:1,step:.05}).on("change",(function(e){$C.uniforms.uC.value=e.value})),pD.addInput(mD,"uD",{min:.1,max:3,step:.1}).on("change",(function(e){$C.uniforms.uD.value=e.value}));const hD=new i.Clock,uD=()=>{const e=hD.getElapsedTime();$C.uniforms.uTime.value=e,$C.needsUpdate=!0,oD.render(_C,nD),window.requestAnimationFrame(uD)};let cD;uD(),cD=new Array(4).fill().map((e=>new Array(3).fill().map((e=>Math.random()))));const dD=(e=0,t=[.5,.5,.5],n=[.5,.5,.5],o=[1,1,1],A=[0,.33,.67])=>o.map(((o,i)=>Math.cos(o*e+6.28318*A[i]*$C.uniforms.uD.value)*n[i]+t[i]));let ID=0;!function e(){ID+=.5;const t=new Array(100).fill().map(((e,t)=>`rgb(${dD((t+ID)/100*(2*Math.PI),cD[0],cD[1],cD[2],cD[3]).map((e=>255*e)).join(",")})`)).join(",");document.getElementById("body").style.background=`linear-gradient(${t})`;const n=new Array(30).fill().map(((e,t)=>`rgb(${dD((t+ID)/100*(2*Math.PI),cD[1],cD[0],cD[3],cD[2]).map((e=>255*e)).join(",")})`)).join(",");document.getElementById("webcam").style.background=`linear-gradient(${n})`,requestAnimationFrame(e)}()})()})();
//# sourceMappingURL=bundle.fdf47a938ecb8cb30dae.js.map